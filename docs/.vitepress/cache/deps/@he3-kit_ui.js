import {
  Fragment,
  Teleport,
  Text,
  Transition,
  TransitionGroup,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createTextVNode,
  createVNode,
  defineComponent,
  getCurrentInstance,
  getCurrentScope,
  h,
  inject,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeStyle,
  onBeforeMount,
  onBeforeUnmount,
  onMounted,
  onScopeDispose,
  onUnmounted,
  openBlock,
  popScopeId,
  provide,
  pushScopeId,
  reactive,
  readonly,
  ref,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDynamicComponent,
  shallowRef,
  toDisplayString,
  toRaw,
  toRefs,
  unref,
  useCssVars,
  vModelText,
  vShow,
  watch,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-SUYGMFRK.js";

// node_modules/.pnpm/@he3-kit+ui@0.0.5/node_modules/@he3-kit/ui/dist/index.js
var Be = (t, e) => {
  if (t.install = (i) => {
    for (const n of [t, ...Object.values(e ?? {})])
      i.component(n.name, n);
  }, e)
    for (const [i, n] of Object.entries(e))
      t[i] = n;
  return t;
};
var jT = (t) => (pushScopeId("data-v-6af29ae6"), t = t(), popScopeId(), t);
var IT = jT(() => createBaseVNode("div", null, null, -1));
var AT = {
  name: "HLayoutVertical"
};
var GT = defineComponent({
  ...AT,
  props: {
    mode: { default: "middle" },
    width: { default: 300 }
  },
  setup(t) {
    const e = t, i = ref({
      above: `${e.width}px 20px calc(100% - 20px - ${e.width}px)`,
      middle: "49% 2% 49%",
      below: `calc(100% - 20px - ${e.width}px) 20px ${e.width}px`
    });
    return (n, O) => (openBlock(), createElementBlock("div", {
      class: "wrap",
      style: normalizeStyle(`grid-template-rows: ${i.value[e.mode]};`)
    }, [
      createBaseVNode("div", null, [
        renderSlot(n.$slots, "above", {}, void 0, true)
      ]),
      IT,
      createBaseVNode("div", null, [
        renderSlot(n.$slots, "below", {}, void 0, true)
      ])
    ], 4));
  }
});
var ei = (t, e) => {
  const i = t.__vccOpts || t;
  for (const [n, O] of e)
    i[n] = O;
  return i;
};
var LT = ei(GT, [["__scopeId", "data-v-6af29ae6"]]);
var DT = (t) => (pushScopeId("data-v-752d7591"), t = t(), popScopeId(), t);
var MT = DT(() => createBaseVNode("div", null, null, -1));
var NT = {
  name: "HLayoutHorizontal"
};
var BT = defineComponent({
  ...NT,
  props: {
    mode: { default: "middle" },
    width: { default: 300 }
  },
  setup(t) {
    const e = t, i = ref({
      left: `${e.width}px 20px calc(100% - 20px - ${e.width}px)`,
      middle: "49% 2% 49%",
      right: `calc(100% - 20px - ${e.width}px) 20px ${e.width}px`
    });
    return (n, O) => (openBlock(), createElementBlock("div", {
      class: "wrap",
      style: normalizeStyle(`grid-template-columns: ${i.value[e.mode]};`)
    }, [
      createBaseVNode("div", null, [
        renderSlot(n.$slots, "left", {}, void 0, true)
      ]),
      MT,
      createBaseVNode("div", null, [
        renderSlot(n.$slots, "right", {}, void 0, true)
      ])
    ], 4));
  }
});
var FT = ei(BT, [["__scopeId", "data-v-752d7591"]]);
var HT = {
  name: "HLayoutSingle"
};
var KT = defineComponent({
  ...HT,
  props: {
    mode: { default: "middle" },
    width: { default: 600 }
  },
  setup(t) {
    const e = t, i = {
      left: "flex-start",
      middle: "center",
      right: "flex-end"
    };
    return (n, O) => (openBlock(), createElementBlock("div", {
      class: "layout-wrapper",
      style: normalizeStyle(`justify-content: ${i[e.mode]}`)
    }, [
      createBaseVNode("div", {
        style: normalizeStyle(`max-width: ${e.width}px`)
      }, [
        renderSlot(n.$slots, "default", {}, void 0, true)
      ], 4)
    ], 4));
  }
});
var JT = ei(KT, [["__scopeId", "data-v-ac980b12"]]);
var ek = {
  name: "splitpanes",
  emits: ["ready", "resize", "resized", "pane-click", "pane-maximize", "pane-add", "pane-remove", "splitter-click"],
  props: {
    horizontal: { type: Boolean },
    pushOtherPanes: { type: Boolean, default: true },
    dblClickSplitter: { type: Boolean, default: true },
    rtl: { type: Boolean, default: false },
    firstSplitter: { type: Boolean }
  },
  provide() {
    return {
      requestUpdate: this.requestUpdate,
      onPaneAdd: this.onPaneAdd,
      onPaneRemove: this.onPaneRemove,
      onPaneClick: this.onPaneClick
    };
  },
  data: () => ({
    container: null,
    ready: false,
    panes: [],
    touch: {
      mouseDown: false,
      dragging: false,
      activeSplitter: null
    },
    splitterTaps: {
      splitter: null,
      timeoutId: null
    }
  }),
  computed: {
    panesCount() {
      return this.panes.length;
    },
    indexedPanes() {
      return this.panes.reduce((t, e) => (t[e.id] = e) && t, {});
    }
  },
  methods: {
    updatePaneComponents() {
      this.panes.forEach((t) => {
        t.update && t.update({
          [this.horizontal ? "height" : "width"]: `${this.indexedPanes[t.id].size}%`
        });
      });
    },
    bindEvents() {
      document.addEventListener("mousemove", this.onMouseMove, { passive: false }), document.addEventListener("mouseup", this.onMouseUp), "ontouchstart" in window && (document.addEventListener("touchmove", this.onMouseMove, { passive: false }), document.addEventListener("touchend", this.onMouseUp));
    },
    unbindEvents() {
      document.removeEventListener("mousemove", this.onMouseMove, { passive: false }), document.removeEventListener("mouseup", this.onMouseUp), "ontouchstart" in window && (document.removeEventListener("touchmove", this.onMouseMove, { passive: false }), document.removeEventListener("touchend", this.onMouseUp));
    },
    onMouseDown(t, e) {
      this.bindEvents(), this.touch.mouseDown = true, this.touch.activeSplitter = e;
    },
    onMouseMove(t) {
      this.touch.mouseDown && (t.preventDefault(), this.touch.dragging = true, this.calculatePanesSize(this.getCurrentMouseDrag(t)), this.$emit("resize", this.panes.map((e) => ({ min: e.min, max: e.max, size: e.size }))));
    },
    onMouseUp() {
      this.touch.dragging && this.$emit("resized", this.panes.map((t) => ({ min: t.min, max: t.max, size: t.size }))), this.touch.mouseDown = false, setTimeout(() => {
        this.touch.dragging = false, this.unbindEvents();
      }, 100);
    },
    onSplitterClick(t, e) {
      "ontouchstart" in window && (t.preventDefault(), this.dblClickSplitter && (this.splitterTaps.splitter === e ? (clearTimeout(this.splitterTaps.timeoutId), this.splitterTaps.timeoutId = null, this.onSplitterDblClick(t, e), this.splitterTaps.splitter = null) : (this.splitterTaps.splitter = e, this.splitterTaps.timeoutId = setTimeout(() => {
        this.splitterTaps.splitter = null;
      }, 500)))), this.touch.dragging || this.$emit("splitter-click", this.panes[e]);
    },
    onSplitterDblClick(t, e) {
      let i = 0;
      this.panes = this.panes.map((n, O) => (n.size = O === e ? n.max : n.min, O !== e && (i += n.min), n)), this.panes[e].size -= i, this.$emit("pane-maximize", this.panes[e]), this.$emit("resized", this.panes.map((n) => ({ min: n.min, max: n.max, size: n.size })));
    },
    onPaneClick(t, e) {
      this.$emit("pane-click", this.indexedPanes[e]);
    },
    getCurrentMouseDrag(t) {
      const e = this.container.getBoundingClientRect(), { clientX: i, clientY: n } = "ontouchstart" in window && t.touches ? t.touches[0] : t;
      return {
        x: i - e.left,
        y: n - e.top
      };
    },
    getCurrentDragPercentage(t) {
      t = t[this.horizontal ? "y" : "x"];
      const e = this.container[this.horizontal ? "clientHeight" : "clientWidth"];
      return this.rtl && !this.horizontal && (t = e - t), t * 100 / e;
    },
    calculatePanesSize(t) {
      const e = this.touch.activeSplitter;
      let i = {
        prevPanesSize: this.sumPrevPanesSize(e),
        nextPanesSize: this.sumNextPanesSize(e),
        prevReachedMinPanes: 0,
        nextReachedMinPanes: 0
      };
      const n = 0 + (this.pushOtherPanes ? 0 : i.prevPanesSize), O = 100 - (this.pushOtherPanes ? 0 : i.nextPanesSize), r = Math.max(Math.min(this.getCurrentDragPercentage(t), O), n);
      let a = [e, e + 1], o = this.panes[a[0]] || null, s = this.panes[a[1]] || null;
      const l = o.max < 100 && r >= o.max + i.prevPanesSize, c = s.max < 100 && r <= 100 - (s.max + this.sumNextPanesSize(e + 1));
      if (l || c) {
        l ? (o.size = o.max, s.size = Math.max(100 - o.max - i.prevPanesSize - i.nextPanesSize, 0)) : (o.size = Math.max(100 - s.max - i.prevPanesSize - this.sumNextPanesSize(e + 1), 0), s.size = s.max);
        return;
      }
      if (this.pushOtherPanes) {
        const u = this.doPushOtherPanes(i, r);
        if (!u)
          return;
        ({ sums: i, panesToResize: a } = u), o = this.panes[a[0]] || null, s = this.panes[a[1]] || null;
      }
      o !== null && (o.size = Math.min(Math.max(r - i.prevPanesSize - i.prevReachedMinPanes, o.min), o.max)), s !== null && (s.size = Math.min(Math.max(100 - r - i.nextPanesSize - i.nextReachedMinPanes, s.min), s.max));
    },
    doPushOtherPanes(t, e) {
      const i = this.touch.activeSplitter, n = [i, i + 1];
      return e < t.prevPanesSize + this.panes[n[0]].min && (n[0] = this.findPrevExpandedPane(i).index, t.prevReachedMinPanes = 0, n[0] < i && this.panes.forEach((O, r) => {
        r > n[0] && r <= i && (O.size = O.min, t.prevReachedMinPanes += O.min);
      }), t.prevPanesSize = this.sumPrevPanesSize(n[0]), n[0] === void 0) ? (t.prevReachedMinPanes = 0, this.panes[0].size = this.panes[0].min, this.panes.forEach((O, r) => {
        r > 0 && r <= i && (O.size = O.min, t.prevReachedMinPanes += O.min);
      }), this.panes[n[1]].size = 100 - t.prevReachedMinPanes - this.panes[0].min - t.prevPanesSize - t.nextPanesSize, null) : e > 100 - t.nextPanesSize - this.panes[n[1]].min && (n[1] = this.findNextExpandedPane(i).index, t.nextReachedMinPanes = 0, n[1] > i + 1 && this.panes.forEach((O, r) => {
        r > i && r < n[1] && (O.size = O.min, t.nextReachedMinPanes += O.min);
      }), t.nextPanesSize = this.sumNextPanesSize(n[1] - 1), n[1] === void 0) ? (t.nextReachedMinPanes = 0, this.panes[this.panesCount - 1].size = this.panes[this.panesCount - 1].min, this.panes.forEach((O, r) => {
        r < this.panesCount - 1 && r >= i + 1 && (O.size = O.min, t.nextReachedMinPanes += O.min);
      }), this.panes[n[0]].size = 100 - t.prevPanesSize - t.nextReachedMinPanes - this.panes[this.panesCount - 1].min - t.nextPanesSize, null) : { sums: t, panesToResize: n };
    },
    sumPrevPanesSize(t) {
      return this.panes.reduce((e, i, n) => e + (n < t ? i.size : 0), 0);
    },
    sumNextPanesSize(t) {
      return this.panes.reduce((e, i, n) => e + (n > t + 1 ? i.size : 0), 0);
    },
    findPrevExpandedPane(t) {
      return [...this.panes].reverse().find((e) => e.index < t && e.size > e.min) || {};
    },
    findNextExpandedPane(t) {
      return this.panes.find((e) => e.index > t + 1 && e.size > e.min) || {};
    },
    checkSplitpanesNodes() {
      Array.from(this.container.children).forEach((t) => {
        const e = t.classList.contains("splitpanes__pane"), i = t.classList.contains("splitpanes__splitter");
        !e && !i && (t.parentNode.removeChild(t), console.warn("Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed."));
      });
    },
    addSplitter(t, e, i = false) {
      const n = t - 1, O = document.createElement("div");
      O.classList.add("splitpanes__splitter"), i || (O.onmousedown = (r) => this.onMouseDown(r, n), typeof window < "u" && "ontouchstart" in window && (O.ontouchstart = (r) => this.onMouseDown(r, n)), O.onclick = (r) => this.onSplitterClick(r, n + 1)), this.dblClickSplitter && (O.ondblclick = (r) => this.onSplitterDblClick(r, n + 1)), e.parentNode.insertBefore(O, e);
    },
    removeSplitter(t) {
      t.onmousedown = void 0, t.onclick = void 0, t.ondblclick = void 0, t.parentNode.removeChild(t);
    },
    redoSplitters() {
      const t = Array.from(this.container.children);
      t.forEach((i) => {
        i.className.includes("splitpanes__splitter") && this.removeSplitter(i);
      });
      let e = 0;
      t.forEach((i) => {
        i.className.includes("splitpanes__pane") && (!e && this.firstSplitter ? this.addSplitter(e, i, true) : e && this.addSplitter(e, i), e++);
      });
    },
    requestUpdate({ target: t, ...e }) {
      const i = this.indexedPanes[t._.uid];
      Object.entries(e).forEach(([n, O]) => i[n] = O);
    },
    onPaneAdd(t) {
      let e = -1;
      Array.from(t.$el.parentNode.children).some((O) => (O.className.includes("splitpanes__pane") && e++, O === t.$el));
      const i = parseFloat(t.minSize), n = parseFloat(t.maxSize);
      this.panes.splice(e, 0, {
        id: t._.uid,
        index: e,
        min: isNaN(i) ? 0 : i,
        max: isNaN(n) ? 100 : n,
        size: t.size === null ? null : parseFloat(t.size),
        givenSize: t.size,
        update: t.update
      }), this.panes.forEach((O, r) => O.index = r), this.ready && this.$nextTick(() => {
        this.redoSplitters(), this.resetPaneSizes({ addedPane: this.panes[e] }), this.$emit("pane-add", { index: e, panes: this.panes.map((O) => ({ min: O.min, max: O.max, size: O.size })) });
      });
    },
    onPaneRemove(t) {
      const e = this.panes.findIndex((n) => n.id === t._.uid), i = this.panes.splice(e, 1)[0];
      this.panes.forEach((n, O) => n.index = O), this.$nextTick(() => {
        this.redoSplitters(), this.resetPaneSizes({ removedPane: { ...i, index: e } }), this.$emit("pane-remove", { removed: i, panes: this.panes.map((n) => ({ min: n.min, max: n.max, size: n.size })) });
      });
    },
    resetPaneSizes(t = {}) {
      !t.addedPane && !t.removedPane ? this.initialPanesSizing() : this.panes.some((e) => e.givenSize !== null || e.min || e.max < 100) ? this.equalizeAfterAddOrRemove(t) : this.equalize(), this.ready && this.$emit("resized", this.panes.map((e) => ({ min: e.min, max: e.max, size: e.size })));
    },
    equalize() {
      const t = 100 / this.panesCount;
      let e = 0;
      const i = [], n = [];
      this.panes.forEach((O) => {
        O.size = Math.max(Math.min(t, O.max), O.min), e -= O.size, O.size >= O.max && i.push(O.id), O.size <= O.min && n.push(O.id);
      }), e > 0.1 && this.readjustSizes(e, i, n);
    },
    initialPanesSizing() {
      let t = 100;
      const e = [], i = [];
      let n = 0;
      this.panes.forEach((r) => {
        t -= r.size, r.size !== null && n++, r.size >= r.max && e.push(r.id), r.size <= r.min && i.push(r.id);
      });
      let O = 100;
      t > 0.1 && (this.panes.forEach((r) => {
        r.size === null && (r.size = Math.max(Math.min(t / (this.panesCount - n), r.max), r.min)), O -= r.size;
      }), O > 0.1 && this.readjustSizes(t, e, i));
    },
    equalizeAfterAddOrRemove({ addedPane: t, removedPane: e } = {}) {
      let i = 100 / this.panesCount, n = 0;
      const O = [], r = [];
      t && t.givenSize !== null && (i = (100 - t.givenSize) / (this.panesCount - 1)), this.panes.forEach((a) => {
        n -= a.size, a.size >= a.max && O.push(a.id), a.size <= a.min && r.push(a.id);
      }), !(Math.abs(n) < 0.1) && (this.panes.forEach((a) => {
        t && t.givenSize !== null && t.id === a.id || (a.size = Math.max(Math.min(i, a.max), a.min)), n -= a.size, a.size >= a.max && O.push(a.id), a.size <= a.min && r.push(a.id);
      }), n > 0.1 && this.readjustSizes(n, O, r));
    },
    readjustSizes(t, e, i) {
      let n;
      t > 0 ? n = t / (this.panesCount - e.length) : n = t / (this.panesCount - i.length), this.panes.forEach((O, r) => {
        if (t > 0 && !e.includes(O.id)) {
          const a = Math.max(Math.min(O.size + n, O.max), O.min), o = a - O.size;
          t -= o, O.size = a;
        } else if (!i.includes(O.id)) {
          const a = Math.max(Math.min(O.size + n, O.max), O.min), o = a - O.size;
          t -= o, O.size = a;
        }
        O.update({
          [this.horizontal ? "height" : "width"]: `${this.indexedPanes[O.id].size}%`
        });
      }), Math.abs(t) > 0.1 && this.$nextTick(() => {
        this.ready && console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
      });
    }
  },
  watch: {
    panes: {
      deep: true,
      immediate: false,
      handler() {
        this.updatePaneComponents();
      }
    },
    horizontal() {
      this.updatePaneComponents();
    },
    firstSplitter() {
      this.redoSplitters();
    },
    dblClickSplitter(t) {
      [...this.container.querySelectorAll(".splitpanes__splitter")].forEach((e, i) => {
        e.ondblclick = t ? (n) => this.onSplitterDblClick(n, i) : void 0;
      });
    }
  },
  beforeUnmount() {
    this.ready = false;
  },
  mounted() {
    this.container = this.$refs.container, this.checkSplitpanesNodes(), this.redoSplitters(), this.resetPaneSizes(), this.$emit("ready"), this.ready = true;
  },
  render() {
    return h(
      "div",
      {
        ref: "container",
        class: [
          "splitpanes",
          `splitpanes--${this.horizontal ? "horizontal" : "vertical"}`,
          {
            "splitpanes--dragging": this.touch.dragging
          }
        ]
      },
      this.$slots.default()
    );
  }
};
var tk = (t, e) => {
  const i = t.__vccOpts || t;
  for (const [n, O] of e)
    i[n] = O;
  return i;
};
var ik = {
  name: "pane",
  inject: ["requestUpdate", "onPaneAdd", "onPaneRemove", "onPaneClick"],
  props: {
    size: { type: [Number, String], default: null },
    minSize: { type: [Number, String], default: 0 },
    maxSize: { type: [Number, String], default: 100 }
  },
  data: () => ({
    style: {}
  }),
  mounted() {
    this.onPaneAdd(this);
  },
  beforeUnmount() {
    this.onPaneRemove(this);
  },
  methods: {
    update(t) {
      this.style = t;
    }
  },
  computed: {
    sizeNumber() {
      return this.size || this.size === 0 ? parseFloat(this.size) : null;
    },
    minSizeNumber() {
      return parseFloat(this.minSize);
    },
    maxSizeNumber() {
      return parseFloat(this.maxSize);
    }
  },
  watch: {
    sizeNumber(t) {
      this.requestUpdate({ target: this, size: t });
    },
    minSizeNumber(t) {
      this.requestUpdate({ target: this, min: t });
    },
    maxSizeNumber(t) {
      this.requestUpdate({ target: this, max: t });
    }
  }
};
function nk(t, e, i, n, O, r) {
  return openBlock(), createElementBlock("div", {
    class: "splitpanes__pane",
    onClick: e[0] || (e[0] = (a) => r.onPaneClick(a, t._.uid)),
    style: normalizeStyle(t.style)
  }, [
    renderSlot(t.$slots, "default")
  ], 4);
}
var bQ = tk(ik, [["render", nk]]);
var Ok = { class: "horizontal-leftside" };
var rk = { class: "horizontal-rightside" };
var ak = {
  name: "HLayoutSplitPane"
};
var ok = defineComponent({
  ...ak,
  setup(t) {
    return (e, i) => (openBlock(), createBlock(unref(ek), { class: "horizontal he3-theme" }, {
      default: withCtx(() => [
        createVNode(unref(bQ), { "min-size": "20" }, {
          default: withCtx(() => [
            createBaseVNode("div", Ok, [
              renderSlot(e.$slots, "left")
            ])
          ]),
          _: 3
        }),
        createVNode(unref(bQ), { "min-size": "20" }, {
          default: withCtx(() => [
            createBaseVNode("div", rk, [
              renderSlot(e.$slots, "right")
            ])
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
});
var sk = Be(LT);
var lk = Be(FT);
var ck = Be(JT);
var Wb = Be(ok);
var bo = /^[a-z0-9]+(-[a-z0-9]+)*$/;
var Lc = (t, e, i, n = "") => {
  const O = t.split(":");
  if (t.slice(0, 1) === "@") {
    if (O.length < 2 || O.length > 3)
      return null;
    n = O.shift().slice(1);
  }
  if (O.length > 3 || !O.length)
    return null;
  if (O.length > 1) {
    const o = O.pop(), s = O.pop(), l = {
      provider: O.length > 0 ? O[0] : n,
      prefix: s,
      name: o
    };
    return e && !yl(l) ? null : l;
  }
  const r = O[0], a = r.split("-");
  if (a.length > 1) {
    const o = {
      provider: n,
      prefix: a.shift(),
      name: a.join("-")
    };
    return e && !yl(o) ? null : o;
  }
  if (i && n === "") {
    const o = {
      provider: n,
      prefix: "",
      name: r
    };
    return e && !yl(o, i) ? null : o;
  }
  return null;
};
var yl = (t, e) => t ? !!((t.provider === "" || t.provider.match(bo)) && (e && t.prefix === "" || t.prefix.match(bo)) && t.name.match(bo)) : false;
var Yb = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
);
var Il = Object.freeze({
  rotate: 0,
  vFlip: false,
  hFlip: false
});
var Dc = Object.freeze({
  ...Yb,
  ...Il
});
var fh = Object.freeze({
  ...Dc,
  body: "",
  hidden: false
});
function uk(t, e) {
  const i = {};
  !t.hFlip != !e.hFlip && (i.hFlip = true), !t.vFlip != !e.vFlip && (i.vFlip = true);
  const n = ((t.rotate || 0) + (e.rotate || 0)) % 4;
  return n && (i.rotate = n), i;
}
function vQ(t, e) {
  const i = uk(t, e);
  for (const n in fh)
    n in Il ? n in t && !(n in i) && (i[n] = Il[n]) : n in e ? i[n] = e[n] : n in t && (i[n] = t[n]);
  return i;
}
function fk(t, e) {
  const i = t.icons, n = t.aliases || /* @__PURE__ */ Object.create(null), O = /* @__PURE__ */ Object.create(null);
  function r(a) {
    if (i[a])
      return O[a] = [];
    if (!(a in O)) {
      O[a] = null;
      const o = n[a] && n[a].parent, s = o && r(o);
      s && (O[a] = [o].concat(s));
    }
    return O[a];
  }
  return (e || Object.keys(i).concat(Object.keys(n))).forEach(r), O;
}
function hk(t, e, i) {
  const n = t.icons, O = t.aliases || /* @__PURE__ */ Object.create(null);
  let r = {};
  function a(o) {
    r = vQ(
      n[o] || O[o],
      r
    );
  }
  return a(e), i.forEach(a), vQ(t, r);
}
function Rb(t, e) {
  const i = [];
  if (typeof t != "object" || typeof t.icons != "object")
    return i;
  t.not_found instanceof Array && t.not_found.forEach((O) => {
    e(O, null), i.push(O);
  });
  const n = fk(t);
  for (const O in n) {
    const r = n[O];
    r && (e(O, hk(t, O, r)), i.push(O));
  }
  return i;
}
var dk = {
  provider: "",
  aliases: {},
  not_found: {},
  ...Yb
};
function Iu(t, e) {
  for (const i in e)
    if (i in t && typeof t[i] != typeof e[i])
      return false;
  return true;
}
function Zb(t) {
  if (typeof t != "object" || t === null)
    return null;
  const e = t;
  if (typeof e.prefix != "string" || !t.icons || typeof t.icons != "object" || !Iu(t, dk))
    return null;
  const i = e.icons;
  for (const O in i) {
    const r = i[O];
    if (!O.match(bo) || typeof r.body != "string" || !Iu(
      r,
      fh
    ))
      return null;
  }
  const n = e.aliases || /* @__PURE__ */ Object.create(null);
  for (const O in n) {
    const r = n[O], a = r.parent;
    if (!O.match(bo) || typeof a != "string" || !i[a] && !n[a] || !Iu(
      r,
      fh
    ))
      return null;
  }
  return e;
}
var XQ = /* @__PURE__ */ Object.create(null);
function pk(t, e) {
  return {
    provider: t,
    prefix: e,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function HO(t, e) {
  const i = XQ[t] || (XQ[t] = /* @__PURE__ */ Object.create(null));
  return i[e] || (i[e] = pk(t, e));
}
function pp(t, e) {
  return Zb(e) ? Rb(e, (i, n) => {
    n ? t.icons[i] = n : t.missing.add(i);
  }) : [];
}
function $k(t, e, i) {
  try {
    if (typeof i.body == "string")
      return t.icons[e] = { ...i }, true;
  } catch {
  }
  return false;
}
var jo = false;
function Ub(t) {
  return typeof t == "boolean" && (jo = t), jo;
}
function Qk(t) {
  const e = typeof t == "string" ? Lc(t, true, jo) : t;
  if (e) {
    const i = HO(e.provider, e.prefix), n = e.name;
    return i.icons[n] || (i.missing.has(n) ? null : void 0);
  }
}
function gk(t, e) {
  const i = Lc(t, true, jo);
  if (!i)
    return false;
  const n = HO(i.provider, i.prefix);
  return $k(n, i.name, e);
}
function mk(t, e) {
  if (typeof t != "object")
    return false;
  if (typeof e != "string" && (e = t.provider || ""), jo && !e && !t.prefix) {
    let O = false;
    return Zb(t) && (t.prefix = "", Rb(t, (r, a) => {
      a && gk(r, a) && (O = true);
    })), O;
  }
  const i = t.prefix;
  if (!yl({
    provider: e,
    prefix: i,
    name: "a"
  }))
    return false;
  const n = HO(e, i);
  return !!pp(n, t);
}
var Vb = Object.freeze({
  width: null,
  height: null
});
var qb = Object.freeze({
  ...Vb,
  ...Il
});
var Sk = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
var Pk = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function xQ(t, e, i) {
  if (e === 1)
    return t;
  if (i = i || 100, typeof t == "number")
    return Math.ceil(t * e * i) / i;
  if (typeof t != "string")
    return t;
  const n = t.split(Sk);
  if (n === null || !n.length)
    return t;
  const O = [];
  let r = n.shift(), a = Pk.test(r);
  for (; ; ) {
    if (a) {
      const o = parseFloat(r);
      isNaN(o) ? O.push(r) : O.push(Math.ceil(o * e * i) / i);
    } else
      O.push(r);
    if (r = n.shift(), r === void 0)
      return O.join("");
    a = !a;
  }
}
var yk = (t) => t === "unset" || t === "undefined" || t === "none";
function bk(t, e) {
  const i = {
    ...Dc,
    ...t
  }, n = {
    ...qb,
    ...e
  }, O = {
    left: i.left,
    top: i.top,
    width: i.width,
    height: i.height
  };
  let r = i.body;
  [i, n].forEach((p) => {
    const $ = [], g = p.hFlip, Q = p.vFlip;
    let m = p.rotate;
    g ? Q ? m += 2 : ($.push(
      "translate(" + (O.width + O.left).toString() + " " + (0 - O.top).toString() + ")"
    ), $.push("scale(-1 1)"), O.top = O.left = 0) : Q && ($.push(
      "translate(" + (0 - O.left).toString() + " " + (O.height + O.top).toString() + ")"
    ), $.push("scale(1 -1)"), O.top = O.left = 0);
    let b;
    switch (m < 0 && (m -= Math.floor(m / 4) * 4), m = m % 4, m) {
      case 1:
        b = O.height / 2 + O.top, $.unshift(
          "rotate(90 " + b.toString() + " " + b.toString() + ")"
        );
        break;
      case 2:
        $.unshift(
          "rotate(180 " + (O.width / 2 + O.left).toString() + " " + (O.height / 2 + O.top).toString() + ")"
        );
        break;
      case 3:
        b = O.width / 2 + O.left, $.unshift(
          "rotate(-90 " + b.toString() + " " + b.toString() + ")"
        );
        break;
    }
    m % 2 === 1 && (O.left !== O.top && (b = O.left, O.left = O.top, O.top = b), O.width !== O.height && (b = O.width, O.width = O.height, O.height = b)), $.length && (r = '<g transform="' + $.join(" ") + '">' + r + "</g>");
  });
  const a = n.width, o = n.height, s = O.width, l = O.height;
  let c, u;
  a === null ? (u = o === null ? "1em" : o === "auto" ? l : o, c = xQ(u, s / l)) : (c = a === "auto" ? s : a, u = o === null ? xQ(c, l / s) : o === "auto" ? l : o);
  const h10 = {}, d = (p, $) => {
    yk($) || (h10[p] = $.toString());
  };
  return d("width", c), d("height", u), h10.viewBox = O.left.toString() + " " + O.top.toString() + " " + s.toString() + " " + l.toString(), {
    attributes: h10,
    body: r
  };
}
var vk = /\sid="(\S+)"/g;
var Xk = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
var xk = 0;
function wk(t, e = Xk) {
  const i = [];
  let n;
  for (; n = vk.exec(t); )
    i.push(n[1]);
  if (!i.length)
    return t;
  const O = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return i.forEach((r) => {
    const a = typeof e == "function" ? e(r) : e + (xk++).toString(), o = r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    t = t.replace(
      new RegExp('([#;"])(' + o + ')([")]|\\.[a-z])', "g"),
      "$1" + a + O + "$3"
    );
  }), t = t.replace(new RegExp(O, "g"), ""), t;
}
var hh = /* @__PURE__ */ Object.create(null);
function Tk(t, e) {
  hh[t] = e;
}
function dh(t) {
  return hh[t] || hh[""];
}
function $p(t) {
  let e;
  if (typeof t.resources == "string")
    e = [t.resources];
  else if (e = t.resources, !(e instanceof Array) || !e.length)
    return null;
  return {
    resources: e,
    path: t.path || "/",
    maxURL: t.maxURL || 500,
    rotate: t.rotate || 750,
    timeout: t.timeout || 5e3,
    random: t.random === true,
    index: t.index || 0,
    dataAfterTimeout: t.dataAfterTimeout !== false
  };
}
var Qp = /* @__PURE__ */ Object.create(null);
var Ia = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
];
var bl = [];
for (; Ia.length > 0; )
  Ia.length === 1 || Math.random() > 0.5 ? bl.push(Ia.shift()) : bl.push(Ia.pop());
Qp[""] = $p({
  resources: ["https://api.iconify.design"].concat(bl)
});
function kk(t, e) {
  const i = $p(e);
  return i === null ? false : (Qp[t] = i, true);
}
function gp(t) {
  return Qp[t];
}
var _k = () => {
  let t;
  try {
    if (t = fetch, typeof t == "function")
      return t;
  } catch {
  }
};
var wQ = _k();
function Wk(t, e) {
  const i = gp(t);
  if (!i)
    return 0;
  let n;
  if (!i.maxURL)
    n = 0;
  else {
    let O = 0;
    i.resources.forEach((a) => {
      O = Math.max(O, a.length);
    });
    const r = e + ".json?icons=";
    n = i.maxURL - O - i.path.length - r.length;
  }
  return n;
}
function Yk(t) {
  return t === 404;
}
var Rk = (t, e, i) => {
  const n = [], O = Wk(t, e), r = "icons";
  let a = {
    type: r,
    provider: t,
    prefix: e,
    icons: []
  }, o = 0;
  return i.forEach((s, l) => {
    o += s.length + 1, o >= O && l > 0 && (n.push(a), a = {
      type: r,
      provider: t,
      prefix: e,
      icons: []
    }, o = s.length), a.icons.push(s);
  }), n.push(a), n;
};
function Zk(t) {
  if (typeof t == "string") {
    const e = gp(t);
    if (e)
      return e.path;
  }
  return "/";
}
var Uk = (t, e, i) => {
  if (!wQ) {
    i("abort", 424);
    return;
  }
  let n = Zk(e.provider);
  switch (e.type) {
    case "icons": {
      const r = e.prefix, o = e.icons.join(","), s = new URLSearchParams({
        icons: o
      });
      n += r + ".json?" + s.toString();
      break;
    }
    case "custom": {
      const r = e.uri;
      n += r.slice(0, 1) === "/" ? r.slice(1) : r;
      break;
    }
    default:
      i("abort", 400);
      return;
  }
  let O = 503;
  wQ(t + n).then((r) => {
    const a = r.status;
    if (a !== 200) {
      setTimeout(() => {
        i(Yk(a) ? "abort" : "next", a);
      });
      return;
    }
    return O = 501, r.json();
  }).then((r) => {
    if (typeof r != "object" || r === null) {
      setTimeout(() => {
        r === 404 ? i("abort", r) : i("next", O);
      });
      return;
    }
    setTimeout(() => {
      i("success", r);
    });
  }).catch(() => {
    i("next", O);
  });
};
var Vk = {
  prepare: Rk,
  send: Uk
};
function qk(t) {
  const e = {
    loaded: [],
    missing: [],
    pending: []
  }, i = /* @__PURE__ */ Object.create(null);
  t.sort((O, r) => O.provider !== r.provider ? O.provider.localeCompare(r.provider) : O.prefix !== r.prefix ? O.prefix.localeCompare(r.prefix) : O.name.localeCompare(r.name));
  let n = {
    provider: "",
    prefix: "",
    name: ""
  };
  return t.forEach((O) => {
    if (n.name === O.name && n.prefix === O.prefix && n.provider === O.provider)
      return;
    n = O;
    const r = O.provider, a = O.prefix, o = O.name, s = i[r] || (i[r] = /* @__PURE__ */ Object.create(null)), l = s[a] || (s[a] = HO(r, a));
    let c;
    o in l.icons ? c = e.loaded : a === "" || l.missing.has(o) ? c = e.missing : c = e.pending;
    const u = {
      provider: r,
      prefix: a,
      name: o
    };
    c.push(u);
  }), e;
}
function zb(t, e) {
  t.forEach((i) => {
    const n = i.loaderCallbacks;
    n && (i.loaderCallbacks = n.filter((O) => O.id !== e));
  });
}
function zk(t) {
  t.pendingCallbacksFlag || (t.pendingCallbacksFlag = true, setTimeout(() => {
    t.pendingCallbacksFlag = false;
    const e = t.loaderCallbacks ? t.loaderCallbacks.slice(0) : [];
    if (!e.length)
      return;
    let i = false;
    const n = t.provider, O = t.prefix;
    e.forEach((r) => {
      const a = r.icons, o = a.pending.length;
      a.pending = a.pending.filter((s) => {
        if (s.prefix !== O)
          return true;
        const l = s.name;
        if (t.icons[l])
          a.loaded.push({
            provider: n,
            prefix: O,
            name: l
          });
        else if (t.missing.has(l))
          a.missing.push({
            provider: n,
            prefix: O,
            name: l
          });
        else
          return i = true, true;
        return false;
      }), a.pending.length !== o && (i || zb([t], r.id), r.callback(
        a.loaded.slice(0),
        a.missing.slice(0),
        a.pending.slice(0),
        r.abort
      ));
    });
  }));
}
var Ck = 0;
function Ek(t, e, i) {
  const n = Ck++, O = zb.bind(null, i, n);
  if (!e.pending.length)
    return O;
  const r = {
    id: n,
    icons: e,
    callback: t,
    abort: O
  };
  return i.forEach((a) => {
    (a.loaderCallbacks || (a.loaderCallbacks = [])).push(r);
  }), O;
}
function jk(t, e = true, i = false) {
  const n = [];
  return t.forEach((O) => {
    const r = typeof O == "string" ? Lc(O, e, i) : O;
    r && n.push(r);
  }), n;
}
var Ik = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: false,
  dataAfterTimeout: false
};
function Ak(t, e, i, n) {
  const O = t.resources.length, r = t.random ? Math.floor(Math.random() * O) : t.index;
  let a;
  if (t.random) {
    let y = t.resources.slice(0);
    for (a = []; y.length > 1; ) {
      const v = Math.floor(Math.random() * y.length);
      a.push(y[v]), y = y.slice(0, v).concat(y.slice(v + 1));
    }
    a = a.concat(y);
  } else
    a = t.resources.slice(r).concat(t.resources.slice(0, r));
  const o = Date.now();
  let s = "pending", l = 0, c, u = null, h10 = [], d = [];
  typeof n == "function" && d.push(n);
  function p() {
    u && (clearTimeout(u), u = null);
  }
  function $() {
    s === "pending" && (s = "aborted"), p(), h10.forEach((y) => {
      y.status === "pending" && (y.status = "aborted");
    }), h10 = [];
  }
  function g(y, v) {
    v && (d = []), typeof y == "function" && d.push(y);
  }
  function Q() {
    return {
      startTime: o,
      payload: e,
      status: s,
      queriesSent: l,
      queriesPending: h10.length,
      subscribe: g,
      abort: $
    };
  }
  function m() {
    s = "failed", d.forEach((y) => {
      y(void 0, c);
    });
  }
  function b() {
    h10.forEach((y) => {
      y.status === "pending" && (y.status = "aborted");
    }), h10 = [];
  }
  function P(y, v, T) {
    const _ = v !== "success";
    switch (h10 = h10.filter((x) => x !== y), s) {
      case "pending":
        break;
      case "failed":
        if (_ || !t.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (v === "abort") {
      c = T, m();
      return;
    }
    if (_) {
      c = T, h10.length || (a.length ? S() : m());
      return;
    }
    if (p(), b(), !t.random) {
      const x = t.resources.indexOf(y.resource);
      x !== -1 && x !== t.index && (t.index = x);
    }
    s = "completed", d.forEach((x) => {
      x(T);
    });
  }
  function S() {
    if (s !== "pending")
      return;
    p();
    const y = a.shift();
    if (y === void 0) {
      if (h10.length) {
        u = setTimeout(() => {
          p(), s === "pending" && (b(), m());
        }, t.timeout);
        return;
      }
      m();
      return;
    }
    const v = {
      status: "pending",
      resource: y,
      callback: (T, _) => {
        P(v, T, _);
      }
    };
    h10.push(v), l++, u = setTimeout(S, t.rotate), i(y, e, v.callback);
  }
  return setTimeout(S), Q;
}
function Cb(t) {
  const e = {
    ...Ik,
    ...t
  };
  let i = [];
  function n() {
    i = i.filter((o) => o().status === "pending");
  }
  function O(o, s, l) {
    const c = Ak(
      e,
      o,
      s,
      (u, h10) => {
        n(), l && l(u, h10);
      }
    );
    return i.push(c), c;
  }
  function r(o) {
    return i.find((s) => o(s)) || null;
  }
  return {
    query: O,
    find: r,
    setIndex: (o) => {
      e.index = o;
    },
    getIndex: () => e.index,
    cleanup: n
  };
}
function TQ() {
}
var Au = /* @__PURE__ */ Object.create(null);
function Gk(t) {
  if (!Au[t]) {
    const e = gp(t);
    if (!e)
      return;
    const i = Cb(e), n = {
      config: e,
      redundancy: i
    };
    Au[t] = n;
  }
  return Au[t];
}
function Lk(t, e, i) {
  let n, O;
  if (typeof t == "string") {
    const r = dh(t);
    if (!r)
      return i(void 0, 424), TQ;
    O = r.send;
    const a = Gk(t);
    a && (n = a.redundancy);
  } else {
    const r = $p(t);
    if (r) {
      n = Cb(r);
      const a = t.resources ? t.resources[0] : "", o = dh(a);
      o && (O = o.send);
    }
  }
  return !n || !O ? (i(void 0, 424), TQ) : n.query(e, O, i)().abort;
}
var kQ = "iconify2";
var Io = "iconify";
var Eb = Io + "-count";
var _Q = Io + "-version";
var jb = 36e5;
var Dk = 168;
function ph(t, e) {
  try {
    return t.getItem(e);
  } catch {
  }
}
function mp(t, e, i) {
  try {
    return t.setItem(e, i), true;
  } catch {
  }
}
function WQ(t, e) {
  try {
    t.removeItem(e);
  } catch {
  }
}
function $h(t, e) {
  return mp(t, Eb, e.toString());
}
function Qh(t) {
  return parseInt(ph(t, Eb)) || 0;
}
var Mc = {
  local: true,
  session: true
};
var Ib = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
var Sp = false;
function Mk(t) {
  Sp = t;
}
var Vs = typeof window > "u" ? {} : window;
function Ab(t) {
  const e = t + "Storage";
  try {
    if (Vs && Vs[e] && typeof Vs[e].length == "number")
      return Vs[e];
  } catch {
  }
  Mc[t] = false;
}
function Gb(t, e) {
  const i = Ab(t);
  if (!i)
    return;
  const n = ph(i, _Q);
  if (n !== kQ) {
    if (n) {
      const o = Qh(i);
      for (let s = 0; s < o; s++)
        WQ(i, Io + s.toString());
    }
    mp(i, _Q, kQ), $h(i, 0);
    return;
  }
  const O = Math.floor(Date.now() / jb) - Dk, r = (o) => {
    const s = Io + o.toString(), l = ph(i, s);
    if (typeof l == "string") {
      try {
        const c = JSON.parse(l);
        if (typeof c == "object" && typeof c.cached == "number" && c.cached > O && typeof c.provider == "string" && typeof c.data == "object" && typeof c.data.prefix == "string" && e(c, o))
          return true;
      } catch {
      }
      WQ(i, s);
    }
  };
  let a = Qh(i);
  for (let o = a - 1; o >= 0; o--)
    r(o) || (o === a - 1 ? (a--, $h(i, a)) : Ib[t].add(o));
}
function Lb() {
  if (!Sp) {
    Mk(true);
    for (const t in Mc)
      Gb(t, (e) => {
        const i = e.data, n = e.provider, O = i.prefix, r = HO(
          n,
          O
        );
        if (!pp(r, i).length)
          return false;
        const a = i.lastModified || -1;
        return r.lastModifiedCached = r.lastModifiedCached ? Math.min(r.lastModifiedCached, a) : a, true;
      });
  }
}
function Nk(t, e) {
  const i = t.lastModifiedCached;
  if (i && i >= e)
    return i === e;
  if (t.lastModifiedCached = e, i)
    for (const n in Mc)
      Gb(n, (O) => {
        const r = O.data;
        return O.provider !== t.provider || r.prefix !== t.prefix || r.lastModified === e;
      });
  return true;
}
function Bk(t, e) {
  Sp || Lb();
  function i(n) {
    let O;
    if (!Mc[n] || !(O = Ab(n)))
      return;
    const r = Ib[n];
    let a;
    if (r.size)
      r.delete(a = Array.from(r).shift());
    else if (a = Qh(O), !$h(O, a + 1))
      return;
    const o = {
      cached: Math.floor(Date.now() / jb),
      provider: t.provider,
      data: e
    };
    return mp(
      O,
      Io + a.toString(),
      JSON.stringify(o)
    );
  }
  e.lastModified && !Nk(t, e.lastModified) || Object.keys(e.icons).length && (e.not_found && (e = Object.assign({}, e), delete e.not_found), i("local") || i("session"));
}
function YQ() {
}
function Fk(t) {
  t.iconsLoaderFlag || (t.iconsLoaderFlag = true, setTimeout(() => {
    t.iconsLoaderFlag = false, zk(t);
  }));
}
function Hk(t, e) {
  t.iconsToLoad ? t.iconsToLoad = t.iconsToLoad.concat(e).sort() : t.iconsToLoad = e, t.iconsQueueFlag || (t.iconsQueueFlag = true, setTimeout(() => {
    t.iconsQueueFlag = false;
    const { provider: i, prefix: n } = t, O = t.iconsToLoad;
    delete t.iconsToLoad;
    let r;
    if (!O || !(r = dh(i)))
      return;
    r.prepare(i, n, O).forEach((o) => {
      Lk(i, o, (s) => {
        if (typeof s != "object")
          o.icons.forEach((l) => {
            t.missing.add(l);
          });
        else
          try {
            const l = pp(
              t,
              s
            );
            if (!l.length)
              return;
            const c = t.pendingIcons;
            c && l.forEach((u) => {
              c.delete(u);
            }), Bk(t, s);
          } catch (l) {
            console.error(l);
          }
        Fk(t);
      });
    });
  }));
}
var Kk = (t, e) => {
  const i = jk(t, true, Ub()), n = qk(i);
  if (!n.pending.length) {
    let s = true;
    return e && setTimeout(() => {
      s && e(
        n.loaded,
        n.missing,
        n.pending,
        YQ
      );
    }), () => {
      s = false;
    };
  }
  const O = /* @__PURE__ */ Object.create(null), r = [];
  let a, o;
  return n.pending.forEach((s) => {
    const { provider: l, prefix: c } = s;
    if (c === o && l === a)
      return;
    a = l, o = c, r.push(HO(l, c));
    const u = O[l] || (O[l] = /* @__PURE__ */ Object.create(null));
    u[c] || (u[c] = []);
  }), n.pending.forEach((s) => {
    const { provider: l, prefix: c, name: u } = s, h10 = HO(l, c), d = h10.pendingIcons || (h10.pendingIcons = /* @__PURE__ */ new Set());
    d.has(u) || (d.add(u), O[l][c].push(u));
  }), r.forEach((s) => {
    const { provider: l, prefix: c } = s;
    O[l][c].length && Hk(s, O[l][c]);
  }), e ? Ek(e, n, r) : YQ;
};
function Jk(t, e) {
  const i = {
    ...t
  };
  for (const n in e) {
    const O = e[n], r = typeof O;
    n in Vb ? (O === null || O && (r === "string" || r === "number")) && (i[n] = O) : r === typeof i[n] && (i[n] = n === "rotate" ? O % 4 : O);
  }
  return i;
}
var e_ = /[\s,]+/;
function t_(t, e) {
  e.split(e_).forEach((i) => {
    switch (i.trim()) {
      case "horizontal":
        t.hFlip = true;
        break;
      case "vertical":
        t.vFlip = true;
        break;
    }
  });
}
function i_(t, e = 0) {
  const i = t.replace(/^-?[0-9.]*/, "");
  function n(O) {
    for (; O < 0; )
      O += 4;
    return O % 4;
  }
  if (i === "") {
    const O = parseInt(t);
    return isNaN(O) ? 0 : n(O);
  } else if (i !== t) {
    let O = 0;
    switch (i) {
      case "%":
        O = 25;
        break;
      case "deg":
        O = 90;
    }
    if (O) {
      let r = parseFloat(t.slice(0, t.length - i.length));
      return isNaN(r) ? 0 : (r = r / O, r % 1 === 0 ? n(r) : 0);
    }
  }
  return e;
}
function n_(t, e) {
  let i = t.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const n in e)
    i += " " + n + '="' + e[n] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + i + ">" + t + "</svg>";
}
function O_(t) {
  return t.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function r_(t) {
  return 'url("data:image/svg+xml,' + O_(t) + '")';
}
var RQ = {
  ...qb,
  inline: false
};
var a_ = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "aria-hidden": true,
  role: "img"
};
var o_ = {
  display: "inline-block"
};
var gh = {
  backgroundColor: "currentColor"
};
var Db = {
  backgroundColor: "transparent"
};
var ZQ = {
  Image: "var(--svg)",
  Repeat: "no-repeat",
  Size: "100% 100%"
};
var UQ = {
  webkitMask: gh,
  mask: gh,
  background: Db
};
for (const t in UQ) {
  const e = UQ[t];
  for (const i in ZQ)
    e[t + i] = ZQ[i];
}
var vl = {};
["horizontal", "vertical"].forEach((t) => {
  const e = t.slice(0, 1) + "Flip";
  vl[t + "-flip"] = e, vl[t.slice(0, 1) + "-flip"] = e, vl[t + "Flip"] = e;
});
function VQ(t) {
  return t + (t.match(/^[-0-9.]+$/) ? "px" : "");
}
var qQ = (t, e) => {
  const i = Jk(RQ, e), n = { ...a_ }, O = e.mode || "svg", r = {}, a = e.style, o = typeof a == "object" && !(a instanceof Array) ? a : {};
  for (let $ in e) {
    const g = e[$];
    if (g !== void 0)
      switch ($) {
        case "icon":
        case "style":
        case "onLoad":
        case "mode":
          break;
        case "inline":
        case "hFlip":
        case "vFlip":
          i[$] = g === true || g === "true" || g === 1;
          break;
        case "flip":
          typeof g == "string" && t_(i, g);
          break;
        case "color":
          r.color = g;
          break;
        case "rotate":
          typeof g == "string" ? i[$] = i_(g) : typeof g == "number" && (i[$] = g);
          break;
        case "ariaHidden":
        case "aria-hidden":
          g !== true && g !== "true" && delete n["aria-hidden"];
          break;
        default: {
          const Q = vl[$];
          Q ? (g === true || g === "true" || g === 1) && (i[Q] = true) : RQ[$] === void 0 && (n[$] = g);
        }
      }
  }
  const s = bk(t, i), l = s.attributes;
  if (i.inline && (r.verticalAlign = "-0.125em"), O === "svg") {
    n.style = {
      ...r,
      ...o
    }, Object.assign(n, l);
    let $ = 0, g = e.id;
    return typeof g == "string" && (g = g.replace(/-/g, "_")), n.innerHTML = wk(s.body, g ? () => g + "ID" + $++ : "iconifyVue"), h("svg", n);
  }
  const { body: c, width: u, height: h10 } = t, d = O === "mask" || (O === "bg" ? false : c.indexOf("currentColor") !== -1), p = n_(c, {
    ...l,
    width: u + "",
    height: h10 + ""
  });
  return n.style = {
    ...r,
    "--svg": r_(p),
    width: VQ(l.width),
    height: VQ(l.height),
    ...o_,
    ...d ? gh : Db,
    ...o
  }, h("span", n);
};
Ub(true);
Tk("", Vk);
if (typeof document < "u" && typeof window < "u") {
  Lb();
  const t = window;
  if (t.IconifyPreload !== void 0) {
    const e = t.IconifyPreload, i = "Invalid IconifyPreload syntax.";
    typeof e == "object" && e !== null && (e instanceof Array ? e : [e]).forEach((n) => {
      try {
        (typeof n != "object" || n === null || n instanceof Array || // Check for 'icons' and 'prefix'
        typeof n.icons != "object" || typeof n.prefix != "string" || // Add icon set
        !mk(n)) && console.error(i);
      } catch {
        console.error(i);
      }
    });
  }
  if (t.IconifyProviders !== void 0) {
    const e = t.IconifyProviders;
    if (typeof e == "object" && e !== null)
      for (let i in e) {
        const n = "IconifyProviders[" + i + "] is invalid.";
        try {
          const O = e[i];
          if (typeof O != "object" || !O || O.resources === void 0)
            continue;
          kk(i, O) || console.error(n);
        } catch {
          console.error(n);
        }
      }
  }
}
var s_ = {
  ...Dc,
  body: ""
};
var l_ = defineComponent({
  // Do not inherit other attributes: it is handled by render()
  inheritAttrs: false,
  // Set initial data
  data() {
    return {
      // Mounted status
      iconMounted: false,
      // Callback counter to trigger re-render
      counter: 0
    };
  },
  mounted() {
    this._name = "", this._loadingIcon = null, this.iconMounted = true;
  },
  unmounted() {
    this.abortLoading();
  },
  methods: {
    abortLoading() {
      this._loadingIcon && (this._loadingIcon.abort(), this._loadingIcon = null);
    },
    // Get data for icon to render or null
    getIcon(t, e) {
      if (typeof t == "object" && t !== null && typeof t.body == "string")
        return this._name = "", this.abortLoading(), {
          data: t
        };
      let i;
      if (typeof t != "string" || (i = Lc(t, false, true)) === null)
        return this.abortLoading(), null;
      const n = Qk(i);
      if (!n)
        return (!this._loadingIcon || this._loadingIcon.name !== t) && (this.abortLoading(), this._name = "", n !== null && (this._loadingIcon = {
          name: t,
          abort: Kk([i], () => {
            this.counter++;
          })
        })), null;
      this.abortLoading(), this._name !== t && (this._name = t, e && e(t));
      const O = ["iconify"];
      return i.prefix !== "" && O.push("iconify--" + i.prefix), i.provider !== "" && O.push("iconify--" + i.provider), { data: n, classes: O };
    }
  },
  // Render icon
  render() {
    this.counter;
    const t = this.$attrs, e = this.iconMounted ? this.getIcon(t.icon, t.onLoad) : null;
    if (!e)
      return qQ(s_, t);
    let i = t;
    return e.classes && (i = {
      ...t,
      class: (typeof t.class == "string" ? t.class + " " : "") + e.classes.join(" ")
    }), qQ({
      ...Dc,
      ...e.data
    }, i);
  }
});
var c_ = {
  name: "HIcon"
};
var u_ = defineComponent({
  ...c_,
  props: {
    icon: null,
    size: { default: 14 }
  },
  setup(t) {
    const e = t;
    return useCssVars((i) => ({
      "593b3b34": `${e.size}px`
    })), (i, n) => (openBlock(), createBlock(unref(l_), {
      icon: t.icon,
      class: "icon"
    }, null, 8, ["icon"]));
  }
});
var Bt = Be(u_);
var f_ = ["src"];
var h_ = {
  name: "HImagePreview"
};
var d_ = defineComponent({
  ...h_,
  props: {
    data: null,
    mime: { default: "image/png" }
  },
  setup(t) {
    const e = t;
    let i = /* @__PURE__ */ new Map([
      ["image/png", "img"],
      ["image/jpeg", "img"],
      ["image/gif", "img"]
    ]);
    const n = computed(() => i.get(e.mime)), O = computed(() => e.data.includes("data:image") && e.data.includes(";base64,") ? e.data : "data:" + e.mime + ";base64," + e.data);
    return (r, a) => unref(n) === "img" ? (openBlock(), createElementBlock("img", {
      key: 0,
      src: unref(O)
    }, null, 8, f_)) : createCommentVNode("", true);
  }
});
var p_ = Be(d_);
var Te = class {
  /**
  @internal
  */
  constructor() {
  }
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, false, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, true, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, i, n) {
    let O = [];
    return this.decompose(
      0,
      e,
      O,
      2
      /* Open.To */
    ), n.length && n.decompose(
      0,
      n.length,
      O,
      3
      /* Open.To */
    ), this.decompose(
      i,
      this.length,
      O,
      1
      /* Open.From */
    ), pn.from(O, this.length - (i - e) + n.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, i = this.length) {
    let n = [];
    return this.decompose(e, i, n, 0), pn.from(n, i - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return true;
    if (e.length != this.length || e.lines != this.lines)
      return false;
    let i = this.scanIdentical(e, 1), n = this.length - this.scanIdentical(e, -1), O = new vo(this), r = new vo(e);
    for (let a = i, o = i; ; ) {
      if (O.next(a), r.next(a), a = 0, O.lineBreak != r.lineBreak || O.done != r.done || O.value != r.value)
        return false;
      if (o += O.value.length, O.done || o >= n)
        return true;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new vo(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, i = this.length) {
    return new Mb(this, e, i);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, i) {
    let n;
    if (e == null)
      n = this.iter();
    else {
      i == null && (i = this.lines + 1);
      let O = this.line(e).from;
      n = this.iterRange(O, Math.max(O, i == this.lines + 1 ? this.length : i <= 1 ? 0 : this.line(i - 1).to));
    }
    return new Nb(n);
  }
  /**
  @internal
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? Te.empty : e.length <= 32 ? new et(e) : pn.from(et.split(e, []));
  }
};
var et = class extends Te {
  constructor(e, i = $_(e)) {
    super(), this.text = e, this.length = i;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, i, n, O) {
    for (let r = 0; ; r++) {
      let a = this.text[r], o = O + a.length;
      if ((i ? n : o) >= e)
        return new Q_(O, o, n, a);
      O = o + 1, n++;
    }
  }
  decompose(e, i, n, O) {
    let r = e <= 0 && i >= this.length ? this : new et(zQ(this.text, e, i), Math.min(i, this.length) - Math.max(0, e));
    if (O & 1) {
      let a = n.pop(), o = Xl(r.text, a.text.slice(), 0, r.length);
      if (o.length <= 32)
        n.push(new et(o, a.length + r.length));
      else {
        let s = o.length >> 1;
        n.push(new et(o.slice(0, s)), new et(o.slice(s)));
      }
    } else
      n.push(r);
  }
  replace(e, i, n) {
    if (!(n instanceof et))
      return super.replace(e, i, n);
    let O = Xl(this.text, Xl(n.text, zQ(this.text, 0, e)), i), r = this.length + n.length - (i - e);
    return O.length <= 32 ? new et(O, r) : pn.from(et.split(O, []), r);
  }
  sliceString(e, i = this.length, n = `
`) {
    let O = "";
    for (let r = 0, a = 0; r <= i && a < this.text.length; a++) {
      let o = this.text[a], s = r + o.length;
      r > e && a && (O += n), e < s && i > r && (O += o.slice(Math.max(0, e - r), i - r)), r = s + 1;
    }
    return O;
  }
  flatten(e) {
    for (let i of this.text)
      e.push(i);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, i) {
    let n = [], O = -1;
    for (let r of e)
      n.push(r), O += r.length + 1, n.length == 32 && (i.push(new et(n, O)), n = [], O = -1);
    return O > -1 && i.push(new et(n, O)), i;
  }
};
var pn = class extends Te {
  constructor(e, i) {
    super(), this.children = e, this.length = i, this.lines = 0;
    for (let n of e)
      this.lines += n.lines;
  }
  lineInner(e, i, n, O) {
    for (let r = 0; ; r++) {
      let a = this.children[r], o = O + a.length, s = n + a.lines - 1;
      if ((i ? s : o) >= e)
        return a.lineInner(e, i, n, O);
      O = o + 1, n = s + 1;
    }
  }
  decompose(e, i, n, O) {
    for (let r = 0, a = 0; a <= i && r < this.children.length; r++) {
      let o = this.children[r], s = a + o.length;
      if (e <= s && i >= a) {
        let l = O & ((a <= e ? 1 : 0) | (s >= i ? 2 : 0));
        a >= e && s <= i && !l ? n.push(o) : o.decompose(e - a, i - a, n, l);
      }
      a = s + 1;
    }
  }
  replace(e, i, n) {
    if (n.lines < this.lines)
      for (let O = 0, r = 0; O < this.children.length; O++) {
        let a = this.children[O], o = r + a.length;
        if (e >= r && i <= o) {
          let s = a.replace(e - r, i - r, n), l = this.lines - a.lines + s.lines;
          if (s.lines < l >> 5 - 1 && s.lines > l >> 5 + 1) {
            let c = this.children.slice();
            return c[O] = s, new pn(c, this.length - (i - e) + n.length);
          }
          return super.replace(r, o, s);
        }
        r = o + 1;
      }
    return super.replace(e, i, n);
  }
  sliceString(e, i = this.length, n = `
`) {
    let O = "";
    for (let r = 0, a = 0; r < this.children.length && a <= i; r++) {
      let o = this.children[r], s = a + o.length;
      a > e && r && (O += n), e < s && i > a && (O += o.sliceString(e - a, i - a, n)), a = s + 1;
    }
    return O;
  }
  flatten(e) {
    for (let i of this.children)
      i.flatten(e);
  }
  scanIdentical(e, i) {
    if (!(e instanceof pn))
      return 0;
    let n = 0, [O, r, a, o] = i > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; O += i, r += i) {
      if (O == a || r == o)
        return n;
      let s = this.children[O], l = e.children[r];
      if (s != l)
        return n + s.scanIdentical(l, i);
      n += s.length + 1;
    }
  }
  static from(e, i = e.reduce((n, O) => n + O.length + 1, -1)) {
    let n = 0;
    for (let d of e)
      n += d.lines;
    if (n < 32) {
      let d = [];
      for (let p of e)
        p.flatten(d);
      return new et(d, i);
    }
    let O = Math.max(
      32,
      n >> 5
      /* Tree.BranchShift */
    ), r = O << 1, a = O >> 1, o = [], s = 0, l = -1, c = [];
    function u(d) {
      let p;
      if (d.lines > r && d instanceof pn)
        for (let $ of d.children)
          u($);
      else
        d.lines > a && (s > a || !s) ? (h10(), o.push(d)) : d instanceof et && s && (p = c[c.length - 1]) instanceof et && d.lines + p.lines <= 32 ? (s += d.lines, l += d.length + 1, c[c.length - 1] = new et(p.text.concat(d.text), p.length + 1 + d.length)) : (s + d.lines > O && h10(), s += d.lines, l += d.length + 1, c.push(d));
    }
    function h10() {
      s != 0 && (o.push(c.length == 1 ? c[0] : pn.from(c, l)), l = -1, s = c.length = 0);
    }
    for (let d of e)
      u(d);
    return h10(), o.length == 1 ? o[0] : new pn(o, i);
  }
};
Te.empty = new et([""], 0);
function $_(t) {
  let e = -1;
  for (let i of t)
    e += i.length + 1;
  return e;
}
function Xl(t, e, i = 0, n = 1e9) {
  for (let O = 0, r = 0, a = true; r < t.length && O <= n; r++) {
    let o = t[r], s = O + o.length;
    s >= i && (s > n && (o = o.slice(0, n - O)), O < i && (o = o.slice(i - O)), a ? (e[e.length - 1] += o, a = false) : e.push(o)), O = s + 1;
  }
  return e;
}
function zQ(t, e, i) {
  return Xl(t, [""], e, i);
}
var vo = class {
  constructor(e, i = 1) {
    this.dir = i, this.done = false, this.lineBreak = false, this.value = "", this.nodes = [e], this.offsets = [i > 0 ? 1 : (e instanceof et ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, i) {
    for (this.done = this.lineBreak = false; ; ) {
      let n = this.nodes.length - 1, O = this.nodes[n], r = this.offsets[n], a = r >> 1, o = O instanceof et ? O.text.length : O.children.length;
      if (a == (i > 0 ? o : 0)) {
        if (n == 0)
          return this.done = true, this.value = "", this;
        i > 0 && this.offsets[n - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((r & 1) == (i > 0 ? 0 : 1)) {
        if (this.offsets[n] += i, e == 0)
          return this.lineBreak = true, this.value = `
`, this;
        e--;
      } else if (O instanceof et) {
        let s = O.text[a + (i < 0 ? -1 : 0)];
        if (this.offsets[n] += i, s.length > Math.max(0, e))
          return this.value = e == 0 ? s : i > 0 ? s.slice(e) : s.slice(0, s.length - e), this;
        e -= s.length;
      } else {
        let s = O.children[a + (i < 0 ? -1 : 0)];
        e > s.length ? (e -= s.length, this.offsets[n] += i) : (i < 0 && this.offsets[n]--, this.nodes.push(s), this.offsets.push(i > 0 ? 1 : (s instanceof et ? s.text.length : s.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
};
var Mb = class {
  constructor(e, i, n) {
    this.value = "", this.done = false, this.cursor = new vo(e, i > n ? -1 : 1), this.pos = i > n ? e.length : 0, this.from = Math.min(i, n), this.to = Math.max(i, n);
  }
  nextInner(e, i) {
    if (i < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = true, this;
    e += Math.max(0, i < 0 ? this.pos - this.to : this.from - this.pos);
    let n = i < 0 ? this.pos - this.from : this.to - this.pos;
    e > n && (e = n), n -= e;
    let { value: O } = this.cursor.next(e);
    return this.pos += (O.length + e) * i, this.value = O.length <= n ? O : i < 0 ? O.slice(O.length - n) : O.slice(0, n), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
};
var Nb = class {
  constructor(e) {
    this.inner = e, this.afterBreak = true, this.value = "", this.done = false;
  }
  next(e = 0) {
    let { done: i, lineBreak: n, value: O } = this.inner.next(e);
    return i ? (this.done = true, this.value = "") : n ? this.afterBreak ? this.value = "" : (this.afterBreak = true, this.next()) : (this.value = O, this.afterBreak = false), this;
  }
  get lineBreak() {
    return false;
  }
};
typeof Symbol < "u" && (Te.prototype[Symbol.iterator] = function() {
  return this.iter();
}, vo.prototype[Symbol.iterator] = Mb.prototype[Symbol.iterator] = Nb.prototype[Symbol.iterator] = function() {
  return this;
});
var Q_ = class {
  /**
  @internal
  */
  constructor(e, i, n, O) {
    this.from = e, this.to = i, this.number = n, this.text = O;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
};
var Gr = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((t) => t ? parseInt(t, 36) : 1);
for (let t = 1; t < Gr.length; t++)
  Gr[t] += Gr[t - 1];
function g_(t) {
  for (let e = 1; e < Gr.length; e += 2)
    if (Gr[e] > t)
      return Gr[e - 1] <= t;
  return false;
}
function CQ(t) {
  return t >= 127462 && t <= 127487;
}
var EQ = 8205;
function Mt(t, e, i = true, n = true) {
  return (i ? Bb : m_)(t, e, n);
}
function Bb(t, e, i) {
  if (e == t.length)
    return e;
  e && Fb(t.charCodeAt(e)) && Hb(t.charCodeAt(e - 1)) && e--;
  let n = Xt(t, e);
  for (e += _i(n); e < t.length; ) {
    let O = Xt(t, e);
    if (n == EQ || O == EQ || i && g_(O))
      e += _i(O), n = O;
    else if (CQ(O)) {
      let r = 0, a = e - 2;
      for (; a >= 0 && CQ(Xt(t, a)); )
        r++, a -= 2;
      if (r % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function m_(t, e, i) {
  for (; e > 0; ) {
    let n = Bb(t, e - 2, i);
    if (n < e)
      return n;
    e--;
  }
  return 0;
}
function Fb(t) {
  return t >= 56320 && t < 57344;
}
function Hb(t) {
  return t >= 55296 && t < 56320;
}
function Xt(t, e) {
  let i = t.charCodeAt(e);
  if (!Hb(i) || e + 1 == t.length)
    return i;
  let n = t.charCodeAt(e + 1);
  return Fb(n) ? (i - 55296 << 10) + (n - 56320) + 65536 : i;
}
function Pp(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
function _i(t) {
  return t < 65536 ? 1 : 2;
}
var mh = /\r\n?|\n/;
var wt = function(t) {
  return t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t;
}(wt || (wt = {}));
var mn = class {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let i = 0; i < this.sections.length; i += 2)
      e += this.sections[i];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let i = 0; i < this.sections.length; i += 2) {
      let n = this.sections[i + 1];
      e += n < 0 ? this.sections[i] : n;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let i = 0, n = 0, O = 0; i < this.sections.length; ) {
      let r = this.sections[i++], a = this.sections[i++];
      a < 0 ? (e(n, O, r), O += r) : O += a, n += r;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, i = false) {
    Sh(this, e, i);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let i = 0; i < this.sections.length; ) {
      let n = this.sections[i++], O = this.sections[i++];
      O < 0 ? e.push(n, O) : e.push(O, n);
    }
    return new mn(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : Kb(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(e, i = false) {
    return e.empty ? this : Ph(this, e, i);
  }
  mapPos(e, i = -1, n = wt.Simple) {
    let O = 0, r = 0;
    for (let a = 0; a < this.sections.length; ) {
      let o = this.sections[a++], s = this.sections[a++], l = O + o;
      if (s < 0) {
        if (l > e)
          return r + (e - O);
        r += o;
      } else {
        if (n != wt.Simple && l >= e && (n == wt.TrackDel && O < e && l > e || n == wt.TrackBefore && O < e || n == wt.TrackAfter && l > e))
          return null;
        if (l > e || l == e && i < 0 && !o)
          return e == O || i < 0 ? r : r + s;
        r += s;
      }
      O = l;
    }
    if (e > O)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${O}`);
    return r;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, i = e) {
    for (let n = 0, O = 0; n < this.sections.length && O <= i; ) {
      let r = this.sections[n++], a = this.sections[n++], o = O + r;
      if (a >= 0 && O <= i && o >= e)
        return O < e && o > i ? "cover" : true;
      O = o;
    }
    return false;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let i = 0; i < this.sections.length; ) {
      let n = this.sections[i++], O = this.sections[i++];
      e += (e ? " " : "") + n + (O >= 0 ? ":" + O : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((i) => typeof i != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new mn(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new mn(e);
  }
};
var ct = class extends mn {
  constructor(e, i) {
    super(e), this.inserted = i;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return Sh(this, (i, n, O, r, a) => e = e.replace(O, O + (n - i), a), false), e;
  }
  mapDesc(e, i = false) {
    return Ph(this, e, i, true);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let i = this.sections.slice(), n = [];
    for (let O = 0, r = 0; O < i.length; O += 2) {
      let a = i[O], o = i[O + 1];
      if (o >= 0) {
        i[O] = o, i[O + 1] = a;
        let s = O >> 1;
        for (; n.length < s; )
          n.push(Te.empty);
        n.push(a ? e.slice(r, r + a) : Te.empty);
      }
      r += a;
    }
    return new ct(i, n);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : Kb(this, e, true);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, i = false) {
    return e.empty ? this : Ph(this, e, i, true);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, i = false) {
    Sh(this, e, i);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return mn.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let i = [], n = [], O = [], r = new Ao(this);
    e:
      for (let a = 0, o = 0; ; ) {
        let s = a == e.length ? 1e9 : e[a++];
        for (; o < s || o == s && r.len == 0; ) {
          if (r.done)
            break e;
          let c = Math.min(r.len, s - o);
          Wt(O, c, -1);
          let u = r.ins == -1 ? -1 : r.off == 0 ? r.ins : 0;
          Wt(i, c, u), u > 0 && sO(n, i, r.text), r.forward(c), o += c;
        }
        let l = e[a++];
        for (; o < l; ) {
          if (r.done)
            break e;
          let c = Math.min(r.len, l - o);
          Wt(i, c, -1), Wt(O, c, r.ins == -1 ? -1 : r.off == 0 ? r.ins : 0), r.forward(c), o += c;
        }
      }
    return {
      changes: new ct(i, n),
      filtered: mn.create(O)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let i = 0; i < this.sections.length; i += 2) {
      let n = this.sections[i], O = this.sections[i + 1];
      O < 0 ? e.push(n) : O == 0 ? e.push([n]) : e.push([n].concat(this.inserted[i >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, i, n) {
    let O = [], r = [], a = 0, o = null;
    function s(c = false) {
      if (!c && !O.length)
        return;
      a < i && Wt(O, i - a, -1);
      let u = new ct(O, r);
      o = o ? o.compose(u.map(o)) : u, O = [], r = [], a = 0;
    }
    function l(c) {
      if (Array.isArray(c))
        for (let u of c)
          l(u);
      else if (c instanceof ct) {
        if (c.length != i)
          throw new RangeError(`Mismatched change set length (got ${c.length}, expected ${i})`);
        s(), o = o ? o.compose(c.map(o)) : c;
      } else {
        let { from: u, to: h10 = u, insert: d } = c;
        if (u > h10 || u < 0 || h10 > i)
          throw new RangeError(`Invalid change range ${u} to ${h10} (in doc of length ${i})`);
        let p = d ? typeof d == "string" ? Te.of(d.split(n || mh)) : d : Te.empty, $ = p.length;
        if (u == h10 && $ == 0)
          return;
        u < a && s(), u > a && Wt(O, u - a, -1), Wt(O, h10 - u, $), sO(r, O, p), a = h10;
      }
    }
    return l(e), s(!o), o;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new ct(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let i = [], n = [];
    for (let O = 0; O < e.length; O++) {
      let r = e[O];
      if (typeof r == "number")
        i.push(r, -1);
      else {
        if (!Array.isArray(r) || typeof r[0] != "number" || r.some((a, o) => o && typeof a != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (r.length == 1)
          i.push(r[0], 0);
        else {
          for (; n.length < O; )
            n.push(Te.empty);
          n[O] = Te.of(r.slice(1)), i.push(r[0], n[O].length);
        }
      }
    }
    return new ct(i, n);
  }
  /**
  @internal
  */
  static createSet(e, i) {
    return new ct(e, i);
  }
};
function Wt(t, e, i, n = false) {
  if (e == 0 && i <= 0)
    return;
  let O = t.length - 2;
  O >= 0 && i <= 0 && i == t[O + 1] ? t[O] += e : e == 0 && t[O] == 0 ? t[O + 1] += i : n ? (t[O] += e, t[O + 1] += i) : t.push(e, i);
}
function sO(t, e, i) {
  if (i.length == 0)
    return;
  let n = e.length - 2 >> 1;
  if (n < t.length)
    t[t.length - 1] = t[t.length - 1].append(i);
  else {
    for (; t.length < n; )
      t.push(Te.empty);
    t.push(i);
  }
}
function Sh(t, e, i) {
  let n = t.inserted;
  for (let O = 0, r = 0, a = 0; a < t.sections.length; ) {
    let o = t.sections[a++], s = t.sections[a++];
    if (s < 0)
      O += o, r += o;
    else {
      let l = O, c = r, u = Te.empty;
      for (; l += o, c += s, s && n && (u = u.append(n[a - 2 >> 1])), !(i || a == t.sections.length || t.sections[a + 1] < 0); )
        o = t.sections[a++], s = t.sections[a++];
      e(O, l, r, c, u), O = l, r = c;
    }
  }
}
function Ph(t, e, i, n = false) {
  let O = [], r = n ? [] : null, a = new Ao(t), o = new Ao(e);
  for (let s = -1; ; )
    if (a.ins == -1 && o.ins == -1) {
      let l = Math.min(a.len, o.len);
      Wt(O, l, -1), a.forward(l), o.forward(l);
    } else if (o.ins >= 0 && (a.ins < 0 || s == a.i || a.off == 0 && (o.len < a.len || o.len == a.len && !i))) {
      let l = o.len;
      for (Wt(O, o.ins, -1); l; ) {
        let c = Math.min(a.len, l);
        a.ins >= 0 && s < a.i && a.len <= c && (Wt(O, 0, a.ins), r && sO(r, O, a.text), s = a.i), a.forward(c), l -= c;
      }
      o.next();
    } else if (a.ins >= 0) {
      let l = 0, c = a.len;
      for (; c; )
        if (o.ins == -1) {
          let u = Math.min(c, o.len);
          l += u, c -= u, o.forward(u);
        } else if (o.ins == 0 && o.len < c)
          c -= o.len, o.next();
        else
          break;
      Wt(O, l, s < a.i ? a.ins : 0), r && s < a.i && sO(r, O, a.text), s = a.i, a.forward(a.len - c);
    } else {
      if (a.done && o.done)
        return r ? ct.createSet(O, r) : mn.create(O);
      throw new Error("Mismatched change set lengths");
    }
}
function Kb(t, e, i = false) {
  let n = [], O = i ? [] : null, r = new Ao(t), a = new Ao(e);
  for (let o = false; ; ) {
    if (r.done && a.done)
      return O ? ct.createSet(n, O) : mn.create(n);
    if (r.ins == 0)
      Wt(n, r.len, 0, o), r.next();
    else if (a.len == 0 && !a.done)
      Wt(n, 0, a.ins, o), O && sO(O, n, a.text), a.next();
    else {
      if (r.done || a.done)
        throw new Error("Mismatched change set lengths");
      {
        let s = Math.min(r.len2, a.len), l = n.length;
        if (r.ins == -1) {
          let c = a.ins == -1 ? -1 : a.off ? 0 : a.ins;
          Wt(n, s, c, o), O && c && sO(O, n, a.text);
        } else
          a.ins == -1 ? (Wt(n, r.off ? 0 : r.len, s, o), O && sO(O, n, r.textBit(s))) : (Wt(n, r.off ? 0 : r.len, a.off ? 0 : a.ins, o), O && !a.off && sO(O, n, a.text));
        o = (r.ins > s || a.ins >= 0 && a.len > s) && (o || n.length > l), r.forward2(s), a.forward(s);
      }
    }
  }
}
var Ao = class {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, i = this.i - 2 >> 1;
    return i >= e.length ? Te.empty : e[i];
  }
  textBit(e) {
    let { inserted: i } = this.set, n = this.i - 2 >> 1;
    return n >= i.length && !e ? Te.empty : i[n].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
};
var LO = class {
  constructor(e, i, n) {
    this.from = e, this.to = i, this.flags = n;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 16 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 16 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 3;
    return e == 3 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 5;
    return e == 33554431 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, i = -1) {
    let n, O;
    return this.empty ? n = O = e.mapPos(this.from, i) : (n = e.mapPos(this.from, 1), O = e.mapPos(this.to, -1)), n == this.from && O == this.to ? this : new LO(n, O, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, i = e) {
    if (e <= this.anchor && i >= this.anchor)
      return R.range(e, i);
    let n = Math.abs(e - this.anchor) > Math.abs(i - this.anchor) ? e : i;
    return R.range(this.anchor, n);
  }
  /**
  Compare this range to another range.
  */
  eq(e) {
    return this.anchor == e.anchor && this.head == e.head;
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return R.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, i, n) {
    return new LO(e, i, n);
  }
};
var R = class {
  constructor(e, i) {
    this.ranges = e, this.mainIndex = i;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, i = -1) {
    return e.empty ? this : R.create(this.ranges.map((n) => n.map(e, i)), this.mainIndex);
  }
  /**
  Compare this selection to another selection.
  */
  eq(e) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return false;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(e.ranges[i]))
        return false;
    return true;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new R([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, i = true) {
    return R.create([e].concat(this.ranges), i ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, i = this.mainIndex) {
    let n = this.ranges.slice();
    return n[i] = e, R.create(n, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new R(e.ranges.map((i) => LO.fromJSON(i)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, i = e) {
    return new R([R.range(e, i)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, i = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let n = 0, O = 0; O < e.length; O++) {
      let r = e[O];
      if (r.empty ? r.from <= n : r.from < n)
        return R.normalized(e.slice(), i);
      n = r.to;
    }
    return new R(e, i);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, i = 0, n, O) {
    return LO.create(e, e, (i == 0 ? 0 : i < 0 ? 4 : 8) | (n == null ? 3 : Math.min(2, n)) | (O ?? 33554431) << 5);
  }
  /**
  Create a selection range.
  */
  static range(e, i, n, O) {
    let r = (n ?? 33554431) << 5 | (O == null ? 3 : Math.min(2, O));
    return i < e ? LO.create(i, e, 24 | r) : LO.create(e, i, (i > e ? 4 : 0) | r);
  }
  /**
  @internal
  */
  static normalized(e, i = 0) {
    let n = e[i];
    e.sort((O, r) => O.from - r.from), i = e.indexOf(n);
    for (let O = 1; O < e.length; O++) {
      let r = e[O], a = e[O - 1];
      if (r.empty ? r.from <= a.to : r.from < a.to) {
        let o = a.from, s = Math.max(r.to, a.to);
        O <= i && i--, e.splice(--O, 2, r.anchor > r.head ? R.range(s, o) : R.range(o, s));
      }
    }
    return new R(e, i);
  }
};
function Jb(t, e) {
  for (let i of t.ranges)
    if (i.to > e)
      throw new RangeError("Selection points outside of document");
}
var yp = 0;
var K = class {
  constructor(e, i, n, O, r) {
    this.combine = e, this.compareInput = i, this.compare = n, this.isStatic = O, this.id = yp++, this.default = e([]), this.extensions = typeof r == "function" ? r(this) : r;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new K(e.combine || ((i) => i), e.compareInput || ((i, n) => i === n), e.compare || (e.combine ? (i, n) => i === n : bp), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new xl([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, i) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new xl(e, this, 1, i);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, i) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new xl(e, this, 2, i);
  }
  from(e, i) {
    return i || (i = (n) => n), this.compute([e], (n) => i(n.field(e)));
  }
};
function bp(t, e) {
  return t == e || t.length == e.length && t.every((i, n) => i === e[n]);
}
var xl = class {
  constructor(e, i, n, O) {
    this.dependencies = e, this.facet = i, this.type = n, this.value = O, this.id = yp++;
  }
  dynamicSlot(e) {
    var i;
    let n = this.value, O = this.facet.compareInput, r = this.id, a = e[r] >> 1, o = this.type == 2, s = false, l = false, c = [];
    for (let u of this.dependencies)
      u == "doc" ? s = true : u == "selection" ? l = true : ((i = e[u.id]) !== null && i !== void 0 ? i : 1) & 1 || c.push(e[u.id]);
    return {
      create(u) {
        return u.values[a] = n(u), 1;
      },
      update(u, h10) {
        if (s && h10.docChanged || l && (h10.docChanged || h10.selection) || yh(u, c)) {
          let d = n(u);
          if (o ? !jQ(d, u.values[a], O) : !O(d, u.values[a]))
            return u.values[a] = d, 1;
        }
        return 0;
      },
      reconfigure: (u, h10) => {
        let d, p = h10.config.address[r];
        if (p != null) {
          let $ = Gl(h10, p);
          if (this.dependencies.every((g) => g instanceof K ? h10.facet(g) === u.facet(g) : g instanceof St ? h10.field(g, false) == u.field(g, false) : true) || (o ? jQ(d = n(u), $, O) : O(d = n(u), $)))
            return u.values[a] = $, 0;
        } else
          d = n(u);
        return u.values[a] = d, 1;
      }
    };
  }
};
function jQ(t, e, i) {
  if (t.length != e.length)
    return false;
  for (let n = 0; n < t.length; n++)
    if (!i(t[n], e[n]))
      return false;
  return true;
}
function yh(t, e) {
  let i = false;
  for (let n of e)
    Xo(t, n) & 1 && (i = true);
  return i;
}
function S_(t, e, i) {
  let n = i.map((s) => t[s.id]), O = i.map((s) => s.type), r = n.filter((s) => !(s & 1)), a = t[e.id] >> 1;
  function o(s) {
    let l = [];
    for (let c = 0; c < n.length; c++) {
      let u = Gl(s, n[c]);
      if (O[c] == 2)
        for (let h10 of u)
          l.push(h10);
      else
        l.push(u);
    }
    return e.combine(l);
  }
  return {
    create(s) {
      for (let l of n)
        Xo(s, l);
      return s.values[a] = o(s), 1;
    },
    update(s, l) {
      if (!yh(s, r))
        return 0;
      let c = o(s);
      return e.compare(c, s.values[a]) ? 0 : (s.values[a] = c, 1);
    },
    reconfigure(s, l) {
      let c = yh(s, n), u = l.config.facets[e.id], h10 = l.facet(e);
      if (u && !c && bp(i, u))
        return s.values[a] = h10, 0;
      let d = o(s);
      return e.compare(d, h10) ? (s.values[a] = h10, 0) : (s.values[a] = d, 1);
    }
  };
}
var IQ = K.define({ static: true });
var St = class {
  constructor(e, i, n, O, r) {
    this.id = e, this.createF = i, this.updateF = n, this.compareF = O, this.spec = r, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let i = new St(yp++, e.create, e.update, e.compare || ((n, O) => n === O), e);
    return e.provide && (i.provides = e.provide(i)), i;
  }
  create(e) {
    let i = e.facet(IQ).find((n) => n.field == this);
    return ((i == null ? void 0 : i.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let i = e[this.id] >> 1;
    return {
      create: (n) => (n.values[i] = this.create(n), 1),
      update: (n, O) => {
        let r = n.values[i], a = this.updateF(r, O);
        return this.compareF(r, a) ? 0 : (n.values[i] = a, 1);
      },
      reconfigure: (n, O) => O.config.address[this.id] != null ? (n.values[i] = O.field(this), 0) : (n.values[i] = this.create(n), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, IQ.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
};
var IO = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Aa(t) {
  return (e) => new ev(e, t);
}
var wO = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: Aa(IO.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: Aa(IO.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: Aa(IO.default),
  /**
  A lower-than-default precedence.
  */
  low: Aa(IO.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: Aa(IO.lowest)
};
var ev = class {
  constructor(e, i) {
    this.inner = e, this.prec = i;
  }
};
var ms = class {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new bh(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return ms.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
};
var bh = class {
  constructor(e, i) {
    this.compartment = e, this.inner = i;
  }
};
var Al = class {
  constructor(e, i, n, O, r, a) {
    for (this.base = e, this.compartments = i, this.dynamicSlots = n, this.address = O, this.staticValues = r, this.facets = a, this.statusTemplate = []; this.statusTemplate.length < n.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let i = this.address[e.id];
    return i == null ? e.default : this.staticValues[i >> 1];
  }
  static resolve(e, i, n) {
    let O = [], r = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ new Map();
    for (let h10 of P_(e, i, a))
      h10 instanceof St ? O.push(h10) : (r[h10.facet.id] || (r[h10.facet.id] = [])).push(h10);
    let o = /* @__PURE__ */ Object.create(null), s = [], l = [];
    for (let h10 of O)
      o[h10.id] = l.length << 1, l.push((d) => h10.slot(d));
    let c = n == null ? void 0 : n.config.facets;
    for (let h10 in r) {
      let d = r[h10], p = d[0].facet, $ = c && c[h10] || [];
      if (d.every(
        (g) => g.type == 0
        /* Provider.Static */
      ))
        if (o[p.id] = s.length << 1 | 1, bp($, d))
          s.push(n.facet(p));
        else {
          let g = p.combine(d.map((Q) => Q.value));
          s.push(n && p.compare(g, n.facet(p)) ? n.facet(p) : g);
        }
      else {
        for (let g of d)
          g.type == 0 ? (o[g.id] = s.length << 1 | 1, s.push(g.value)) : (o[g.id] = l.length << 1, l.push((Q) => g.dynamicSlot(Q)));
        o[p.id] = l.length << 1, l.push((g) => S_(g, p, d));
      }
    }
    let u = l.map((h10) => h10(o));
    return new Al(e, a, u, o, s, r);
  }
};
function P_(t, e, i) {
  let n = [[], [], [], [], []], O = /* @__PURE__ */ new Map();
  function r(a, o) {
    let s = O.get(a);
    if (s != null) {
      if (s <= o)
        return;
      let l = n[s].indexOf(a);
      l > -1 && n[s].splice(l, 1), a instanceof bh && i.delete(a.compartment);
    }
    if (O.set(a, o), Array.isArray(a))
      for (let l of a)
        r(l, o);
    else if (a instanceof bh) {
      if (i.has(a.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let l = e.get(a.compartment) || a.inner;
      i.set(a.compartment, l), r(l, o);
    } else if (a instanceof ev)
      r(a.inner, a.prec);
    else if (a instanceof St)
      n[o].push(a), a.provides && r(a.provides, o);
    else if (a instanceof xl)
      n[o].push(a), a.facet.extensions && r(a.facet.extensions, IO.default);
    else {
      let l = a.extension;
      if (!l)
        throw new Error(`Unrecognized extension value in extension set (${a}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      r(l, o);
    }
  }
  return r(t, IO.default), n.reduce((a, o) => a.concat(o));
}
function Xo(t, e) {
  if (e & 1)
    return 2;
  let i = e >> 1, n = t.status[i];
  if (n == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (n & 2)
    return n;
  t.status[i] = 4;
  let O = t.computeSlot(t, t.config.dynamicSlots[i]);
  return t.status[i] = 2 | O;
}
function Gl(t, e) {
  return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
}
var tv = K.define();
var iv = K.define({
  combine: (t) => t.some((e) => e),
  static: true
});
var nv = K.define({
  combine: (t) => t.length ? t[0] : void 0,
  static: true
});
var Ov = K.define();
var rv = K.define();
var av = K.define();
var ov = K.define({
  combine: (t) => t.length ? t[0] : false
});
var Dn = class {
  /**
  @internal
  */
  constructor(e, i) {
    this.type = e, this.value = i;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new y_();
  }
};
var y_ = class {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new Dn(this, e);
  }
};
var b_ = class {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new fe(this, e);
  }
};
var fe = class {
  /**
  @internal
  */
  constructor(e, i) {
    this.type = e, this.value = i;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let i = this.type.map(this.value, e);
    return i === void 0 ? void 0 : i == this.value ? this : new fe(this.type, i);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds.
  */
  static define(e = {}) {
    return new b_(e.map || ((i) => i));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, i) {
    if (!e.length)
      return e;
    let n = [];
    for (let O of e) {
      let r = O.map(i);
      r && n.push(r);
    }
    return n;
  }
};
fe.reconfigure = fe.define();
fe.appendConfig = fe.define();
var ht = class {
  constructor(e, i, n, O, r, a) {
    this.startState = e, this.changes = i, this.selection = n, this.effects = O, this.annotations = r, this.scrollIntoView = a, this._doc = null, this._state = null, n && Jb(n, i.newLength), r.some((o) => o.type == ht.time) || (this.annotations = r.concat(ht.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, i, n, O, r, a) {
    return new ht(e, i, n, O, r, a);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let i of this.annotations)
      if (i.type == e)
        return i.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let i = this.annotation(ht.userEvent);
    return !!(i && (i == e || i.length > e.length && i.slice(0, e.length) == e && i[e.length] == "."));
  }
};
ht.time = Dn.define();
ht.userEvent = Dn.define();
ht.addToHistory = Dn.define();
ht.remote = Dn.define();
function v_(t, e) {
  let i = [];
  for (let n = 0, O = 0; ; ) {
    let r, a;
    if (n < t.length && (O == e.length || e[O] >= t[n]))
      r = t[n++], a = t[n++];
    else if (O < e.length)
      r = e[O++], a = e[O++];
    else
      return i;
    !i.length || i[i.length - 1] < r ? i.push(r, a) : i[i.length - 1] < a && (i[i.length - 1] = a);
  }
}
function sv(t, e, i) {
  var n;
  let O, r, a;
  return i ? (O = e.changes, r = ct.empty(e.changes.length), a = t.changes.compose(e.changes)) : (O = e.changes.map(t.changes), r = t.changes.mapDesc(e.changes, true), a = t.changes.compose(O)), {
    changes: a,
    selection: e.selection ? e.selection.map(r) : (n = t.selection) === null || n === void 0 ? void 0 : n.map(O),
    effects: fe.mapEffects(t.effects, O).concat(fe.mapEffects(e.effects, r)),
    annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: t.scrollIntoView || e.scrollIntoView
  };
}
function vh(t, e, i) {
  let n = e.selection, O = Lr(e.annotations);
  return e.userEvent && (O = O.concat(ht.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof ct ? e.changes : ct.of(e.changes || [], i, t.facet(nv)),
    selection: n && (n instanceof R ? n : R.single(n.anchor, n.head)),
    effects: Lr(e.effects),
    annotations: O,
    scrollIntoView: !!e.scrollIntoView
  };
}
function lv(t, e, i) {
  let n = vh(t, e.length ? e[0] : {}, t.doc.length);
  e.length && e[0].filter === false && (i = false);
  for (let r = 1; r < e.length; r++) {
    e[r].filter === false && (i = false);
    let a = !!e[r].sequential;
    n = sv(n, vh(t, e[r], a ? n.changes.newLength : t.doc.length), a);
  }
  let O = ht.create(t, n.changes, n.selection, n.effects, n.annotations, n.scrollIntoView);
  return x_(i ? X_(O) : O);
}
function X_(t) {
  let e = t.startState, i = true;
  for (let O of e.facet(Ov)) {
    let r = O(t);
    if (r === false) {
      i = false;
      break;
    }
    Array.isArray(r) && (i = i === true ? r : v_(i, r));
  }
  if (i !== true) {
    let O, r;
    if (i === false)
      r = t.changes.invertedDesc, O = ct.empty(e.doc.length);
    else {
      let a = t.changes.filter(i);
      O = a.changes, r = a.filtered.mapDesc(a.changes).invertedDesc;
    }
    t = ht.create(e, O, t.selection && t.selection.map(r), fe.mapEffects(t.effects, r), t.annotations, t.scrollIntoView);
  }
  let n = e.facet(rv);
  for (let O = n.length - 1; O >= 0; O--) {
    let r = n[O](t);
    r instanceof ht ? t = r : Array.isArray(r) && r.length == 1 && r[0] instanceof ht ? t = r[0] : t = lv(e, Lr(r), false);
  }
  return t;
}
function x_(t) {
  let e = t.startState, i = e.facet(av), n = t;
  for (let O = i.length - 1; O >= 0; O--) {
    let r = i[O](t);
    r && Object.keys(r).length && (n = sv(n, vh(e, r, t.changes.newLength), true));
  }
  return n == t ? t : ht.create(e, t.changes, t.selection, n.effects, n.annotations, n.scrollIntoView);
}
var w_ = [];
function Lr(t) {
  return t == null ? w_ : Array.isArray(t) ? t : [t];
}
var Le = function(t) {
  return t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t;
}(Le || (Le = {}));
var T_ = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
var Xh;
try {
  Xh = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function k_(t) {
  if (Xh)
    return Xh.test(t);
  for (let e = 0; e < t.length; e++) {
    let i = t[e];
    if (/\w/.test(i) || i > "" && (i.toUpperCase() != i.toLowerCase() || T_.test(i)))
      return true;
  }
  return false;
}
function __(t) {
  return (e) => {
    if (!/\S/.test(e))
      return Le.Space;
    if (k_(e))
      return Le.Word;
    for (let i = 0; i < t.length; i++)
      if (e.indexOf(t[i]) > -1)
        return Le.Word;
    return Le.Other;
  };
}
var ye = class {
  constructor(e, i, n, O, r, a) {
    this.config = e, this.doc = i, this.selection = n, this.values = O, this.status = e.statusTemplate.slice(), this.computeSlot = r, a && (a._state = this);
    for (let o = 0; o < this.config.dynamicSlots.length; o++)
      Xo(this, o << 1);
    this.computeSlot = null;
  }
  field(e, i = true) {
    let n = this.config.address[e.id];
    if (n == null) {
      if (i)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Xo(this, n), Gl(this, n);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return lv(this, e, true);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let i = this.config, { base: n, compartments: O } = i;
    for (let a of e.effects)
      a.is(ms.reconfigure) ? (i && (O = /* @__PURE__ */ new Map(), i.compartments.forEach((o, s) => O.set(s, o)), i = null), O.set(a.value.compartment, a.value.extension)) : a.is(fe.reconfigure) ? (i = null, n = a.value) : a.is(fe.appendConfig) && (i = null, n = Lr(n).concat(a.value));
    let r;
    i ? r = e.startState.values.slice() : (i = Al.resolve(n, O, this), r = new ye(i, this.doc, this.selection, i.dynamicSlots.map(() => null), (o, s) => s.reconfigure(o, this), null).values), new ye(i, e.newDoc, e.newSelection, r, (a, o) => o.update(a, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((i) => ({
      changes: { from: i.from, to: i.to, insert: e },
      range: R.cursor(i.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let i = this.selection, n = e(i.ranges[0]), O = this.changes(n.changes), r = [n.range], a = Lr(n.effects);
    for (let o = 1; o < i.ranges.length; o++) {
      let s = e(i.ranges[o]), l = this.changes(s.changes), c = l.map(O);
      for (let h10 = 0; h10 < o; h10++)
        r[h10] = r[h10].map(c);
      let u = O.mapDesc(l, true);
      r.push(s.range.map(u)), O = O.compose(c), a = fe.mapEffects(a, c).concat(fe.mapEffects(Lr(s.effects), u));
    }
    return {
      changes: O,
      selection: R.create(r, i.mainIndex),
      effects: a
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof ct ? e : ct.of(e, this.doc.length, this.facet(ye.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return Te.of(e.split(this.facet(ye.lineSeparator) || mh));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, i = this.doc.length) {
    return this.doc.sliceString(e, i, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let i = this.config.address[e.id];
    return i == null ? e.default : (Xo(this, i), Gl(this, i));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let i = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let n in e) {
        let O = e[n];
        O instanceof St && this.config.address[O.id] != null && (i[n] = O.spec.toJSON(this.field(e[n]), this));
      }
    return i;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, i = {}, n) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let O = [];
    if (n) {
      for (let r in n)
        if (Object.prototype.hasOwnProperty.call(e, r)) {
          let a = n[r], o = e[r];
          O.push(a.init((s) => a.spec.fromJSON(o, s)));
        }
    }
    return ye.create({
      doc: e.doc,
      selection: R.fromJSON(e.selection),
      extensions: i.extensions ? O.concat([i.extensions]) : O
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let i = Al.resolve(e.extensions || [], /* @__PURE__ */ new Map()), n = e.doc instanceof Te ? e.doc : Te.of((e.doc || "").split(i.staticFacet(ye.lineSeparator) || mh)), O = e.selection ? e.selection instanceof R ? e.selection : R.single(e.selection.anchor, e.selection.head) : R.single(0);
    return Jb(O, n.length), i.staticFacet(iv) || (O = O.asSingle()), new ye(i, n, O, i.dynamicSlots.map(() => null), (r, a) => a.create(r), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(ye.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(ye.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(ov);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...i) {
    for (let n of this.facet(ye.phrases))
      if (Object.prototype.hasOwnProperty.call(n, e)) {
        e = n[e];
        break;
      }
    return i.length && (e = e.replace(/\$(\$|\d*)/g, (n, O) => {
      if (O == "$")
        return "$";
      let r = +(O || 1);
      return !r || r > i.length ? n : i[r - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, i, n = -1) {
    let O = [];
    for (let r of this.facet(tv))
      for (let a of r(this, i, n))
        Object.prototype.hasOwnProperty.call(a, e) && O.push(a[e]);
    return O;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return __(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: i, from: n, length: O } = this.doc.lineAt(e), r = this.charCategorizer(e), a = e - n, o = e - n;
    for (; a > 0; ) {
      let s = Mt(i, a, false);
      if (r(i.slice(s, a)) != Le.Word)
        break;
      a = s;
    }
    for (; o < O; ) {
      let s = Mt(i, o);
      if (r(i.slice(o, s)) != Le.Word)
        break;
      o = s;
    }
    return a == o ? null : R.range(a + n, o + n);
  }
};
ye.allowMultipleSelections = iv;
ye.tabSize = K.define({
  combine: (t) => t.length ? t[0] : 4
});
ye.lineSeparator = nv;
ye.readOnly = ov;
ye.phrases = K.define({
  compare(t, e) {
    let i = Object.keys(t), n = Object.keys(e);
    return i.length == n.length && i.every((O) => t[O] == e[O]);
  }
});
ye.languageData = tv;
ye.changeFilter = Ov;
ye.transactionFilter = rv;
ye.transactionExtender = av;
ms.reconfigure = fe.define();
function Xn(t, e, i = {}) {
  let n = {};
  for (let O of t)
    for (let r of Object.keys(O)) {
      let a = O[r], o = n[r];
      if (o === void 0)
        n[r] = a;
      else if (!(o === a || a === void 0))
        if (Object.hasOwnProperty.call(i, r))
          n[r] = i[r](o, a);
        else
          throw new Error("Config merge conflict for field " + r);
    }
  for (let O in e)
    n[O] === void 0 && (n[O] = e[O]);
  return n;
}
var KO = class {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, i = e) {
    return xh.create(e, i, this);
  }
};
KO.prototype.startSide = KO.prototype.endSide = 0;
KO.prototype.point = false;
KO.prototype.mapMode = wt.TrackDel;
var xh = class cv {
  constructor(e, i, n) {
    this.from = e, this.to = i, this.value = n;
  }
  /**
  @internal
  */
  static create(e, i, n) {
    return new cv(e, i, n);
  }
};
function wh(t, e) {
  return t.from - e.from || t.value.startSide - e.value.startSide;
}
var vp = class {
  constructor(e, i, n, O) {
    this.from = e, this.to = i, this.value = n, this.maxPoint = O;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, i, n, O = 0) {
    let r = n ? this.to : this.from;
    for (let a = O, o = r.length; ; ) {
      if (a == o)
        return a;
      let s = a + o >> 1, l = r[s] - e || (n ? this.value[s].endSide : this.value[s].startSide) - i;
      if (s == a)
        return l >= 0 ? a : o;
      l >= 0 ? o = s : a = s + 1;
    }
  }
  between(e, i, n, O) {
    for (let r = this.findIndex(i, -1e9, true), a = this.findIndex(n, 1e9, false, r); r < a; r++)
      if (O(this.from[r] + e, this.to[r] + e, this.value[r]) === false)
        return false;
  }
  map(e, i) {
    let n = [], O = [], r = [], a = -1, o = -1;
    for (let s = 0; s < this.value.length; s++) {
      let l = this.value[s], c = this.from[s] + e, u = this.to[s] + e, h10, d;
      if (c == u) {
        let p = i.mapPos(c, l.startSide, l.mapMode);
        if (p == null || (h10 = d = p, l.startSide != l.endSide && (d = i.mapPos(c, l.endSide), d < h10)))
          continue;
      } else if (h10 = i.mapPos(c, l.startSide), d = i.mapPos(u, l.endSide), h10 > d || h10 == d && l.startSide > 0 && l.endSide <= 0)
        continue;
      (d - h10 || l.endSide - l.startSide) < 0 || (a < 0 && (a = h10), l.point && (o = Math.max(o, d - h10)), n.push(l), O.push(h10 - a), r.push(d - a));
    }
    return { mapped: n.length ? new vp(O, r, n, o) : null, pos: a };
  }
};
var We = class {
  constructor(e, i, n, O) {
    this.chunkPos = e, this.chunk = i, this.nextLayer = n, this.maxPoint = O;
  }
  /**
  @internal
  */
  static create(e, i, n, O) {
    return new We(e, i, n, O);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let i of this.chunk)
      e += i.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: i = [], sort: n = false, filterFrom: O = 0, filterTo: r = this.length } = e, a = e.filter;
    if (i.length == 0 && !a)
      return this;
    if (n && (i = i.slice().sort(wh)), this.isEmpty)
      return i.length ? We.of(i) : this;
    let o = new uv(this, null, -1).goto(0), s = 0, l = [], c = new QO();
    for (; o.value || s < i.length; )
      if (s < i.length && (o.from - i[s].from || o.startSide - i[s].value.startSide) >= 0) {
        let u = i[s++];
        c.addInner(u.from, u.to, u.value) || l.push(u);
      } else
        o.rangeIndex == 1 && o.chunkIndex < this.chunk.length && (s == i.length || this.chunkEnd(o.chunkIndex) < i[s].from) && (!a || O > this.chunkEnd(o.chunkIndex) || r < this.chunkPos[o.chunkIndex]) && c.addChunk(this.chunkPos[o.chunkIndex], this.chunk[o.chunkIndex]) ? o.nextChunk() : ((!a || O > o.to || r < o.from || a(o.from, o.to, o.value)) && (c.addInner(o.from, o.to, o.value) || l.push(xh.create(o.from, o.to, o.value))), o.next());
    return c.finishInner(this.nextLayer.isEmpty && !l.length ? We.empty : this.nextLayer.update({ add: l, filter: a, filterFrom: O, filterTo: r }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let i = [], n = [], O = -1;
    for (let a = 0; a < this.chunk.length; a++) {
      let o = this.chunkPos[a], s = this.chunk[a], l = e.touchesRange(o, o + s.length);
      if (l === false)
        O = Math.max(O, s.maxPoint), i.push(s), n.push(e.mapPos(o));
      else if (l === true) {
        let { mapped: c, pos: u } = s.map(o, e);
        c && (O = Math.max(O, c.maxPoint), i.push(c), n.push(u));
      }
    }
    let r = this.nextLayer.map(e);
    return i.length == 0 ? r : new We(n, i, r || We.empty, O);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, i, n) {
    if (!this.isEmpty) {
      for (let O = 0; O < this.chunk.length; O++) {
        let r = this.chunkPos[O], a = this.chunk[O];
        if (i >= r && e <= r + a.length && a.between(r, e - r, i - r, n) === false)
          return;
      }
      this.nextLayer.between(e, i, n);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return Go.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, i = 0) {
    return Go.from(e).goto(i);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, i, n, O, r = -1) {
    let a = e.filter((u) => u.maxPoint > 0 || !u.isEmpty && u.maxPoint >= r), o = i.filter((u) => u.maxPoint > 0 || !u.isEmpty && u.maxPoint >= r), s = AQ(a, o, n), l = new Ga(a, s, r), c = new Ga(o, s, r);
    n.iterGaps((u, h10, d) => GQ(l, u, c, h10, d, O)), n.empty && n.length == 0 && GQ(l, 0, c, 0, 0, O);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, i, n = 0, O) {
    O == null && (O = 1e9 - 1);
    let r = e.filter((c) => !c.isEmpty && i.indexOf(c) < 0), a = i.filter((c) => !c.isEmpty && e.indexOf(c) < 0);
    if (r.length != a.length)
      return false;
    if (!r.length)
      return true;
    let o = AQ(r, a), s = new Ga(r, o, 0).goto(n), l = new Ga(a, o, 0).goto(n);
    for (; ; ) {
      if (s.to != l.to || !Th(s.active, l.active) || s.point && (!l.point || !s.point.eq(l.point)))
        return false;
      if (s.to > O)
        return true;
      s.next(), l.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, i, n, O, r = -1) {
    let a = new Ga(e, null, r).goto(i), o = i, s = a.openStart;
    for (; ; ) {
      let l = Math.min(a.to, n);
      if (a.point) {
        let c = a.activeForPoint(a.to), u = a.pointFrom < i ? c.length + 1 : Math.min(c.length, s);
        O.point(o, l, a.point, c, u, a.pointRank), s = Math.min(a.openEnd(l), c.length);
      } else
        l > o && (O.span(o, l, a.active, s), s = a.openEnd(l));
      if (a.to > n)
        return s + (a.point && a.to > n ? 1 : 0);
      o = a.to, a.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, i = false) {
    let n = new QO();
    for (let O of e instanceof xh ? [e] : i ? W_(e) : e)
      n.add(O.from, O.to, O.value);
    return n.finish();
  }
};
We.empty = new We([], [], null, -1);
function W_(t) {
  if (t.length > 1)
    for (let e = t[0], i = 1; i < t.length; i++) {
      let n = t[i];
      if (wh(e, n) > 0)
        return t.slice().sort(wh);
      e = n;
    }
  return t;
}
We.empty.nextLayer = We.empty;
var QO = class {
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  finishChunk(e) {
    this.chunks.push(new vp(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, i, n) {
    this.addInner(e, i, n) || (this.nextLayer || (this.nextLayer = new QO())).add(e, i, n);
  }
  /**
  @internal
  */
  addInner(e, i, n) {
    let O = e - this.lastTo || n.startSide - this.last.endSide;
    if (O <= 0 && (e - this.lastFrom || n.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return O < 0 ? false : (this.from.length == 250 && this.finishChunk(true), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(i - this.chunkStart), this.last = n, this.lastFrom = e, this.lastTo = i, this.value.push(n), n.point && (this.maxPoint = Math.max(this.maxPoint, i - e)), true);
  }
  /**
  @internal
  */
  addChunk(e, i) {
    if ((e - this.lastTo || i.value[0].startSide - this.last.endSide) < 0)
      return false;
    this.from.length && this.finishChunk(true), this.setMaxPoint = Math.max(this.setMaxPoint, i.maxPoint), this.chunks.push(i), this.chunkPos.push(e);
    let n = i.value.length - 1;
    return this.last = i.value[n], this.lastFrom = i.from[n] + e, this.lastTo = i.to[n] + e, true;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(We.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(false), this.chunks.length == 0)
      return e;
    let i = We.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, i;
  }
};
function AQ(t, e, i) {
  let n = /* @__PURE__ */ new Map();
  for (let r of t)
    for (let a = 0; a < r.chunk.length; a++)
      r.chunk[a].maxPoint <= 0 && n.set(r.chunk[a], r.chunkPos[a]);
  let O = /* @__PURE__ */ new Set();
  for (let r of e)
    for (let a = 0; a < r.chunk.length; a++) {
      let o = n.get(r.chunk[a]);
      o != null && (i ? i.mapPos(o) : o) == r.chunkPos[a] && !(i != null && i.touchesRange(o, o + r.chunk[a].length)) && O.add(r.chunk[a]);
    }
  return O;
}
var uv = class {
  constructor(e, i, n, O = 0) {
    this.layer = e, this.skip = i, this.minPoint = n, this.rank = O;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, i = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, i, false), this;
  }
  gotoInner(e, i, n) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let O = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(O) || this.layer.chunkEnd(this.chunkIndex) < e || O.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, n = false;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let O = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], i, true);
      (!n || this.rangeIndex < O) && this.setRangeIndex(O);
    }
    this.next();
  }
  forward(e, i) {
    (this.to - e || this.endSide - i) < 0 && this.gotoInner(e, i, true);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], i = this.layer.chunk[this.chunkIndex], n = e + i.from[this.rangeIndex];
        if (this.from = n, this.to = e + i.to[this.rangeIndex], this.value = i.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
};
var Go = class {
  constructor(e) {
    this.heap = e;
  }
  static from(e, i = null, n = -1) {
    let O = [];
    for (let r = 0; r < e.length; r++)
      for (let a = e[r]; !a.isEmpty; a = a.nextLayer)
        a.maxPoint >= n && O.push(new uv(a, i, n, r));
    return O.length == 1 ? O[0] : new Go(O);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, i = -1e9) {
    for (let n of this.heap)
      n.goto(e, i);
    for (let n = this.heap.length >> 1; n >= 0; n--)
      Gu(this.heap, n);
    return this.next(), this;
  }
  forward(e, i) {
    for (let n of this.heap)
      n.forward(e, i);
    for (let n = this.heap.length >> 1; n >= 0; n--)
      Gu(this.heap, n);
    (this.to - e || this.value.endSide - i) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), Gu(this.heap, 0);
    }
  }
};
function Gu(t, e) {
  for (let i = t[e]; ; ) {
    let n = (e << 1) + 1;
    if (n >= t.length)
      break;
    let O = t[n];
    if (n + 1 < t.length && O.compare(t[n + 1]) >= 0 && (O = t[n + 1], n++), i.compare(O) < 0)
      break;
    t[n] = i, t[e] = O, e = n;
  }
}
var Ga = class {
  constructor(e, i, n) {
    this.minPoint = n, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Go.from(e, i, n);
  }
  goto(e, i = -1e9) {
    return this.cursor.goto(e, i), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = i, this.openStart = -1, this.next(), this;
  }
  forward(e, i) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - i) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, i);
  }
  removeActive(e) {
    qs(this.active, e), qs(this.activeTo, e), qs(this.activeRank, e), this.minActive = LQ(this.active, this.activeTo);
  }
  addActive(e) {
    let i = 0, { value: n, to: O, rank: r } = this.cursor;
    for (; i < this.activeRank.length && this.activeRank[i] <= r; )
      i++;
    zs(this.active, i, n), zs(this.activeTo, i, O), zs(this.activeRank, i, r), e && zs(e, i, this.cursor.from), this.minActive = LQ(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, i = this.point;
    this.point = null;
    let n = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let O = this.minActive;
      if (O > -1 && (this.activeTo[O] - this.cursor.from || this.active[O].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[O] > e) {
          this.to = this.activeTo[O], this.endSide = this.active[O].endSide;
          break;
        }
        this.removeActive(O), n && qs(n, O);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let r = this.cursor.value;
          if (!r.point)
            this.addActive(n), this.cursor.next();
          else if (i && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = r, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = r.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (n) {
      this.openStart = 0;
      for (let O = n.length - 1; O >= 0 && n[O] < e; O--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let i = [];
    for (let n = this.active.length - 1; n >= 0 && !(this.activeRank[n] < this.pointRank); n--)
      (this.activeTo[n] > e || this.activeTo[n] == e && this.active[n].endSide >= this.point.endSide) && i.push(this.active[n]);
    return i.reverse();
  }
  openEnd(e) {
    let i = 0;
    for (let n = this.activeTo.length - 1; n >= 0 && this.activeTo[n] > e; n--)
      i++;
    return i;
  }
};
function GQ(t, e, i, n, O, r) {
  t.goto(e), i.goto(n);
  let a = n + O, o = n, s = n - e;
  for (; ; ) {
    let l = t.to + s - i.to || t.endSide - i.endSide, c = l < 0 ? t.to + s : i.to, u = Math.min(c, a);
    if (t.point || i.point ? t.point && i.point && (t.point == i.point || t.point.eq(i.point)) && Th(t.activeForPoint(t.to + s), i.activeForPoint(i.to)) || r.comparePoint(o, u, t.point, i.point) : u > o && !Th(t.active, i.active) && r.compareRange(o, u, t.active, i.active), c > a)
      break;
    o = c, l <= 0 && t.next(), l >= 0 && i.next();
  }
}
function Th(t, e) {
  if (t.length != e.length)
    return false;
  for (let i = 0; i < t.length; i++)
    if (t[i] != e[i] && !t[i].eq(e[i]))
      return false;
  return true;
}
function qs(t, e) {
  for (let i = e, n = t.length - 1; i < n; i++)
    t[i] = t[i + 1];
  t.pop();
}
function zs(t, e, i) {
  for (let n = t.length - 1; n >= e; n--)
    t[n + 1] = t[n];
  t[e] = i;
}
function LQ(t, e) {
  let i = -1, n = 1e9;
  for (let O = 0; O < e.length; O++)
    (e[O] - n || t[O].endSide - t[i].endSide) < 0 && (i = O, n = e[O]);
  return i;
}
function Ss(t, e, i = t.length) {
  let n = 0;
  for (let O = 0; O < i; )
    t.charCodeAt(O) == 9 ? (n += e - n % e, O++) : (n++, O = Mt(t, O));
  return n;
}
function kh(t, e, i, n) {
  for (let O = 0, r = 0; ; ) {
    if (r >= e)
      return O;
    if (O == t.length)
      break;
    r += t.charCodeAt(O) == 9 ? i - r % i : 1, O = Mt(t, O);
  }
  return n === true ? -1 : t.length;
}
var _h = "ͼ";
var DQ = typeof Symbol > "u" ? "__" + _h : Symbol.for(_h);
var Wh = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
var MQ = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
var gO = class {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, i) {
    this.rules = [];
    let { finish: n } = i || {};
    function O(a) {
      return /^@/.test(a) ? [a] : a.split(/,\s*/);
    }
    function r(a, o, s, l) {
      let c = [], u = /^@(\w+)\b/.exec(a[0]), h10 = u && u[1] == "keyframes";
      if (u && o == null)
        return s.push(a[0] + ";");
      for (let d in o) {
        let p = o[d];
        if (/&/.test(d))
          r(
            d.split(/,\s*/).map(($) => a.map((g) => $.replace(/&/, g))).reduce(($, g) => $.concat(g)),
            p,
            s
          );
        else if (p && typeof p == "object") {
          if (!u)
            throw new RangeError("The value of a property (" + d + ") should be a primitive value.");
          r(O(d), p, c, h10);
        } else
          p != null && c.push(d.replace(/_.*/, "").replace(/[A-Z]/g, ($) => "-" + $.toLowerCase()) + ": " + p + ";");
      }
      (c.length || h10) && s.push((n && !u && !l ? a.map(n) : a).join(", ") + " {" + c.join(" ") + "}");
    }
    for (let a in e)
      r(O(a), e[a], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let e = MQ[DQ] || 1;
    return MQ[DQ] = e + 1, _h + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>)
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  static mount(e, i) {
    (e[Wh] || new Y_(e)).mount(Array.isArray(i) ? i : [i]);
  }
};
var Cs = null;
var Y_ = class {
  constructor(e) {
    if (!e.head && e.adoptedStyleSheets && typeof CSSStyleSheet < "u") {
      if (Cs)
        return e.adoptedStyleSheets = [Cs.sheet].concat(e.adoptedStyleSheets), e[Wh] = Cs;
      this.sheet = new CSSStyleSheet(), e.adoptedStyleSheets = [this.sheet].concat(e.adoptedStyleSheets), Cs = this;
    } else {
      this.styleTag = (e.ownerDocument || e).createElement("style");
      let i = e.head || e;
      i.insertBefore(this.styleTag, i.firstChild);
    }
    this.modules = [], e[Wh] = this;
  }
  mount(e) {
    let i = this.sheet, n = 0, O = 0;
    for (let r = 0; r < e.length; r++) {
      let a = e[r], o = this.modules.indexOf(a);
      if (o < O && o > -1 && (this.modules.splice(o, 1), O--, o = -1), o == -1) {
        if (this.modules.splice(O++, 0, a), i)
          for (let s = 0; s < a.rules.length; s++)
            i.insertRule(a.rules[s], n++);
      } else {
        for (; O < o; )
          n += this.modules[O++].rules.length;
        n += a.rules.length, O++;
      }
    }
    if (!i) {
      let r = "";
      for (let a = 0; a < this.modules.length; a++)
        r += this.modules[a].getRules() + `
`;
      this.styleTag.textContent = r;
    }
  }
};
var mO = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var Lo = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var NQ = typeof navigator < "u" && /Chrome\/(\d+)/.exec(navigator.userAgent);
var R_ = typeof navigator < "u" && /Mac/.test(navigator.platform);
var Z_ = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
var U_ = R_ || NQ && +NQ[1] < 57;
for (xt = 0; xt < 10; xt++)
  mO[48 + xt] = mO[96 + xt] = String(xt);
var xt;
for (xt = 1; xt <= 24; xt++)
  mO[xt + 111] = "F" + xt;
var xt;
for (xt = 65; xt <= 90; xt++)
  mO[xt] = String.fromCharCode(xt + 32), Lo[xt] = String.fromCharCode(xt);
var xt;
for (Lu in mO)
  Lo.hasOwnProperty(Lu) || (Lo[Lu] = mO[Lu]);
var Lu;
function V_(t) {
  var e = U_ && (t.ctrlKey || t.altKey || t.metaKey) || Z_ && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", i = !e && t.key || (t.shiftKey ? Lo : mO)[t.keyCode] || t.key || "Unidentified";
  return i == "Esc" && (i = "Escape"), i == "Del" && (i = "Delete"), i == "Left" && (i = "ArrowLeft"), i == "Up" && (i = "ArrowUp"), i == "Right" && (i = "ArrowRight"), i == "Down" && (i = "ArrowDown"), i;
}
function Ll(t) {
  let e;
  return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t, e.getSelection();
}
function Jr(t, e) {
  return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : false;
}
function q_(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function wl(t, e) {
  if (!e.anchorNode)
    return false;
  try {
    return Jr(t, e.anchorNode);
  } catch {
    return false;
  }
}
function Do(t) {
  return t.nodeType == 3 ? ea(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
}
function Dl(t, e, i, n) {
  return i ? BQ(t, e, i, n, -1) || BQ(t, e, i, n, 1) : false;
}
function Ml(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}
function BQ(t, e, i, n, O) {
  for (; ; ) {
    if (t == i && e == n)
      return true;
    if (e == (O < 0 ? 0 : Mo(t))) {
      if (t.nodeName == "DIV")
        return false;
      let r = t.parentNode;
      if (!r || r.nodeType != 1)
        return false;
      e = Ml(t) + (O < 0 ? 0 : 1), t = r;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (O < 0 ? -1 : 0)], t.nodeType == 1 && t.contentEditable == "false")
        return false;
      e = O < 0 ? Mo(t) : 0;
    } else
      return false;
  }
}
function Mo(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
var fv = { left: 0, right: 0, top: 0, bottom: 0 };
function Xp(t, e) {
  let i = e ? t.left : t.right;
  return { left: i, right: i, top: t.top, bottom: t.bottom };
}
function z_(t) {
  return {
    left: 0,
    right: t.innerWidth,
    top: 0,
    bottom: t.innerHeight
  };
}
function C_(t, e, i, n, O, r, a, o) {
  let s = t.ownerDocument, l = s.defaultView || window;
  for (let c = t; c; )
    if (c.nodeType == 1) {
      let u, h10 = c == s.body;
      if (h10)
        u = z_(l);
      else {
        if (c.scrollHeight <= c.clientHeight && c.scrollWidth <= c.clientWidth) {
          c = c.assignedSlot || c.parentNode;
          continue;
        }
        let $ = c.getBoundingClientRect();
        u = {
          left: $.left,
          right: $.left + c.clientWidth,
          top: $.top,
          bottom: $.top + c.clientHeight
        };
      }
      let d = 0, p = 0;
      if (O == "nearest")
        e.top < u.top ? (p = -(u.top - e.top + a), i > 0 && e.bottom > u.bottom + p && (p = e.bottom - u.bottom + p + a)) : e.bottom > u.bottom && (p = e.bottom - u.bottom + a, i < 0 && e.top - p < u.top && (p = -(u.top + p - e.top + a)));
      else {
        let $ = e.bottom - e.top, g = u.bottom - u.top;
        p = (O == "center" && $ <= g ? e.top + $ / 2 - g / 2 : O == "start" || O == "center" && i < 0 ? e.top - a : e.bottom - g + a) - u.top;
      }
      if (n == "nearest" ? e.left < u.left ? (d = -(u.left - e.left + r), i > 0 && e.right > u.right + d && (d = e.right - u.right + d + r)) : e.right > u.right && (d = e.right - u.right + r, i < 0 && e.left < u.left + d && (d = -(u.left + d - e.left + r))) : d = (n == "center" ? e.left + (e.right - e.left) / 2 - (u.right - u.left) / 2 : n == "start" == o ? e.left - r : e.right - (u.right - u.left) + r) - u.left, d || p)
        if (h10)
          l.scrollBy(d, p);
        else {
          let $ = 0, g = 0;
          if (p) {
            let Q = c.scrollTop;
            c.scrollTop += p, g = c.scrollTop - Q;
          }
          if (d) {
            let Q = c.scrollLeft;
            c.scrollLeft += d, $ = c.scrollLeft - Q;
          }
          e = {
            left: e.left - $,
            top: e.top - g,
            right: e.right - $,
            bottom: e.bottom - g
          }, $ && Math.abs($ - d) < 1 && (n = "nearest"), g && Math.abs(g - p) < 1 && (O = "nearest");
        }
      if (h10)
        break;
      c = c.assignedSlot || c.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
}
function E_(t) {
  let e = t.ownerDocument;
  for (let i = t.parentNode; i && i != e.body; )
    if (i.nodeType == 1) {
      if (i.scrollHeight > i.clientHeight || i.scrollWidth > i.clientWidth)
        return i;
      i = i.assignedSlot || i.parentNode;
    } else if (i.nodeType == 11)
      i = i.host;
    else
      break;
  return null;
}
var j_ = class {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    this.set(e.anchorNode, e.anchorOffset, e.focusNode, e.focusOffset);
  }
  set(e, i, n, O) {
    this.anchorNode = e, this.anchorOffset = i, this.focusNode = n, this.focusOffset = O;
  }
};
var br = null;
function hv(t) {
  if (t.setActive)
    return t.setActive();
  if (br)
    return t.focus(br);
  let e = [];
  for (let i = t; i && (e.push(i, i.scrollTop, i.scrollLeft), i != i.ownerDocument); i = i.parentNode)
    ;
  if (t.focus(br == null ? {
    get preventScroll() {
      return br = { preventScroll: true }, true;
    }
  } : void 0), !br) {
    br = false;
    for (let i = 0; i < e.length; ) {
      let n = e[i++], O = e[i++], r = e[i++];
      n.scrollTop != O && (n.scrollTop = O), n.scrollLeft != r && (n.scrollLeft = r);
    }
  }
}
var FQ;
function ea(t, e, i = e) {
  let n = FQ || (FQ = document.createRange());
  return n.setEnd(t, i), n.setStart(t, e), n;
}
function Dr(t, e, i) {
  let n = { key: e, code: e, keyCode: i, which: i, cancelable: true }, O = new KeyboardEvent("keydown", n);
  O.synthetic = true, t.dispatchEvent(O);
  let r = new KeyboardEvent("keyup", n);
  return r.synthetic = true, t.dispatchEvent(r), O.defaultPrevented || r.defaultPrevented;
}
function I_(t) {
  for (; t; ) {
    if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host))
      return t;
    t = t.assignedSlot || t.parentNode;
  }
  return null;
}
function dv(t) {
  for (; t.attributes.length; )
    t.removeAttributeNode(t.attributes[0]);
}
function A_(t, e) {
  let i = e.focusNode, n = e.focusOffset;
  if (!i || e.anchorNode != i || e.anchorOffset != n)
    return false;
  for (; ; )
    if (n) {
      if (i.nodeType != 1)
        return false;
      let O = i.childNodes[n - 1];
      O.contentEditable == "false" ? n-- : (i = O, n = Mo(i));
    } else {
      if (i == t)
        return true;
      n = Ml(i), i = i.parentNode;
    }
}
var Zt = class {
  constructor(e, i, n = true) {
    this.node = e, this.offset = i, this.precise = n;
  }
  static before(e, i) {
    return new Zt(e.parentNode, Ml(e), i);
  }
  static after(e, i) {
    return new Zt(e.parentNode, Ml(e) + 1, i);
  }
};
var xp = [];
var Ee = class {
  constructor() {
    this.parent = null, this.dom = null, this.dirty = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let i = this.posAtStart;
    for (let n of this.children) {
      if (n == e)
        return i;
      i += n.length + n.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  // Will return a rectangle directly before (when side < 0), after
  // (side > 0) or directly on (when the browser supports it) the
  // given position.
  coordsAt(e, i) {
    return null;
  }
  sync(e, i) {
    if (this.dirty & 2) {
      let n = this.dom, O = null, r;
      for (let a of this.children) {
        if (a.dirty) {
          if (!a.dom && (r = O ? O.nextSibling : n.firstChild)) {
            let o = Ee.get(r);
            (!o || !o.parent && o.canReuseDOM(a)) && a.reuseDOM(r);
          }
          a.sync(e, i), a.dirty = 0;
        }
        if (r = O ? O.nextSibling : n.firstChild, i && !i.written && i.node == n && r != a.dom && (i.written = true), a.dom.parentNode == n)
          for (; r && r != a.dom; )
            r = HQ(r);
        else
          n.insertBefore(a.dom, r);
        O = a.dom;
      }
      for (r = O ? O.nextSibling : n.firstChild, r && i && i.node == n && (i.written = true); r; )
        r = HQ(r);
    } else if (this.dirty & 1)
      for (let n of this.children)
        n.dirty && (n.sync(e, i), n.dirty = 0);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, i) {
    let n;
    if (e == this.dom)
      n = this.dom.childNodes[i];
    else {
      let O = Mo(e) == 0 ? 0 : i == 0 ? -1 : 1;
      for (; ; ) {
        let r = e.parentNode;
        if (r == this.dom)
          break;
        O == 0 && r.firstChild != r.lastChild && (e == r.firstChild ? O = -1 : O = 1), e = r;
      }
      O < 0 ? n = e : n = e.nextSibling;
    }
    if (n == this.dom.firstChild)
      return 0;
    for (; n && !Ee.get(n); )
      n = n.nextSibling;
    if (!n)
      return this.length;
    for (let O = 0, r = 0; ; O++) {
      let a = this.children[O];
      if (a.dom == n)
        return r;
      r += a.length + a.breakAfter;
    }
  }
  domBoundsAround(e, i, n = 0) {
    let O = -1, r = -1, a = -1, o = -1;
    for (let s = 0, l = n, c = n; s < this.children.length; s++) {
      let u = this.children[s], h10 = l + u.length;
      if (l < e && h10 > i)
        return u.domBoundsAround(e, i, l);
      if (h10 >= e && O == -1 && (O = s, r = l), l > i && u.dom.parentNode == this.dom) {
        a = s, o = c;
        break;
      }
      c = h10, l = h10 + u.breakAfter;
    }
    return {
      from: r,
      to: o < 0 ? n + this.length : o,
      startDOM: (O ? this.children[O - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: a < this.children.length && a >= 0 ? this.children[a].dom : null
    };
  }
  markDirty(e = false) {
    this.dirty |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let i = this.parent; i; i = i.parent) {
      if (e && (i.dirty |= 2), i.dirty & 1)
        return;
      i.dirty |= 1, e = false;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.dirty && this.markParentsDirty(true));
  }
  setDOM(e) {
    this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this;
  }
  get rootView() {
    for (let e = this; ; ) {
      let i = e.parent;
      if (!i)
        return e;
      e = i;
    }
  }
  replaceChildren(e, i, n = xp) {
    this.markDirty();
    for (let O = e; O < i; O++) {
      let r = this.children[O];
      r.parent == this && r.destroy();
    }
    this.children.splice(e, i - e, ...n);
    for (let O = 0; O < n.length; O++)
      n[O].setParent(this);
  }
  ignoreMutation(e) {
    return false;
  }
  ignoreEvent(e) {
    return false;
  }
  childCursor(e = this.length) {
    return new pv(this.children, e, this.children.length);
  }
  childPos(e, i = 1) {
    return this.childCursor().findPos(e, i);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return true;
  }
  get isWidget() {
    return false;
  }
  merge(e, i, n, O, r, a) {
    return false;
  }
  become(e) {
    return false;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor;
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    this.parent = null;
  }
};
Ee.prototype.breakAfter = 0;
function HQ(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
var pv = class {
  constructor(e, i, n) {
    this.children = e, this.pos = i, this.i = n, this.off = 0;
  }
  findPos(e, i = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (i > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let n = this.children[--this.i];
      this.pos -= n.length + n.breakAfter;
    }
  }
};
function $v(t, e, i, n, O, r, a, o, s) {
  let { children: l } = t, c = l.length ? l[e] : null, u = r.length ? r[r.length - 1] : null, h10 = u ? u.breakAfter : a;
  if (!(e == n && c && !a && !h10 && r.length < 2 && c.merge(i, O, r.length ? u : null, i == 0, o, s))) {
    if (n < l.length) {
      let d = l[n];
      d && O < d.length ? (e == n && (d = d.split(O), O = 0), !h10 && u && d.merge(0, O, u, true, 0, s) ? r[r.length - 1] = d : (O && d.merge(0, O, null, false, 0, s), r.push(d))) : d != null && d.breakAfter && (u ? u.breakAfter = 1 : a = 1), n++;
    }
    for (c && (c.breakAfter = a, i > 0 && (!a && r.length && c.merge(i, c.length, r[0], false, o, 0) ? c.breakAfter = r.shift().breakAfter : (i < c.length || c.children.length && c.children[c.children.length - 1].length == 0) && c.merge(i, c.length, null, false, o, 0), e++)); e < n && r.length; )
      if (l[n - 1].become(r[r.length - 1]))
        n--, r.pop(), s = r.length ? 0 : o;
      else if (l[e].become(r[0]))
        e++, r.shift(), o = r.length ? 0 : s;
      else
        break;
    !r.length && e && n < l.length && !l[e - 1].breakAfter && l[n].merge(0, 0, l[e - 1], false, o, s) && e--, (e < n || r.length) && t.replaceChildren(e, n, r);
  }
}
function Qv(t, e, i, n, O, r) {
  let a = t.childCursor(), { i: o, off: s } = a.findPos(i, 1), { i: l, off: c } = a.findPos(e, -1), u = e - i;
  for (let h10 of n)
    u += h10.length;
  t.length += u, $v(t, l, c, o, s, n, 0, O, r);
}
var Qi = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" };
var Yh = typeof document < "u" ? document : { documentElement: { style: {} } };
var Rh = /Edge\/(\d+)/.exec(Qi.userAgent);
var gv = /MSIE \d/.test(Qi.userAgent);
var Zh = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Qi.userAgent);
var Nc = !!(gv || Zh || Rh);
var KQ = !Nc && /gecko\/(\d+)/i.test(Qi.userAgent);
var Du = !Nc && /Chrome\/(\d+)/.exec(Qi.userAgent);
var JQ = "webkitFontSmoothing" in Yh.documentElement.style;
var mv = !Nc && /Apple Computer/.test(Qi.vendor);
var eg = mv && (/Mobile\/\w+/.test(Qi.userAgent) || Qi.maxTouchPoints > 2);
var J = {
  mac: eg || /Mac/.test(Qi.platform),
  windows: /Win/.test(Qi.platform),
  linux: /Linux|X11/.test(Qi.platform),
  ie: Nc,
  ie_version: gv ? Yh.documentMode || 6 : Zh ? +Zh[1] : Rh ? +Rh[1] : 0,
  gecko: KQ,
  gecko_version: KQ ? +(/Firefox\/(\d+)/.exec(Qi.userAgent) || [0, 0])[1] : 0,
  chrome: !!Du,
  chrome_version: Du ? +Du[1] : 0,
  ios: eg,
  android: /Android\b/.test(Qi.userAgent),
  webkit: JQ,
  safari: mv,
  webkit_version: JQ ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: Yh.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
var G_ = 256;
var SO = class extends Ee {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, i) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (i && i.node == this.dom && (i.written = true), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, i, n) {
    return n && (!(n instanceof SO) || this.length - (i - e) + n.length > G_) ? false : (this.text = this.text.slice(0, e) + (n ? n.text : "") + this.text.slice(i), this.markDirty(), true);
  }
  split(e) {
    let i = new SO(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), i;
  }
  localPosFromDOM(e, i) {
    return e == this.dom ? i : i ? this.text.length : 0;
  }
  domAtPos(e) {
    return new Zt(this.dom, e);
  }
  domBoundsAround(e, i, n) {
    return { from: n, to: n + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, i) {
    return Uh(this.dom, e, i);
  }
};
var bn = class extends Ee {
  constructor(e, i = [], n = 0) {
    super(), this.mark = e, this.children = i, this.length = n;
    for (let O of i)
      O.setParent(this);
  }
  setAttrs(e) {
    if (dv(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let i in this.mark.attrs)
        e.setAttribute(i, this.mark.attrs[i]);
    return e;
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.dirty |= 6);
  }
  sync(e, i) {
    this.dom ? this.dirty & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, i);
  }
  merge(e, i, n, O, r, a) {
    return n && (!(n instanceof bn && n.mark.eq(this.mark)) || e && r <= 0 || i < this.length && a <= 0) ? false : (Qv(this, e, i, n ? n.children : [], r - 1, a - 1), this.markDirty(), true);
  }
  split(e) {
    let i = [], n = 0, O = -1, r = 0;
    for (let o of this.children) {
      let s = n + o.length;
      s > e && i.push(n < e ? o.split(e - n) : o), O < 0 && n >= e && (O = r), n = s, r++;
    }
    let a = this.length - e;
    return this.length = e, O > -1 && (this.children.length = O, this.markDirty()), new bn(this.mark, i, a);
  }
  domAtPos(e) {
    return yv(this, e);
  }
  coordsAt(e, i) {
    return vv(this, e, i);
  }
};
function Uh(t, e, i) {
  let n = t.nodeValue.length;
  e > n && (e = n);
  let O = e, r = e, a = 0;
  e == 0 && i < 0 || e == n && i >= 0 ? J.chrome || J.gecko || (e ? (O--, a = 1) : r < n && (r++, a = -1)) : i < 0 ? O-- : r < n && r++;
  let o = ea(t, O, r).getClientRects();
  if (!o.length)
    return fv;
  let s = o[(a ? a < 0 : i >= 0) ? 0 : o.length - 1];
  return J.safari && !a && s.width == 0 && (s = Array.prototype.find.call(o, (l) => l.width) || s), a ? Xp(s, a < 0) : s || null;
}
var lO = class extends Ee {
  constructor(e, i, n) {
    super(), this.widget = e, this.length = i, this.side = n, this.prevWidget = null;
  }
  static create(e, i, n) {
    return new (e.customView || lO)(e, i, n);
  }
  split(e) {
    let i = lO.create(this.widget, this.length - e, this.side);
    return this.length -= e, i;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.dom.contentEditable = "false");
  }
  getSide() {
    return this.side;
  }
  merge(e, i, n, O, r, a) {
    return n && (!(n instanceof lO) || !this.widget.compare(n.widget) || e > 0 && r <= 0 || i < this.length && a <= 0) ? false : (this.length = e + (n ? n.length : 0) + (this.length - i), true);
  }
  become(e) {
    return e.length == this.length && e instanceof lO && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.eq(e.widget) || this.markDirty(true), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, true) : false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Te.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: i } = e, n = i && i.state.doc, O = this.posAtStart;
    return n ? n.slice(O, O + this.length) : Te.empty;
  }
  domAtPos(e) {
    return e == 0 ? Zt.before(this.dom) : Zt.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, i) {
    let n = this.dom.getClientRects(), O = null;
    if (!n.length)
      return fv;
    for (let r = e > 0 ? n.length - 1 : 0; O = n[r], !(e > 0 ? r == 0 : r == n.length - 1 || O.top < O.bottom); r += e > 0 ? -1 : 1)
      ;
    return this.length ? O : Xp(O, this.side > 0);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
};
var Sv = class extends lO {
  domAtPos(e) {
    let { topView: i, text: n } = this.widget;
    return i ? Vh(e, 0, i, n, (O, r) => O.domAtPos(r), (O) => new Zt(n, Math.min(O, n.nodeValue.length))) : new Zt(n, Math.min(e, n.nodeValue.length));
  }
  sync() {
    this.setDOM(this.widget.toDOM());
  }
  localPosFromDOM(e, i) {
    let { topView: n, text: O } = this.widget;
    return n ? Pv(e, i, n, O) : Math.min(i, this.length);
  }
  ignoreMutation() {
    return false;
  }
  get overrideDOMText() {
    return null;
  }
  coordsAt(e, i) {
    let { topView: n, text: O } = this.widget;
    return n ? Vh(e, i, n, O, (r, a, o) => r.coordsAt(a, o), (r, a) => Uh(O, r, a)) : Uh(O, e, i);
  }
  destroy() {
    var e;
    super.destroy(), (e = this.widget.topView) === null || e === void 0 || e.destroy();
  }
  get isEditable() {
    return true;
  }
  canReuseDOM() {
    return true;
  }
};
function Vh(t, e, i, n, O, r) {
  if (i instanceof bn) {
    for (let a = i.dom.firstChild; a; a = a.nextSibling) {
      let o = Ee.get(a);
      if (!o)
        return r(t, e);
      let s = Jr(a, n), l = o.length + (s ? n.nodeValue.length : 0);
      if (t < l || t == l && o.getSide() <= 0)
        return s ? Vh(t, e, o, n, O, r) : O(o, t, e);
      t -= l;
    }
    return O(i, i.length, -1);
  } else
    return i.dom == n ? r(t, e) : O(i, t, e);
}
function Pv(t, e, i, n) {
  if (i instanceof bn)
    for (let O of i.children) {
      let r = 0, a = Jr(O.dom, n);
      if (Jr(O.dom, t))
        return r + (a ? Pv(t, e, O, n) : O.localPosFromDOM(t, e));
      r += a ? n.nodeValue.length : O.length;
    }
  else if (i.dom == n)
    return Math.min(e, n.nodeValue.length);
  return i.localPosFromDOM(t, e);
}
var ta = class extends Ee {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return false;
  }
  become(e) {
    return e instanceof ta && e.side == this.side;
  }
  split() {
    return new ta(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return Zt.before(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    let i = this.dom.getBoundingClientRect(), n = L_(this, this.side > 0 ? -1 : 1);
    return n && n.top < i.bottom && n.bottom > i.top ? { left: i.left, right: i.right, top: n.top, bottom: n.bottom } : i;
  }
  get overrideDOMText() {
    return Te.empty;
  }
};
SO.prototype.children = lO.prototype.children = ta.prototype.children = xp;
function L_(t, e) {
  let i = t.parent, n = i ? i.children.indexOf(t) : -1;
  for (; i && n >= 0; )
    if (e < 0 ? n > 0 : n < i.children.length) {
      let O = i.children[n + e];
      if (O instanceof SO) {
        let r = O.coordsAt(e < 0 ? O.length : 0, e);
        if (r)
          return r;
      }
      n += e;
    } else if (i instanceof bn && i.parent)
      n = i.parent.children.indexOf(i) + (e < 0 ? 0 : 1), i = i.parent;
    else {
      let O = i.dom.lastChild;
      if (O && O.nodeName == "BR")
        return O.getClientRects()[0];
      break;
    }
}
function yv(t, e) {
  let i = t.dom, { children: n } = t, O = 0;
  for (let r = 0; O < n.length; O++) {
    let a = n[O], o = r + a.length;
    if (!(o == r && a.getSide() <= 0)) {
      if (e > r && e < o && a.dom.parentNode == i)
        return a.domAtPos(e - r);
      if (e <= r)
        break;
      r = o;
    }
  }
  for (let r = O; r > 0; r--) {
    let a = n[r - 1];
    if (a.dom.parentNode == i)
      return a.domAtPos(a.length);
  }
  for (let r = O; r < n.length; r++) {
    let a = n[r];
    if (a.dom.parentNode == i)
      return a.domAtPos(0);
  }
  return new Zt(i, 0);
}
function bv(t, e, i) {
  let n, { children: O } = t;
  i > 0 && e instanceof bn && O.length && (n = O[O.length - 1]) instanceof bn && n.mark.eq(e.mark) ? bv(n, e.children[0], i - 1) : (O.push(e), e.setParent(t)), t.length += e.length;
}
function vv(t, e, i) {
  let n = null, O = -1, r = null, a = -1;
  function o(l, c) {
    for (let u = 0, h10 = 0; u < l.children.length && h10 <= c; u++) {
      let d = l.children[u], p = h10 + d.length;
      p >= c && (d.children.length ? o(d, c - h10) : !r && (p > c || h10 == p && d.getSide() > 0) ? (r = d, a = c - h10) : (h10 < c || h10 == p && d.getSide() < 0) && (n = d, O = c - h10)), h10 = p;
    }
  }
  o(t, e);
  let s = (i < 0 ? n : r) || n || r;
  return s ? s.coordsAt(Math.max(0, s == n ? O : a), i) : D_(t);
}
function D_(t) {
  let e = t.dom.lastChild;
  if (!e)
    return t.dom.getBoundingClientRect();
  let i = Do(e);
  return i[i.length - 1] || null;
}
function qh(t, e) {
  for (let i in t)
    i == "class" && e.class ? e.class += " " + t.class : i == "style" && e.style ? e.style += ";" + t.style : e[i] = t[i];
  return e;
}
function wp(t, e) {
  if (t == e)
    return true;
  if (!t || !e)
    return false;
  let i = Object.keys(t), n = Object.keys(e);
  if (i.length != n.length)
    return false;
  for (let O of i)
    if (n.indexOf(O) == -1 || t[O] !== e[O])
      return false;
  return true;
}
function zh(t, e, i) {
  let n = null;
  if (e)
    for (let O in e)
      i && O in i || t.removeAttribute(n = O);
  if (i)
    for (let O in i)
      e && e[O] == i[O] || t.setAttribute(n = O, i[O]);
  return !!n;
}
var xn = class {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return false;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, i) {
    return false;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return true;
  }
  /**
  @internal
  */
  get customView() {
    return null;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
};
var Re = function(t) {
  return t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t;
}(Re || (Re = {}));
var ne = class extends KO {
  constructor(e, i, n, O) {
    super(), this.startSide = e, this.endSide = i, this.widget = n, this.spec = O;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return false;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new Bc(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let i = e.side || 0, n = !!e.block;
    return i += n ? i > 0 ? 3e8 : -4e8 : i > 0 ? 1e8 : -1e8, new JO(e, i, i, n, e.widget || null, false);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let i = !!e.block, n, O;
    if (e.isBlockGap)
      n = -5e8, O = 4e8;
    else {
      let { start: r, end: a } = Xv(e, i);
      n = (r ? i ? -3e8 : -1 : 5e8) - 1, O = (a ? i ? 2e8 : 1 : -6e8) + 1;
    }
    return new JO(e, n, O, i, e.widget || null, true);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new Ps(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, i = false) {
    return We.of(e, i);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : false;
  }
};
ne.none = We.empty;
var Bc = class extends ne {
  constructor(e) {
    let { start: i, end: n } = Xv(e);
    super(i ? -1 : 5e8, n ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    return this == e || e instanceof Bc && this.tagName == e.tagName && this.class == e.class && wp(this.attrs, e.attrs);
  }
  range(e, i = e) {
    if (e >= i)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, i);
  }
};
Bc.prototype.point = false;
var Ps = class extends ne {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof Ps && this.spec.class == e.spec.class && wp(this.spec.attributes, e.spec.attributes);
  }
  range(e, i = e) {
    if (i != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, i);
  }
};
Ps.prototype.mapMode = wt.TrackBefore;
Ps.prototype.point = true;
var JO = class extends ne {
  constructor(e, i, n, O, r, a) {
    super(i, n, r, e), this.block = O, this.isReplace = a, this.mapMode = O ? i <= 0 ? wt.TrackBefore : wt.TrackAfter : wt.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide < this.endSide ? Re.WidgetRange : this.startSide <= 0 ? Re.WidgetBefore : Re.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && this.widget.estimatedHeight >= 5;
  }
  eq(e) {
    return e instanceof JO && M_(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, i = e) {
    if (this.isReplace && (e > i || e == i && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && i != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, i);
  }
};
JO.prototype.point = true;
function Xv(t, e = false) {
  let { inclusiveStart: i, inclusiveEnd: n } = t;
  return i == null && (i = t.inclusive), n == null && (n = t.inclusive), { start: i ?? e, end: n ?? e };
}
function M_(t, e) {
  return t == e || !!(t && e && t.compare(e));
}
function Ch(t, e, i, n = 0) {
  let O = i.length - 1;
  O >= 0 && i[O] + n >= t ? i[O] = Math.max(i[O], e) : i.push(t, e);
}
var Nt = class extends Ee {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, i, n, O, r, a) {
    if (n) {
      if (!(n instanceof Nt))
        return false;
      this.dom || n.transferDOM(this);
    }
    return O && this.setDeco(n ? n.attrs : null), Qv(this, e, i, n ? n.children : [], r, a), true;
  }
  split(e) {
    let i = new Nt();
    if (i.breakAfter = this.breakAfter, this.length == 0)
      return i;
    let { i: n, off: O } = this.childPos(e);
    O && (i.append(this.children[n].split(O), 0), this.children[n].merge(O, this.children[n].length, null, false, 0, 0), n++);
    for (let r = n; r < this.children.length; r++)
      i.append(this.children[r], 0);
    for (; n > 0 && this.children[n - 1].length == 0; )
      this.children[--n].destroy();
    return this.children.length = n, this.markDirty(), this.length = e, i;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    wp(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, i) {
    bv(this, e, i);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let i = e.spec.attributes, n = e.spec.class;
    i && (this.attrs = qh(i, this.attrs || {})), n && (this.attrs = qh({ class: n }, this.attrs || {}));
  }
  domAtPos(e) {
    return yv(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.dirty |= 6);
  }
  sync(e, i) {
    var n;
    this.dom ? this.dirty & 4 && (dv(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (zh(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, i);
    let O = this.dom.lastChild;
    for (; O && Ee.get(O) instanceof bn; )
      O = O.lastChild;
    if (!O || !this.length || O.nodeName != "BR" && ((n = Ee.get(O)) === null || n === void 0 ? void 0 : n.isEditable) == false && (!J.ios || !this.children.some((r) => r instanceof SO))) {
      let r = document.createElement("BR");
      r.cmIgnore = true, this.dom.appendChild(r);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0;
    for (let i of this.children) {
      if (!(i instanceof SO) || /[^ -~]/.test(i.text))
        return null;
      let n = Do(i.dom);
      if (n.length != 1)
        return null;
      e += n[0].width;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length
    } : null;
  }
  coordsAt(e, i) {
    return vv(this, e, i);
  }
  become(e) {
    return false;
  }
  get type() {
    return Re.Text;
  }
  static find(e, i) {
    for (let n = 0, O = 0; n < e.children.length; n++) {
      let r = e.children[n], a = O + r.length;
      if (a >= i) {
        if (r instanceof Nt)
          return r;
        if (a > i)
          break;
      }
      O = a + r.breakAfter;
    }
    return null;
  }
};
var NO = class extends Ee {
  constructor(e, i, n) {
    super(), this.widget = e, this.length = i, this.type = n, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, i, n, O, r, a) {
    return n && (!(n instanceof NO) || !this.widget.compare(n.widget) || e > 0 && r <= 0 || i < this.length && a <= 0) ? false : (this.length = e + (n ? n.length : 0) + (this.length - i), true);
  }
  domAtPos(e) {
    return e == 0 ? Zt.before(this.dom) : Zt.after(this.dom, e == this.length);
  }
  split(e) {
    let i = this.length - e;
    this.length = e;
    let n = new NO(this.widget, i, this.type);
    return n.breakAfter = this.breakAfter, n;
  }
  get children() {
    return xp;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.dom.contentEditable = "false");
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Te.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof NO && e.type == this.type && e.widget.constructor == this.widget.constructor ? (e.widget.eq(this.widget) || this.markDirty(true), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.breakAfter = e.breakAfter, true) : false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
};
var Tp = class {
  constructor(e, i, n, O) {
    this.doc = e, this.pos = i, this.end = n, this.disallowBlockEffectsFor = O, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = true, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = i;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !e.breakAfter && !(e instanceof NO && e.type == Re.WidgetBefore);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new Nt()), this.atCursorPos = true), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Es(new ta(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, this.posCovered() || this.getLine();
  }
  buildText(e, i, n) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: r, lineBreak: a, done: o } = this.cursor.next(this.skip);
        if (this.skip = 0, o)
          throw new Error("Ran out of text content when drawing inline views");
        if (a) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = true, e--;
          continue;
        } else
          this.text = r, this.textOff = 0;
      }
      let O = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(i.slice(i.length - n)), this.getLine().append(Es(new SO(this.text.slice(this.textOff, this.textOff + O)), i), n), this.atCursorPos = true, this.textOff += O, e -= O, n = 0;
    }
  }
  span(e, i, n, O) {
    this.buildText(i - e, n, O), this.pos = i, this.openStart < 0 && (this.openStart = O);
  }
  point(e, i, n, O, r, a) {
    if (this.disallowBlockEffectsFor[a] && n instanceof JO) {
      if (n.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (i > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let o = i - e;
    if (n instanceof JO)
      if (n.block) {
        let { type: s } = n;
        s == Re.WidgetAfter && !this.posCovered() && this.getLine(), this.addBlockWidget(new NO(n.widget || new tg("div"), o, s));
      } else {
        let s = lO.create(n.widget || new tg("span"), o, o ? 0 : n.startSide), l = this.atCursorPos && !s.isEditable && r <= O.length && (e < i || n.startSide > 0), c = !s.isEditable && (e < i || r > O.length || n.startSide <= 0), u = this.getLine();
        this.pendingBuffer == 2 && !l && (this.pendingBuffer = 0), this.flushBuffer(O), l && (u.append(Es(new ta(1), O), r), r = O.length + Math.max(0, r - O.length)), u.append(Es(s, O), r), this.atCursorPos = c, this.pendingBuffer = c ? e < i || r > O.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = O.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(n);
    o && (this.textOff + o <= this.text.length ? this.textOff += o : (this.skip += o - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = i), this.openStart < 0 && (this.openStart = r);
  }
  static build(e, i, n, O, r) {
    let a = new Tp(e, i, n, r);
    return a.openEnd = We.spans(O, i, n, a), a.openStart < 0 && (a.openStart = a.openEnd), a.finish(a.openEnd), a;
  }
};
function Es(t, e) {
  for (let i of e)
    t = new bn(i, [t], t.length);
  return t;
}
var tg = class extends xn {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
};
var xv = K.define();
var wv = K.define();
var Tv = K.define();
var kv = K.define();
var Eh = K.define();
var _v = K.define();
var Wv = K.define();
var Yv = K.define({
  combine: (t) => t.some((e) => e)
});
var Rv = K.define({
  combine: (t) => t.some((e) => e)
});
var Nl = class {
  constructor(e, i = "nearest", n = "nearest", O = 5, r = 5) {
    this.range = e, this.y = i, this.x = n, this.yMargin = O, this.xMargin = r;
  }
  map(e) {
    return e.empty ? this : new Nl(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin);
  }
};
var ig = fe.define({ map: (t, e) => t.map(e) });
function Pi(t, e, i) {
  let n = t.facet(kv);
  n.length ? n[0](e) : window.onerror ? window.onerror(String(e), i, void 0, void 0, e) : i ? console.error(i + ":", e) : console.error(e);
}
var Fc = K.define({ combine: (t) => t.length ? t[0] : true });
var N_ = 0;
var fo = K.define();
var it = class {
  constructor(e, i, n, O) {
    this.id = e, this.create = i, this.domEventHandlers = n, this.extension = O(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, i) {
    const { eventHandlers: n, provide: O, decorations: r } = i || {};
    return new it(N_++, e, n, (a) => {
      let o = [fo.of(a)];
      return r && o.push(No.of((s) => {
        let l = s.plugin(a);
        return l ? r(l) : ne.none;
      })), O && o.push(O(a)), o;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, i) {
    return it.define((n) => new e(n), i);
  }
};
var Mu = class {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let i = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(i);
          } catch (n) {
            if (Pi(i.state, n, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (i) {
        Pi(e.state, i, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var i;
    if (!((i = this.value) === null || i === void 0) && i.destroy)
      try {
        this.value.destroy();
      } catch (n) {
        Pi(e.state, n, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
};
var Zv = K.define();
var kp = K.define();
var No = K.define();
var Uv = K.define();
var Vv = K.define();
var ho = K.define();
var Sn = class {
  constructor(e, i, n, O) {
    this.fromA = e, this.toA = i, this.fromB = n, this.toB = O;
  }
  join(e) {
    return new Sn(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let i = e.length, n = this;
    for (; i > 0; i--) {
      let O = e[i - 1];
      if (!(O.fromA > n.toA)) {
        if (O.toA < n.fromA)
          break;
        n = n.join(O), e.splice(i - 1, 1);
      }
    }
    return e.splice(i, 0, n), e;
  }
  static extendWithRanges(e, i) {
    if (i.length == 0)
      return e;
    let n = [];
    for (let O = 0, r = 0, a = 0, o = 0; ; O++) {
      let s = O == e.length ? null : e[O], l = a - o, c = s ? s.fromB : 1e9;
      for (; r < i.length && i[r] < c; ) {
        let u = i[r], h10 = i[r + 1], d = Math.max(o, u), p = Math.min(c, h10);
        if (d <= p && new Sn(d + l, p + l, d, p).addToSet(n), h10 > c)
          break;
        r += 2;
      }
      if (!s)
        return n;
      new Sn(s.fromA, s.toA, s.fromB, s.toB).addToSet(n), a = s.toA, o = s.toB;
    }
  }
};
var Bl = class {
  constructor(e, i, n) {
    this.view = e, this.state = i, this.transactions = n, this.flags = 0, this.startState = e.state, this.changes = ct.empty(this.startState.doc.length);
    for (let r of n)
      this.changes = this.changes.compose(r.changes);
    let O = [];
    this.changes.iterChangedRanges((r, a, o, s) => O.push(new Sn(r, a, o, s))), this.changedRanges = O;
  }
  /**
  @internal
  */
  static create(e, i, n) {
    return new Bl(e, i, n);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
};
var Ne = function(t) {
  return t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t;
}(Ne || (Ne = {}));
var jh = Ne.LTR;
var B_ = Ne.RTL;
function qv(t) {
  let e = [];
  for (let i = 0; i < t.length; i++)
    e.push(1 << +t[i]);
  return e;
}
var F_ = qv("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
var H_ = qv("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
var Ih = /* @__PURE__ */ Object.create(null);
var ln = [];
for (let t of ["()", "[]", "{}"]) {
  let e = t.charCodeAt(0), i = t.charCodeAt(1);
  Ih[e] = i, Ih[i] = -e;
}
function K_(t) {
  return t <= 247 ? F_[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? H_[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8203 ? 256 : 64336 <= t && t <= 65023 ? 4 : t == 8204 ? 256 : 1;
}
var J_ = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
var Mr = class {
  /**
  @internal
  */
  constructor(e, i, n) {
    this.from = e, this.to = i, this.level = n;
  }
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? B_ : jh;
  }
  /**
  @internal
  */
  side(e, i) {
    return this.dir == i == e ? this.to : this.from;
  }
  /**
  @internal
  */
  static find(e, i, n, O) {
    let r = -1;
    for (let a = 0; a < e.length; a++) {
      let o = e[a];
      if (o.from <= i && o.to >= i) {
        if (o.level == n)
          return a;
        (r < 0 || (O != 0 ? O < 0 ? o.from < i : o.to > i : e[r].level > o.level)) && (r = a);
      }
    }
    if (r < 0)
      throw new RangeError("Index out of range");
    return r;
  }
};
var Me = [];
function eW(t, e) {
  let i = t.length, n = e == jh ? 1 : 2, O = e == jh ? 2 : 1;
  if (!t || n == 1 && !J_.test(t))
    return zv(i);
  for (let a = 0, o = n, s = n; a < i; a++) {
    let l = K_(t.charCodeAt(a));
    l == 512 ? l = o : l == 8 && s == 4 && (l = 16), Me[a] = l == 4 ? 2 : l, l & 7 && (s = l), o = l;
  }
  for (let a = 0, o = n, s = n; a < i; a++) {
    let l = Me[a];
    if (l == 128)
      a < i - 1 && o == Me[a + 1] && o & 24 ? l = Me[a] = o : Me[a] = 256;
    else if (l == 64) {
      let c = a + 1;
      for (; c < i && Me[c] == 64; )
        c++;
      let u = a && o == 8 || c < i && Me[c] == 8 ? s == 1 ? 1 : 8 : 256;
      for (let h10 = a; h10 < c; h10++)
        Me[h10] = u;
      a = c - 1;
    } else
      l == 8 && s == 1 && (Me[a] = 1);
    o = l, l & 7 && (s = l);
  }
  for (let a = 0, o = 0, s = 0, l, c, u; a < i; a++)
    if (c = Ih[l = t.charCodeAt(a)])
      if (c < 0) {
        for (let h10 = o - 3; h10 >= 0; h10 -= 3)
          if (ln[h10 + 1] == -c) {
            let d = ln[h10 + 2], p = d & 2 ? n : d & 4 ? d & 1 ? O : n : 0;
            p && (Me[a] = Me[ln[h10]] = p), o = h10;
            break;
          }
      } else {
        if (ln.length == 189)
          break;
        ln[o++] = a, ln[o++] = l, ln[o++] = s;
      }
    else if ((u = Me[a]) == 2 || u == 1) {
      let h10 = u == n;
      s = h10 ? 0 : 1;
      for (let d = o - 3; d >= 0; d -= 3) {
        let p = ln[d + 2];
        if (p & 2)
          break;
        if (h10)
          ln[d + 2] |= 2;
        else {
          if (p & 4)
            break;
          ln[d + 2] |= 4;
        }
      }
    }
  for (let a = 0; a < i; a++)
    if (Me[a] == 256) {
      let o = a + 1;
      for (; o < i && Me[o] == 256; )
        o++;
      let s = (a ? Me[a - 1] : n) == 1, l = (o < i ? Me[o] : n) == 1, c = s == l ? s ? 1 : 2 : n;
      for (let u = a; u < o; u++)
        Me[u] = c;
      a = o - 1;
    }
  let r = [];
  if (n == 1)
    for (let a = 0; a < i; ) {
      let o = a, s = Me[a++] != 1;
      for (; a < i && s == (Me[a] != 1); )
        a++;
      if (s)
        for (let l = a; l > o; ) {
          let c = l, u = Me[--l] != 2;
          for (; l > o && u == (Me[l - 1] != 2); )
            l--;
          r.push(new Mr(l, c, u ? 2 : 1));
        }
      else
        r.push(new Mr(o, a, 0));
    }
  else
    for (let a = 0; a < i; ) {
      let o = a, s = Me[a++] == 2;
      for (; a < i && s == (Me[a] == 2); )
        a++;
      r.push(new Mr(o, a, s ? 1 : 2));
    }
  return r;
}
function zv(t) {
  return [new Mr(0, t, 0)];
}
var Cv = "";
function tW(t, e, i, n, O) {
  var r;
  let a = n.head - t.from, o = -1;
  if (a == 0) {
    if (!O || !t.length)
      return null;
    e[0].level != i && (a = e[0].side(false, i), o = 0);
  } else if (a == t.length) {
    if (O)
      return null;
    let h10 = e[e.length - 1];
    h10.level != i && (a = h10.side(true, i), o = e.length - 1);
  }
  o < 0 && (o = Mr.find(e, a, (r = n.bidiLevel) !== null && r !== void 0 ? r : -1, n.assoc));
  let s = e[o];
  a == s.side(O, i) && (s = e[o += O ? 1 : -1], a = s.side(!O, i));
  let l = O == (s.dir == i), c = Mt(t.text, a, l);
  if (Cv = t.text.slice(Math.min(a, c), Math.max(a, c)), c != s.side(O, i))
    return R.cursor(c + t.from, l ? -1 : 1, s.level);
  let u = o == (O ? e.length - 1 : 0) ? null : e[o + (O ? 1 : -1)];
  return !u && s.level != i ? R.cursor(O ? t.to : t.from, O ? -1 : 1, i) : u && u.level < s.level ? R.cursor(u.side(!O, i) + t.from, O ? 1 : -1, u.level) : R.cursor(c + t.from, O ? -1 : 1, s.level);
}
var cO = "￿";
var Ev = class {
  constructor(e, i) {
    this.points = e, this.text = "", this.lineSeparator = i.facet(ye.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += cO;
  }
  readRange(e, i) {
    if (!e)
      return this;
    let n = e.parentNode;
    for (let O = e; ; ) {
      this.findPointBefore(n, O), this.readNode(O);
      let r = O.nextSibling;
      if (r == i)
        break;
      let a = Ee.get(O), o = Ee.get(r);
      (a && o ? a.breakAfter : (a ? a.breakAfter : ng(O)) || ng(r) && (O.nodeName != "BR" || O.cmIgnore)) && this.lineBreak(), O = r;
    }
    return this.findPointBefore(n, i), this;
  }
  readTextNode(e) {
    let i = e.nodeValue;
    for (let n of this.points)
      n.node == e && (n.pos = this.text.length + Math.min(n.offset, i.length));
    for (let n = 0, O = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let r = -1, a = 1, o;
      if (this.lineSeparator ? (r = i.indexOf(this.lineSeparator, n), a = this.lineSeparator.length) : (o = O.exec(i)) && (r = o.index, a = o[0].length), this.append(i.slice(n, r < 0 ? i.length : r)), r < 0)
        break;
      if (this.lineBreak(), a > 1)
        for (let s of this.points)
          s.node == e && s.pos > this.text.length && (s.pos -= a - 1);
      n = r + a;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let i = Ee.get(e), n = i && i.overrideDOMText;
    if (n != null) {
      this.findPointInside(e, n.length);
      for (let O = n.iter(); !O.next().done; )
        O.lineBreak ? this.lineBreak() : this.append(O.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, i) {
    for (let n of this.points)
      n.node == e && e.childNodes[n.offset] == i && (n.pos = this.text.length);
  }
  findPointInside(e, i) {
    for (let n of this.points)
      (e.nodeType == 3 ? n.node == e : e.contains(n.node)) && (n.pos = this.text.length + Math.min(i, n.offset));
  }
};
function ng(t) {
  return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
}
var Og = class {
  constructor(e, i) {
    this.node = e, this.offset = i, this.pos = -1;
  }
};
var rg = class extends Ee {
  constructor(e) {
    super(), this.view = e, this.compositionDeco = ne.none, this.decorations = [], this.dynamicDecorationMap = [], this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = false, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new Nt()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Sn(0, 0, 0, e.state.doc.length)], 0);
  }
  get length() {
    return this.view.state.doc.length;
  }
  // Update the document view to a given state. scrollIntoView can be
  // used as a hint to compute a new viewport that includes that
  // position, if we know the editor is going to scroll that position
  // into view.
  update(e) {
    let i = e.changedRanges;
    this.minWidth > 0 && i.length && (i.every(({ fromA: a, toA: o }) => o < this.minWidthFrom || a > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.view.inputState.composing < 0 ? this.compositionDeco = ne.none : (e.transactions.length || this.dirty) && (this.compositionDeco = nW(this.view, e.changes)), (J.ie || J.chrome) && !this.compositionDeco.size && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = true);
    let n = this.decorations, O = this.updateDeco(), r = oW(n, O, e.changes);
    return i = Sn.extendWithRanges(i, r), this.dirty == 0 && i.length == 0 ? false : (this.updateInner(i, e.startState.doc.length), e.transactions.length && (this.lastUpdate = Date.now()), true);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, i) {
    this.view.viewState.mustMeasureContent = true, this.updateChildren(e, i);
    let { observer: n } = this.view;
    n.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let r = J.chrome || J.ios ? { node: n.selectionRange.focusNode, written: false } : void 0;
      this.sync(this.view, r), this.dirty = 0, r && (r.written || n.selectionRange.focusNode != r.node) && (this.forceSelection = true), this.dom.style.height = "";
    });
    let O = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let r of this.children)
        r instanceof NO && r.widget instanceof ag && O.push(r.dom);
    n.updateGaps(O);
  }
  updateChildren(e, i) {
    let n = this.childCursor(i);
    for (let O = e.length - 1; ; O--) {
      let r = O >= 0 ? e[O] : null;
      if (!r)
        break;
      let { fromA: a, toA: o, fromB: s, toB: l } = r, { content: c, breakAtStart: u, openStart: h10, openEnd: d } = Tp.build(this.view.state.doc, s, l, this.decorations, this.dynamicDecorationMap), { i: p, off: $ } = n.findPos(o, 1), { i: g, off: Q } = n.findPos(a, -1);
      $v(this, g, Q, p, $, c, u, h10, d);
    }
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = false, i = false) {
    if ((e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange(), !(i || this.mayControlSelection()))
      return;
    let n = this.forceSelection;
    this.forceSelection = false;
    let O = this.view.state.selection.main, r = this.domAtPos(O.anchor), a = O.empty ? r : this.domAtPos(O.head);
    if (J.gecko && O.empty && iW(r)) {
      let s = document.createTextNode("");
      this.view.observer.ignore(() => r.node.insertBefore(s, r.node.childNodes[r.offset] || null)), r = a = new Zt(s, 0), n = true;
    }
    let o = this.view.observer.selectionRange;
    (n || !o.focusNode || !Dl(r.node, r.offset, o.anchorNode, o.anchorOffset) || !Dl(a.node, a.offset, o.focusNode, o.focusOffset)) && (this.view.observer.ignore(() => {
      J.android && J.chrome && this.dom.contains(o.focusNode) && sW(o.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: true }));
      let s = Ll(this.view.root);
      if (s)
        if (O.empty) {
          if (J.gecko) {
            let l = rW(r.node, r.offset);
            if (l && l != 3) {
              let c = Iv(r.node, r.offset, l == 1 ? 1 : -1);
              c && (r = new Zt(c, l == 1 ? 0 : c.nodeValue.length));
            }
          }
          s.collapse(r.node, r.offset), O.bidiLevel != null && o.cursorBidiLevel != null && (o.cursorBidiLevel = O.bidiLevel);
        } else if (s.extend) {
          s.collapse(r.node, r.offset);
          try {
            s.extend(a.node, a.offset);
          } catch {
          }
        } else {
          let l = document.createRange();
          O.anchor > O.head && ([r, a] = [a, r]), l.setEnd(a.node, a.offset), l.setStart(r.node, r.offset), s.removeAllRanges(), s.addRange(l);
        }
    }), this.view.observer.setSelectionRange(r, a)), this.impreciseAnchor = r.precise ? null : new Zt(o.anchorNode, o.anchorOffset), this.impreciseHead = a.precise ? null : new Zt(o.focusNode, o.focusOffset);
  }
  enforceCursorAssoc() {
    if (this.compositionDeco.size)
      return;
    let { view: e } = this, i = e.state.selection.main, n = Ll(e.root), { anchorNode: O, anchorOffset: r } = e.observer.selectionRange;
    if (!n || !i.empty || !i.assoc || !n.modify)
      return;
    let a = Nt.find(this, i.head);
    if (!a)
      return;
    let o = a.posAtStart;
    if (i.head == o || i.head == o + a.length)
      return;
    let s = this.coordsAt(i.head, -1), l = this.coordsAt(i.head, 1);
    if (!s || !l || s.bottom > l.top)
      return;
    let c = this.domAtPos(i.head + i.assoc);
    n.collapse(c.node, c.offset), n.modify("move", i.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let u = e.observer.selectionRange;
    e.docView.posFromDOM(u.anchorNode, u.anchorOffset) != i.from && n.collapse(O, r);
  }
  mayControlSelection() {
    let e = this.view.root.activeElement;
    return e == this.dom || wl(this.dom, this.view.observer.selectionRange) && !(e && this.dom.contains(e));
  }
  nearest(e) {
    for (let i = e; i; ) {
      let n = Ee.get(i);
      if (n && n.rootView == this)
        return n;
      i = i.parentNode;
    }
    return null;
  }
  posFromDOM(e, i) {
    let n = this.nearest(e);
    if (!n)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return n.localPosFromDOM(e, i) + n.posAtStart;
  }
  domAtPos(e) {
    let { i, off: n } = this.childCursor().findPos(e, -1);
    for (; i < this.children.length - 1; ) {
      let O = this.children[i];
      if (n < O.length || O instanceof Nt)
        break;
      i++, n = 0;
    }
    return this.children[i].domAtPos(n);
  }
  coordsAt(e, i) {
    for (let n = this.length, O = this.children.length - 1; ; O--) {
      let r = this.children[O], a = n - r.breakAfter - r.length;
      if (e > a || e == a && r.type != Re.WidgetBefore && r.type != Re.WidgetAfter && (!O || i == 2 || this.children[O - 1].breakAfter || this.children[O - 1].type == Re.WidgetBefore && i > -2))
        return r.coordsAt(e - a, i);
      n = a;
    }
  }
  measureVisibleLineHeights(e) {
    let i = [], { from: n, to: O } = e, r = this.view.contentDOM.clientWidth, a = r > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, o = -1, s = this.view.textDirection == Ne.LTR;
    for (let l = 0, c = 0; c < this.children.length; c++) {
      let u = this.children[c], h10 = l + u.length;
      if (h10 > O)
        break;
      if (l >= n) {
        let d = u.dom.getBoundingClientRect();
        if (i.push(d.height), a) {
          let p = u.dom.lastChild, $ = p ? Do(p) : [];
          if ($.length) {
            let g = $[$.length - 1], Q = s ? g.right - d.left : d.right - g.left;
            Q > o && (o = Q, this.minWidth = r, this.minWidthFrom = l, this.minWidthTo = h10);
          }
        }
      }
      l = h10 + u.breakAfter;
    }
    return i;
  }
  textDirectionAt(e) {
    let { i } = this.childPos(e, 1);
    return getComputedStyle(this.children[i].dom).direction == "rtl" ? Ne.RTL : Ne.LTR;
  }
  measureTextSize() {
    for (let O of this.children)
      if (O instanceof Nt) {
        let r = O.measureTextSize();
        if (r)
          return r;
      }
    let e = document.createElement("div"), i, n;
    return e.className = "cm-line", e.style.width = "99999px", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let O = Do(e.firstChild)[0];
      i = e.getBoundingClientRect().height, n = O ? O.width / 27 : 7, e.remove();
    }), { lineHeight: i, charWidth: n };
  }
  childCursor(e = this.length) {
    let i = this.children.length;
    return i && (e -= this.children[--i].length), new pv(this.children, e, i);
  }
  computeBlockGapDeco() {
    let e = [], i = this.view.viewState;
    for (let n = 0, O = 0; ; O++) {
      let r = O == i.viewports.length ? null : i.viewports[O], a = r ? r.from - 1 : this.length;
      if (a > n) {
        let o = i.lineBlockAt(a).bottom - i.lineBlockAt(n).top;
        e.push(ne.replace({
          widget: new ag(o),
          block: true,
          inclusive: true,
          isBlockGap: true
        }).range(n, a));
      }
      if (!r)
        break;
      n = r.to + 1;
    }
    return ne.set(e);
  }
  updateDeco() {
    let e = this.view.state.facet(No).map((i, n) => (this.dynamicDecorationMap[n] = typeof i == "function") ? i(this.view) : i);
    for (let i = e.length; i < e.length + 3; i++)
      this.dynamicDecorationMap[i] = false;
    return this.decorations = [
      ...e,
      this.compositionDeco,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(e) {
    let { range: i } = e, n = this.coordsAt(i.head, i.empty ? i.assoc : i.head > i.anchor ? -1 : 1), O;
    if (!n)
      return;
    !i.empty && (O = this.coordsAt(i.anchor, i.anchor > i.head ? -1 : 1)) && (n = {
      left: Math.min(n.left, O.left),
      top: Math.min(n.top, O.top),
      right: Math.max(n.right, O.right),
      bottom: Math.max(n.bottom, O.bottom)
    });
    let r = 0, a = 0, o = 0, s = 0;
    for (let c of this.view.state.facet(Vv).map((u) => u(this.view)))
      if (c) {
        let { left: u, right: h10, top: d, bottom: p } = c;
        u != null && (r = Math.max(r, u)), h10 != null && (a = Math.max(a, h10)), d != null && (o = Math.max(o, d)), p != null && (s = Math.max(s, p));
      }
    let l = {
      left: n.left - r,
      top: n.top - o,
      right: n.right + a,
      bottom: n.bottom + s
    };
    C_(this.view.scrollDOM, l, i.head < i.anchor ? -1 : 1, e.x, e.y, e.xMargin, e.yMargin, this.view.textDirection == Ne.LTR);
  }
};
function iW(t) {
  return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false");
}
var ag = class extends xn {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", true;
  }
  get estimatedHeight() {
    return this.height;
  }
};
function jv(t) {
  let e = t.observer.selectionRange, i = e.focusNode && Iv(e.focusNode, e.focusOffset, 0);
  if (!i)
    return null;
  let n = t.docView.nearest(i);
  if (!n)
    return null;
  if (n instanceof Nt) {
    let O = i;
    for (; O.parentNode != n.dom; )
      O = O.parentNode;
    let r = O.previousSibling;
    for (; r && !Ee.get(r); )
      r = r.previousSibling;
    let a = r ? Ee.get(r).posAtEnd : n.posAtStart;
    return { from: a, to: a, node: O, text: i };
  } else {
    for (; ; ) {
      let { parent: r } = n;
      if (!r)
        return null;
      if (r instanceof Nt)
        break;
      n = r;
    }
    let O = n.posAtStart;
    return { from: O, to: O + n.length, node: n.dom, text: i };
  }
}
function nW(t, e) {
  let i = jv(t);
  if (!i)
    return ne.none;
  let { from: n, to: O, node: r, text: a } = i, o = e.mapPos(n, 1), s = Math.max(o, e.mapPos(O, -1)), { state: l } = t, c = r.nodeType == 3 ? r.nodeValue : new Ev([], l).readRange(r.firstChild, null).text;
  if (s - o < c.length)
    if (l.doc.sliceString(o, Math.min(l.doc.length, o + c.length), cO) == c)
      s = o + c.length;
    else if (l.doc.sliceString(Math.max(0, s - c.length), s, cO) == c)
      o = s - c.length;
    else
      return ne.none;
  else if (l.doc.sliceString(o, s, cO) != c)
    return ne.none;
  let u = Ee.get(r);
  return u instanceof Sv ? u = u.widget.topView : u && (u.parent = null), ne.set(ne.replace({ widget: new OW(r, a, u), inclusive: true }).range(o, s));
}
var OW = class extends xn {
  constructor(e, i, n) {
    super(), this.top = e, this.text = i, this.topView = n;
  }
  eq(e) {
    return this.top == e.top && this.text == e.text;
  }
  toDOM() {
    return this.top;
  }
  ignoreEvent() {
    return false;
  }
  get customView() {
    return Sv;
  }
};
function Iv(t, e, i) {
  for (; ; ) {
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && e > 0 && i <= 0)
      t = t.childNodes[e - 1], e = Mo(t);
    else if (t.nodeType == 1 && e < t.childNodes.length && i >= 0)
      t = t.childNodes[e], e = 0;
    else
      return null;
  }
}
function rW(t, e) {
  return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0);
}
var aW = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, i) {
    Ch(e, i, this.changes);
  }
  comparePoint(e, i) {
    Ch(e, i, this.changes);
  }
};
function oW(t, e, i) {
  let n = new aW();
  return We.compare(t, e, i, n), n.changes;
}
function sW(t, e) {
  for (let i = t; i && i != e; i = i.assignedSlot || i.parentNode)
    if (i.nodeType == 1 && i.contentEditable == "false")
      return true;
  return false;
}
function lW(t, e, i = 1) {
  let n = t.charCategorizer(e), O = t.doc.lineAt(e), r = e - O.from;
  if (O.length == 0)
    return R.cursor(e);
  r == 0 ? i = 1 : r == O.length && (i = -1);
  let a = r, o = r;
  i < 0 ? a = Mt(O.text, r, false) : o = Mt(O.text, r);
  let s = n(O.text.slice(a, o));
  for (; a > 0; ) {
    let l = Mt(O.text, a, false);
    if (n(O.text.slice(l, a)) != s)
      break;
    a = l;
  }
  for (; o < O.length; ) {
    let l = Mt(O.text, o);
    if (n(O.text.slice(o, l)) != s)
      break;
    o = l;
  }
  return R.range(a + O.from, o + O.from);
}
function cW(t, e) {
  return e.left > t ? e.left - t : Math.max(0, t - e.right);
}
function uW(t, e) {
  return e.top > t ? e.top - t : Math.max(0, t - e.bottom);
}
function Nu(t, e) {
  return t.top < e.bottom - 1 && t.bottom > e.top + 1;
}
function og(t, e) {
  return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t;
}
function sg(t, e) {
  return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t;
}
function Ah(t, e, i) {
  let n, O, r, a, o = false, s, l, c, u;
  for (let p = t.firstChild; p; p = p.nextSibling) {
    let $ = Do(p);
    for (let g = 0; g < $.length; g++) {
      let Q = $[g];
      O && Nu(O, Q) && (Q = og(sg(Q, O.bottom), O.top));
      let m = cW(e, Q), b = uW(i, Q);
      if (m == 0 && b == 0)
        return p.nodeType == 3 ? lg(p, e, i) : Ah(p, e, i);
      if (!n || a > b || a == b && r > m) {
        n = p, O = Q, r = m, a = b;
        let P = b ? i < Q.top ? -1 : 1 : m ? e < Q.left ? -1 : 1 : 0;
        o = !P || (P > 0 ? g < $.length - 1 : g > 0);
      }
      m == 0 ? i > Q.bottom && (!c || c.bottom < Q.bottom) ? (s = p, c = Q) : i < Q.top && (!u || u.top > Q.top) && (l = p, u = Q) : c && Nu(c, Q) ? c = sg(c, Q.bottom) : u && Nu(u, Q) && (u = og(u, Q.top));
    }
  }
  if (c && c.bottom >= i ? (n = s, O = c) : u && u.top <= i && (n = l, O = u), !n)
    return { node: t, offset: 0 };
  let h10 = Math.max(O.left, Math.min(O.right, e));
  if (n.nodeType == 3)
    return lg(n, h10, i);
  if (o && n.contentEditable != "false")
    return Ah(n, h10, i);
  let d = Array.prototype.indexOf.call(t.childNodes, n) + (e >= (O.left + O.right) / 2 ? 1 : 0);
  return { node: t, offset: d };
}
function lg(t, e, i) {
  let n = t.nodeValue.length, O = -1, r = 1e9, a = 0;
  for (let o = 0; o < n; o++) {
    let s = ea(t, o, o + 1).getClientRects();
    for (let l = 0; l < s.length; l++) {
      let c = s[l];
      if (c.top == c.bottom)
        continue;
      a || (a = e - c.left);
      let u = (c.top > i ? c.top - i : i - c.bottom) - 1;
      if (c.left - 1 <= e && c.right + 1 >= e && u < r) {
        let h10 = e >= (c.left + c.right) / 2, d = h10;
        if ((J.chrome || J.gecko) && ea(t, o).getBoundingClientRect().left == c.right && (d = !h10), u <= 0)
          return { node: t, offset: o + (d ? 1 : 0) };
        O = o + (d ? 1 : 0), r = u;
      }
    }
  }
  return { node: t, offset: O > -1 ? O : a > 0 ? t.nodeValue.length : 0 };
}
function Av(t, e, i, n = -1) {
  var O;
  let r = t.contentDOM.getBoundingClientRect(), a = r.top + t.viewState.paddingTop, o, { docHeight: s } = t.viewState, { x: l, y: c } = e, u = c - a;
  if (u < 0)
    return 0;
  if (u > s)
    return t.state.doc.length;
  for (let b = t.defaultLineHeight / 2, P = false; o = t.elementAtHeight(u), o.type != Re.Text; )
    for (; u = n > 0 ? o.bottom + b : o.top - b, !(u >= 0 && u <= s); ) {
      if (P)
        return i ? null : 0;
      P = true, n = -n;
    }
  c = a + u;
  let h10 = o.from;
  if (h10 < t.viewport.from)
    return t.viewport.from == 0 ? 0 : i ? null : cg(t, r, o, l, c);
  if (h10 > t.viewport.to)
    return t.viewport.to == t.state.doc.length ? t.state.doc.length : i ? null : cg(t, r, o, l, c);
  let d = t.dom.ownerDocument, p = t.root.elementFromPoint ? t.root : d, $ = p.elementFromPoint(l, c);
  $ && !t.contentDOM.contains($) && ($ = null), $ || (l = Math.max(r.left + 1, Math.min(r.right - 1, l)), $ = p.elementFromPoint(l, c), $ && !t.contentDOM.contains($) && ($ = null));
  let g, Q = -1;
  if ($ && ((O = t.docView.nearest($)) === null || O === void 0 ? void 0 : O.isEditable) != false) {
    if (d.caretPositionFromPoint) {
      let b = d.caretPositionFromPoint(l, c);
      b && ({ offsetNode: g, offset: Q } = b);
    } else if (d.caretRangeFromPoint) {
      let b = d.caretRangeFromPoint(l, c);
      b && ({ startContainer: g, startOffset: Q } = b, (!t.contentDOM.contains(g) || J.safari && fW(g, Q, l) || J.chrome && hW(g, Q, l)) && (g = void 0));
    }
  }
  if (!g || !t.docView.dom.contains(g)) {
    let b = Nt.find(t.docView, h10);
    if (!b)
      return u > o.top + o.height / 2 ? o.to : o.from;
    ({ node: g, offset: Q } = Ah(b.dom, l, c));
  }
  let m = t.docView.nearest(g);
  if (!m)
    return null;
  if (m.isWidget) {
    let b = m.dom.getBoundingClientRect();
    return e.y < b.top || e.y <= b.bottom && e.x <= (b.left + b.right) / 2 ? m.posAtStart : m.posAtEnd;
  } else
    return m.localPosFromDOM(g, Q) + m.posAtStart;
}
function cg(t, e, i, n, O) {
  let r = Math.round((n - e.left) * t.defaultCharacterWidth);
  if (t.lineWrapping && i.height > t.defaultLineHeight * 1.5) {
    let o = Math.floor((O - i.top) / t.defaultLineHeight);
    r += o * t.viewState.heightOracle.lineLength;
  }
  let a = t.state.sliceDoc(i.from, i.to);
  return i.from + kh(a, r, t.state.tabSize);
}
function fW(t, e, i) {
  let n;
  if (t.nodeType != 3 || e != (n = t.nodeValue.length))
    return false;
  for (let O = t.nextSibling; O; O = O.nextSibling)
    if (O.nodeType != 1 || O.nodeName != "BR")
      return false;
  return ea(t, n - 1, n).getBoundingClientRect().left > i;
}
function hW(t, e, i) {
  if (e != 0)
    return false;
  for (let O = t; ; ) {
    let r = O.parentNode;
    if (!r || r.nodeType != 1 || r.firstChild != O)
      return false;
    if (r.classList.contains("cm-line"))
      break;
    O = r;
  }
  let n = t.nodeType == 1 ? t.getBoundingClientRect() : ea(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
  return i - n.left > 5;
}
function dW(t, e, i, n) {
  let O = t.state.doc.lineAt(e.head), r = !n || !t.lineWrapping ? null : t.coordsAtPos(e.assoc < 0 && e.head > O.from ? e.head - 1 : e.head);
  if (r) {
    let s = t.dom.getBoundingClientRect(), l = t.textDirectionAt(O.from), c = t.posAtCoords({
      x: i == (l == Ne.LTR) ? s.right - 1 : s.left + 1,
      y: (r.top + r.bottom) / 2
    });
    if (c != null)
      return R.cursor(c, i ? -1 : 1);
  }
  let a = Nt.find(t.docView, e.head), o = a ? i ? a.posAtEnd : a.posAtStart : i ? O.to : O.from;
  return R.cursor(o, i ? -1 : 1);
}
function ug(t, e, i, n) {
  let O = t.state.doc.lineAt(e.head), r = t.bidiSpans(O), a = t.textDirectionAt(O.from);
  for (let o = e, s = null; ; ) {
    let l = tW(O, r, a, o, i), c = Cv;
    if (!l) {
      if (O.number == (i ? t.state.doc.lines : 1))
        return o;
      c = `
`, O = t.state.doc.line(O.number + (i ? 1 : -1)), r = t.bidiSpans(O), l = R.cursor(i ? O.from : O.to);
    }
    if (s) {
      if (!s(c))
        return o;
    } else {
      if (!n)
        return l;
      s = n(c);
    }
    o = l;
  }
}
function pW(t, e, i) {
  let n = t.state.charCategorizer(e), O = n(i);
  return (r) => {
    let a = n(r);
    return O == Le.Space && (O = a), O == a;
  };
}
function $W(t, e, i, n) {
  let O = e.head, r = i ? 1 : -1;
  if (O == (i ? t.state.doc.length : 0))
    return R.cursor(O, e.assoc);
  let a = e.goalColumn, o, s = t.contentDOM.getBoundingClientRect(), l = t.coordsAtPos(O), c = t.documentTop;
  if (l)
    a == null && (a = l.left - s.left), o = r < 0 ? l.top : l.bottom;
  else {
    let d = t.viewState.lineBlockAt(O);
    a == null && (a = Math.min(s.right - s.left, t.defaultCharacterWidth * (O - d.from))), o = (r < 0 ? d.top : d.bottom) + c;
  }
  let u = s.left + a, h10 = n ?? t.defaultLineHeight >> 1;
  for (let d = 0; ; d += 10) {
    let p = o + (h10 + d) * r, $ = Av(t, { x: u, y: p }, false, r);
    if (p < s.top || p > s.bottom || (r < 0 ? $ < O : $ > O))
      return R.cursor($, e.assoc, void 0, a);
  }
}
function Bu(t, e, i) {
  let n = t.state.facet(Uv).map((O) => O(t));
  for (; ; ) {
    let O = false;
    for (let r of n)
      r.between(i.from - 1, i.from + 1, (a, o, s) => {
        i.from > a && i.from < o && (i = e.head > i.from ? R.cursor(a, 1) : R.cursor(o, -1), O = true);
      });
    if (!O)
      return i;
  }
}
var QW = class {
  constructor(e) {
    this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.chromeScrollHack = -1, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.registeredEvents = [], this.customHandlers = [], this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.mouseSelection = null;
    let i = (n, O) => {
      this.ignoreDuringComposition(O) || O.type == "keydown" && this.keydown(e, O) || (this.mustFlushObserver(O) && e.observer.forceFlush(), this.runCustomHandlers(O.type, e, O) ? O.preventDefault() : n(e, O));
    };
    for (let n in dt) {
      let O = dt[n];
      e.contentDOM.addEventListener(n, (r) => {
        fg(e, r) && i(O, r);
      }, Gh[n]), this.registeredEvents.push(n);
    }
    e.scrollDOM.addEventListener("mousedown", (n) => {
      n.target == e.scrollDOM && n.clientY > e.contentDOM.getBoundingClientRect().bottom && i(dt.mousedown, n);
    }), J.chrome && J.chrome_version == 102 && e.scrollDOM.addEventListener("wheel", () => {
      this.chromeScrollHack < 0 ? e.contentDOM.style.pointerEvents = "none" : window.clearTimeout(this.chromeScrollHack), this.chromeScrollHack = setTimeout(() => {
        this.chromeScrollHack = -1, e.contentDOM.style.pointerEvents = "";
      }, 100);
    }, { passive: true }), this.notifiedFocused = e.hasFocus, J.safari && e.contentDOM.addEventListener("input", () => null);
  }
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  ensureHandlers(e, i) {
    var n;
    let O;
    this.customHandlers = [];
    for (let r of i)
      if (O = (n = r.update(e).spec) === null || n === void 0 ? void 0 : n.domEventHandlers) {
        this.customHandlers.push({ plugin: r.value, handlers: O });
        for (let a in O)
          this.registeredEvents.indexOf(a) < 0 && a != "scroll" && (this.registeredEvents.push(a), e.contentDOM.addEventListener(a, (o) => {
            fg(e, o) && this.runCustomHandlers(a, e, o) && o.preventDefault();
          }));
      }
  }
  runCustomHandlers(e, i, n) {
    for (let O of this.customHandlers) {
      let r = O.handlers[e];
      if (r)
        try {
          if (r.call(O.plugin, n, i) || n.defaultPrevented)
            return true;
        } catch (a) {
          Pi(i.state, a);
        }
    }
    return false;
  }
  runScrollHandlers(e, i) {
    this.lastScrollTop = e.scrollDOM.scrollTop, this.lastScrollLeft = e.scrollDOM.scrollLeft;
    for (let n of this.customHandlers) {
      let O = n.handlers.scroll;
      if (O)
        try {
          O.call(n.plugin, i, e);
        } catch (r) {
          Pi(e.state, r);
        }
    }
  }
  keydown(e, i) {
    if (this.lastKeyCode = i.keyCode, this.lastKeyTime = Date.now(), i.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return true;
    if (J.android && J.chrome && !i.synthetic && (i.keyCode == 13 || i.keyCode == 8))
      return e.observer.delayAndroidKey(i.key, i.keyCode), true;
    let n;
    return J.ios && !i.synthetic && !i.altKey && !i.metaKey && ((n = Gv.find((O) => O.keyCode == i.keyCode)) && !i.ctrlKey || gW.indexOf(i.key) > -1 && i.ctrlKey && !i.shiftKey) ? (this.pendingIOSKey = n || i, setTimeout(() => this.flushIOSKey(e), 250), true) : false;
  }
  flushIOSKey(e) {
    let i = this.pendingIOSKey;
    return i ? (this.pendingIOSKey = void 0, Dr(e.contentDOM, i.key, i.keyCode)) : false;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? true : J.safari && !J.ios && Date.now() - this.compositionEndedAt < 100 ? (this.compositionEndedAt = 0, true) : false : false;
  }
  mustFlushObserver(e) {
    return e.type == "keydown" && e.keyCode != 229;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
};
var Gv = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
];
var gW = "dthko";
var Lv = [16, 17, 18, 20, 91, 92, 224, 225];
function js(t) {
  return t * 0.7 + 8;
}
var mW = class {
  constructor(e, i, n, O) {
    this.view = e, this.style = n, this.mustSelect = O, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = i, this.scrollParent = E_(e.contentDOM);
    let r = e.contentDOM.ownerDocument;
    r.addEventListener("mousemove", this.move = this.move.bind(this)), r.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = i.shiftKey, this.multiple = e.state.facet(ye.allowMultipleSelections) && SW(e, i), this.dragMove = PW(e, i), this.dragging = yW(e, i) && Bv(i) == 1 ? null : false;
  }
  start(e) {
    this.dragging === false && (e.preventDefault(), this.select(e));
  }
  move(e) {
    var i;
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging !== false)
      return;
    this.select(this.lastEvent = e);
    let n = 0, O = 0, r = ((i = this.scrollParent) === null || i === void 0 ? void 0 : i.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight };
    e.clientX <= r.left ? n = -js(r.left - e.clientX) : e.clientX >= r.right && (n = js(e.clientX - r.right)), e.clientY <= r.top ? O = -js(r.top - e.clientY) : e.clientY >= r.bottom && (O = js(e.clientY - r.bottom)), this.setScrollSpeed(n, O);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = null;
  }
  setScrollSpeed(e, i) {
    this.scrollSpeed = { x: e, y: i }, e || i ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === false && this.select(this.lastEvent);
  }
  select(e) {
    let i = this.style.get(e, this.extend, this.multiple);
    (this.mustSelect || !i.eq(this.view.state.selection) || i.main.assoc != this.view.state.selection.main.assoc) && this.view.dispatch({
      selection: i,
      userEvent: "select.pointer"
    }), this.mustSelect = false;
  }
  update(e) {
    e.docChanged && this.dragging && (this.dragging = this.dragging.map(e.changes)), this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
};
function SW(t, e) {
  let i = t.state.facet(xv);
  return i.length ? i[0](e) : J.mac ? e.metaKey : e.ctrlKey;
}
function PW(t, e) {
  let i = t.state.facet(wv);
  return i.length ? i[0](e) : J.mac ? !e.altKey : !e.ctrlKey;
}
function yW(t, e) {
  let { main: i } = t.state.selection;
  if (i.empty)
    return false;
  let n = Ll(t.root);
  if (!n || n.rangeCount == 0)
    return true;
  let O = n.getRangeAt(0).getClientRects();
  for (let r = 0; r < O.length; r++) {
    let a = O[r];
    if (a.left <= e.clientX && a.right >= e.clientX && a.top <= e.clientY && a.bottom >= e.clientY)
      return true;
  }
  return false;
}
function fg(t, e) {
  if (!e.bubbles)
    return true;
  if (e.defaultPrevented)
    return false;
  for (let i = e.target, n; i != t.contentDOM; i = i.parentNode)
    if (!i || i.nodeType == 11 || (n = Ee.get(i)) && n.ignoreEvent(e))
      return false;
  return true;
}
var dt = /* @__PURE__ */ Object.create(null);
var Gh = /* @__PURE__ */ Object.create(null);
var Dv = J.ie && J.ie_version < 15 || J.ios && J.webkit_version < 604;
function bW(t) {
  let e = t.dom.parentNode;
  if (!e)
    return;
  let i = e.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.focus(), setTimeout(() => {
    t.focus(), i.remove(), Mv(t, i.value);
  }, 50);
}
function Mv(t, e) {
  let { state: i } = t, n, O = 1, r = i.toText(e), a = r.lines == i.selection.ranges.length;
  if (Lh != null && i.selection.ranges.every((s) => s.empty) && Lh == r.toString()) {
    let s = -1;
    n = i.changeByRange((l) => {
      let c = i.doc.lineAt(l.from);
      if (c.from == s)
        return { range: l };
      s = c.from;
      let u = i.toText((a ? r.line(O++).text : e) + i.lineBreak);
      return {
        changes: { from: c.from, insert: u },
        range: R.cursor(l.from + u.length)
      };
    });
  } else
    a ? n = i.changeByRange((s) => {
      let l = r.line(O++);
      return {
        changes: { from: s.from, to: s.to, insert: l.text },
        range: R.cursor(s.from + l.length)
      };
    }) : n = i.replaceSelection(r);
  t.dispatch(n, {
    userEvent: "input.paste",
    scrollIntoView: true
  });
}
dt.keydown = (t, e) => {
  t.inputState.setSelectionOrigin("select"), e.keyCode == 27 ? t.inputState.lastEscPress = Date.now() : Lv.indexOf(e.keyCode) < 0 && (t.inputState.lastEscPress = 0);
};
dt.touchstart = (t, e) => {
  t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer");
};
dt.touchmove = (t) => {
  t.inputState.setSelectionOrigin("select.pointer");
};
Gh.touchstart = Gh.touchmove = { passive: true };
dt.mousedown = (t, e) => {
  if (t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)
    return;
  let i = null;
  for (let n of t.state.facet(Tv))
    if (i = n(t, e), i)
      break;
  if (!i && e.button == 0 && (i = xW(t, e)), i) {
    let n = t.root.activeElement != t.contentDOM;
    t.inputState.startMouseSelection(new mW(t, e, i, n)), n && t.observer.ignore(() => hv(t.contentDOM)), t.inputState.mouseSelection && t.inputState.mouseSelection.start(e);
  }
};
function hg(t, e, i, n) {
  if (n == 1)
    return R.cursor(e, i);
  if (n == 2)
    return lW(t.state, e, i);
  {
    let O = Nt.find(t.docView, e), r = t.state.doc.lineAt(O ? O.posAtEnd : e), a = O ? O.posAtStart : r.from, o = O ? O.posAtEnd : r.to;
    return o < t.state.doc.length && o == r.to && o++, R.range(a, o);
  }
}
var Nv = (t, e) => t >= e.top && t <= e.bottom;
var dg = (t, e, i) => Nv(e, i) && t >= i.left && t <= i.right;
function vW(t, e, i, n) {
  let O = Nt.find(t.docView, e);
  if (!O)
    return 1;
  let r = e - O.posAtStart;
  if (r == 0)
    return 1;
  if (r == O.length)
    return -1;
  let a = O.coordsAt(r, -1);
  if (a && dg(i, n, a))
    return -1;
  let o = O.coordsAt(r, 1);
  return o && dg(i, n, o) ? 1 : a && Nv(n, a) ? -1 : 1;
}
function pg(t, e) {
  let i = t.posAtCoords({ x: e.clientX, y: e.clientY }, false);
  return { pos: i, bias: vW(t, i, e.clientX, e.clientY) };
}
var XW = J.ie && J.ie_version <= 11;
var $g = null;
var Qg = 0;
var gg = 0;
function Bv(t) {
  if (!XW)
    return t.detail;
  let e = $g, i = gg;
  return $g = t, gg = Date.now(), Qg = !e || i > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (Qg + 1) % 3 : 1;
}
function xW(t, e) {
  let i = pg(t, e), n = Bv(e), O = t.state.selection;
  return {
    update(r) {
      r.docChanged && (i.pos = r.changes.mapPos(i.pos), O = O.map(r.changes));
    },
    get(r, a, o) {
      let s = pg(t, r), l = hg(t, s.pos, s.bias, n);
      if (i.pos != s.pos && !a) {
        let c = hg(t, i.pos, i.bias, n), u = Math.min(c.from, l.from), h10 = Math.max(c.to, l.to);
        l = u < l.from ? R.range(u, h10) : R.range(h10, u);
      }
      return a ? O.replaceRange(O.main.extend(l.from, l.to)) : o && O.ranges.length > 1 && O.ranges.some((c) => c.eq(l)) ? wW(O, l) : o ? O.addRange(l) : R.create([l]);
    }
  };
}
function wW(t, e) {
  for (let i = 0; ; i++)
    if (t.ranges[i].eq(e))
      return R.create(t.ranges.slice(0, i).concat(t.ranges.slice(i + 1)), t.mainIndex == i ? 0 : t.mainIndex - (t.mainIndex > i ? 1 : 0));
}
dt.dragstart = (t, e) => {
  let { selection: { main: i } } = t.state, { mouseSelection: n } = t.inputState;
  n && (n.dragging = i), e.dataTransfer && (e.dataTransfer.setData("Text", t.state.sliceDoc(i.from, i.to)), e.dataTransfer.effectAllowed = "copyMove");
};
function mg(t, e, i, n) {
  if (!i)
    return;
  let O = t.posAtCoords({ x: e.clientX, y: e.clientY }, false);
  e.preventDefault();
  let { mouseSelection: r } = t.inputState, a = n && r && r.dragging && r.dragMove ? { from: r.dragging.from, to: r.dragging.to } : null, o = { from: O, insert: i }, s = t.state.changes(a ? [a, o] : o);
  t.focus(), t.dispatch({
    changes: s,
    selection: { anchor: s.mapPos(O, -1), head: s.mapPos(O, 1) },
    userEvent: a ? "move.drop" : "input.drop"
  });
}
dt.drop = (t, e) => {
  if (!e.dataTransfer)
    return;
  if (t.state.readOnly)
    return e.preventDefault();
  let i = e.dataTransfer.files;
  if (i && i.length) {
    e.preventDefault();
    let n = Array(i.length), O = 0, r = () => {
      ++O == i.length && mg(t, e, n.filter((a) => a != null).join(t.state.lineBreak), false);
    };
    for (let a = 0; a < i.length; a++) {
      let o = new FileReader();
      o.onerror = r, o.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(o.result) || (n[a] = o.result), r();
      }, o.readAsText(i[a]);
    }
  } else
    mg(t, e, e.dataTransfer.getData("Text"), true);
};
dt.paste = (t, e) => {
  if (t.state.readOnly)
    return e.preventDefault();
  t.observer.flush();
  let i = Dv ? null : e.clipboardData;
  i ? (Mv(t, i.getData("text/plain")), e.preventDefault()) : bW(t);
};
function TW(t, e) {
  let i = t.dom.parentNode;
  if (!i)
    return;
  let n = i.appendChild(document.createElement("textarea"));
  n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.value = e, n.focus(), n.selectionEnd = e.length, n.selectionStart = 0, setTimeout(() => {
    n.remove(), t.focus();
  }, 50);
}
function kW(t) {
  let e = [], i = [], n = false;
  for (let O of t.selection.ranges)
    O.empty || (e.push(t.sliceDoc(O.from, O.to)), i.push(O));
  if (!e.length) {
    let O = -1;
    for (let { from: r } of t.selection.ranges) {
      let a = t.doc.lineAt(r);
      a.number > O && (e.push(a.text), i.push({ from: a.from, to: Math.min(t.doc.length, a.to + 1) })), O = a.number;
    }
    n = true;
  }
  return { text: e.join(t.lineBreak), ranges: i, linewise: n };
}
var Lh = null;
dt.copy = dt.cut = (t, e) => {
  let { text: i, ranges: n, linewise: O } = kW(t.state);
  if (!i && !O)
    return;
  Lh = O ? i : null;
  let r = Dv ? null : e.clipboardData;
  r ? (e.preventDefault(), r.clearData(), r.setData("text/plain", i)) : TW(t, i), e.type == "cut" && !t.state.readOnly && t.dispatch({
    changes: n,
    scrollIntoView: true,
    userEvent: "delete.cut"
  });
};
var Fv = Dn.define();
function Hv(t, e) {
  let i = [];
  for (let n of t.facet(Wv)) {
    let O = n(t, e);
    O && i.push(O);
  }
  return i ? t.update({ effects: i, annotations: Fv.of(true) }) : null;
}
function Kv(t) {
  setTimeout(() => {
    let e = t.hasFocus;
    if (e != t.inputState.notifiedFocused) {
      let i = Hv(t.state, e);
      i ? t.dispatch(i) : t.update([]);
    }
  }, 10);
}
dt.focus = (t) => {
  t.inputState.lastFocusTime = Date.now(), !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), Kv(t);
};
dt.blur = (t) => {
  t.observer.clearSelectionRange(), Kv(t);
};
dt.compositionstart = dt.compositionupdate = (t) => {
  t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = true), t.inputState.composing < 0 && (t.inputState.composing = 0);
};
dt.compositionend = (t) => {
  t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionFirstChange = null, J.chrome && J.android && t.observer.flushSoon(), setTimeout(() => {
    t.inputState.composing < 0 && t.docView.compositionDeco.size && t.update([]);
  }, 50);
};
dt.contextmenu = (t) => {
  t.inputState.lastContextMenu = Date.now();
};
dt.beforeinput = (t, e) => {
  var i;
  let n;
  if (J.chrome && J.android && (n = Gv.find((O) => O.inputType == e.inputType)) && (t.observer.delayAndroidKey(n.key, n.keyCode), n.key == "Backspace" || n.key == "Delete")) {
    let O = ((i = window.visualViewport) === null || i === void 0 ? void 0 : i.height) || 0;
    setTimeout(() => {
      var r;
      (((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0) > O + 10 && t.hasFocus && (t.contentDOM.blur(), t.focus());
    }, 100);
  }
};
var Sg = ["pre-wrap", "normal", "pre-line", "break-spaces"];
var _W = class {
  constructor(e) {
    this.lineWrapping = e, this.doc = Te.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.lineLength = 30, this.heightChanged = false;
  }
  heightForGap(e, i) {
    let n = this.doc.lineAt(i).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (n += Math.max(0, Math.ceil((i - e - n * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * n;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return Sg.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let i = false;
    for (let n = 0; n < e.length; n++) {
      let O = e[n];
      O < 0 ? n++ : this.heightSamples[Math.floor(O * 10)] || (i = true, this.heightSamples[Math.floor(O * 10)] = true);
    }
    return i;
  }
  refresh(e, i, n, O, r) {
    let a = Sg.indexOf(e) > -1, o = Math.round(i) != Math.round(this.lineHeight) || this.lineWrapping != a;
    if (this.lineWrapping = a, this.lineHeight = i, this.charWidth = n, this.lineLength = O, o) {
      this.heightSamples = {};
      for (let s = 0; s < r.length; s++) {
        let l = r[s];
        l < 0 ? s++ : this.heightSamples[Math.floor(l * 10)] = true;
      }
    }
    return o;
  }
};
var WW = class {
  constructor(e, i) {
    this.from = e, this.heights = i, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
};
var Vn = class {
  /**
  @internal
  */
  constructor(e, i, n, O, r) {
    this.from = e, this.length = i, this.top = n, this.height = O, this.type = r;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  @internal
  */
  join(e) {
    let i = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(e.type) ? e.type : [e]);
    return new Vn(this.from, this.length + e.length, this.top, this.height + e.height, i);
  }
};
var qe = function(t) {
  return t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t;
}(qe || (qe = {}));
var Tl = 1e-3;
var Ft = class {
  constructor(e, i, n = 2) {
    this.length = e, this.height = i, this.flags = n;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e, i) {
    this.height != i && (Math.abs(this.height - i) > Tl && (e.heightChanged = true), this.height = i);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, i, n) {
    return Ft.of(n);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, i) {
    i.push(this);
  }
  decomposeRight(e, i) {
    i.push(this);
  }
  applyChanges(e, i, n, O) {
    let r = this, a = n.doc;
    for (let o = O.length - 1; o >= 0; o--) {
      let { fromA: s, toA: l, fromB: c, toB: u } = O[o], h10 = r.lineAt(s, qe.ByPosNoHeight, n.setDoc(i), 0, 0), d = h10.to >= l ? h10 : r.lineAt(l, qe.ByPosNoHeight, n, 0, 0);
      for (u += d.to - l, l = d.to; o > 0 && h10.from <= O[o - 1].toA; )
        s = O[o - 1].fromA, c = O[o - 1].fromB, o--, s < h10.from && (h10 = r.lineAt(s, qe.ByPosNoHeight, n, 0, 0));
      c += h10.from - s, s = h10.from;
      let p = _p.build(n.setDoc(a), e, c, u);
      r = r.replace(s, l, p);
    }
    return r.updateHeight(n, 0);
  }
  static empty() {
    return new pi(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let i = 0, n = e.length, O = 0, r = 0;
    for (; ; )
      if (i == n)
        if (O > r * 2) {
          let o = e[i - 1];
          o.break ? e.splice(--i, 1, o.left, null, o.right) : e.splice(--i, 1, o.left, o.right), n += 1 + o.break, O -= o.size;
        } else if (r > O * 2) {
          let o = e[n];
          o.break ? e.splice(n, 1, o.left, null, o.right) : e.splice(n, 1, o.left, o.right), n += 2 + o.break, r -= o.size;
        } else
          break;
      else if (O < r) {
        let o = e[i++];
        o && (O += o.size);
      } else {
        let o = e[--n];
        o && (r += o.size);
      }
    let a = 0;
    return e[i - 1] == null ? (a = 1, i--) : e[i] == null && (a = 1, n++), new YW(Ft.of(e.slice(0, i)), a, Ft.of(e.slice(n)));
  }
};
Ft.prototype.size = 1;
var Jv = class extends Ft {
  constructor(e, i, n) {
    super(e, i), this.type = n;
  }
  blockAt(e, i, n, O) {
    return new Vn(O, this.length, n, this.height, this.type);
  }
  lineAt(e, i, n, O, r) {
    return this.blockAt(0, n, O, r);
  }
  forEachLine(e, i, n, O, r, a) {
    e <= r + this.length && i >= r && a(this.blockAt(0, n, O, r));
  }
  updateHeight(e, i = 0, n = false, O) {
    return O && O.from <= i && O.more && this.setHeight(e, O.heights[O.index++]), this.outdated = false, this;
  }
  toString() {
    return `block(${this.length})`;
  }
};
var pi = class extends Jv {
  constructor(e, i) {
    super(e, i, Re.Text), this.collapsed = 0, this.widgetHeight = 0;
  }
  replace(e, i, n) {
    let O = n[0];
    return n.length == 1 && (O instanceof pi || O instanceof bt && O.flags & 4) && Math.abs(this.length - O.length) < 10 ? (O instanceof bt ? O = new pi(O.length, this.height) : O.height = this.height, this.outdated || (O.outdated = false), O) : Ft.of(n);
  }
  updateHeight(e, i = 0, n = false, O) {
    return O && O.from <= i && O.more ? this.setHeight(e, O.heights[O.index++]) : (n || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed))), this.outdated = false, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
};
var bt = class extends Ft {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, i) {
    let n = e.doc.lineAt(i).number, O = e.doc.lineAt(i + this.length).number, r = O - n + 1, a, o = 0;
    if (e.lineWrapping) {
      let s = Math.min(this.height, e.lineHeight * r);
      a = s / r, o = (this.height - s) / (this.length - r - 1);
    } else
      a = this.height / r;
    return { firstLine: n, lastLine: O, perLine: a, perChar: o };
  }
  blockAt(e, i, n, O) {
    let { firstLine: r, lastLine: a, perLine: o, perChar: s } = this.heightMetrics(i, O);
    if (i.lineWrapping) {
      let l = O + Math.round(Math.max(0, Math.min(1, (e - n) / this.height)) * this.length), c = i.doc.lineAt(l), u = o + c.length * s, h10 = Math.max(n, e - u / 2);
      return new Vn(c.from, c.length, h10, u, Re.Text);
    } else {
      let l = Math.max(0, Math.min(a - r, Math.floor((e - n) / o))), { from: c, length: u } = i.doc.line(r + l);
      return new Vn(c, u, n + o * l, o, Re.Text);
    }
  }
  lineAt(e, i, n, O, r) {
    if (i == qe.ByHeight)
      return this.blockAt(e, n, O, r);
    if (i == qe.ByPosNoHeight) {
      let { from: d, to: p } = n.doc.lineAt(e);
      return new Vn(d, p - d, 0, 0, Re.Text);
    }
    let { firstLine: a, perLine: o, perChar: s } = this.heightMetrics(n, r), l = n.doc.lineAt(e), c = o + l.length * s, u = l.number - a, h10 = O + o * u + s * (l.from - r - u);
    return new Vn(l.from, l.length, Math.max(O, Math.min(h10, O + this.height - c)), c, Re.Text);
  }
  forEachLine(e, i, n, O, r, a) {
    e = Math.max(e, r), i = Math.min(i, r + this.length);
    let { firstLine: o, perLine: s, perChar: l } = this.heightMetrics(n, r);
    for (let c = e, u = O; c <= i; ) {
      let h10 = n.doc.lineAt(c);
      if (c == e) {
        let p = h10.number - o;
        u += s * p + l * (e - r - p);
      }
      let d = s + l * h10.length;
      a(new Vn(h10.from, h10.length, u, d, Re.Text)), u += d, c = h10.to + 1;
    }
  }
  replace(e, i, n) {
    let O = this.length - i;
    if (O > 0) {
      let r = n[n.length - 1];
      r instanceof bt ? n[n.length - 1] = new bt(r.length + O) : n.push(null, new bt(O - 1));
    }
    if (e > 0) {
      let r = n[0];
      r instanceof bt ? n[0] = new bt(e + r.length) : n.unshift(new bt(e - 1), null);
    }
    return Ft.of(n);
  }
  decomposeLeft(e, i) {
    i.push(new bt(e - 1), null);
  }
  decomposeRight(e, i) {
    i.push(null, new bt(this.length - e - 1));
  }
  updateHeight(e, i = 0, n = false, O) {
    let r = i + this.length;
    if (O && O.from <= i + this.length && O.more) {
      let a = [], o = Math.max(i, O.from), s = -1;
      for (O.from > i && a.push(new bt(O.from - i - 1).updateHeight(e, i)); o <= r && O.more; ) {
        let c = e.doc.lineAt(o).length;
        a.length && a.push(null);
        let u = O.heights[O.index++];
        s == -1 ? s = u : Math.abs(u - s) >= Tl && (s = -2);
        let h10 = new pi(c, u);
        h10.outdated = false, a.push(h10), o += c + 1;
      }
      o <= r && a.push(null, new bt(r - o).updateHeight(e, o));
      let l = Ft.of(a);
      return (s < 0 || Math.abs(l.height - this.height) >= Tl || Math.abs(s - this.heightMetrics(e, i).perLine) >= Tl) && (e.heightChanged = true), l;
    } else
      (n || this.outdated) && (this.setHeight(e, e.heightForGap(i, i + this.length)), this.outdated = false);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
};
var YW = class extends Ft {
  constructor(e, i, n) {
    super(e.length + i + n.length, e.height + n.height, i | (e.outdated || n.outdated ? 2 : 0)), this.left = e, this.right = n, this.size = e.size + n.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, i, n, O) {
    let r = n + this.left.height;
    return e < r ? this.left.blockAt(e, i, n, O) : this.right.blockAt(e, i, r, O + this.left.length + this.break);
  }
  lineAt(e, i, n, O, r) {
    let a = O + this.left.height, o = r + this.left.length + this.break, s = i == qe.ByHeight ? e < a : e < o, l = s ? this.left.lineAt(e, i, n, O, r) : this.right.lineAt(e, i, n, a, o);
    if (this.break || (s ? l.to < o : l.from > o))
      return l;
    let c = i == qe.ByPosNoHeight ? qe.ByPosNoHeight : qe.ByPos;
    return s ? l.join(this.right.lineAt(o, c, n, a, o)) : this.left.lineAt(o, c, n, O, r).join(l);
  }
  forEachLine(e, i, n, O, r, a) {
    let o = O + this.left.height, s = r + this.left.length + this.break;
    if (this.break)
      e < s && this.left.forEachLine(e, i, n, O, r, a), i >= s && this.right.forEachLine(e, i, n, o, s, a);
    else {
      let l = this.lineAt(s, qe.ByPos, n, O, r);
      e < l.from && this.left.forEachLine(e, l.from - 1, n, O, r, a), l.to >= e && l.from <= i && a(l), i > l.to && this.right.forEachLine(l.to + 1, i, n, o, s, a);
    }
  }
  replace(e, i, n) {
    let O = this.left.length + this.break;
    if (i < O)
      return this.balanced(this.left.replace(e, i, n), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - O, i - O, n));
    let r = [];
    e > 0 && this.decomposeLeft(e, r);
    let a = r.length;
    for (let o of n)
      r.push(o);
    if (e > 0 && Pg(r, a - 1), i < this.length) {
      let o = r.length;
      this.decomposeRight(i, r), Pg(r, o);
    }
    return Ft.of(r);
  }
  decomposeLeft(e, i) {
    let n = this.left.length;
    if (e <= n)
      return this.left.decomposeLeft(e, i);
    i.push(this.left), this.break && (n++, e >= n && i.push(null)), e > n && this.right.decomposeLeft(e - n, i);
  }
  decomposeRight(e, i) {
    let n = this.left.length, O = n + this.break;
    if (e >= O)
      return this.right.decomposeRight(e - O, i);
    e < n && this.left.decomposeRight(e, i), this.break && e < O && i.push(null), i.push(this.right);
  }
  balanced(e, i) {
    return e.size > 2 * i.size || i.size > 2 * e.size ? Ft.of(this.break ? [e, null, i] : [e, i]) : (this.left = e, this.right = i, this.height = e.height + i.height, this.outdated = e.outdated || i.outdated, this.size = e.size + i.size, this.length = e.length + this.break + i.length, this);
  }
  updateHeight(e, i = 0, n = false, O) {
    let { left: r, right: a } = this, o = i + r.length + this.break, s = null;
    return O && O.from <= i + r.length && O.more ? s = r = r.updateHeight(e, i, n, O) : r.updateHeight(e, i, n), O && O.from <= o + a.length && O.more ? s = a = a.updateHeight(e, o, n, O) : a.updateHeight(e, o, n), s ? this.balanced(r, a) : (this.height = this.left.height + this.right.height, this.outdated = false, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
};
function Pg(t, e) {
  let i, n;
  t[e] == null && (i = t[e - 1]) instanceof bt && (n = t[e + 1]) instanceof bt && t.splice(e - 1, 3, new bt(i.length + 1 + n.length));
}
var RW = 5;
var _p = class {
  constructor(e, i) {
    this.pos = e, this.oracle = i, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, i) {
    if (this.lineStart > -1) {
      let n = Math.min(i, this.lineEnd), O = this.nodes[this.nodes.length - 1];
      O instanceof pi ? O.length += n - this.pos : (n > this.pos || !this.isCovered) && this.nodes.push(new pi(n - this.pos, -1)), this.writtenTo = n, i > n && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = i;
  }
  point(e, i, n) {
    if (e < i || n.heightRelevant) {
      let O = n.widget ? n.widget.estimatedHeight : 0;
      O < 0 && (O = this.oracle.lineHeight);
      let r = i - e;
      n.block ? this.addBlock(new Jv(r, O, n.type)) : (r || O >= RW) && this.addLineDeco(O, r);
    } else
      i > e && this.span(e, i);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: i } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = i, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new pi(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, i) {
    let n = new bt(i - e);
    return this.oracle.doc.lineAt(e).to == i && (n.flags |= 4), n;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof pi)
      return e;
    let i = new pi(0, -1);
    return this.nodes.push(i), i;
  }
  addBlock(e) {
    this.enterLine(), e.type == Re.WidgetAfter && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, e.type != Re.WidgetBefore && (this.covering = e);
  }
  addLineDeco(e, i) {
    let n = this.ensureLine();
    n.length += i, n.collapsed += i, n.widgetHeight = Math.max(n.widgetHeight, e), this.writtenTo = this.pos = this.pos + i;
  }
  finish(e) {
    let i = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(i instanceof pi) && !this.isCovered ? this.nodes.push(new pi(0, -1)) : (this.writtenTo < this.pos || i == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let n = e;
    for (let O of this.nodes)
      O instanceof pi && O.updateHeight(this.oracle, n), n += O ? O.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, i, n, O) {
    let r = new _p(n, e);
    return We.spans(i, n, O, r, 0), r.finish(n);
  }
};
function ZW(t, e, i) {
  let n = new UW();
  return We.compare(t, e, i, n, 0), n.changes;
}
var UW = class {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, i, n, O) {
    (e < i || n && n.heightRelevant || O && O.heightRelevant) && Ch(e, i, this.changes, 5);
  }
};
function VW(t, e) {
  let i = t.getBoundingClientRect(), n = t.ownerDocument, O = n.defaultView || window, r = Math.max(0, i.left), a = Math.min(O.innerWidth, i.right), o = Math.max(0, i.top), s = Math.min(O.innerHeight, i.bottom);
  for (let l = t.parentNode; l && l != n.body; )
    if (l.nodeType == 1) {
      let c = l, u = window.getComputedStyle(c);
      if ((c.scrollHeight > c.clientHeight || c.scrollWidth > c.clientWidth) && u.overflow != "visible") {
        let h10 = c.getBoundingClientRect();
        r = Math.max(r, h10.left), a = Math.min(a, h10.right), o = Math.max(o, h10.top), s = l == t.parentNode ? h10.bottom : Math.min(s, h10.bottom);
      }
      l = u.position == "absolute" || u.position == "fixed" ? c.offsetParent : c.parentNode;
    } else if (l.nodeType == 11)
      l = l.host;
    else
      break;
  return {
    left: r - i.left,
    right: Math.max(r, a) - i.left,
    top: o - (i.top + e),
    bottom: Math.max(o, s) - (i.top + e)
  };
}
function qW(t, e) {
  let i = t.getBoundingClientRect();
  return {
    left: 0,
    right: i.right - i.left,
    top: e,
    bottom: i.bottom - (i.top + e)
  };
}
var Fu = class {
  constructor(e, i, n) {
    this.from = e, this.to = i, this.size = n;
  }
  static same(e, i) {
    if (e.length != i.length)
      return false;
    for (let n = 0; n < e.length; n++) {
      let O = e[n], r = i[n];
      if (O.from != r.from || O.to != r.to || O.size != r.size)
        return false;
    }
    return true;
  }
  draw(e) {
    return ne.replace({ widget: new zW(this.size, e) }).range(this.from, this.to);
  }
};
var zW = class extends xn {
  constructor(e, i) {
    super(), this.size = e, this.vertical = i;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
};
var yg = class {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = true, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scaler = bg, this.scrollTarget = null, this.printing = false, this.mustMeasureContent = true, this.defaultTextDirection = Ne.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = false;
    let i = e.facet(kp).some((n) => typeof n != "function" && n.class == "cm-lineWrapping");
    this.heightOracle = new _W(i), this.stateDeco = e.facet(No).filter((n) => typeof n != "function"), this.heightMap = Ft.empty().applyChanges(this.stateDeco, Te.empty, this.heightOracle.setDoc(e.doc), [new Sn(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = ne.set(this.lineGaps.map((n) => n.draw(false))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: i } = this.state.selection;
    for (let n = 0; n <= 1; n++) {
      let O = n ? i.head : i.anchor;
      if (!e.some(({ from: r, to: a }) => O >= r && O <= a)) {
        let { from: r, to: a } = this.lineBlockAt(O);
        e.push(new Is(r, a));
      }
    }
    this.viewports = e.sort((n, O) => n.from - O.from), this.scaler = this.heightMap.height <= 7e6 ? bg : new jW(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e : po(e, this.scaler));
    });
  }
  update(e, i = null) {
    this.state = e.state;
    let n = this.stateDeco;
    this.stateDeco = this.state.facet(No).filter((l) => typeof l != "function");
    let O = e.changedRanges, r = Sn.extendWithRanges(O, ZW(n, this.stateDeco, e ? e.changes : ct.empty(this.state.doc.length))), a = this.heightMap.height;
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), r), this.heightMap.height != a && (e.flags |= 2);
    let o = r.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (i && (i.range.head < o.from || i.range.head > o.to) || !this.viewportIsAppropriate(o)) && (o = this.getViewport(0, i));
    let s = !e.changes.empty || e.flags & 2 || o.from != this.viewport.from || o.to != this.viewport.to;
    this.viewport = o, this.updateForViewport(), s && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), i && (this.scrollTarget = i), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(Rv) && (this.mustEnforceCursorAssoc = true);
  }
  measure(e) {
    let i = e.contentDOM, n = window.getComputedStyle(i), O = this.heightOracle, r = n.whiteSpace;
    this.defaultTextDirection = n.direction == "rtl" ? Ne.RTL : Ne.LTR;
    let a = this.heightOracle.mustRefreshForWrapping(r), o = i.getBoundingClientRect(), s = a || this.mustMeasureContent || this.contentDOMHeight != o.height;
    this.contentDOMHeight = o.height, this.mustMeasureContent = false;
    let l = 0, c = 0, u = parseInt(n.paddingTop) || 0, h10 = parseInt(n.paddingBottom) || 0;
    (this.paddingTop != u || this.paddingBottom != h10) && (this.paddingTop = u, this.paddingBottom = h10, l |= 10), this.editorWidth != e.scrollDOM.clientWidth && (O.lineWrapping && (s = true), this.editorWidth = e.scrollDOM.clientWidth, l |= 8);
    let d = (this.printing ? qW : VW)(i, this.paddingTop), p = d.top - this.pixelViewport.top, $ = d.bottom - this.pixelViewport.bottom;
    this.pixelViewport = d;
    let g = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (g != this.inView && (this.inView = g, g && (s = true)), !this.inView && !this.scrollTarget)
      return 0;
    let Q = o.width;
    if ((this.contentDOMWidth != Q || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = o.width, this.editorHeight = e.scrollDOM.clientHeight, l |= 8), s) {
      let b = e.docView.measureVisibleLineHeights(this.viewport);
      if (O.mustRefreshForHeights(b) && (a = true), a || O.lineWrapping && Math.abs(Q - this.contentDOMWidth) > O.charWidth) {
        let { lineHeight: P, charWidth: S } = e.docView.measureTextSize();
        a = P > 0 && O.refresh(r, P, S, Q / S, b), a && (e.docView.minWidth = 0, l |= 8);
      }
      p > 0 && $ > 0 ? c = Math.max(p, $) : p < 0 && $ < 0 && (c = Math.min(p, $)), O.heightChanged = false;
      for (let P of this.viewports) {
        let S = P.from == this.viewport.from ? b : e.docView.measureVisibleLineHeights(P);
        this.heightMap = (a ? Ft.empty().applyChanges(this.stateDeco, Te.empty, this.heightOracle, [new Sn(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(O, 0, a, new WW(P.from, S));
      }
      O.heightChanged && (l |= 2);
    }
    let m = !this.viewportIsAppropriate(this.viewport, c) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return m && (this.viewport = this.getViewport(c, this.scrollTarget)), this.updateForViewport(), (l & 2 || m) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) && this.updateLineGaps(this.ensureLineGaps(a ? [] : this.lineGaps, e)), l |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = false, e.docView.enforceCursorAssoc()), l;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, i) {
    let n = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), O = this.heightMap, r = this.heightOracle, { visibleTop: a, visibleBottom: o } = this, s = new Is(O.lineAt(a - n * 1e3, qe.ByHeight, r, 0, 0).from, O.lineAt(o + (1 - n) * 1e3, qe.ByHeight, r, 0, 0).to);
    if (i) {
      let { head: l } = i.range;
      if (l < s.from || l > s.to) {
        let c = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), u = O.lineAt(l, qe.ByPos, r, 0, 0), h10;
        i.y == "center" ? h10 = (u.top + u.bottom) / 2 - c / 2 : i.y == "start" || i.y == "nearest" && l < s.from ? h10 = u.top : h10 = u.bottom - c, s = new Is(O.lineAt(h10 - 1e3 / 2, qe.ByHeight, r, 0, 0).from, O.lineAt(h10 + c + 1e3 / 2, qe.ByHeight, r, 0, 0).to);
      }
    }
    return s;
  }
  mapViewport(e, i) {
    let n = i.mapPos(e.from, -1), O = i.mapPos(e.to, 1);
    return new Is(this.heightMap.lineAt(n, qe.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(O, qe.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: i }, n = 0) {
    if (!this.inView)
      return true;
    let { top: O } = this.heightMap.lineAt(e, qe.ByPos, this.heightOracle, 0, 0), { bottom: r } = this.heightMap.lineAt(i, qe.ByPos, this.heightOracle, 0, 0), { visibleTop: a, visibleBottom: o } = this;
    return (e == 0 || O <= a - Math.max(10, Math.min(
      -n,
      250
      /* VP.MaxCoverMargin */
    ))) && (i == this.state.doc.length || r >= o + Math.max(10, Math.min(
      n,
      250
      /* VP.MaxCoverMargin */
    ))) && O > a - 2 * 1e3 && r < o + 2 * 1e3;
  }
  mapLineGaps(e, i) {
    if (!e.length || i.empty)
      return e;
    let n = [];
    for (let O of e)
      i.touchesRange(O.from, O.to) || n.push(new Fu(i.mapPos(O.from), i.mapPos(O.to), O.size));
    return n;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, i) {
    let n = this.heightOracle.lineWrapping, O = n ? 1e4 : 2e3, r = O >> 1, a = O << 1;
    if (this.defaultTextDirection != Ne.LTR && !n)
      return [];
    let o = [], s = (l, c, u, h10) => {
      if (c - l < r)
        return;
      let d = this.state.selection.main, p = [d.from];
      d.empty || p.push(d.to);
      for (let g of p)
        if (g > l && g < c) {
          s(l, g - 10, u, h10), s(g + 10, c, u, h10);
          return;
        }
      let $ = EW(e, (g) => g.from >= u.from && g.to <= u.to && Math.abs(g.from - l) < r && Math.abs(g.to - c) < r && !p.some((Q) => g.from < Q && g.to > Q));
      if (!$) {
        if (c < u.to && i && n && i.visibleRanges.some((g) => g.from <= c && g.to >= c)) {
          let g = i.moveToLineBoundary(R.cursor(c), false, true).head;
          g > l && (c = g);
        }
        $ = new Fu(l, c, this.gapSize(u, l, c, h10));
      }
      o.push($);
    };
    for (let l of this.viewportLines) {
      if (l.length < a)
        continue;
      let c = CW(l.from, l.to, this.stateDeco);
      if (c.total < a)
        continue;
      let u = this.scrollTarget ? this.scrollTarget.range.head : null, h10, d;
      if (n) {
        let p = O / this.heightOracle.lineLength * this.heightOracle.lineHeight, $, g;
        if (u != null) {
          let Q = Gs(c, u), m = ((this.visibleBottom - this.visibleTop) / 2 + p) / l.height;
          $ = Q - m, g = Q + m;
        } else
          $ = (this.visibleTop - l.top - p) / l.height, g = (this.visibleBottom - l.top + p) / l.height;
        h10 = As(c, $), d = As(c, g);
      } else {
        let p = c.total * this.heightOracle.charWidth, $ = O * this.heightOracle.charWidth, g, Q;
        if (u != null) {
          let m = Gs(c, u), b = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + $) / p;
          g = m - b, Q = m + b;
        } else
          g = (this.pixelViewport.left - $) / p, Q = (this.pixelViewport.right + $) / p;
        h10 = As(c, g), d = As(c, Q);
      }
      h10 > l.from && s(l.from, h10, l, c), d < l.to && s(d, l.to, l, c);
    }
    return o;
  }
  gapSize(e, i, n, O) {
    let r = Gs(O, n) - Gs(O, i);
    return this.heightOracle.lineWrapping ? e.height * r : O.total * this.heightOracle.charWidth * r;
  }
  updateLineGaps(e) {
    Fu.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = ne.set(e.map((i) => i.draw(this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let i = [];
    We.spans(e, this.viewport.from, this.viewport.to, {
      span(O, r) {
        i.push({ from: O, to: r });
      },
      point() {
      }
    }, 20);
    let n = i.length != this.visibleRanges.length || this.visibleRanges.some((O, r) => O.from != i[r].from || O.to != i[r].to);
    return this.visibleRanges = i, n ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((i) => i.from <= e && i.to >= e) || po(this.heightMap.lineAt(e, qe.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return po(this.heightMap.lineAt(this.scaler.fromDOM(e), qe.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  elementAtHeight(e) {
    return po(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
};
var Is = class {
  constructor(e, i) {
    this.from = e, this.to = i;
  }
};
function CW(t, e, i) {
  let n = [], O = t, r = 0;
  return We.spans(i, t, e, {
    span() {
    },
    point(a, o) {
      a > O && (n.push({ from: O, to: a }), r += a - O), O = o;
    }
  }, 20), O < e && (n.push({ from: O, to: e }), r += e - O), { total: r, ranges: n };
}
function As({ total: t, ranges: e }, i) {
  if (i <= 0)
    return e[0].from;
  if (i >= 1)
    return e[e.length - 1].to;
  let n = Math.floor(t * i);
  for (let O = 0; ; O++) {
    let { from: r, to: a } = e[O], o = a - r;
    if (n <= o)
      return r + n;
    n -= o;
  }
}
function Gs(t, e) {
  let i = 0;
  for (let { from: n, to: O } of t.ranges) {
    if (e <= O) {
      i += e - n;
      break;
    }
    i += O - n;
  }
  return i / t.total;
}
function EW(t, e) {
  for (let i of t)
    if (e(i))
      return i;
}
var bg = {
  toDOM(t) {
    return t;
  },
  fromDOM(t) {
    return t;
  },
  scale: 1
};
var jW = class {
  constructor(e, i, n) {
    let O = 0, r = 0, a = 0;
    this.viewports = n.map(({ from: o, to: s }) => {
      let l = i.lineAt(o, qe.ByPos, e, 0, 0).top, c = i.lineAt(s, qe.ByPos, e, 0, 0).bottom;
      return O += c - l, { from: o, to: s, top: l, bottom: c, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - O) / (i.height - O);
    for (let o of this.viewports)
      o.domTop = a + (o.top - r) * this.scale, a = o.domBottom = o.domTop + (o.bottom - o.top), r = o.bottom;
  }
  toDOM(e) {
    for (let i = 0, n = 0, O = 0; ; i++) {
      let r = i < this.viewports.length ? this.viewports[i] : null;
      if (!r || e < r.top)
        return O + (e - n) * this.scale;
      if (e <= r.bottom)
        return r.domTop + (e - r.top);
      n = r.bottom, O = r.domBottom;
    }
  }
  fromDOM(e) {
    for (let i = 0, n = 0, O = 0; ; i++) {
      let r = i < this.viewports.length ? this.viewports[i] : null;
      if (!r || e < r.domTop)
        return n + (e - O) / this.scale;
      if (e <= r.domBottom)
        return r.top + (e - r.domTop);
      n = r.bottom, O = r.domBottom;
    }
  }
};
function po(t, e) {
  if (e.scale == 1)
    return t;
  let i = e.toDOM(t.top), n = e.toDOM(t.bottom);
  return new Vn(t.from, t.length, i, n - i, Array.isArray(t.type) ? t.type.map((O) => po(O, e)) : t.type);
}
var Ls = K.define({ combine: (t) => t.join(" ") });
var Dh = K.define({ combine: (t) => t.indexOf(true) > -1 });
var Mh = gO.newName();
var e1 = gO.newName();
var t1 = gO.newName();
var i1 = { "&light": "." + e1, "&dark": "." + t1 };
function Nh(t, e, i) {
  return new gO(e, {
    finish(n) {
      return /&/.test(n) ? n.replace(/&\w*/, (O) => {
        if (O == "&")
          return t;
        if (!i || !i[O])
          throw new RangeError(`Unsupported selector: ${O}`);
        return i[O];
      }) : t + " " + n;
    }
  });
}
var IW = Nh("." + Mh, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    boxSizing: "border-box",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused .cm-cursor": {
    display: "block"
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    left: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, i1);
var AW = class {
  constructor(e, i, n, O) {
    this.typeOver = O, this.bounds = null, this.text = "";
    let { impreciseHead: r, impreciseAnchor: a } = e.docView;
    if (e.state.readOnly && i > -1)
      this.newSel = null;
    else if (i > -1 && (this.bounds = e.docView.domBoundsAround(i, n, 0))) {
      let o = r || a ? [] : LW(e), s = new Ev(o, e.state);
      s.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = s.text, this.newSel = DW(o, this.bounds.from);
    } else {
      let o = e.observer.selectionRange, s = r && r.node == o.focusNode && r.offset == o.focusOffset || !Jr(e.contentDOM, o.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(o.focusNode, o.focusOffset), l = a && a.node == o.anchorNode && a.offset == o.anchorOffset || !Jr(e.contentDOM, o.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(o.anchorNode, o.anchorOffset);
      this.newSel = R.single(l, s);
    }
  }
};
function n1(t, e) {
  let i, { newSel: n } = e, O = t.state.selection.main;
  if (e.bounds) {
    let { from: r, to: a } = e.bounds, o = O.from, s = null;
    (t.inputState.lastKeyCode === 8 && t.inputState.lastKeyTime > Date.now() - 100 || J.android && e.text.length < a - r) && (o = O.to, s = "end");
    let l = GW(t.state.doc.sliceString(r, a, cO), e.text, o - r, s);
    l && (J.chrome && t.inputState.lastKeyCode == 13 && l.toB == l.from + 2 && e.text.slice(l.from, l.toB) == cO + cO && l.toB--, i = {
      from: r + l.from,
      to: r + l.toA,
      insert: Te.of(e.text.slice(l.from, l.toB).split(cO))
    });
  } else
    n && (!t.hasFocus && t.state.facet(Fc) || n.main.eq(O)) && (n = null);
  if (!i && !n)
    return false;
  if (!i && e.typeOver && !O.empty && n && n.main.empty ? i = { from: O.from, to: O.to, insert: t.state.doc.slice(O.from, O.to) } : i && i.from >= O.from && i.to <= O.to && (i.from != O.from || i.to != O.to) && O.to - O.from - (i.to - i.from) <= 4 ? i = {
    from: O.from,
    to: O.to,
    insert: t.state.doc.slice(O.from, i.from).append(i.insert).append(t.state.doc.slice(i.to, O.to))
  } : (J.mac || J.android) && i && i.from == i.to && i.from == O.head - 1 && /^\. ?$/.test(i.insert.toString()) && t.contentDOM.getAttribute("autocorrect") == "off" ? (n && i.insert.length == 2 && (n = R.single(n.main.anchor - 1, n.main.head - 1)), i = { from: O.from, to: O.to, insert: Te.of([" "]) }) : J.chrome && i && i.from == i.to && i.from == O.head && i.insert.toString() == `
 ` && t.lineWrapping && (n && (n = R.single(n.main.anchor - 1, n.main.head - 1)), i = { from: O.from, to: O.to, insert: Te.of([" "]) }), i) {
    let r = t.state;
    if (J.ios && t.inputState.flushIOSKey(t) || J.android && (i.from == O.from && i.to == O.to && i.insert.length == 1 && i.insert.lines == 2 && Dr(t.contentDOM, "Enter", 13) || i.from == O.from - 1 && i.to == O.to && i.insert.length == 0 && Dr(t.contentDOM, "Backspace", 8) || i.from == O.from && i.to == O.to + 1 && i.insert.length == 0 && Dr(t.contentDOM, "Delete", 46)))
      return true;
    let a = i.insert.toString();
    if (t.state.facet(_v).some((l) => l(t, i.from, i.to, a)))
      return true;
    t.inputState.composing >= 0 && t.inputState.composing++;
    let o;
    if (i.from >= O.from && i.to <= O.to && i.to - i.from >= (O.to - O.from) / 3 && (!n || n.main.empty && n.main.from == i.from + i.insert.length) && t.inputState.composing < 0) {
      let l = O.from < i.from ? r.sliceDoc(O.from, i.from) : "", c = O.to > i.to ? r.sliceDoc(i.to, O.to) : "";
      o = r.replaceSelection(t.state.toText(l + i.insert.sliceString(0, void 0, t.state.lineBreak) + c));
    } else {
      let l = r.changes(i), c = n && !r.selection.main.eq(n.main) && n.main.to <= l.newLength ? n.main : void 0;
      if (r.selection.ranges.length > 1 && t.inputState.composing >= 0 && i.to <= O.to && i.to >= O.to - 10) {
        let u = t.state.sliceDoc(i.from, i.to), h10 = jv(t) || t.state.doc.lineAt(O.head), d = O.to - i.to, p = O.to - O.from;
        o = r.changeByRange(($) => {
          if ($.from == O.from && $.to == O.to)
            return { changes: l, range: c || $.map(l) };
          let g = $.to - d, Q = g - u.length;
          if ($.to - $.from != p || t.state.sliceDoc(Q, g) != u || // Unfortunately, there's no way to make multiple
          // changes in the same node work without aborting
          // composition, so cursors in the composition range are
          // ignored.
          h10 && $.to >= h10.from && $.from <= h10.to)
            return { range: $ };
          let m = r.changes({ from: Q, to: g, insert: i.insert }), b = $.to - O.to;
          return {
            changes: m,
            range: c ? R.range(Math.max(0, c.anchor + b), Math.max(0, c.head + b)) : $.map(m)
          };
        });
      } else
        o = {
          changes: l,
          selection: c && r.selection.replaceRange(c)
        };
    }
    let s = "input.type";
    return t.composing && (s += ".compose", t.inputState.compositionFirstChange && (s += ".start", t.inputState.compositionFirstChange = false)), t.dispatch(o, { scrollIntoView: true, userEvent: s }), true;
  } else if (n && !n.main.eq(O)) {
    let r = false, a = "select";
    return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == "select" && (r = true), a = t.inputState.lastSelectionOrigin), t.dispatch({ selection: n, scrollIntoView: r, userEvent: a }), true;
  } else
    return false;
}
function GW(t, e, i, n) {
  let O = Math.min(t.length, e.length), r = 0;
  for (; r < O && t.charCodeAt(r) == e.charCodeAt(r); )
    r++;
  if (r == O && t.length == e.length)
    return null;
  let a = t.length, o = e.length;
  for (; a > 0 && o > 0 && t.charCodeAt(a - 1) == e.charCodeAt(o - 1); )
    a--, o--;
  if (n == "end") {
    let s = Math.max(0, r - Math.min(a, o));
    i -= a + s - r;
  }
  if (a < r && t.length < e.length) {
    let s = i <= r && i >= a ? r - i : 0;
    r -= s, o = r + (o - a), a = r;
  } else if (o < r) {
    let s = i <= r && i >= o ? r - i : 0;
    r -= s, a = r + (a - o), o = r;
  }
  return { from: r, toA: a, toB: o };
}
function LW(t) {
  let e = [];
  if (t.root.activeElement != t.contentDOM)
    return e;
  let { anchorNode: i, anchorOffset: n, focusNode: O, focusOffset: r } = t.observer.selectionRange;
  return i && (e.push(new Og(i, n)), (O != i || r != n) && e.push(new Og(O, r))), e;
}
function DW(t, e) {
  if (t.length == 0)
    return null;
  let i = t[0].pos, n = t.length == 2 ? t[1].pos : i;
  return i > -1 && n > -1 ? R.single(i + e, n + e) : null;
}
var MW = {
  childList: true,
  characterData: true,
  subtree: true,
  attributes: true,
  characterDataOldValue: true
};
var Hu = J.ie && J.ie_version <= 11;
var NW = class {
  constructor(e) {
    this.view = e, this.active = false, this.selectionRange = new j_(), this.selectionChanged = false, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.resizeContent = null, this.intersecting = false, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((i) => {
      for (let n of i)
        this.queue.push(n);
      (J.ie && J.ie_version <= 11 || J.ios && e.composing) && i.some((n) => n.type == "childList" && n.removedNodes.length || n.type == "characterData" && n.oldValue.length > n.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), Hu && (this.onCharData = (i) => {
      this.queue.push({
        target: i.target,
        type: "characterData",
        oldValue: i.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var i;
      ((i = this.view.docView) === null || i === void 0 ? void 0 : i.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM), this.resizeContent = new ResizeObserver(() => this.view.requestMeasure()), this.resizeContent.observe(e.contentDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((i) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), i.length > 0 && i[i.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, {}), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((i) => {
      i.length > 0 && i[i.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runScrollHandlers(this.view, e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(false), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = true, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = false, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((i, n) => i != e[n]))) {
      this.gapIntersection.disconnect();
      for (let i of e)
        this.gapIntersection.observe(i);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let i = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: n } = this, O = this.selectionRange;
    if (n.state.facet(Fc) ? n.root.activeElement != this.dom : !wl(n.dom, O))
      return;
    let r = O.anchorNode && n.docView.nearest(O.anchorNode);
    if (r && r.ignoreEvent(e)) {
      i || (this.selectionChanged = false);
      return;
    }
    (J.ie && J.ie_version <= 11 || J.android && J.chrome) && !n.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    O.focusNode && Dl(O.focusNode, O.focusOffset, O.anchorNode, O.anchorOffset) ? this.flushSoon() : this.flush(false);
  }
  readSelectionRange() {
    let { view: e } = this, i = J.safari && e.root.nodeType == 11 && q_(this.dom.ownerDocument) == this.dom && BW(this.view) || Ll(e.root);
    if (!i || this.selectionRange.eq(i))
      return false;
    let n = wl(this.dom, i);
    return n && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && A_(this.dom, i) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), false) : (this.selectionRange.setRange(i), n && (this.selectionChanged = true), true);
  }
  setSelectionRange(e, i) {
    this.selectionRange.set(e.node, e.offset, i.node, i.offset), this.selectionChanged = false;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, i = null;
    for (let n = this.dom; n; )
      if (n.nodeType == 1)
        !i && e < this.scrollTargets.length && this.scrollTargets[e] == n ? e++ : i || (i = this.scrollTargets.slice(0, e)), i && i.push(n), n = n.assignedSlot || n.parentNode;
      else if (n.nodeType == 11)
        n = n.host;
      else
        break;
    if (e < this.scrollTargets.length && !i && (i = this.scrollTargets.slice(0, e)), i) {
      for (let n of this.scrollTargets)
        n.removeEventListener("scroll", this.onScroll);
      for (let n of this.scrollTargets = i)
        n.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, MW), Hu && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = true);
  }
  stop() {
    this.active && (this.active = false, this.observer.disconnect(), Hu && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = false;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, i) {
    var n;
    if (!this.delayedAndroidKey) {
      let O = () => {
        let r = this.delayedAndroidKey;
        r && (this.clearDelayedAndroidKey(), !this.flush() && r.force && Dr(this.dom, r.key, r.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(O);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: i,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((n = this.delayedAndroidKey) === null || n === void 0) && n.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  processRecords() {
    let e = this.queue;
    for (let r of this.observer.takeRecords())
      e.push(r);
    e.length && (this.queue = []);
    let i = -1, n = -1, O = false;
    for (let r of e) {
      let a = this.readMutation(r);
      a && (a.typeOver && (O = true), i == -1 ? { from: i, to: n } = a : (i = Math.min(a.from, i), n = Math.max(a.to, n)));
    }
    return { from: i, to: n, typeOver: O };
  }
  readChange() {
    let { from: e, to: i, typeOver: n } = this.processRecords(), O = this.selectionChanged && wl(this.dom, this.selectionRange);
    return e < 0 && !O ? null : (e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = false, new AW(this.view, e, i, n));
  }
  // Apply pending changes, if any
  flush(e = true) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return false;
    e && this.readSelectionRange();
    let i = this.readChange();
    if (!i)
      return false;
    let n = this.view.state, O = n1(this.view, i);
    return this.view.state == n && this.view.update([]), O;
  }
  readMutation(e) {
    let i = this.view.docView.nearest(e.target);
    if (!i || i.ignoreMutation(e))
      return null;
    if (i.markDirty(e.type == "attributes"), e.type == "attributes" && (i.dirty |= 4), e.type == "childList") {
      let n = vg(i, e.previousSibling || e.target.previousSibling, -1), O = vg(i, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: n ? i.posAfter(n) : i.posAtStart,
        to: O ? i.posBefore(O) : i.posAtEnd,
        typeOver: false
      };
    } else
      return e.type == "characterData" ? { from: i.posAtStart, to: i.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var e, i, n, O;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (i = this.gapIntersection) === null || i === void 0 || i.disconnect(), (n = this.resizeScroll) === null || n === void 0 || n.disconnect(), (O = this.resizeContent) === null || O === void 0 || O.disconnect();
    for (let r of this.scrollTargets)
      r.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
};
function vg(t, e, i) {
  for (; e; ) {
    let n = Ee.get(e);
    if (n && n.parent == t)
      return n;
    let O = e.parentNode;
    e = O != t.dom ? O : i > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function BW(t) {
  let e = null;
  function i(s) {
    s.preventDefault(), s.stopImmediatePropagation(), e = s.getTargetRanges()[0];
  }
  if (t.contentDOM.addEventListener("beforeinput", i, true), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", i, true), !e)
    return null;
  let n = e.startContainer, O = e.startOffset, r = e.endContainer, a = e.endOffset, o = t.docView.domAtPos(t.state.selection.main.anchor);
  return Dl(o.node, o.offset, r, a) && ([n, O, r, a] = [r, a, n, O]), { anchorNode: n, anchorOffset: O, focusNode: r, focusOffset: a };
}
var B = class {
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = false, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.style.cssText = "position: fixed; top: -10000px", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), this._dispatch = e.dispatch || ((i) => this.update([i])), this.dispatch = this.dispatch.bind(this), this._root = e.root || I_(e.parent) || document, this.viewState = new yg(e.state || ye.create(e)), this.plugins = this.state.facet(fo).map((i) => new Mu(i));
    for (let i of this.plugins)
      i.update(this);
    this.observer = new NW(this), this.inputState = new QW(this), this.inputState.ensureHandlers(this, this.plugins), this.docView = new rg(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), e.parent && e.parent.appendChild(this.dom);
  }
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  dispatch(...e) {
    this._dispatch(e.length == 1 && e[0] instanceof ht ? e[0] : this.state.update(...e));
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let i = false, n = false, O, r = this.state;
    for (let h10 of e) {
      if (h10.startState != r)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      r = h10.state;
    }
    if (this.destroyed) {
      this.viewState.state = r;
      return;
    }
    let a = this.hasFocus, o = 0, s = null;
    e.some((h10) => h10.annotation(Fv)) ? (this.inputState.notifiedFocused = a, o = 1) : a != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = a, s = Hv(r, a), s || (o = 1));
    let l = this.observer.delayedAndroidKey, c = null;
    if (l ? (this.observer.clearDelayedAndroidKey(), c = this.observer.readChange(), (c && !this.state.doc.eq(r.doc) || !this.state.selection.eq(r.selection)) && (c = null)) : this.observer.clear(), r.facet(ye.phrases) != this.state.facet(ye.phrases))
      return this.setState(r);
    O = Bl.create(this, r, e), O.flags |= o;
    let u = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let h10 of e) {
        if (u && (u = u.map(h10.changes)), h10.scrollIntoView) {
          let { main: d } = h10.state.selection;
          u = new Nl(d.empty ? d : R.cursor(d.head, d.head > d.anchor ? -1 : 1));
        }
        for (let d of h10.effects)
          d.is(ig) && (u = d.value);
      }
      this.viewState.update(O, u), this.bidiCache = Fl.update(this.bidiCache, O.changes), O.empty || (this.updatePlugins(O), this.inputState.update(O)), i = this.docView.update(O), this.state.facet(ho) != this.styleModules && this.mountStyles(), n = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(i, e.some((h10) => h10.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (O.startState.facet(Ls) != O.state.facet(Ls) && (this.viewState.mustMeasureContent = true), (i || n || u || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !O.empty)
      for (let h10 of this.state.facet(Eh))
        h10(O);
    (s || c) && Promise.resolve().then(() => {
      s && this.state == s.startState && this.dispatch(s), c && !n1(this, c) && l.force && Dr(this.contentDOM, l.key, l.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let i = this.hasFocus;
    try {
      for (let n of this.plugins)
        n.destroy(this);
      this.viewState = new yg(e), this.plugins = e.facet(fo).map((n) => new Mu(n)), this.pluginMap.clear();
      for (let n of this.plugins)
        n.update(this);
      this.docView = new rg(this), this.inputState.ensureHandlers(this, this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    i && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let i = e.startState.facet(fo), n = e.state.facet(fo);
    if (i != n) {
      let O = [];
      for (let r of n) {
        let a = i.indexOf(r);
        if (a < 0)
          O.push(new Mu(r));
        else {
          let o = this.plugins[a];
          o.mustUpdate = e, O.push(o);
        }
      }
      for (let r of this.plugins)
        r.mustUpdate != e && r.destroy(this);
      this.plugins = O, this.pluginMap.clear(), this.inputState.ensureHandlers(this, this.plugins);
    } else
      for (let O of this.plugins)
        O.mustUpdate = e;
    for (let O = 0; O < this.plugins.length; O++)
      this.plugins[O].update(this);
  }
  /**
  @internal
  */
  measure(e = true) {
    if (this.destroyed)
      return;
    this.measureScheduled > -1 && cancelAnimationFrame(this.measureScheduled), this.measureScheduled = 0, e && this.observer.forceFlush();
    let i = null, { scrollHeight: n, scrollTop: O, clientHeight: r } = this.scrollDOM, a = O > n - r - 4 ? n : O;
    try {
      for (let o = 0; ; o++) {
        this.updateState = 1;
        let s = this.viewport, l = this.viewState.lineBlockAtHeight(a), c = this.viewState.measure(this);
        if (!c && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (o > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let u = [];
        c & 4 || ([this.measureRequests, u] = [u, this.measureRequests]);
        let h10 = u.map((g) => {
          try {
            return g.read(this);
          } catch (Q) {
            return Pi(this.state, Q), Xg;
          }
        }), d = Bl.create(this, this.state, []), p = false, $ = false;
        d.flags |= c, i ? i.flags |= c : i = d, this.updateState = 2, d.empty || (this.updatePlugins(d), this.inputState.update(d), this.updateAttrs(), p = this.docView.update(d));
        for (let g = 0; g < u.length; g++)
          if (h10[g] != Xg)
            try {
              let Q = u[g];
              Q.write && Q.write(h10[g], this);
            } catch (Q) {
              Pi(this.state, Q);
            }
        if (this.viewState.editorHeight)
          if (this.viewState.scrollTarget)
            this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, $ = true;
          else {
            let g = this.viewState.lineBlockAt(l.from).top - l.top;
            (g > 1 || g < -1) && (this.scrollDOM.scrollTop += g, $ = true);
          }
        if (p && this.docView.updateSelection(true), this.viewport.from == s.from && this.viewport.to == s.to && !$ && this.measureRequests.length == 0)
          break;
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (i && !i.empty)
      for (let o of this.state.facet(Eh))
        o(i);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return Mh + " " + (this.state.facet(Dh) ? t1 : e1) + " " + this.state.facet(Ls);
  }
  updateAttrs() {
    let e = xg(this, Zv, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), i = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(Fc) ? "true" : "false",
      class: "cm-content",
      style: `${J.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (i["aria-readonly"] = "true"), xg(this, kp, i);
    let n = this.observer.ignore(() => {
      let O = zh(this.contentDOM, this.contentAttrs, i), r = zh(this.dom, this.editorAttrs, e);
      return O || r;
    });
    return this.editorAttrs = e, this.contentAttrs = i, n;
  }
  showAnnouncements(e) {
    let i = true;
    for (let n of e)
      for (let O of n.effects)
        if (O.is(B.announce)) {
          i && (this.announceDOM.textContent = ""), i = false;
          let r = this.announceDOM.appendChild(document.createElement("div"));
          r.textContent = O.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(ho), gO.mount(this.root, this.styleModules.concat(IW).reverse());
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(false);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let i = 0; i < this.measureRequests.length; i++)
          if (this.measureRequests[i].key === e.key) {
            this.measureRequests[i] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let i = this.pluginMap.get(e);
    return (i === void 0 || i && i.spec != e) && this.pluginMap.set(e, i = this.plugins.find((n) => n.spec == e) || null), i && i.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, i, n) {
    return Bu(this, e, ug(this, e, i, n));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, i) {
    return Bu(this, e, ug(this, e, i, (n) => pW(this, e.head, n)));
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, i, n = true) {
    return dW(this, e, i, n);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, i, n) {
    return Bu(this, e, $W(this, e, i, n));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, i = 0) {
    return this.docView.posFromDOM(e, i);
  }
  posAtCoords(e, i = true) {
    return this.readMeasured(), Av(this, e, i);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, i = 1) {
    this.readMeasured();
    let n = this.docView.coordsAt(e, i);
    if (!n || n.left == n.right)
      return n;
    let O = this.state.doc.lineAt(e), r = this.bidiSpans(O), a = r[Mr.find(r, e - O.from, -1, i)];
    return Xp(n, a.dir == Ne.LTR == i > 0);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(Yv) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > FW)
      return zv(e.length);
    let i = this.textDirectionAt(e.from);
    for (let O of this.bidiCache)
      if (O.from == e.from && O.dir == i)
        return O.order;
    let n = eW(e.text, i);
    return this.bidiCache.push(new Fl(e.from, e.to, i, n)), n;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || J.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      hv(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && cancelAnimationFrame(this.measureScheduled), this.destroyed = true;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, i = {}) {
    return ig.of(new Nl(typeof e == "number" ? R.cursor(e) : e, i.y, i.x, i.yMargin, i.xMargin));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return it.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, i) {
    let n = gO.newName(), O = [Ls.of(n), ho.of(Nh(`.${n}`, e))];
    return i && i.dark && O.push(Dh.of(true)), O;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return wO.lowest(ho.of(Nh("." + Mh, e, i1)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var i;
    let n = e.querySelector(".cm-content"), O = n && Ee.get(n) || Ee.get(e);
    return ((i = O == null ? void 0 : O.rootView) === null || i === void 0 ? void 0 : i.view) || null;
  }
};
B.styleModule = ho;
B.inputHandler = _v;
B.focusChangeEffect = Wv;
B.perLineTextDirection = Yv;
B.exceptionSink = kv;
B.updateListener = Eh;
B.editable = Fc;
B.mouseSelectionStyle = Tv;
B.dragMovesSelection = wv;
B.clickAddsSelectionRange = xv;
B.decorations = No;
B.atomicRanges = Uv;
B.scrollMargins = Vv;
B.darkTheme = Dh;
B.contentAttributes = kp;
B.editorAttributes = Zv;
B.lineWrapping = B.contentAttributes.of({ class: "cm-lineWrapping" });
B.announce = fe.define();
var FW = 4096;
var Xg = {};
var Fl = class {
  constructor(e, i, n, O) {
    this.from = e, this.to = i, this.dir = n, this.order = O;
  }
  static update(e, i) {
    if (i.empty)
      return e;
    let n = [], O = e.length ? e[e.length - 1].dir : Ne.LTR;
    for (let r = Math.max(0, e.length - 10); r < e.length; r++) {
      let a = e[r];
      a.dir == O && !i.touchesRange(a.from, a.to) && n.push(new Fl(i.mapPos(a.from, 1), i.mapPos(a.to, -1), a.dir, a.order));
    }
    return n;
  }
};
function xg(t, e, i) {
  for (let n = t.state.facet(e), O = n.length - 1; O >= 0; O--) {
    let r = n[O], a = typeof r == "function" ? r(t) : r;
    a && qh(a, i);
  }
  return i;
}
var HW = J.mac ? "mac" : J.windows ? "win" : J.linux ? "linux" : "key";
function KW(t, e) {
  const i = t.split(/-(?!$)/);
  let n = i[i.length - 1];
  n == "Space" && (n = " ");
  let O, r, a, o;
  for (let s = 0; s < i.length - 1; ++s) {
    const l = i[s];
    if (/^(cmd|meta|m)$/i.test(l))
      o = true;
    else if (/^a(lt)?$/i.test(l))
      O = true;
    else if (/^(c|ctrl|control)$/i.test(l))
      r = true;
    else if (/^s(hift)?$/i.test(l))
      a = true;
    else if (/^mod$/i.test(l))
      e == "mac" ? o = true : r = true;
    else
      throw new Error("Unrecognized modifier name: " + l);
  }
  return O && (n = "Alt-" + n), r && (n = "Ctrl-" + n), o && (n = "Meta-" + n), a && (n = "Shift-" + n), n;
}
function Ds(t, e, i) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), i !== false && e.shiftKey && (t = "Shift-" + t), t;
}
var JW = wO.default(B.domEventHandlers({
  keydown(t, e) {
    return r1(O1(e.state), t, e, "editor");
  }
}));
var ka = K.define({ enables: JW });
var wg = /* @__PURE__ */ new WeakMap();
function O1(t) {
  let e = t.facet(ka), i = wg.get(e);
  return i || wg.set(e, i = iY(e.reduce((n, O) => n.concat(O), []))), i;
}
function eY(t, e, i) {
  return r1(O1(t.state), e, t, i);
}
var oO = null;
var tY = 4e3;
function iY(t, e = HW) {
  let i = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), O = (a, o) => {
    let s = n[a];
    if (s == null)
      n[a] = o;
    else if (s != o)
      throw new Error("Key binding " + a + " is used both as a regular binding and as a multi-stroke prefix");
  }, r = (a, o, s, l) => {
    var c, u;
    let h10 = i[a] || (i[a] = /* @__PURE__ */ Object.create(null)), d = o.split(/ (?!$)/).map((g) => KW(g, e));
    for (let g = 1; g < d.length; g++) {
      let Q = d.slice(0, g).join(" ");
      O(Q, true), h10[Q] || (h10[Q] = {
        preventDefault: true,
        run: [(m) => {
          let b = oO = { view: m, prefix: Q, scope: a };
          return setTimeout(() => {
            oO == b && (oO = null);
          }, tY), true;
        }]
      });
    }
    let p = d.join(" ");
    O(p, false);
    let $ = h10[p] || (h10[p] = { preventDefault: false, run: ((u = (c = h10._any) === null || c === void 0 ? void 0 : c.run) === null || u === void 0 ? void 0 : u.slice()) || [] });
    s && $.run.push(s), l && ($.preventDefault = true);
  };
  for (let a of t) {
    let o = a.scope ? a.scope.split(" ") : ["editor"];
    if (a.any)
      for (let l of o) {
        let c = i[l] || (i[l] = /* @__PURE__ */ Object.create(null));
        c._any || (c._any = { preventDefault: false, run: [] });
        for (let u in c)
          c[u].run.push(a.any);
      }
    let s = a[e] || a.key;
    if (s)
      for (let l of o)
        r(l, s, a.run, a.preventDefault), a.shift && r(l, "Shift-" + s, a.shift, a.preventDefault);
  }
  return i;
}
function r1(t, e, i, n) {
  let O = V_(e), r = Xt(O, 0), a = _i(r) == O.length && O != " ", o = "", s = false;
  oO && oO.view == i && oO.scope == n && (o = oO.prefix + " ", (s = Lv.indexOf(e.keyCode) < 0) && (oO = null));
  let l = /* @__PURE__ */ new Set(), c = (p) => {
    if (p) {
      for (let $ of p.run)
        if (!l.has($) && (l.add($), $(i, e)))
          return true;
      p.preventDefault && (s = true);
    }
    return false;
  }, u = t[n], h10, d;
  if (u) {
    if (c(u[o + Ds(O, e, !a)]))
      return true;
    if (a && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
    !(J.windows && e.ctrlKey && e.altKey) && (h10 = mO[e.keyCode]) && h10 != O) {
      if (c(u[o + Ds(h10, e, true)]))
        return true;
      if (e.shiftKey && (d = Lo[e.keyCode]) != O && d != h10 && c(u[o + Ds(d, e, false)]))
        return true;
    } else if (a && e.shiftKey && c(u[o + Ds(O, e, true)]))
      return true;
    if (c(u._any))
      return true;
  }
  return s;
}
var ys = class {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, i, n, O, r) {
    this.className = e, this.left = i, this.top = n, this.width = O, this.height = r;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, i) {
    return i.className != this.className ? false : (this.adjust(e), true);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, i, n) {
    if (n.empty) {
      let O = e.coordsAtPos(n.head, n.assoc || 1);
      if (!O)
        return [];
      let r = a1(e);
      return [new ys(i, O.left - r.left, O.top - r.top, null, O.bottom - O.top)];
    } else
      return nY(e, i, n);
  }
};
function a1(t) {
  let e = t.scrollDOM.getBoundingClientRect();
  return { left: (t.textDirection == Ne.LTR ? e.left : e.right - t.scrollDOM.clientWidth) - t.scrollDOM.scrollLeft, top: e.top - t.scrollDOM.scrollTop };
}
function Tg(t, e, i) {
  let n = R.cursor(e);
  return {
    from: Math.max(i.from, t.moveToLineBoundary(n, false, true).from),
    to: Math.min(i.to, t.moveToLineBoundary(n, true, true).from),
    type: Re.Text
  };
}
function kg(t, e) {
  let i = t.lineBlockAt(e);
  if (Array.isArray(i.type)) {
    for (let n of i.type)
      if (n.to > e || n.to == e && (n.to == i.to || n.type == Re.Text))
        return n;
  }
  return i;
}
function nY(t, e, i) {
  if (i.to <= t.viewport.from || i.from >= t.viewport.to)
    return [];
  let n = Math.max(i.from, t.viewport.from), O = Math.min(i.to, t.viewport.to), r = t.textDirection == Ne.LTR, a = t.contentDOM, o = a.getBoundingClientRect(), s = a1(t), l = window.getComputedStyle(a.firstChild), c = o.left + parseInt(l.paddingLeft) + Math.min(0, parseInt(l.textIndent)), u = o.right - parseInt(l.paddingRight), h10 = kg(t, n), d = kg(t, O), p = h10.type == Re.Text ? h10 : null, $ = d.type == Re.Text ? d : null;
  if (t.lineWrapping && (p && (p = Tg(t, n, p)), $ && ($ = Tg(t, O, $))), p && $ && p.from == $.from)
    return Q(m(i.from, i.to, p));
  {
    let P = p ? m(i.from, null, p) : b(h10, false), S = $ ? m(null, i.to, $) : b(d, true), y = [];
    return (p || h10).to < ($ || d).from - 1 ? y.push(g(c, P.bottom, u, S.top)) : P.bottom < S.top && t.elementAtHeight((P.bottom + S.top) / 2).type == Re.Text && (P.bottom = S.top = (P.bottom + S.top) / 2), Q(P).concat(y).concat(Q(S));
  }
  function g(P, S, y, v) {
    return new ys(
      e,
      P - s.left,
      S - s.top - 0.01,
      y - P,
      v - S + 0.01
      /* C.Epsilon */
    );
  }
  function Q({ top: P, bottom: S, horizontal: y }) {
    let v = [];
    for (let T = 0; T < y.length; T += 2)
      v.push(g(y[T], P, y[T + 1], S));
    return v;
  }
  function m(P, S, y) {
    let v = 1e9, T = -1e9, _ = [];
    function x(Z, L, ae, Oe, C) {
      let M = t.coordsAtPos(Z, Z == y.to ? -2 : 2), H = t.coordsAtPos(ae, ae == y.from ? 2 : -2);
      v = Math.min(M.top, H.top, v), T = Math.max(M.bottom, H.bottom, T), C == Ne.LTR ? _.push(r && L ? c : M.left, r && Oe ? u : H.right) : _.push(!r && Oe ? c : H.left, !r && L ? u : M.right);
    }
    let k = P ?? y.from, Y = S ?? y.to;
    for (let Z of t.visibleRanges)
      if (Z.to > k && Z.from < Y)
        for (let L = Math.max(Z.from, k), ae = Math.min(Z.to, Y); ; ) {
          let Oe = t.state.doc.lineAt(L);
          for (let C of t.bidiSpans(Oe)) {
            let M = C.from + Oe.from, H = C.to + Oe.from;
            if (M >= ae)
              break;
            H > L && x(Math.max(M, L), P == null && M <= k, Math.min(H, ae), S == null && H >= Y, C.dir);
          }
          if (L = Oe.to + 1, L >= ae)
            break;
        }
    return _.length == 0 && x(k, P == null, Y, S == null, t.textDirection), { top: v, bottom: T, horizontal: _ };
  }
  function b(P, S) {
    let y = o.top + (S ? P.top : P.bottom);
    return { top: y, bottom: y, horizontal: [] };
  }
}
function OY(t, e) {
  return t.constructor == e.constructor && t.eq(e);
}
var rY = class {
  constructor(e, i) {
    this.view = e, this.layer = i, this.drawn = [], this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), i.above && this.dom.classList.add("cm-layer-above"), i.class && this.dom.classList.add(i.class), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), i.mount && i.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(kl) != e.state.facet(kl) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && e.view.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let i = 0, n = e.facet(kl);
    for (; i < n.length && n[i] != this.layer; )
      i++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - i);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((i, n) => !OY(i, this.drawn[n]))) {
      let i = this.dom.firstChild, n = 0;
      for (let O of e)
        O.update && i && O.constructor && this.drawn[n].constructor && O.update(i, this.drawn[n]) ? (i = i.nextSibling, n++) : this.dom.insertBefore(O.draw(), i);
      for (; i; ) {
        let O = i.nextSibling;
        i.remove(), i = O;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
};
var kl = K.define();
function o1(t) {
  return [
    it.define((e) => new rY(e, t)),
    kl.of(t)
  ];
}
var s1 = !J.ios;
var Bo = K.define({
  combine(t) {
    return Xn(t, {
      cursorBlinkRate: 1200,
      drawRangeCursor: true
    }, {
      cursorBlinkRate: (e, i) => Math.min(e, i),
      drawRangeCursor: (e, i) => e || i
    });
  }
});
function aY(t = {}) {
  return [
    Bo.of(t),
    oY,
    sY,
    lY,
    Rv.of(true)
  ];
}
function l1(t) {
  return t.startState.facet(Bo) != t.state.facet(Bo);
}
var oY = o1({
  above: true,
  markers(t) {
    let { state: e } = t, i = e.facet(Bo), n = [];
    for (let O of e.selection.ranges) {
      let r = O == e.selection.main;
      if (O.empty ? !r || s1 : i.drawRangeCursor) {
        let a = r ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", o = O.empty ? O : R.cursor(O.head, O.head > O.anchor ? -1 : 1);
        for (let s of ys.forRange(t, a, o))
          n.push(s);
      }
    }
    return n;
  },
  update(t, e) {
    t.transactions.some((n) => n.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let i = l1(t);
    return i && _g(t.state, e), t.docChanged || t.selectionSet || i;
  },
  mount(t, e) {
    _g(e.state, t);
  },
  class: "cm-cursorLayer"
});
function _g(t, e) {
  e.style.animationDuration = t.facet(Bo).cursorBlinkRate + "ms";
}
var sY = o1({
  above: false,
  markers(t) {
    return t.state.selection.ranges.map((e) => e.empty ? [] : ys.forRange(t, "cm-selectionBackground", e)).reduce((e, i) => e.concat(i));
  },
  update(t, e) {
    return t.docChanged || t.selectionSet || t.viewportChanged || l1(t);
  },
  class: "cm-selectionLayer"
});
var c1 = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
s1 && (c1[".cm-line"].caretColor = "transparent !important");
var lY = wO.highest(B.theme(c1));
var u1 = fe.define({
  map(t, e) {
    return t == null ? null : e.mapPos(t);
  }
});
var $o = St.define({
  create() {
    return null;
  },
  update(t, e) {
    return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((i, n) => n.is(u1) ? n.value : i, t);
  }
});
var cY = it.fromClass(class {
  constructor(t) {
    this.view = t, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(t) {
    var e;
    let i = t.state.field($o);
    i == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t.startState.field($o) != i || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let t = this.view.state.field($o), e = t != null && this.view.coordsAtPos(t);
    if (!e)
      return null;
    let i = this.view.scrollDOM.getBoundingClientRect();
    return {
      left: e.left - i.left + this.view.scrollDOM.scrollLeft,
      top: e.top - i.top + this.view.scrollDOM.scrollTop,
      height: e.bottom - e.top
    };
  }
  drawCursor(t) {
    this.cursor && (t ? (this.cursor.style.left = t.left + "px", this.cursor.style.top = t.top + "px", this.cursor.style.height = t.height + "px") : this.cursor.style.left = "-100000px");
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(t) {
    this.view.state.field($o) != t && this.view.dispatch({ effects: u1.of(t) });
  }
}, {
  eventHandlers: {
    dragover(t) {
      this.setDropPos(this.view.posAtCoords({ x: t.clientX, y: t.clientY }));
    },
    dragleave(t) {
      (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function uY() {
  return [$o, cY];
}
function Wg(t, e, i, n, O) {
  e.lastIndex = 0;
  for (let r = t.iterRange(i, n), a = i, o; !r.next().done; a += r.value.length)
    if (!r.lineBreak)
      for (; o = e.exec(r.value); )
        O(a + o.index, o);
}
function fY(t, e) {
  let i = t.visibleRanges;
  if (i.length == 1 && i[0].from == t.viewport.from && i[0].to == t.viewport.to)
    return i;
  let n = [];
  for (let { from: O, to: r } of i)
    O = Math.max(t.state.doc.lineAt(O).from, O - e), r = Math.min(t.state.doc.lineAt(r).to, r + e), n.length && n[n.length - 1].to >= O ? n[n.length - 1].to = r : n.push({ from: O, to: r });
  return n;
}
var hY = class {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: i, decoration: n, decorate: O, boundary: r, maxLength: a = 1e3 } = e;
    if (!i.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = i, O)
      this.addMatch = (o, s, l, c) => O(c, l, l + o[0].length, o, s);
    else if (typeof n == "function")
      this.addMatch = (o, s, l, c) => {
        let u = n(o, s, l);
        u && c(l, l + o[0].length, u);
      };
    else if (n)
      this.addMatch = (o, s, l, c) => c(l, l + o[0].length, n);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = r, this.maxLength = a;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let i = new QO(), n = i.add.bind(i);
    for (let { from: O, to: r } of fY(e, this.maxLength))
      Wg(e.state.doc, this.regexp, O, r, (a, o) => this.addMatch(o, e, a, n));
    return i.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, i) {
    let n = 1e9, O = -1;
    return e.docChanged && e.changes.iterChanges((r, a, o, s) => {
      s > e.view.viewport.from && o < e.view.viewport.to && (n = Math.min(o, n), O = Math.max(s, O));
    }), e.viewportChanged || O - n > 1e3 ? this.createDeco(e.view) : O > -1 ? this.updateRange(e.view, i.map(e.changes), n, O) : i;
  }
  updateRange(e, i, n, O) {
    for (let r of e.visibleRanges) {
      let a = Math.max(r.from, n), o = Math.min(r.to, O);
      if (o > a) {
        let s = e.state.doc.lineAt(a), l = s.to < o ? e.state.doc.lineAt(o) : s, c = Math.max(r.from, s.from), u = Math.min(r.to, l.to);
        if (this.boundary) {
          for (; a > s.from; a--)
            if (this.boundary.test(s.text[a - 1 - s.from])) {
              c = a;
              break;
            }
          for (; o < l.to; o++)
            if (this.boundary.test(l.text[o - l.from])) {
              u = o;
              break;
            }
        }
        let h10 = [], d, p = ($, g, Q) => h10.push(Q.range($, g));
        if (s == l)
          for (this.regexp.lastIndex = c - s.from; (d = this.regexp.exec(s.text)) && d.index < u - s.from; )
            this.addMatch(d, e, d.index + s.from, p);
        else
          Wg(e.state.doc, this.regexp, c, u, ($, g) => this.addMatch(g, e, $, p));
        i = i.update({ filterFrom: c, filterTo: u, filter: ($, g) => $ < c || g > u, add: h10 });
      }
    }
    return i;
  }
};
var Bh = /x/.unicode != null ? "gu" : "g";
var dY = new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`, Bh);
var pY = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
var Ku = null;
function $Y() {
  var t;
  if (Ku == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    Ku = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;
  }
  return Ku || false;
}
var _l = K.define({
  combine(t) {
    let e = Xn(t, {
      render: null,
      specialChars: dY,
      addSpecialChars: null
    });
    return (e.replaceTabs = !$Y()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, Bh)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, Bh)), e;
  }
});
function QY(t = {}) {
  return [_l.of(t), gY()];
}
var Yg = null;
function gY() {
  return Yg || (Yg = it.fromClass(class {
    constructor(t) {
      this.view = t, this.decorations = ne.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(t.state.facet(_l)), this.decorations = this.decorator.createDeco(t);
    }
    makeDecorator(t) {
      return new hY({
        regexp: t.specialChars,
        decoration: (e, i, n) => {
          let { doc: O } = i.state, r = Xt(e[0], 0);
          if (r == 9) {
            let a = O.lineAt(n), o = i.state.tabSize, s = Ss(a.text, o, n - a.from);
            return ne.replace({ widget: new yY((o - s % o) * this.view.defaultCharacterWidth) });
          }
          return this.decorationCache[r] || (this.decorationCache[r] = ne.replace({ widget: new PY(t, r) }));
        },
        boundary: t.replaceTabs ? void 0 : /[^]/
      });
    }
    update(t) {
      let e = t.state.facet(_l);
      t.startState.facet(_l) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations);
    }
  }, {
    decorations: (t) => t.decorations
  }));
}
var mY = "•";
function SY(t) {
  return t >= 32 ? mY : t == 10 ? "␤" : String.fromCharCode(9216 + t);
}
var PY = class extends xn {
  constructor(e, i) {
    super(), this.options = e, this.code = i;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let i = SY(this.code), n = e.state.phrase("Control character") + " " + (pY[this.code] || "0x" + this.code.toString(16)), O = this.options.render && this.options.render(this.code, n, i);
    if (O)
      return O;
    let r = document.createElement("span");
    return r.textContent = i, r.title = n, r.setAttribute("aria-label", n), r.className = "cm-specialChar", r;
  }
  ignoreEvent() {
    return false;
  }
};
var yY = class extends xn {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return false;
  }
};
function bY() {
  return XY;
}
var vY = ne.line({ class: "cm-activeLine" });
var XY = it.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = -1, i = [];
    for (let n of t.state.selection.ranges) {
      let O = t.lineBlockAt(n.head);
      O.from > e && (i.push(vY.range(O.from)), e = O.from);
    }
    return ne.set(i);
  }
}, {
  decorations: (t) => t.decorations
});
var xY = class extends xn {
  constructor(e) {
    super(), this.content = e;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.className = "cm-placeholder", e.style.pointerEvents = "none", e.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : this.content), typeof this.content == "string" ? e.setAttribute("aria-label", "placeholder " + this.content) : e.setAttribute("aria-hidden", "true"), e;
  }
  ignoreEvent() {
    return false;
  }
};
function wY(t) {
  return it.fromClass(class {
    constructor(e) {
      this.view = e, this.placeholder = ne.set([ne.widget({ widget: new xY(t), side: 1 }).range(0)]);
    }
    get decorations() {
      return this.view.state.doc.length ? ne.none : this.placeholder;
    }
  }, { decorations: (e) => e.decorations });
}
var Fh = 2e3;
function TY(t, e, i) {
  let n = Math.min(e.line, i.line), O = Math.max(e.line, i.line), r = [];
  if (e.off > Fh || i.off > Fh || e.col < 0 || i.col < 0) {
    let a = Math.min(e.off, i.off), o = Math.max(e.off, i.off);
    for (let s = n; s <= O; s++) {
      let l = t.doc.line(s);
      l.length <= o && r.push(R.range(l.from + a, l.to + o));
    }
  } else {
    let a = Math.min(e.col, i.col), o = Math.max(e.col, i.col);
    for (let s = n; s <= O; s++) {
      let l = t.doc.line(s), c = kh(l.text, a, t.tabSize, true);
      if (c < 0)
        r.push(R.cursor(l.to));
      else {
        let u = kh(l.text, o, t.tabSize);
        r.push(R.range(l.from + c, l.from + u));
      }
    }
  }
  return r;
}
function kY(t, e) {
  let i = t.coordsAtPos(t.viewport.from);
  return i ? Math.round(Math.abs((i.left - e) / t.defaultCharacterWidth)) : -1;
}
function Rg(t, e) {
  let i = t.posAtCoords({ x: e.clientX, y: e.clientY }, false), n = t.state.doc.lineAt(i), O = i - n.from, r = O > Fh ? -1 : O == n.length ? kY(t, e.clientX) : Ss(n.text, t.state.tabSize, i - n.from);
  return { line: n.number, col: r, off: O };
}
function _Y(t, e) {
  let i = Rg(t, e), n = t.state.selection;
  return i ? {
    update(O) {
      if (O.docChanged) {
        let r = O.changes.mapPos(O.startState.doc.line(i.line).from), a = O.state.doc.lineAt(r);
        i = { line: a.number, col: i.col, off: Math.min(i.off, a.length) }, n = n.map(O.changes);
      }
    },
    get(O, r, a) {
      let o = Rg(t, O);
      if (!o)
        return n;
      let s = TY(t.state, i, o);
      return s.length ? a ? R.create(s.concat(n.ranges)) : R.create(s) : n;
    }
  } : null;
}
function WY(t) {
  let e = (t == null ? void 0 : t.eventFilter) || ((i) => i.altKey && i.button == 0);
  return B.mouseSelectionStyle.of((i, n) => e(n) ? _Y(i, n) : null);
}
var YY = {
  Alt: [18, (t) => t.altKey],
  Control: [17, (t) => t.ctrlKey],
  Shift: [16, (t) => t.shiftKey],
  Meta: [91, (t) => t.metaKey]
};
var RY = { style: "cursor: crosshair" };
function ZY(t = {}) {
  let [e, i] = YY[t.key || "Alt"], n = it.fromClass(class {
    constructor(O) {
      this.view = O, this.isDown = false;
    }
    set(O) {
      this.isDown != O && (this.isDown = O, this.view.update([]));
    }
  }, {
    eventHandlers: {
      keydown(O) {
        this.set(O.keyCode == e || i(O));
      },
      keyup(O) {
        (O.keyCode == e || !i(O)) && this.set(false);
      },
      mousemove(O) {
        this.set(i(O));
      }
    }
  });
  return [
    n,
    B.contentAttributes.of((O) => {
      var r;
      return !((r = O.plugin(n)) === null || r === void 0) && r.isDown ? RY : null;
    })
  ];
}
var Ms = "-10000px";
var f1 = class {
  constructor(e, i, n) {
    this.facet = i, this.createTooltipView = n, this.input = e.state.facet(i), this.tooltips = this.input.filter((O) => O), this.tooltipViews = this.tooltips.map(n);
  }
  update(e) {
    var i;
    let n = e.state.facet(this.facet), O = n.filter((a) => a);
    if (n === this.input) {
      for (let a of this.tooltipViews)
        a.update && a.update(e);
      return false;
    }
    let r = [];
    for (let a = 0; a < O.length; a++) {
      let o = O[a], s = -1;
      if (o) {
        for (let l = 0; l < this.tooltips.length; l++) {
          let c = this.tooltips[l];
          c && c.create == o.create && (s = l);
        }
        if (s < 0)
          r[a] = this.createTooltipView(o);
        else {
          let l = r[a] = this.tooltipViews[s];
          l.update && l.update(e);
        }
      }
    }
    for (let a of this.tooltipViews)
      r.indexOf(a) < 0 && (a.dom.remove(), (i = a.destroy) === null || i === void 0 || i.call(a));
    return this.input = n, this.tooltips = O, this.tooltipViews = r, true;
  }
};
function UY(t) {
  let { win: e } = t;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
var Ju = K.define({
  combine: (t) => {
    var e, i, n;
    return {
      position: J.ios ? "absolute" : ((e = t.find((O) => O.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((i = t.find((O) => O.parent)) === null || i === void 0 ? void 0 : i.parent) || null,
      tooltipSpace: ((n = t.find((O) => O.tooltipSpace)) === null || n === void 0 ? void 0 : n.tooltipSpace) || UY
    };
  }
});
var Zg = /* @__PURE__ */ new WeakMap();
var h1 = it.fromClass(class {
  constructor(t) {
    this.view = t, this.inView = true, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = t.state.facet(Ju);
    this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.manager = new f1(t, Wp, (i) => this.createTooltip(i)), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((i) => {
      Date.now() > this.lastTransaction - 50 && i.length > 0 && i[i.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let t of this.manager.tooltipViews)
        this.intersectionObserver.observe(t.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(t) {
    t.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(t);
    e && this.observeIntersection();
    let i = e || t.geometryChanged, n = t.state.facet(Ju);
    if (n.position != this.position) {
      this.position = n.position;
      for (let O of this.manager.tooltipViews)
        O.dom.style.position = this.position;
      i = true;
    }
    if (n.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = n.parent, this.createContainer();
      for (let O of this.manager.tooltipViews)
        this.container.appendChild(O.dom);
      i = true;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    i && this.maybeMeasure();
  }
  createTooltip(t) {
    let e = t.create(this.view);
    if (e.dom.classList.add("cm-tooltip"), t.arrow && !e.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let i = document.createElement("div");
      i.className = "cm-tooltip-arrow", e.dom.appendChild(i);
    }
    return e.dom.style.position = this.position, e.dom.style.top = Ms, this.container.appendChild(e.dom), e.mount && e.mount(this.view), e;
  }
  destroy() {
    var t, e;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let i of this.manager.tooltipViews)
      i.dom.remove(), (t = i.destroy) === null || t === void 0 || t.call(i);
    (e = this.intersectionObserver) === null || e === void 0 || e.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let t = this.view.dom.getBoundingClientRect();
    return {
      editor: t,
      parent: this.parent ? this.container.getBoundingClientRect() : t,
      pos: this.manager.tooltips.map((e, i) => {
        let n = this.manager.tooltipViews[i];
        return n.getCoords ? n.getCoords(e.pos) : this.view.coordsAtPos(e.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: e }) => e.getBoundingClientRect()),
      space: this.view.state.facet(Ju).tooltipSpace(this.view)
    };
  }
  writeMeasure(t) {
    var e;
    let { editor: i, space: n } = t, O = [];
    for (let r = 0; r < this.manager.tooltips.length; r++) {
      let a = this.manager.tooltips[r], o = this.manager.tooltipViews[r], { dom: s } = o, l = t.pos[r], c = t.size[r];
      if (!l || l.bottom <= Math.max(i.top, n.top) || l.top >= Math.min(i.bottom, n.bottom) || l.right < Math.max(i.left, n.left) - 0.1 || l.left > Math.min(i.right, n.right) + 0.1) {
        s.style.top = Ms;
        continue;
      }
      let u = a.arrow ? o.dom.querySelector(".cm-tooltip-arrow") : null, h10 = u ? 7 : 0, d = c.right - c.left, p = (e = Zg.get(o)) !== null && e !== void 0 ? e : c.bottom - c.top, $ = o.offset || qY, g = this.view.textDirection == Ne.LTR, Q = c.width > n.right - n.left ? g ? n.left : n.right - c.width : g ? Math.min(l.left - (u ? 14 : 0) + $.x, n.right - d) : Math.max(n.left, l.left - d + (u ? 14 : 0) - $.x), m = !!a.above;
      !a.strictSide && (m ? l.top - (c.bottom - c.top) - $.y < n.top : l.bottom + (c.bottom - c.top) + $.y > n.bottom) && m == n.bottom - l.bottom > l.top - n.top && (m = !m);
      let b = (m ? l.top - n.top : n.bottom - l.bottom) - h10;
      if (b < p && o.resize !== false) {
        if (b < this.view.defaultLineHeight) {
          s.style.top = Ms;
          continue;
        }
        Zg.set(o, p), s.style.height = (p = b) + "px";
      } else
        s.style.height && (s.style.height = "");
      let P = m ? l.top - p - h10 - $.y : l.bottom + h10 + $.y, S = Q + d;
      if (o.overlap !== true)
        for (let y of O)
          y.left < S && y.right > Q && y.top < P + p && y.bottom > P && (P = m ? y.top - p - 2 - h10 : y.bottom + h10 + 2);
      this.position == "absolute" ? (s.style.top = P - t.parent.top + "px", s.style.left = Q - t.parent.left + "px") : (s.style.top = P + "px", s.style.left = Q + "px"), u && (u.style.left = `${l.left + (g ? $.x : -$.x) - (Q + 14 - 7)}px`), o.overlap !== true && O.push({ left: Q, top: P, right: S, bottom: P + p }), s.classList.toggle("cm-tooltip-above", m), s.classList.toggle("cm-tooltip-below", !m), o.positioned && o.positioned(t.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let t of this.manager.tooltipViews)
        t.dom.style.top = Ms;
  }
}, {
  eventHandlers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
var VY = B.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: `${7}px`,
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: `${7}px solid transparent`,
      borderRight: `${7}px solid transparent`
    },
    ".cm-tooltip-above &": {
      bottom: `-${7}px`,
      "&:before": {
        borderTop: `${7}px solid #bbb`
      },
      "&:after": {
        borderTop: `${7}px solid #f5f5f5`,
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: `-${7}px`,
      "&:before": {
        borderBottom: `${7}px solid #bbb`
      },
      "&:after": {
        borderBottom: `${7}px solid #f5f5f5`,
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
});
var qY = { x: 0, y: 0 };
var Wp = K.define({
  enables: [h1, VY]
});
var Hl = K.define();
var Yp = class {
  constructor(e) {
    this.view = e, this.mounted = false, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new f1(e, Hl, (i) => this.createHostedView(i));
  }
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new Yp(e);
  }
  createHostedView(e) {
    let i = e.create(this.view);
    return i.dom.classList.add("cm-tooltip-section"), this.dom.appendChild(i.dom), this.mounted && i.mount && i.mount(this.view), i;
  }
  mount(e) {
    for (let i of this.manager.tooltipViews)
      i.mount && i.mount(e);
    this.mounted = true;
  }
  positioned(e) {
    for (let i of this.manager.tooltipViews)
      i.positioned && i.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
};
var zY = Wp.compute([Hl], (t) => {
  let e = t.facet(Hl).filter((i) => i);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((i) => i.pos)),
    end: Math.max(...e.filter((i) => i.end != null).map((i) => i.end)),
    create: Yp.create,
    above: e[0].above,
    arrow: e.some((i) => i.arrow)
  };
});
var CY = class {
  constructor(e, i, n, O, r) {
    this.view = e, this.source = i, this.field = n, this.setHover = O, this.hoverTime = r, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { lastMove: e } = this, i = this.view.contentDOM.contains(e.target) ? this.view.posAtCoords(e) : null;
    if (i == null)
      return;
    let n = this.view.coordsAtPos(i);
    if (n == null || e.y < n.top || e.y > n.bottom || e.x < n.left - this.view.defaultCharacterWidth || e.x > n.right + this.view.defaultCharacterWidth)
      return;
    let O = this.view.bidiSpans(this.view.state.doc.lineAt(i)).find((o) => o.from <= i && o.to >= i), r = O && O.dir == Ne.RTL ? -1 : 1, a = this.source(this.view, i, e.x < n.left ? -r : r);
    if (a != null && a.then) {
      let o = this.pending = { pos: i };
      a.then((s) => {
        this.pending == o && (this.pending = null, s && this.view.dispatch({ effects: this.setHover.of(s) }));
      }, (s) => Pi(this.view.state, s, "hover tooltip"));
    } else
      a && this.view.dispatch({ effects: this.setHover.of(a) });
  }
  mousemove(e) {
    var i;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let n = this.active;
    if (n && !Ug(this.lastMove.target) || this.pending) {
      let { pos: O } = n || this.pending, r = (i = n == null ? void 0 : n.end) !== null && i !== void 0 ? i : O;
      (O == r ? this.view.posAtCoords(this.lastMove) != O : !EY(
        this.view,
        O,
        r,
        e.clientX,
        e.clientY,
        6
        /* Hover.MaxDist */
      )) && (this.view.dispatch({ effects: this.setHover.of(null) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1, this.active && !Ug(e.relatedTarget) && this.view.dispatch({ effects: this.setHover.of(null) });
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
};
function Ug(t) {
  for (let e = t; e; e = e.parentNode)
    if (e.nodeType == 1 && e.classList.contains("cm-tooltip"))
      return true;
  return false;
}
function EY(t, e, i, n, O, r) {
  let a = document.createRange(), o = t.domAtPos(e), s = t.domAtPos(i);
  a.setEnd(s.node, s.offset), a.setStart(o.node, o.offset);
  let l = a.getClientRects();
  a.detach();
  for (let c = 0; c < l.length; c++) {
    let u = l[c];
    if (Math.max(u.top - O, O - u.bottom, u.left - n, n - u.right) <= r)
      return true;
  }
  return false;
}
function jY(t, e = {}) {
  let i = fe.define(), n = St.define({
    create() {
      return null;
    },
    update(O, r) {
      if (O && (e.hideOnChange && (r.docChanged || r.selection) || e.hideOn && e.hideOn(r, O)))
        return null;
      if (O && r.docChanged) {
        let a = r.changes.mapPos(O.pos, -1, wt.TrackDel);
        if (a == null)
          return null;
        let o = Object.assign(/* @__PURE__ */ Object.create(null), O);
        o.pos = a, O.end != null && (o.end = r.changes.mapPos(O.end)), O = o;
      }
      for (let a of r.effects)
        a.is(i) && (O = a.value), a.is(AY) && (O = null);
      return O;
    },
    provide: (O) => Hl.from(O)
  });
  return [
    n,
    it.define((O) => new CY(
      O,
      t,
      n,
      i,
      e.hoverTime || 300
      /* Hover.Time */
    )),
    zY
  ];
}
function IY(t, e) {
  let i = t.plugin(h1);
  if (!i)
    return null;
  let n = i.manager.tooltips.indexOf(e);
  return n < 0 ? null : i.manager.tooltipViews[n];
}
var AY = fe.define();
var Vg = K.define({
  combine(t) {
    let e, i;
    for (let n of t)
      e = e || n.topContainer, i = i || n.bottomContainer;
    return { topContainer: e, bottomContainer: i };
  }
});
function Fo(t, e) {
  let i = t.plugin(d1), n = i ? i.specs.indexOf(e) : -1;
  return n > -1 ? i.panels[n] : null;
}
var d1 = it.fromClass(class {
  constructor(t) {
    this.input = t.state.facet(Ho), this.specs = this.input.filter((i) => i), this.panels = this.specs.map((i) => i(t));
    let e = t.state.facet(Vg);
    this.top = new Ns(t, true, e.topContainer), this.bottom = new Ns(t, false, e.bottomContainer), this.top.sync(this.panels.filter((i) => i.top)), this.bottom.sync(this.panels.filter((i) => !i.top));
    for (let i of this.panels)
      i.dom.classList.add("cm-panel"), i.mount && i.mount();
  }
  update(t) {
    let e = t.state.facet(Vg);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new Ns(t.view, true, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new Ns(t.view, false, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let i = t.state.facet(Ho);
    if (i != this.input) {
      let n = i.filter((s) => s), O = [], r = [], a = [], o = [];
      for (let s of n) {
        let l = this.specs.indexOf(s), c;
        l < 0 ? (c = s(t.view), o.push(c)) : (c = this.panels[l], c.update && c.update(t)), O.push(c), (c.top ? r : a).push(c);
      }
      this.specs = n, this.panels = O, this.top.sync(r), this.bottom.sync(a);
      for (let s of o)
        s.dom.classList.add("cm-panel"), s.mount && s.mount();
    } else
      for (let n of this.panels)
        n.update && n.update(t);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (t) => B.scrollMargins.of((e) => {
    let i = e.plugin(t);
    return i && { top: i.top.scrollMargin(), bottom: i.bottom.scrollMargin() };
  })
});
var Ns = class {
  constructor(e, i, n) {
    this.view = e, this.top = i, this.container = n, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let i of this.panels)
      i.destroy && e.indexOf(i) < 0 && i.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let i = this.container || this.view.dom;
      i.insertBefore(this.dom, this.top ? i.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let i of this.panels)
      if (i.dom.parentNode == this.dom) {
        for (; e != i.dom; )
          e = qg(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(i.dom, e);
    for (; e; )
      e = qg(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
};
function qg(t) {
  let e = t.nextSibling;
  return t.remove(), e;
}
var Ho = K.define({
  enables: d1
});
var An = class extends KO {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return false;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
};
An.prototype.elementClass = "";
An.prototype.toDOM = void 0;
An.prototype.mapMode = wt.TrackBefore;
An.prototype.startSide = An.prototype.endSide = -1;
An.prototype.point = true;
var Wl = K.define();
var GY = {
  class: "",
  renderEmptyElements: false,
  elementStyle: "",
  markers: () => We.empty,
  lineMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
};
var xo = K.define();
function LY(t) {
  return [p1(), xo.of(Object.assign(Object.assign({}, GY), t))];
}
var Hh = K.define({
  combine: (t) => t.some((e) => e)
});
function p1(t) {
  let e = [
    DY
  ];
  return t && t.fixed === false && e.push(Hh.of(true)), e;
}
var DY = it.fromClass(class {
  constructor(t) {
    this.view = t, this.prevViewport = t.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight + "px", this.gutters = t.state.facet(xo).map((e) => new Cg(t, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !t.state.facet(Hh), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(false), t.scrollDOM.insertBefore(this.dom, t.contentDOM);
  }
  update(t) {
    if (this.updateGutters(t)) {
      let e = this.prevViewport, i = t.view.viewport, n = Math.min(e.to, i.to) - Math.max(e.from, i.from);
      this.syncGutters(n < (i.to - i.from) * 0.8);
    }
    t.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(Hh) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = t.view.viewport;
  }
  syncGutters(t) {
    let e = this.dom.nextSibling;
    t && this.dom.remove();
    let i = We.iter(this.view.state.facet(Wl), this.view.viewport.from), n = [], O = this.gutters.map((r) => new MY(r, this.view.viewport, -this.view.documentPadding.top));
    for (let r of this.view.viewportLineBlocks) {
      let a;
      if (Array.isArray(r.type)) {
        for (let o of r.type)
          if (o.type == Re.Text) {
            a = o;
            break;
          }
      } else
        a = r.type == Re.Text ? r : void 0;
      if (a) {
        n.length && (n = []), $1(i, n, r.from);
        for (let o of O)
          o.line(this.view, a, n);
      }
    }
    for (let r of O)
      r.finish();
    t && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(t) {
    let e = t.startState.facet(xo), i = t.state.facet(xo), n = t.docChanged || t.heightChanged || t.viewportChanged || !We.eq(t.startState.facet(Wl), t.state.facet(Wl), t.view.viewport.from, t.view.viewport.to);
    if (e == i)
      for (let O of this.gutters)
        O.update(t) && (n = true);
    else {
      n = true;
      let O = [];
      for (let r of i) {
        let a = e.indexOf(r);
        a < 0 ? O.push(new Cg(this.view, r)) : (this.gutters[a].update(t), O.push(this.gutters[a]));
      }
      for (let r of this.gutters)
        r.dom.remove(), O.indexOf(r) < 0 && r.destroy();
      for (let r of O)
        this.dom.appendChild(r.dom);
      this.gutters = O;
    }
    return n;
  }
  destroy() {
    for (let t of this.gutters)
      t.destroy();
    this.dom.remove();
  }
}, {
  provide: (t) => B.scrollMargins.of((e) => {
    let i = e.plugin(t);
    return !i || i.gutters.length == 0 || !i.fixed ? null : e.textDirection == Ne.LTR ? { left: i.dom.offsetWidth } : { right: i.dom.offsetWidth };
  })
});
function zg(t) {
  return Array.isArray(t) ? t : [t];
}
function $1(t, e, i) {
  for (; t.value && t.from <= i; )
    t.from == i && e.push(t.value), t.next();
}
var MY = class {
  constructor(e, i, n) {
    this.gutter = e, this.height = n, this.i = 0, this.cursor = We.iter(e.markers, i.from);
  }
  line(e, i, n) {
    let O = [];
    $1(this.cursor, O, i.from), n.length && (O = O.concat(n));
    let r = this.gutter.config.lineMarker(e, i, O);
    r && O.unshift(r);
    let a = this.gutter;
    if (O.length == 0 && !a.config.renderEmptyElements)
      return;
    let o = i.top - this.height;
    if (this.i == a.elements.length) {
      let s = new Q1(e, i.height, o, O);
      a.elements.push(s), a.dom.appendChild(s.dom);
    } else
      a.elements[this.i].update(e, i.height, o, O);
    this.height = i.bottom, this.i++;
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let i = e.elements.pop();
      e.dom.removeChild(i.dom), i.destroy();
    }
  }
};
var Cg = class {
  constructor(e, i) {
    this.view = e, this.config = i, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let n in i.domEventHandlers)
      this.dom.addEventListener(n, (O) => {
        let r = O.target, a;
        if (r != this.dom && this.dom.contains(r)) {
          for (; r.parentNode != this.dom; )
            r = r.parentNode;
          let s = r.getBoundingClientRect();
          a = (s.top + s.bottom) / 2;
        } else
          a = O.clientY;
        let o = e.lineBlockAtHeight(a - e.documentTop);
        i.domEventHandlers[n](e, o, O) && O.preventDefault();
      });
    this.markers = zg(i.markers(e)), i.initialSpacer && (this.spacer = new Q1(e, 0, 0, [i.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let i = this.markers;
    if (this.markers = zg(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let O = this.config.updateSpacer(this.spacer.markers[0], e);
      O != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [O]);
    }
    let n = e.view.viewport;
    return !We.eq(this.markers, i, n.from, n.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : false);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
};
var Q1 = class {
  constructor(e, i, n, O) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, i, n, O);
  }
  update(e, i, n, O) {
    this.height != i && (this.dom.style.height = (this.height = i) + "px"), this.above != n && (this.dom.style.marginTop = (this.above = n) ? n + "px" : ""), NY(this.markers, O) || this.setMarkers(e, O);
  }
  setMarkers(e, i) {
    let n = "cm-gutterElement", O = this.dom.firstChild;
    for (let r = 0, a = 0; ; ) {
      let o = a, s = r < i.length ? i[r++] : null, l = false;
      if (s) {
        let c = s.elementClass;
        c && (n += " " + c);
        for (let u = a; u < this.markers.length; u++)
          if (this.markers[u].compare(s)) {
            o = u, l = true;
            break;
          }
      } else
        o = this.markers.length;
      for (; a < o; ) {
        let c = this.markers[a++];
        if (c.toDOM) {
          c.destroy(O);
          let u = O.nextSibling;
          O.remove(), O = u;
        }
      }
      if (!s)
        break;
      s.toDOM && (l ? O = O.nextSibling : this.dom.insertBefore(s.toDOM(e), O)), l && a++;
    }
    this.dom.className = n, this.markers = i;
  }
  destroy() {
    this.setMarkers(null, []);
  }
};
function NY(t, e) {
  if (t.length != e.length)
    return false;
  for (let i = 0; i < t.length; i++)
    if (!t[i].compare(e[i]))
      return false;
  return true;
}
var BY = K.define();
var Er = K.define({
  combine(t) {
    return Xn(t, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, i) {
        let n = Object.assign({}, e);
        for (let O in i) {
          let r = n[O], a = i[O];
          n[O] = r ? (o, s, l) => r(o, s, l) || a(o, s, l) : a;
        }
        return n;
      }
    });
  }
});
var ef = class extends An {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
};
function tf(t, e) {
  return t.state.facet(Er).formatNumber(e, t.state);
}
var FY = xo.compute([Er], (t) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: false,
  markers(e) {
    return e.state.facet(BY);
  },
  lineMarker(e, i, n) {
    return n.some((O) => O.toDOM) ? null : new ef(tf(e, e.state.doc.lineAt(i.from).number));
  },
  lineMarkerChange: (e) => e.startState.facet(Er) != e.state.facet(Er),
  initialSpacer(e) {
    return new ef(tf(e, Eg(e.state.doc.lines)));
  },
  updateSpacer(e, i) {
    let n = tf(i.view, Eg(i.view.state.doc.lines));
    return n == e.number ? e : new ef(n);
  },
  domEventHandlers: t.facet(Er).domEventHandlers
}));
function HY(t = {}) {
  return [
    Er.of(t),
    p1(),
    FY
  ];
}
function Eg(t) {
  let e = 9;
  for (; e < t; )
    e = e * 10 + 9;
  return e;
}
var KY = new class extends An {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}();
var JY = Wl.compute(["selection"], (t) => {
  let e = [], i = -1;
  for (let n of t.selection.ranges) {
    let O = t.doc.lineAt(n.head).from;
    O > i && (i = O, e.push(KY.range(O)));
  }
  return We.of(e);
});
function eR() {
  return JY;
}
var g1 = 1024;
var tR = 0;
var Wi = class {
  constructor(e, i) {
    this.from = e, this.to = i;
  }
};
var se = class {
  /// Create a new node prop type.
  constructor(e = {}) {
    this.id = tR++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /// This is meant to be used with
  /// [`NodeSet.extend`](#common.NodeSet.extend) or
  /// [`LRParser.configure`](#lr.ParserConfig.props) to compute
  /// prop values for each node type in the set. Takes a [match
  /// object](#common.NodeType^match) or function that returns undefined
  /// if the node type doesn't get this prop, and the prop's value if
  /// it does.
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = lt.match(e)), (i) => {
      let n = e(i);
      return n === void 0 ? null : [this, n];
    };
  }
};
se.closedBy = new se({ deserialize: (t) => t.split(" ") });
se.openedBy = new se({ deserialize: (t) => t.split(" ") });
se.group = new se({ deserialize: (t) => t.split(" ") });
se.contextHash = new se({ perNode: true });
se.lookAhead = new se({ perNode: true });
se.mounted = new se({ perNode: true });
var iR = class {
  constructor(e, i, n) {
    this.tree = e, this.overlay = i, this.parser = n;
  }
};
var nR = /* @__PURE__ */ Object.create(null);
var lt = class {
  /// @internal
  constructor(e, i, n, O = 0) {
    this.name = e, this.props = i, this.id = n, this.flags = O;
  }
  /// Define a node type.
  static define(e) {
    let i = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : nR, n = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), O = new lt(e.name || "", i, e.id, n);
    if (e.props) {
      for (let r of e.props)
        if (Array.isArray(r) || (r = r(O)), r) {
          if (r[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          i[r[0].id] = r[1];
        }
    }
    return O;
  }
  /// Retrieves a node prop for this type. Will return `undefined` if
  /// the prop isn't present on this node.
  prop(e) {
    return this.props[e.id];
  }
  /// True when this is the top node of a grammar.
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /// True when this node is produced by a skip rule.
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /// Indicates whether this is an error node.
  get isError() {
    return (this.flags & 4) > 0;
  }
  /// When true, this node type doesn't correspond to a user-declared
  /// named node, for example because it is used to cache repetition.
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /// Returns true when this node's name or one of its
  /// [groups](#common.NodeProp^group) matches the given string.
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return true;
      let i = this.prop(se.group);
      return i ? i.indexOf(e) > -1 : false;
    }
    return this.id == e;
  }
  /// Create a function from node types to arbitrary values by
  /// specifying an object whose property names are node or
  /// [group](#common.NodeProp^group) names. Often useful with
  /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  /// names, separated by spaces, in a single property name to map
  /// multiple node names to a single value.
  static match(e) {
    let i = /* @__PURE__ */ Object.create(null);
    for (let n in e)
      for (let O of n.split(" "))
        i[O] = e[n];
    return (n) => {
      for (let O = n.prop(se.group), r = -1; r < (O ? O.length : 0); r++) {
        let a = i[r < 0 ? n.name : O[r]];
        if (a)
          return a;
      }
    };
  }
};
lt.none = new lt(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
var _a = class {
  /// Create a set with the given types. The `id` property of each
  /// type should correspond to its position within the array.
  constructor(e) {
    this.types = e;
    for (let i = 0; i < e.length; i++)
      if (e[i].id != i)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /// Create a copy of this set with some node properties added. The
  /// arguments to this method can be created with
  /// [`NodeProp.add`](#common.NodeProp.add).
  extend(...e) {
    let i = [];
    for (let n of this.types) {
      let O = null;
      for (let r of e) {
        let a = r(n);
        a && (O || (O = Object.assign({}, n.props)), O[a[0].id] = a[1]);
      }
      i.push(O ? new lt(n.name, O, n.id, n.flags) : n);
    }
    return new _a(i);
  }
};
var Bs = /* @__PURE__ */ new WeakMap();
var jg = /* @__PURE__ */ new WeakMap();
var ze;
(function(t) {
  t[t.ExcludeBuffers = 1] = "ExcludeBuffers", t[t.IncludeAnonymous = 2] = "IncludeAnonymous", t[t.IgnoreMounts = 4] = "IgnoreMounts", t[t.IgnoreOverlays = 8] = "IgnoreOverlays";
})(ze || (ze = {}));
var ve = class {
  /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  constructor(e, i, n, O, r) {
    if (this.type = e, this.children = i, this.positions = n, this.length = O, this.props = null, r && r.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [a, o] of r)
        this.props[typeof a == "number" ? a : a.id] = o;
    }
  }
  /// @internal
  toString() {
    let e = this.prop(se.mounted);
    if (e && !e.overlay)
      return e.tree.toString();
    let i = "";
    for (let n of this.children) {
      let O = n.toString();
      O && (i && (i += ","), i += O);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (i.length ? "(" + i + ")" : "") : i;
  }
  /// Get a [tree cursor](#common.TreeCursor) positioned at the top of
  /// the tree. Mode can be used to [control](#common.IterMode) which
  /// nodes the cursor visits.
  cursor(e = 0) {
    return new Ko(this.topNode, e);
  }
  /// Get a [tree cursor](#common.TreeCursor) pointing into this tree
  /// at the given position and side (see
  /// [`moveTo`](#common.TreeCursor.moveTo).
  cursorAt(e, i = 0, n = 0) {
    let O = Bs.get(this) || this.topNode, r = new Ko(O);
    return r.moveTo(e, i), Bs.set(this, r._tree), r;
  }
  /// Get a [syntax node](#common.SyntaxNode) object for the top of the
  /// tree.
  get topNode() {
    return new Ri(this, 0, 0, null);
  }
  /// Get the [syntax node](#common.SyntaxNode) at the given position.
  /// If `side` is -1, this will move into nodes that end at the
  /// position. If 1, it'll move into nodes that start at the
  /// position. With 0, it'll only enter nodes that cover the position
  /// from both sides.
  ///
  /// Note that this will not enter
  /// [overlays](#common.MountedTree.overlay), and you often want
  /// [`resolveInner`](#common.Tree.resolveInner) instead.
  resolve(e, i = 0) {
    let n = ia(Bs.get(this) || this.topNode, e, i, false);
    return Bs.set(this, n), n;
  }
  /// Like [`resolve`](#common.Tree.resolve), but will enter
  /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  /// pointing into the innermost overlaid tree at the given position
  /// (with parent links going through all parent structure, including
  /// the host trees).
  resolveInner(e, i = 0) {
    let n = ia(jg.get(this) || this.topNode, e, i, true);
    return jg.set(this, n), n;
  }
  /// Iterate over the tree and its children, calling `enter` for any
  /// node that touches the `from`/`to` region (if given) before
  /// running over such a node's children, and `leave` (if given) when
  /// leaving the node. When `enter` returns `false`, that node will
  /// not have its children iterated over (or `leave` called).
  iterate(e) {
    let { enter: i, leave: n, from: O = 0, to: r = this.length } = e;
    for (let a = this.cursor((e.mode || 0) | ze.IncludeAnonymous); ; ) {
      let o = false;
      if (a.from <= r && a.to >= O && (a.type.isAnonymous || i(a) !== false)) {
        if (a.firstChild())
          continue;
        o = true;
      }
      for (; o && n && !a.type.isAnonymous && n(a), !a.nextSibling(); ) {
        if (!a.parent())
          return;
        o = true;
      }
    }
  }
  /// Get the value of the given [node prop](#common.NodeProp) for this
  /// node. Works with both per-node and per-type props.
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /// Returns the node's [per-node props](#common.NodeProp.perNode) in a
  /// format that can be passed to the [`Tree`](#common.Tree)
  /// constructor.
  get propValues() {
    let e = [];
    if (this.props)
      for (let i in this.props)
        e.push([+i, this.props[i]]);
    return e;
  }
  /// Balance the direct children of this tree, producing a copy of
  /// which may have children grouped into subtrees with type
  /// [`NodeType.none`](#common.NodeType^none).
  balance(e = {}) {
    return this.children.length <= 8 ? this : Up(lt.none, this.children, this.positions, 0, this.children.length, 0, this.length, (i, n, O) => new ve(this.type, i, n, O, this.propValues), e.makeTree || ((i, n, O) => new ve(lt.none, i, n, O)));
  }
  /// Build a tree from a postfix-ordered buffer of node information,
  /// or a cursor over such a buffer.
  static build(e) {
    return rR(e);
  }
};
ve.empty = new ve(lt.none, [], [], 0);
var Rp = class {
  constructor(e, i) {
    this.buffer = e, this.index = i;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new Rp(this.buffer, this.index);
  }
};
var fr = class {
  /// Create a tree buffer.
  constructor(e, i, n) {
    this.buffer = e, this.length = i, this.set = n;
  }
  /// @internal
  get type() {
    return lt.none;
  }
  /// @internal
  toString() {
    let e = [];
    for (let i = 0; i < this.buffer.length; )
      e.push(this.childString(i)), i = this.buffer[i + 3];
    return e.join(",");
  }
  /// @internal
  childString(e) {
    let i = this.buffer[e], n = this.buffer[e + 3], O = this.set.types[i], r = O.name;
    if (/\W/.test(r) && !O.isError && (r = JSON.stringify(r)), e += 4, n == e)
      return r;
    let a = [];
    for (; e < n; )
      a.push(this.childString(e)), e = this.buffer[e + 3];
    return r + "(" + a.join(",") + ")";
  }
  /// @internal
  findChild(e, i, n, O, r) {
    let { buffer: a } = this, o = -1;
    for (let s = e; s != i && !(m1(r, O, a[s + 1], a[s + 2]) && (o = s, n > 0)); s = a[s + 3])
      ;
    return o;
  }
  /// @internal
  slice(e, i, n) {
    let O = this.buffer, r = new Uint16Array(i - e), a = 0;
    for (let o = e, s = 0; o < i; ) {
      r[s++] = O[o++], r[s++] = O[o++] - n;
      let l = r[s++] = O[o++] - n;
      r[s++] = O[o++] - e, a = Math.max(a, l);
    }
    return new fr(r, a, this.set);
  }
};
function m1(t, e, i, n) {
  switch (t) {
    case -2:
      return i < e;
    case -1:
      return n >= e && i < e;
    case 0:
      return i < e && n > e;
    case 1:
      return i <= e && n > e;
    case 2:
      return n > e;
    case 4:
      return true;
  }
}
function S1(t, e) {
  let i = t.childBefore(e);
  for (; i; ) {
    let n = i.lastChild;
    if (!n || n.to != i.to)
      break;
    n.type.isError && n.from == n.to ? (t = i, i = n.prevSibling) : i = n;
  }
  return t;
}
function ia(t, e, i, n) {
  for (var O; t.from == t.to || (i < 1 ? t.from >= e : t.from > e) || (i > -1 ? t.to <= e : t.to < e); ) {
    let a = !n && t instanceof Ri && t.index < 0 ? null : t.parent;
    if (!a)
      return t;
    t = a;
  }
  let r = n ? 0 : ze.IgnoreOverlays;
  if (n)
    for (let a = t, o = a.parent; o; a = o, o = a.parent)
      a instanceof Ri && a.index < 0 && ((O = o.enter(e, i, r)) === null || O === void 0 ? void 0 : O.from) != a.from && (t = o);
  for (; ; ) {
    let a = t.enter(e, i, r);
    if (!a)
      return t;
    t = a;
  }
}
var Ri = class {
  constructor(e, i, n, O) {
    this._tree = e, this.from = i, this.index = n, this._parent = O;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, i, n, O, r = 0) {
    for (let a = this; ; ) {
      for (let { children: o, positions: s } = a._tree, l = i > 0 ? o.length : -1; e != l; e += i) {
        let c = o[e], u = s[e] + a.from;
        if (m1(O, n, u, u + c.length)) {
          if (c instanceof fr) {
            if (r & ze.ExcludeBuffers)
              continue;
            let h10 = c.findChild(0, c.buffer.length, i, n - u, O);
            if (h10 > -1)
              return new $n(new OR(a, c, e, u), null, h10);
          } else if (r & ze.IncludeAnonymous || !c.type.isAnonymous || Zp(c)) {
            let h10;
            if (!(r & ze.IgnoreMounts) && c.props && (h10 = c.prop(se.mounted)) && !h10.overlay)
              return new Ri(h10.tree, u, e, a);
            let d = new Ri(c, u, e, a);
            return r & ze.IncludeAnonymous || !d.type.isAnonymous ? d : d.nextChild(i < 0 ? c.children.length - 1 : 0, i, n, O);
          }
        }
      }
      if (r & ze.IncludeAnonymous || !a.type.isAnonymous || (a.index >= 0 ? e = a.index + i : e = i < 0 ? -1 : a._parent._tree.children.length, a = a._parent, !a))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, i, n = 0) {
    let O;
    if (!(n & ze.IgnoreOverlays) && (O = this._tree.prop(se.mounted)) && O.overlay) {
      let r = e - this.from;
      for (let { from: a, to: o } of O.overlay)
        if ((i > 0 ? a <= r : a < r) && (i < 0 ? o >= r : o > r))
          return new Ri(O.tree, O.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, i, n);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  cursor(e = 0) {
    return new Ko(this, e);
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  resolve(e, i = 0) {
    return ia(this, e, i, false);
  }
  resolveInner(e, i = 0) {
    return ia(this, e, i, true);
  }
  enterUnfinishedNodesBefore(e) {
    return S1(this, e);
  }
  getChild(e, i = null, n = null) {
    let O = Kl(this, e, i, n);
    return O.length ? O[0] : null;
  }
  getChildren(e, i = null, n = null) {
    return Kl(this, e, i, n);
  }
  /// @internal
  toString() {
    return this._tree.toString();
  }
  get node() {
    return this;
  }
  matchContext(e) {
    return Jl(this, e);
  }
};
function Kl(t, e, i, n) {
  let O = t.cursor(), r = [];
  if (!O.firstChild())
    return r;
  if (i != null) {
    for (; !O.type.is(i); )
      if (!O.nextSibling())
        return r;
  }
  for (; ; ) {
    if (n != null && O.type.is(n))
      return r;
    if (O.type.is(e) && r.push(O.node), !O.nextSibling())
      return n == null ? r : [];
  }
}
function Jl(t, e, i = e.length - 1) {
  for (let n = t.parent; i >= 0; n = n.parent) {
    if (!n)
      return false;
    if (!n.type.isAnonymous) {
      if (e[i] && e[i] != n.name)
        return false;
      i--;
    }
  }
  return true;
}
var OR = class {
  constructor(e, i, n, O) {
    this.parent = e, this.buffer = i, this.index = n, this.start = O;
  }
};
var $n = class {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, i, n) {
    this.context = e, this._parent = i, this.index = n, this.type = e.buffer.set.types[e.buffer.buffer[n]];
  }
  child(e, i, n) {
    let { buffer: O } = this.context, r = O.findChild(this.index + 4, O.buffer[this.index + 3], e, i - this.context.start, n);
    return r < 0 ? null : new $n(this.context, this, r);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, i, n = 0) {
    if (n & ze.ExcludeBuffers)
      return null;
    let { buffer: O } = this.context, r = O.findChild(this.index + 4, O.buffer[this.index + 3], i > 0 ? 1 : -1, e - this.context.start, i);
    return r < 0 ? null : new $n(this.context, this, r);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, i = e.buffer[this.index + 3];
    return i < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new $n(this.context, this._parent, i) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, i = this._parent ? this._parent.index + 4 : 0;
    return this.index == i ? this.externalSibling(-1) : new $n(this.context, this._parent, e.findChild(
      i,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  cursor(e = 0) {
    return new Ko(this, e);
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], i = [], { buffer: n } = this.context, O = this.index + 4, r = n.buffer[this.index + 3];
    if (r > O) {
      let a = n.buffer[this.index + 1];
      e.push(n.slice(O, r, a)), i.push(0);
    }
    return new ve(this.type, e, i, this.to - this.from);
  }
  resolve(e, i = 0) {
    return ia(this, e, i, false);
  }
  resolveInner(e, i = 0) {
    return ia(this, e, i, true);
  }
  enterUnfinishedNodesBefore(e) {
    return S1(this, e);
  }
  /// @internal
  toString() {
    return this.context.buffer.childString(this.index);
  }
  getChild(e, i = null, n = null) {
    let O = Kl(this, e, i, n);
    return O.length ? O[0] : null;
  }
  getChildren(e, i = null, n = null) {
    return Kl(this, e, i, n);
  }
  get node() {
    return this;
  }
  matchContext(e) {
    return Jl(this, e);
  }
};
var Ko = class {
  /// Shorthand for `.type.name`.
  get name() {
    return this.type.name;
  }
  /// @internal
  constructor(e, i = 0) {
    if (this.mode = i, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Ri)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let n = e._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, true) : false;
  }
  yieldBuf(e, i) {
    this.index = e;
    let { start: n, buffer: O } = this.buffer;
    return this.type = i || O.set.types[O.buffer[e]], this.from = n + O.buffer[e + 1], this.to = n + O.buffer[e + 2], true;
  }
  yield(e) {
    return e ? e instanceof Ri ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : false;
  }
  /// @internal
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /// @internal
  enterChild(e, i, n) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, i, n, this.mode));
    let { buffer: O } = this.buffer, r = O.findChild(this.index + 4, O.buffer[this.index + 3], e, i - this.buffer.start, n);
    return r < 0 ? false : (this.stack.push(this.index), this.yieldBuf(r));
  }
  /// Move the cursor to this node's first child. When this returns
  /// false, the node has no child, and the cursor has not been moved.
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /// Move the cursor to this node's last child.
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /// Move the cursor to the first child that ends after `pos`.
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /// Move to the last child that starts before `pos`.
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /// Move the cursor to the child around `pos`. If side is -1 the
  /// child may end at that position, when 1 it may start there. This
  /// will also enter [overlaid](#common.MountedTree.overlay)
  /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  /// set to false.
  enter(e, i, n = this.mode) {
    return this.buffer ? n & ze.ExcludeBuffers ? false : this.enterChild(1, e, i) : this.yield(this._tree.enter(e, i, n));
  }
  /// Move to the node's parent node, if this isn't the top node.
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & ze.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & ze.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /// @internal
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : false;
    let { buffer: i } = this.buffer, n = this.stack.length - 1;
    if (e < 0) {
      let O = n < 0 ? 0 : this.stack[n] + 4;
      if (this.index != O)
        return this.yieldBuf(i.findChild(
          O,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let O = i.buffer[this.index + 3];
      if (O < (n < 0 ? i.buffer.length : i.buffer[this.stack[n] + 3]))
        return this.yieldBuf(O);
    }
    return n < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : false;
  }
  /// Move to this node's next sibling, if any.
  nextSibling() {
    return this.sibling(1);
  }
  /// Move to this node's previous sibling, if any.
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let i, n, { buffer: O } = this;
    if (O) {
      if (e > 0) {
        if (this.index < O.buffer.buffer.length)
          return false;
      } else
        for (let r = 0; r < this.index; r++)
          if (O.buffer.buffer[r + 3] < this.index)
            return false;
      ({ index: i, parent: n } = O);
    } else
      ({ index: i, _parent: n } = this._tree);
    for (; n; { index: i, _parent: n } = n)
      if (i > -1)
        for (let r = i + e, a = e < 0 ? -1 : n._tree.children.length; r != a; r += e) {
          let o = n._tree.children[r];
          if (this.mode & ze.IncludeAnonymous || o instanceof fr || !o.type.isAnonymous || Zp(o))
            return false;
        }
    return true;
  }
  move(e, i) {
    if (i && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return true;
    for (; ; ) {
      if (this.sibling(e))
        return true;
      if (this.atLastNode(e) || !this.parent())
        return false;
    }
  }
  /// Move to the next node in a
  /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  /// traversal, going from a node to its first child or, if the
  /// current node is empty or `enter` is false, its next sibling or
  /// the next sibling of the first parent node that has one.
  next(e = true) {
    return this.move(1, e);
  }
  /// Move to the next node in a last-to-first pre-order traveral. A
  /// node is followed by its last child or, if it has none, its
  /// previous sibling or the previous sibling of the first parent
  /// node that has one.
  prev(e = true) {
    return this.move(-1, e);
  }
  /// Move the cursor to the innermost node that covers `pos`. If
  /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  /// it will enter nodes that start at `pos`.
  moveTo(e, i = 0) {
    for (; (this.from == this.to || (i < 1 ? this.from >= e : this.from > e) || (i > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, i); )
      ;
    return this;
  }
  /// Get a [syntax node](#common.SyntaxNode) at the cursor's current
  /// position.
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, i = null, n = 0;
    if (e && e.context == this.buffer) {
      e:
        for (let O = this.index, r = this.stack.length; r >= 0; ) {
          for (let a = e; a; a = a._parent)
            if (a.index == O) {
              if (O == this.index)
                return a;
              i = a, n = r + 1;
              break e;
            }
          O = this.stack[--r];
        }
    }
    for (let O = n; O < this.stack.length; O++)
      i = new $n(this.buffer, i, this.stack[O]);
    return this.bufferNode = new $n(this.buffer, i, this.index);
  }
  /// Get the [tree](#common.Tree) that represents the current node, if
  /// any. Will return null when the node is in a [tree
  /// buffer](#common.TreeBuffer).
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /// Iterate over the current node and all its descendants, calling
  /// `enter` when entering a node and `leave`, if given, when leaving
  /// one. When `enter` returns `false`, any children of that node are
  /// skipped, and `leave` isn't called for it.
  iterate(e, i) {
    for (let n = 0; ; ) {
      let O = false;
      if (this.type.isAnonymous || e(this) !== false) {
        if (this.firstChild()) {
          n++;
          continue;
        }
        this.type.isAnonymous || (O = true);
      }
      for (; O && i && i(this), O = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!n)
          return;
        this.parent(), n--, O = true;
      }
    }
  }
  /// Test whether the current node matches a given context—a sequence
  /// of direct parent node names. Empty strings in the context array
  /// are treated as wildcards.
  matchContext(e) {
    if (!this.buffer)
      return Jl(this.node, e);
    let { buffer: i } = this.buffer, { types: n } = i.set;
    for (let O = e.length - 1, r = this.stack.length - 1; O >= 0; r--) {
      if (r < 0)
        return Jl(this.node, e, O);
      let a = n[i.buffer[this.stack[r]]];
      if (!a.isAnonymous) {
        if (e[O] && e[O] != a.name)
          return false;
        O--;
      }
    }
    return true;
  }
};
function Zp(t) {
  return t.children.some((e) => e instanceof fr || !e.type.isAnonymous || Zp(e));
}
function rR(t) {
  var e;
  let { buffer: i, nodeSet: n, maxBufferLength: O = g1, reused: r = [], minRepeatType: a = n.types.length } = t, o = Array.isArray(i) ? new Rp(i, i.length) : i, s = n.types, l = 0, c = 0;
  function u(P, S, y, v, T) {
    let { id: _, start: x, end: k, size: Y } = o, Z = c;
    for (; Y < 0; )
      if (o.next(), Y == -1) {
        let M = r[_];
        y.push(M), v.push(x - P);
        return;
      } else if (Y == -3) {
        l = _;
        return;
      } else if (Y == -4) {
        c = _;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${Y}`);
    let L = s[_], ae, Oe, C = x - P;
    if (k - x <= O && (Oe = $(o.pos - S, T))) {
      let M = new Uint16Array(Oe.size - Oe.skip), H = o.pos - Oe.size, xe = M.length;
      for (; o.pos > H; )
        xe = g(Oe.start, M, xe);
      ae = new fr(M, k - Oe.start, n), C = Oe.start - P;
    } else {
      let M = o.pos - Y;
      o.next();
      let H = [], xe = [], Fe = _ >= a ? _ : -1, nt = 0, Et = k;
      for (; o.pos > M; )
        Fe >= 0 && o.id == Fe && o.size >= 0 ? (o.end <= Et - O && (d(H, xe, x, nt, o.end, Et, Fe, Z), nt = H.length, Et = o.end), o.next()) : u(x, M, H, xe, Fe);
      if (Fe >= 0 && nt > 0 && nt < H.length && d(H, xe, x, nt, x, Et, Fe, Z), H.reverse(), xe.reverse(), Fe > -1 && nt > 0) {
        let jt = h10(L);
        ae = Up(L, H, xe, 0, H.length, 0, k - x, jt, jt);
      } else
        ae = p(L, H, xe, k - x, Z - k);
    }
    y.push(ae), v.push(C);
  }
  function h10(P) {
    return (S, y, v) => {
      let T = 0, _ = S.length - 1, x, k;
      if (_ >= 0 && (x = S[_]) instanceof ve) {
        if (!_ && x.type == P && x.length == v)
          return x;
        (k = x.prop(se.lookAhead)) && (T = y[_] + x.length + k);
      }
      return p(P, S, y, v, T);
    };
  }
  function d(P, S, y, v, T, _, x, k) {
    let Y = [], Z = [];
    for (; P.length > v; )
      Y.push(P.pop()), Z.push(S.pop() + y - T);
    P.push(p(n.types[x], Y, Z, _ - T, k - _)), S.push(T - y);
  }
  function p(P, S, y, v, T = 0, _) {
    if (l) {
      let x = [se.contextHash, l];
      _ = _ ? [x].concat(_) : [x];
    }
    if (T > 25) {
      let x = [se.lookAhead, T];
      _ = _ ? [x].concat(_) : [x];
    }
    return new ve(P, S, y, v, _);
  }
  function $(P, S) {
    let y = o.fork(), v = 0, T = 0, _ = 0, x = y.end - O, k = { size: 0, start: 0, skip: 0 };
    e:
      for (let Y = y.pos - P; y.pos > Y; ) {
        let Z = y.size;
        if (y.id == S && Z >= 0) {
          k.size = v, k.start = T, k.skip = _, _ += 4, v += 4, y.next();
          continue;
        }
        let L = y.pos - Z;
        if (Z < 0 || L < Y || y.start < x)
          break;
        let ae = y.id >= a ? 4 : 0, Oe = y.start;
        for (y.next(); y.pos > L; ) {
          if (y.size < 0)
            if (y.size == -3)
              ae += 4;
            else
              break e;
          else
            y.id >= a && (ae += 4);
          y.next();
        }
        T = Oe, v += Z, _ += ae;
      }
    return (S < 0 || v == P) && (k.size = v, k.start = T, k.skip = _), k.size > 4 ? k : void 0;
  }
  function g(P, S, y) {
    let { id: v, start: T, end: _, size: x } = o;
    if (o.next(), x >= 0 && v < a) {
      let k = y;
      if (x > 4) {
        let Y = o.pos - (x - 4);
        for (; o.pos > Y; )
          y = g(P, S, y);
      }
      S[--y] = k, S[--y] = _ - P, S[--y] = T - P, S[--y] = v;
    } else
      x == -3 ? l = v : x == -4 && (c = v);
    return y;
  }
  let Q = [], m = [];
  for (; o.pos > 0; )
    u(t.start || 0, t.bufferStart || 0, Q, m, -1);
  let b = (e = t.length) !== null && e !== void 0 ? e : Q.length ? m[0] + Q[0].length : 0;
  return new ve(s[t.topID], Q.reverse(), m.reverse(), b);
}
var Ig = /* @__PURE__ */ new WeakMap();
function Yl(t, e) {
  if (!t.isAnonymous || e instanceof fr || e.type != t)
    return 1;
  let i = Ig.get(e);
  if (i == null) {
    i = 1;
    for (let n of e.children) {
      if (n.type != t || !(n instanceof ve)) {
        i = 1;
        break;
      }
      i += Yl(t, n);
    }
    Ig.set(e, i);
  }
  return i;
}
function Up(t, e, i, n, O, r, a, o, s) {
  let l = 0;
  for (let p = n; p < O; p++)
    l += Yl(t, e[p]);
  let c = Math.ceil(
    l * 1.5 / 8
    /* Balance.BranchFactor */
  ), u = [], h10 = [];
  function d(p, $, g, Q, m) {
    for (let b = g; b < Q; ) {
      let P = b, S = $[b], y = Yl(t, p[b]);
      for (b++; b < Q; b++) {
        let v = Yl(t, p[b]);
        if (y + v >= c)
          break;
        y += v;
      }
      if (b == P + 1) {
        if (y > c) {
          let v = p[P];
          d(v.children, v.positions, 0, v.children.length, $[P] + m);
          continue;
        }
        u.push(p[P]);
      } else {
        let v = $[b - 1] + p[b - 1].length - S;
        u.push(Up(t, p, $, P, b, S, v, null, s));
      }
      h10.push(S + m - r);
    }
  }
  return d(e, i, n, O, 0), (o || s)(u, h10, a);
}
var P1 = class {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, i, n) {
    let O = this.map.get(e);
    O || this.map.set(e, O = /* @__PURE__ */ new Map()), O.set(i, n);
  }
  getBuffer(e, i) {
    let n = this.map.get(e);
    return n && n.get(i);
  }
  /// Set the value for this syntax node.
  set(e, i) {
    e instanceof $n ? this.setBuffer(e.context.buffer, e.index, i) : e instanceof Ri && this.map.set(e.tree, i);
  }
  /// Retrieve value for this syntax node, if it exists in the map.
  get(e) {
    return e instanceof $n ? this.getBuffer(e.context.buffer, e.index) : e instanceof Ri ? this.map.get(e.tree) : void 0;
  }
  /// Set the value for the node that a cursor currently points to.
  cursorSet(e, i) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, i) : this.map.set(e.tree, i);
  }
  /// Retrieve the value for the node that a cursor currently points
  /// to.
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
};
var Cn = class {
  /// Construct a tree fragment. You'll usually want to use
  /// [`addTree`](#common.TreeFragment^addTree) and
  /// [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  /// calling this directly.
  constructor(e, i, n, O, r = false, a = false) {
    this.from = e, this.to = i, this.tree = n, this.offset = O, this.open = (r ? 1 : 0) | (a ? 2 : 0);
  }
  /// Whether the start of the fragment represents the start of a
  /// parse, or the end of a change. (In the second case, it may not
  /// be safe to reuse some nodes at the start, depending on the
  /// parsing algorithm.)
  get openStart() {
    return (this.open & 1) > 0;
  }
  /// Whether the end of the fragment represents the end of a
  /// full-document parse, or the start of a change.
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /// Create a set of fragments from a freshly parsed tree, or update
  /// an existing set of fragments by replacing the ones that overlap
  /// with a tree with content from the new tree. When `partial` is
  /// true, the parse is treated as incomplete, and the resulting
  /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  /// true.
  static addTree(e, i = [], n = false) {
    let O = [new Cn(0, e.length, e, 0, false, n)];
    for (let r of i)
      r.to > e.length && O.push(r);
    return O;
  }
  /// Apply a set of edits to an array of fragments, removing or
  /// splitting fragments as necessary to remove edited ranges, and
  /// adjusting offsets for fragments that moved.
  static applyChanges(e, i, n = 128) {
    if (!i.length)
      return e;
    let O = [], r = 1, a = e.length ? e[0] : null;
    for (let o = 0, s = 0, l = 0; ; o++) {
      let c = o < i.length ? i[o] : null, u = c ? c.fromA : 1e9;
      if (u - s >= n)
        for (; a && a.from < u; ) {
          let h10 = a;
          if (s >= h10.from || u <= h10.to || l) {
            let d = Math.max(h10.from, s) - l, p = Math.min(h10.to, u) - l;
            h10 = d >= p ? null : new Cn(d, p, h10.tree, h10.offset + l, o > 0, !!c);
          }
          if (h10 && O.push(h10), a.to > u)
            break;
          a = r < e.length ? e[r++] : null;
        }
      if (!c)
        break;
      s = c.toA, l = c.toA - c.toB;
    }
    return O;
  }
};
var Hc = class {
  /// Start a parse, returning a [partial parse](#common.PartialParse)
  /// object. [`fragments`](#common.TreeFragment) can be passed in to
  /// make the parse incremental.
  ///
  /// By default, the entire input is parsed. You can pass `ranges`,
  /// which should be a sorted array of non-empty, non-overlapping
  /// ranges, to parse only those ranges. The tree returned in that
  /// case will start at `ranges[0].from`.
  startParse(e, i, n) {
    return typeof e == "string" && (e = new aR(e)), n = n ? n.length ? n.map((O) => new Wi(O.from, O.to)) : [new Wi(0, 0)] : [new Wi(0, e.length)], this.createParse(e, i || [], n);
  }
  /// Run a full parse, returning the resulting tree.
  parse(e, i, n) {
    let O = this.startParse(e, i, n);
    for (; ; ) {
      let r = O.advance();
      if (r)
        return r;
    }
  }
};
var aR = class {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return false;
  }
  read(e, i) {
    return this.string.slice(e, i);
  }
};
function Vp(t) {
  return (e, i, n, O) => new sR(e, t, i, n, O);
}
var Ag = class {
  constructor(e, i, n, O, r) {
    this.parser = e, this.parse = i, this.overlay = n, this.target = O, this.ranges = r;
  }
};
var oR = class {
  constructor(e, i, n, O, r, a, o) {
    this.parser = e, this.predicate = i, this.mounts = n, this.index = O, this.start = r, this.target = a, this.prev = o, this.depth = 0, this.ranges = [];
  }
};
var Kh = new se({ perNode: true });
var sR = class {
  constructor(e, i, n, O, r) {
    this.nest = i, this.input = n, this.fragments = O, this.ranges = r, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let n = this.baseParse.advance();
      if (!n)
        return null;
      if (this.baseParse = null, this.baseTree = n, this.startInner(), this.stoppedAt != null)
        for (let O of this.inner)
          O.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let n = this.baseTree;
      return this.stoppedAt != null && (n = new ve(n.type, n.children, n.positions, n.length, n.propValues.concat([[Kh, this.stoppedAt]]))), n;
    }
    let e = this.inner[this.innerDone], i = e.parse.advance();
    if (i) {
      this.innerDone++;
      let n = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      n[se.mounted.id] = new iR(i, e.overlay, e.parser), e.target.props = n;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let i = this.innerDone; i < this.inner.length; i++)
      this.inner[i].ranges[0].from < e && (e = Math.min(e, this.inner[i].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let i = this.innerDone; i < this.inner.length; i++)
        this.inner[i].parse.stopAt(e);
  }
  startInner() {
    let e = new uR(this.fragments), i = null, n = null, O = new Ko(new Ri(this.baseTree, this.ranges[0].from, 0, null), ze.IncludeAnonymous | ze.IgnoreMounts);
    e:
      for (let r, a; this.stoppedAt == null || O.from < this.stoppedAt; ) {
        let o = true, s;
        if (e.hasNode(O)) {
          if (i) {
            let l = i.mounts.find((c) => c.frag.from <= O.from && c.frag.to >= O.to && c.mount.overlay);
            if (l)
              for (let c of l.mount.overlay) {
                let u = c.from + l.pos, h10 = c.to + l.pos;
                u >= O.from && h10 <= O.to && !i.ranges.some((d) => d.from < h10 && d.to > u) && i.ranges.push({ from: u, to: h10 });
              }
          }
          o = false;
        } else if (n && (a = lR(n.ranges, O.from, O.to)))
          o = a != 2;
        else if (!O.type.isAnonymous && O.from < O.to && (r = this.nest(O, this.input))) {
          O.tree || cR(O);
          let l = e.findMounts(O.from, r.parser);
          if (typeof r.overlay == "function")
            i = new oR(r.parser, r.overlay, l, this.inner.length, O.from, O.tree, i);
          else {
            let c = Dg(this.ranges, r.overlay || [new Wi(O.from, O.to)]);
            c.length && this.inner.push(new Ag(r.parser, r.parser.startParse(this.input, Mg(l, c), c), r.overlay ? r.overlay.map((u) => new Wi(u.from - O.from, u.to - O.from)) : null, O.tree, c)), r.overlay ? c.length && (n = { ranges: c, depth: 0, prev: n }) : o = false;
          }
        } else
          i && (s = i.predicate(O)) && (s === true && (s = new Wi(O.from, O.to)), s.from < s.to && i.ranges.push(s));
        if (o && O.firstChild())
          i && i.depth++, n && n.depth++;
        else
          for (; !O.nextSibling(); ) {
            if (!O.parent())
              break e;
            if (i && !--i.depth) {
              let l = Dg(this.ranges, i.ranges);
              l.length && this.inner.splice(i.index, 0, new Ag(i.parser, i.parser.startParse(this.input, Mg(i.mounts, l), l), i.ranges.map((c) => new Wi(c.from - i.start, c.to - i.start)), i.target, l)), i = i.prev;
            }
            n && !--n.depth && (n = n.prev);
          }
      }
  }
};
function lR(t, e, i) {
  for (let n of t) {
    if (n.from >= i)
      break;
    if (n.to > e)
      return n.from <= e && n.to >= i ? 2 : 1;
  }
  return 0;
}
function Gg(t, e, i, n, O, r) {
  if (e < i) {
    let a = t.buffer[e + 1];
    n.push(t.slice(e, i, a)), O.push(a - r);
  }
}
function cR(t) {
  let { node: e } = t, i = 0;
  do
    t.parent(), i++;
  while (!t.tree);
  let n = 0, O = t.tree, r = 0;
  for (; r = O.positions[n] + t.from, !(r <= e.from && r + O.children[n].length >= e.to); n++)
    ;
  let a = O.children[n], o = a.buffer;
  function s(l, c, u, h10, d) {
    let p = l;
    for (; o[p + 2] + r <= e.from; )
      p = o[p + 3];
    let $ = [], g = [];
    Gg(a, l, p, $, g, h10);
    let Q = o[p + 1], m = o[p + 2], b = Q + r == e.from && m + r == e.to && o[p] == e.type.id;
    return $.push(b ? e.toTree() : s(p + 4, o[p + 3], a.set.types[o[p]], Q, m - Q)), g.push(Q - h10), Gg(a, o[p + 3], c, $, g, h10), new ve(u, $, g, d);
  }
  O.children[n] = s(0, o.length, lt.none, 0, a.length);
  for (let l = 0; l <= i; l++)
    t.childAfter(e.from);
}
var Lg = class {
  constructor(e, i) {
    this.offset = i, this.done = false, this.cursor = e.cursor(ze.IncludeAnonymous | ze.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: i } = this, n = e - this.offset;
    for (; !this.done && i.from < n; )
      i.to >= e && i.enter(n, 1, ze.IgnoreOverlays | ze.ExcludeBuffers) || i.next(false) || (this.done = true);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let i = this.cursor.tree; ; ) {
        if (i == e.tree)
          return true;
        if (i.children.length && i.positions[0] == 0 && i.children[0] instanceof ve)
          i = i.children[0];
        else
          break;
      }
    return false;
  }
};
var uR = class {
  constructor(e) {
    var i;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let n = this.curFrag = e[0];
      this.curTo = (i = n.tree.prop(Kh)) !== null && i !== void 0 ? i : n.to, this.inner = new Lg(n.tree, -n.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let i = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = i.tree.prop(Kh)) !== null && e !== void 0 ? e : i.to, this.inner = new Lg(i.tree, -i.offset);
    }
  }
  findMounts(e, i) {
    var n;
    let O = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let r = this.inner.cursor.node; r; r = r.parent) {
        let a = (n = r.tree) === null || n === void 0 ? void 0 : n.prop(se.mounted);
        if (a && a.parser == i)
          for (let o = this.fragI; o < this.fragments.length; o++) {
            let s = this.fragments[o];
            if (s.from >= r.to)
              break;
            s.tree == this.curFrag.tree && O.push({
              frag: s,
              pos: r.from - s.offset,
              mount: a
            });
          }
      }
    }
    return O;
  }
};
function Dg(t, e) {
  let i = null, n = e;
  for (let O = 1, r = 0; O < t.length; O++) {
    let a = t[O - 1].to, o = t[O].from;
    for (; r < n.length; r++) {
      let s = n[r];
      if (s.from >= o)
        break;
      s.to <= a || (i || (n = i = e.slice()), s.from < a ? (i[r] = new Wi(s.from, a), s.to > o && i.splice(r + 1, 0, new Wi(o, s.to))) : s.to > o ? i[r--] = new Wi(o, s.to) : i.splice(r--, 1));
    }
  }
  return n;
}
function fR(t, e, i, n) {
  let O = 0, r = 0, a = false, o = false, s = -1e9, l = [];
  for (; ; ) {
    let c = O == t.length ? 1e9 : a ? t[O].to : t[O].from, u = r == e.length ? 1e9 : o ? e[r].to : e[r].from;
    if (a != o) {
      let h10 = Math.max(s, i), d = Math.min(c, u, n);
      h10 < d && l.push(new Wi(h10, d));
    }
    if (s = Math.min(c, u), s == 1e9)
      break;
    c == s && (a ? (a = false, O++) : a = true), u == s && (o ? (o = false, r++) : o = true);
  }
  return l;
}
function Mg(t, e) {
  let i = [];
  for (let { pos: n, mount: O, frag: r } of t) {
    let a = n + (O.overlay ? O.overlay[0].from : 0), o = a + O.tree.length, s = Math.max(r.from, a), l = Math.min(r.to, o);
    if (O.overlay) {
      let c = O.overlay.map((h10) => new Wi(h10.from + n, h10.to + n)), u = fR(e, c, s, l);
      for (let h10 = 0, d = s; ; h10++) {
        let p = h10 == u.length, $ = p ? l : u[h10].from;
        if ($ > d && i.push(new Cn(d, $, O.tree, -a, r.from >= d || r.openStart, r.to <= $ || r.openEnd)), p)
          break;
        d = u[h10].to;
      }
    } else
      i.push(new Cn(s, l, O.tree, -a, r.from >= a || r.openStart, r.to <= o || r.openEnd));
  }
  return i;
}
var hR = 0;
var Hi = class {
  /// @internal
  constructor(e, i, n) {
    this.set = e, this.base = i, this.modified = n, this.id = hR++;
  }
  /// Define a new tag. If `parent` is given, the tag is treated as a
  /// sub-tag of that parent, and
  /// [highlighters](#highlight.tagHighlighter) that don't mention
  /// this tag will try to fall back to the parent tag (or grandparent
  /// tag, etc).
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let i = new Hi([], null, []);
    if (i.set.push(i), e)
      for (let n of e.set)
        i.set.push(n);
    return i;
  }
  /// Define a tag _modifier_, which is a function that, given a tag,
  /// will return a tag that is a subtag of the original. Applying the
  /// same modifier to a twice tag will return the same value (`m1(t1)
  /// == m1(t1)`) and applying multiple modifiers will, regardless or
  /// order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  ///
  /// When multiple modifiers are applied to a given base tag, each
  /// smaller set of modifiers is registered as a parent, so that for
  /// example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  /// `m1(m3(t1)`, and so on.
  static defineModifier() {
    let e = new ec();
    return (i) => i.modified.indexOf(e) > -1 ? i : ec.get(i.base || i, i.modified.concat(e).sort((n, O) => n.id - O.id));
  }
};
var dR = 0;
var ec = class {
  constructor() {
    this.instances = [], this.id = dR++;
  }
  static get(e, i) {
    if (!i.length)
      return e;
    let n = i[0].instances.find((o) => o.base == e && pR(i, o.modified));
    if (n)
      return n;
    let O = [], r = new Hi(O, e, i);
    for (let o of i)
      o.instances.push(r);
    let a = $R(i);
    for (let o of e.set)
      if (!o.modified.length)
        for (let s of a)
          O.push(ec.get(o, s));
    return r;
  }
};
function pR(t, e) {
  return t.length == e.length && t.every((i, n) => i == e[n]);
}
function $R(t) {
  let e = [[]];
  for (let i = 0; i < t.length; i++)
    for (let n = 0, O = e.length; n < O; n++)
      e.push(e[n].concat(t[i]));
  return e.sort((i, n) => n.length - i.length);
}
function ti(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let i in t) {
    let n = t[i];
    Array.isArray(n) || (n = [n]);
    for (let O of i.split(" "))
      if (O) {
        let r = [], a = 2, o = O;
        for (let u = 0; ; ) {
          if (o == "..." && u > 0 && u + 3 == O.length) {
            a = 1;
            break;
          }
          let h10 = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(o);
          if (!h10)
            throw new RangeError("Invalid path: " + O);
          if (r.push(h10[0] == "*" ? "" : h10[0][0] == '"' ? JSON.parse(h10[0]) : h10[0]), u += h10[0].length, u == O.length)
            break;
          let d = O[u++];
          if (u == O.length && d == "!") {
            a = 0;
            break;
          }
          if (d != "/")
            throw new RangeError("Invalid path: " + O);
          o = O.slice(u);
        }
        let s = r.length - 1, l = r[s];
        if (!l)
          throw new RangeError("Invalid path: " + O);
        let c = new tc(n, a, s > 0 ? r.slice(0, s) : null);
        e[l] = c.sort(e[l]);
      }
  }
  return y1.add(e);
}
var y1 = new se();
var tc = class {
  constructor(e, i, n, O) {
    this.tags = e, this.mode = i, this.context = n, this.next = O;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
tc.empty = new tc([], 2, null);
function b1(t, e) {
  let i = /* @__PURE__ */ Object.create(null);
  for (let r of t)
    if (!Array.isArray(r.tag))
      i[r.tag.id] = r.class;
    else
      for (let a of r.tag)
        i[a.id] = r.class;
  let { scope: n, all: O = null } = e || {};
  return {
    style: (r) => {
      let a = O;
      for (let o of r)
        for (let s of o.set) {
          let l = i[s.id];
          if (l) {
            a = a ? a + " " + l : l;
            break;
          }
        }
      return a;
    },
    scope: n
  };
}
function QR(t, e) {
  let i = null;
  for (let n of t) {
    let O = n.style(e);
    O && (i = i ? i + " " + O : O);
  }
  return i;
}
function gR(t, e, i, n = 0, O = t.length) {
  let r = new mR(n, Array.isArray(e) ? e : [e], i);
  r.highlightRange(t.cursor(), n, O, "", r.highlighters), r.flush(O);
}
var mR = class {
  constructor(e, i, n) {
    this.at = e, this.highlighters = i, this.span = n, this.class = "";
  }
  startSpan(e, i) {
    i != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = i);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, i, n, O, r) {
    let { type: a, from: o, to: s } = e;
    if (o >= n || s <= i)
      return;
    a.isTop && (r = this.highlighters.filter((d) => !d.scope || d.scope(a)));
    let l = O, c = SR(e) || tc.empty, u = QR(r, c.tags);
    if (u && (l && (l += " "), l += u, c.mode == 1 && (O += (O ? " " : "") + u)), this.startSpan(e.from, l), c.opaque)
      return;
    let h10 = e.tree && e.tree.prop(se.mounted);
    if (h10 && h10.overlay) {
      let d = e.node.enter(h10.overlay[0].from + o, 1), p = this.highlighters.filter((g) => !g.scope || g.scope(h10.tree.type)), $ = e.firstChild();
      for (let g = 0, Q = o; ; g++) {
        let m = g < h10.overlay.length ? h10.overlay[g] : null, b = m ? m.from + o : s, P = Math.max(i, Q), S = Math.min(n, b);
        if (P < S && $)
          for (; e.from < S && (this.highlightRange(e, P, S, O, r), this.startSpan(Math.min(S, e.to), l), !(e.to >= b || !e.nextSibling())); )
            ;
        if (!m || b > n)
          break;
        Q = m.to + o, Q > i && (this.highlightRange(d.cursor(), Math.max(i, m.from + o), Math.min(n, Q), O, p), this.startSpan(Q, l));
      }
      $ && e.parent();
    } else if (e.firstChild()) {
      do
        if (!(e.to <= i)) {
          if (e.from >= n)
            break;
          this.highlightRange(e, i, n, O, r), this.startSpan(Math.min(n, e.to), l);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
};
function SR(t) {
  let e = t.type.prop(y1);
  for (; e && e.context && !t.matchContext(e.context); )
    e = e.next;
  return e || null;
}
var I = Hi.define;
var Fs = I();
var OO = I();
var Ng = I(OO);
var Bg = I(OO);
var rO = I();
var Hs = I(rO);
var nf = I(rO);
var hn = I();
var UO = I(hn);
var cn = I();
var un = I();
var Jh = I();
var La = I(Jh);
var Ks = I();
var f = {
  /// A comment.
  comment: Fs,
  /// A line [comment](#highlight.tags.comment).
  lineComment: I(Fs),
  /// A block [comment](#highlight.tags.comment).
  blockComment: I(Fs),
  /// A documentation [comment](#highlight.tags.comment).
  docComment: I(Fs),
  /// Any kind of identifier.
  name: OO,
  /// The [name](#highlight.tags.name) of a variable.
  variableName: I(OO),
  /// A type [name](#highlight.tags.name).
  typeName: Ng,
  /// A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  tagName: I(Ng),
  /// A property or field [name](#highlight.tags.name).
  propertyName: Bg,
  /// An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  attributeName: I(Bg),
  /// The [name](#highlight.tags.name) of a class.
  className: I(OO),
  /// A label [name](#highlight.tags.name).
  labelName: I(OO),
  /// A namespace [name](#highlight.tags.name).
  namespace: I(OO),
  /// The [name](#highlight.tags.name) of a macro.
  macroName: I(OO),
  /// A literal value.
  literal: rO,
  /// A string [literal](#highlight.tags.literal).
  string: Hs,
  /// A documentation [string](#highlight.tags.string).
  docString: I(Hs),
  /// A character literal (subtag of [string](#highlight.tags.string)).
  character: I(Hs),
  /// An attribute value (subtag of [string](#highlight.tags.string)).
  attributeValue: I(Hs),
  /// A number [literal](#highlight.tags.literal).
  number: nf,
  /// An integer [number](#highlight.tags.number) literal.
  integer: I(nf),
  /// A floating-point [number](#highlight.tags.number) literal.
  float: I(nf),
  /// A boolean [literal](#highlight.tags.literal).
  bool: I(rO),
  /// Regular expression [literal](#highlight.tags.literal).
  regexp: I(rO),
  /// An escape [literal](#highlight.tags.literal), for example a
  /// backslash escape in a string.
  escape: I(rO),
  /// A color [literal](#highlight.tags.literal).
  color: I(rO),
  /// A URL [literal](#highlight.tags.literal).
  url: I(rO),
  /// A language keyword.
  keyword: cn,
  /// The [keyword](#highlight.tags.keyword) for the self or this
  /// object.
  self: I(cn),
  /// The [keyword](#highlight.tags.keyword) for null.
  null: I(cn),
  /// A [keyword](#highlight.tags.keyword) denoting some atomic value.
  atom: I(cn),
  /// A [keyword](#highlight.tags.keyword) that represents a unit.
  unit: I(cn),
  /// A modifier [keyword](#highlight.tags.keyword).
  modifier: I(cn),
  /// A [keyword](#highlight.tags.keyword) that acts as an operator.
  operatorKeyword: I(cn),
  /// A control-flow related [keyword](#highlight.tags.keyword).
  controlKeyword: I(cn),
  /// A [keyword](#highlight.tags.keyword) that defines something.
  definitionKeyword: I(cn),
  /// A [keyword](#highlight.tags.keyword) related to defining or
  /// interfacing with modules.
  moduleKeyword: I(cn),
  /// An operator.
  operator: un,
  /// An [operator](#highlight.tags.operator) that dereferences something.
  derefOperator: I(un),
  /// Arithmetic-related [operator](#highlight.tags.operator).
  arithmeticOperator: I(un),
  /// Logical [operator](#highlight.tags.operator).
  logicOperator: I(un),
  /// Bit [operator](#highlight.tags.operator).
  bitwiseOperator: I(un),
  /// Comparison [operator](#highlight.tags.operator).
  compareOperator: I(un),
  /// [Operator](#highlight.tags.operator) that updates its operand.
  updateOperator: I(un),
  /// [Operator](#highlight.tags.operator) that defines something.
  definitionOperator: I(un),
  /// Type-related [operator](#highlight.tags.operator).
  typeOperator: I(un),
  /// Control-flow [operator](#highlight.tags.operator).
  controlOperator: I(un),
  /// Program or markup punctuation.
  punctuation: Jh,
  /// [Punctuation](#highlight.tags.punctuation) that separates
  /// things.
  separator: I(Jh),
  /// Bracket-style [punctuation](#highlight.tags.punctuation).
  bracket: La,
  /// Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  /// tokens).
  angleBracket: I(La),
  /// Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  /// tokens).
  squareBracket: I(La),
  /// Parentheses (usually `(` and `)` tokens). Subtag of
  /// [bracket](#highlight.tags.bracket).
  paren: I(La),
  /// Braces (usually `{` and `}` tokens). Subtag of
  /// [bracket](#highlight.tags.bracket).
  brace: I(La),
  /// Content, for example plain text in XML or markup documents.
  content: hn,
  /// [Content](#highlight.tags.content) that represents a heading.
  heading: UO,
  /// A level 1 [heading](#highlight.tags.heading).
  heading1: I(UO),
  /// A level 2 [heading](#highlight.tags.heading).
  heading2: I(UO),
  /// A level 3 [heading](#highlight.tags.heading).
  heading3: I(UO),
  /// A level 4 [heading](#highlight.tags.heading).
  heading4: I(UO),
  /// A level 5 [heading](#highlight.tags.heading).
  heading5: I(UO),
  /// A level 6 [heading](#highlight.tags.heading).
  heading6: I(UO),
  /// A prose separator (such as a horizontal rule).
  contentSeparator: I(hn),
  /// [Content](#highlight.tags.content) that represents a list.
  list: I(hn),
  /// [Content](#highlight.tags.content) that represents a quote.
  quote: I(hn),
  /// [Content](#highlight.tags.content) that is emphasized.
  emphasis: I(hn),
  /// [Content](#highlight.tags.content) that is styled strong.
  strong: I(hn),
  /// [Content](#highlight.tags.content) that is part of a link.
  link: I(hn),
  /// [Content](#highlight.tags.content) that is styled as code or
  /// monospace.
  monospace: I(hn),
  /// [Content](#highlight.tags.content) that has a strike-through
  /// style.
  strikethrough: I(hn),
  /// Inserted text in a change-tracking format.
  inserted: I(),
  /// Deleted text.
  deleted: I(),
  /// Changed text.
  changed: I(),
  /// An invalid or unsyntactic element.
  invalid: I(),
  /// Metadata or meta-instruction.
  meta: Ks,
  /// [Metadata](#highlight.tags.meta) that applies to the entire
  /// document.
  documentMeta: I(Ks),
  /// [Metadata](#highlight.tags.meta) that annotates or adds
  /// attributes to a given syntactic element.
  annotation: I(Ks),
  /// Processing instruction or preprocessor directive. Subtag of
  /// [meta](#highlight.tags.meta).
  processingInstruction: I(Ks),
  /// [Modifier](#highlight.Tag^defineModifier) that indicates that a
  /// given element is being defined. Expected to be used with the
  /// various [name](#highlight.tags.name) tags.
  definition: Hi.defineModifier(),
  /// [Modifier](#highlight.Tag^defineModifier) that indicates that
  /// something is constant. Mostly expected to be used with
  /// [variable names](#highlight.tags.variableName).
  constant: Hi.defineModifier(),
  /// [Modifier](#highlight.Tag^defineModifier) used to indicate that
  /// a [variable](#highlight.tags.variableName) or [property
  /// name](#highlight.tags.propertyName) is being called or defined
  /// as a function.
  function: Hi.defineModifier(),
  /// [Modifier](#highlight.Tag^defineModifier) that can be applied to
  /// [names](#highlight.tags.name) to indicate that they belong to
  /// the language's standard environment.
  standard: Hi.defineModifier(),
  /// [Modifier](#highlight.Tag^defineModifier) that indicates a given
  /// [names](#highlight.tags.name) is local to some scope.
  local: Hi.defineModifier(),
  /// A generic variant [modifier](#highlight.Tag^defineModifier) that
  /// can be used to tag language-specific alternative variants of
  /// some common tag. It is recommended for themes to define special
  /// forms of at least the [string](#highlight.tags.string) and
  /// [variable name](#highlight.tags.variableName) tags, since those
  /// come up a lot.
  special: Hi.defineModifier()
};
b1([
  { tag: f.link, class: "tok-link" },
  { tag: f.heading, class: "tok-heading" },
  { tag: f.emphasis, class: "tok-emphasis" },
  { tag: f.strong, class: "tok-strong" },
  { tag: f.keyword, class: "tok-keyword" },
  { tag: f.atom, class: "tok-atom" },
  { tag: f.bool, class: "tok-bool" },
  { tag: f.url, class: "tok-url" },
  { tag: f.labelName, class: "tok-labelName" },
  { tag: f.inserted, class: "tok-inserted" },
  { tag: f.deleted, class: "tok-deleted" },
  { tag: f.literal, class: "tok-literal" },
  { tag: f.string, class: "tok-string" },
  { tag: f.number, class: "tok-number" },
  { tag: [f.regexp, f.escape, f.special(f.string)], class: "tok-string2" },
  { tag: f.variableName, class: "tok-variableName" },
  { tag: f.local(f.variableName), class: "tok-variableName tok-local" },
  { tag: f.definition(f.variableName), class: "tok-variableName tok-definition" },
  { tag: f.special(f.variableName), class: "tok-variableName2" },
  { tag: f.definition(f.propertyName), class: "tok-propertyName tok-definition" },
  { tag: f.typeName, class: "tok-typeName" },
  { tag: f.namespace, class: "tok-namespace" },
  { tag: f.className, class: "tok-className" },
  { tag: f.macroName, class: "tok-macroName" },
  { tag: f.propertyName, class: "tok-propertyName" },
  { tag: f.operator, class: "tok-operator" },
  { tag: f.comment, class: "tok-comment" },
  { tag: f.meta, class: "tok-meta" },
  { tag: f.invalid, class: "tok-invalid" },
  { tag: f.punctuation, class: "tok-punctuation" }
]);
var Of;
var uO = new se();
function Kc(t) {
  return K.define({
    combine: t ? (e) => e.concat(t) : void 0
  });
}
var qp = new se();
var gi = class {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, i, n = [], O = "") {
    this.data = e, this.name = O, ye.prototype.hasOwnProperty("tree") || Object.defineProperty(ye.prototype, "tree", { get() {
      return Ye(this);
    } }), this.parser = i, this.extension = [
      PO.of(this),
      ye.languageData.of((r, a, o) => {
        let s = Fg(r, a, o), l = s.type.prop(uO);
        if (!l)
          return [];
        let c = r.facet(l), u = s.type.prop(qp);
        if (u) {
          let h10 = s.resolve(a - s.from, o);
          for (let d of u)
            if (d.test(h10, r)) {
              let p = r.facet(d.facet);
              return d.type == "replace" ? p : p.concat(c);
            }
        }
        return c;
      })
    ].concat(n);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, i, n = -1) {
    return Fg(e, i, n).type.prop(uO) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let i = e.facet(PO);
    if ((i == null ? void 0 : i.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!i || !i.allowsNesting)
      return [];
    let n = [], O = (r, a) => {
      if (r.prop(uO) == this.data) {
        n.push({ from: a, to: a + r.length });
        return;
      }
      let o = r.prop(se.mounted);
      if (o) {
        if (o.tree.prop(uO) == this.data) {
          if (o.overlay)
            for (let s of o.overlay)
              n.push({ from: s.from + a, to: s.to + a });
          else
            n.push({ from: a, to: a + r.length });
          return;
        } else if (o.overlay) {
          let s = n.length;
          if (O(o.tree, o.overlay[0].from + a), n.length > s)
            return;
        }
      }
      for (let s = 0; s < r.children.length; s++) {
        let l = r.children[s];
        l instanceof ve && O(l, r.positions[s] + a);
      }
    };
    return O(Ye(e), 0), n;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return true;
  }
};
gi.setState = fe.define();
function Fg(t, e, i) {
  let n = t.facet(PO), O = Ye(t).topNode;
  if (!n || n.allowsNesting)
    for (let r = O; r; r = r.enter(e, i, ze.ExcludeBuffers))
      r.type.isTop && (O = r);
  return O;
}
var Kt = class extends gi {
  constructor(e, i, n) {
    super(e, i, [], n), this.parser = i;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let i = Kc(e.languageData);
    return new Kt(i, e.parser.configure({
      props: [uO.add((n) => n.isTop ? i : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, i) {
    return new Kt(this.data, this.parser.configure(e), i || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
};
function Ye(t) {
  let e = t.field(gi.state, false);
  return e ? e.tree : ve.empty;
}
var PR = class {
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return true;
  }
  read(e, i) {
    let n = this.cursorPos - this.string.length;
    return e < n || i >= this.cursorPos ? this.doc.sliceString(e, i) : this.string.slice(e - n, i - n);
  }
};
var Da = null;
var er = class {
  constructor(e, i, n = [], O, r, a, o, s) {
    this.parser = e, this.state = i, this.fragments = n, this.tree = O, this.treeLen = r, this.viewport = a, this.skipped = o, this.scheduleOn = s, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, i, n) {
    return new er(e, i, [], ve.empty, 0, n, [], null);
  }
  startParse() {
    return this.parser.startParse(new PR(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, i) {
    return i != null && i >= this.state.doc.length && (i = void 0), this.tree != ve.empty && this.isDone(i ?? this.state.doc.length) ? (this.takeTree(), true) : this.withContext(() => {
      var n;
      if (typeof e == "number") {
        let O = Date.now() + e;
        e = () => Date.now() > O;
      }
      for (this.parse || (this.parse = this.startParse()), i != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > i) && i < this.state.doc.length && this.parse.stopAt(i); ; ) {
        let O = this.parse.advance();
        if (O)
          if (this.fragments = this.withoutTempSkipped(Cn.addTree(O, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (n = this.parse.stoppedAt) !== null && n !== void 0 ? n : this.state.doc.length, this.tree = O, this.parse = null, this.treeLen < (i ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return true;
        if (e())
          return false;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, i;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(i = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = i, this.fragments = this.withoutTempSkipped(Cn.addTree(this.tree, this.fragments, true)), this.parse = null);
  }
  withContext(e) {
    let i = Da;
    Da = this;
    try {
      return e();
    } finally {
      Da = i;
    }
  }
  withoutTempSkipped(e) {
    for (let i; i = this.tempSkipped.pop(); )
      e = Hg(e, i.from, i.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, i) {
    let { fragments: n, tree: O, treeLen: r, viewport: a, skipped: o } = this;
    if (this.takeTree(), !e.empty) {
      let s = [];
      if (e.iterChangedRanges((l, c, u, h10) => s.push({ fromA: l, toA: c, fromB: u, toB: h10 })), n = Cn.applyChanges(n, s), O = ve.empty, r = 0, a = { from: e.mapPos(a.from, -1), to: e.mapPos(a.to, 1) }, this.skipped.length) {
        o = [];
        for (let l of this.skipped) {
          let c = e.mapPos(l.from, 1), u = e.mapPos(l.to, -1);
          c < u && o.push({ from: c, to: u });
        }
      }
    }
    return new er(this.parser, i, n, O, r, a, o, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return false;
    this.viewport = e;
    let i = this.skipped.length;
    for (let n = 0; n < this.skipped.length; n++) {
      let { from: O, to: r } = this.skipped[n];
      O < e.to && r > e.from && (this.fragments = Hg(this.fragments, O, r), this.skipped.splice(n--, 1));
    }
    return this.skipped.length >= i ? false : (this.reset(), true);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, i) {
    this.skipped.push({ from: e, to: i });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends Hc {
      createParse(i, n, O) {
        let r = O[0].from, a = O[O.length - 1].to;
        return {
          parsedPos: r,
          advance() {
            let s = Da;
            if (s) {
              for (let l of O)
                s.tempSkipped.push(l);
              e && (s.scheduleOn = s.scheduleOn ? Promise.all([s.scheduleOn, e]) : e);
            }
            return this.parsedPos = a, new ve(lt.none, [], [], a - r);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let i = this.fragments;
    return this.treeLen >= e && i.length && i[0].from == 0 && i[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Da;
  }
};
function Hg(t, e, i) {
  return Cn.applyChanges(t, [{ fromA: e, toA: i, fromB: e, toB: i }]);
}
var na = class {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let i = this.context.changes(e.changes, e.state), n = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), i.viewport.to);
    return i.work(20, n) || i.takeTree(), new na(i);
  }
  static init(e) {
    let i = Math.min(3e3, e.doc.length), n = er.create(e.facet(PO).parser, e, { from: 0, to: i });
    return n.work(20, i) || n.takeTree(), new na(n);
  }
};
gi.state = St.define({
  create: na.init,
  update(t, e) {
    for (let i of e.effects)
      if (i.is(gi.setState))
        return i.value;
    return e.startState.facet(PO) != e.state.facet(PO) ? na.init(e.state) : t.apply(e);
  }
});
var v1 = (t) => {
  let e = setTimeout(
    () => t(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (v1 = (t) => {
  let e = -1, i = setTimeout(
    () => {
      e = requestIdleCallback(t, {
        timeout: 500 - 100
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(i) : cancelIdleCallback(e);
});
var rf = typeof navigator < "u" && (!((Of = navigator.scheduling) === null || Of === void 0) && Of.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
var yR = it.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let i = this.view.state.field(gi.state).context;
    (i.updateViewport(e.view.viewport) || this.view.viewport.to > i.treeLen) && this.scheduleWork(), e.docChanged && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(i);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, i = e.field(gi.state);
    (i.tree != i.context.tree || !i.context.isDone(e.doc.length)) && (this.working = v1(this.work));
  }
  work(e) {
    this.working = null;
    let i = Date.now();
    if (this.chunkEnd < i && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = i + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: n, viewport: { to: O } } = this.view, r = n.field(gi.state);
    if (r.tree == r.context.tree && r.context.isDone(
      O + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let a = Date.now() + Math.min(this.chunkBudget, 100, e && !rf ? Math.max(25, e.timeRemaining() - 5) : 1e9), o = r.context.treeLen < O && n.doc.length > O + 1e3, s = r.context.work(() => rf && rf() || Date.now() > a, O + (o ? 0 : 1e5));
    this.chunkBudget -= Date.now() - i, (s || this.chunkBudget <= 0) && (r.context.takeTree(), this.view.dispatch({ effects: gi.setState.of(new na(r.context)) })), this.chunkBudget > 0 && !(s && !o) && this.scheduleWork(), this.checkAsyncSchedule(r.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((i) => Pi(this.view.state, i)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
});
var PO = K.define({
  combine(t) {
    return t.length ? t[0] : null;
  },
  enables: (t) => [
    gi.state,
    yR,
    B.contentAttributes.compute([t], (e) => {
      let i = e.facet(t);
      return i && i.name ? { "data-language": i.name } : {};
    })
  ]
});
var li = class {
  /**
  Create a language support object.
  */
  constructor(e, i = []) {
    this.language = e, this.support = i, this.extension = [e, i];
  }
};
var ic = class {
  constructor(e, i, n, O, r, a = void 0) {
    this.name = e, this.alias = i, this.extensions = n, this.filename = O, this.loadFunc = r, this.support = a, this.loading = null;
  }
  /**
  Start loading the the language. Will return a promise that
  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
  object when the language successfully loads.
  */
  load() {
    return this.loading || (this.loading = this.loadFunc().then((e) => this.support = e, (e) => {
      throw this.loading = null, e;
    }));
  }
  /**
  Create a language description.
  */
  static of(e) {
    let { load: i, support: n } = e;
    if (!i) {
      if (!n)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      i = () => Promise.resolve(n);
    }
    return new ic(e.name, (e.alias || []).concat(e.name).map((O) => O.toLowerCase()), e.extensions || [], e.filename, i, n);
  }
  /**
  Look for a language in the given array of descriptions that
  matches the filename. Will first match
  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
  and return the first language that matches.
  */
  static matchFilename(e, i) {
    for (let O of e)
      if (O.filename && O.filename.test(i))
        return O;
    let n = /\.([^.]+)$/.exec(i);
    if (n) {
      for (let O of e)
        if (O.extensions.indexOf(n[1]) > -1)
          return O;
    }
    return null;
  }
  /**
  Look for a language whose name or alias matches the the given
  name (case-insensitively). If `fuzzy` is true, and no direct
  matchs is found, this'll also search for a language whose name
  or alias occurs in the string (for names shorter than three
  characters, only when surrounded by non-word characters).
  */
  static matchLanguageName(e, i, n = true) {
    i = i.toLowerCase();
    for (let O of e)
      if (O.alias.some((r) => r == i))
        return O;
    if (n)
      for (let O of e)
        for (let r of O.alias) {
          let a = i.indexOf(r);
          if (a > -1 && (r.length > 2 || !/\w/.test(i[a - 1]) && !/\w/.test(i[a + r.length])))
            return O;
        }
    return null;
  }
};
var X1 = K.define();
var bs = K.define({
  combine: (t) => {
    if (!t.length)
      return "  ";
    let e = t[0];
    if (!e || /\S/.test(e) || Array.from(e).some((i) => i != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
    return e;
  }
});
function tr(t) {
  let e = t.facet(bs);
  return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
}
function Jo(t, e) {
  let i = "", n = t.tabSize, O = t.facet(bs)[0];
  if (O == "	") {
    for (; e >= n; )
      i += "	", e -= n;
    O = " ";
  }
  for (let r = 0; r < e; r++)
    i += O;
  return i;
}
function zp(t, e) {
  t instanceof ye && (t = new Jc(t));
  for (let n of t.state.facet(X1)) {
    let O = n(t, e);
    if (O !== void 0)
      return O;
  }
  let i = Ye(t.state);
  return i ? bR(t, i, e) : null;
}
var Jc = class {
  /**
  Create an indent context.
  */
  constructor(e, i = {}) {
    this.state = e, this.options = i, this.unit = tr(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, i = 1) {
    let n = this.state.doc.lineAt(e), { simulateBreak: O, simulateDoubleBreak: r } = this.options;
    return O != null && O >= n.from && O <= n.to ? r && O == e ? { text: "", from: e } : (i < 0 ? O < e : O <= e) ? { text: n.text.slice(O - n.from), from: O } : { text: n.text.slice(0, O - n.from), from: n.from } : n;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, i = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: n, from: O } = this.lineAt(e, i);
    return n.slice(e - O, Math.min(n.length, e + 100 - O));
  }
  /**
  Find the column for the given position.
  */
  column(e, i = 1) {
    let { text: n, from: O } = this.lineAt(e, i), r = this.countColumn(n, e - O), a = this.options.overrideIndentation ? this.options.overrideIndentation(O) : -1;
    return a > -1 && (r += a - this.countColumn(n, n.search(/\S|$/))), r;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, i = e.length) {
    return Ss(e, this.state.tabSize, i);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, i = 1) {
    let { text: n, from: O } = this.lineAt(e, i), r = this.options.overrideIndentation;
    if (r) {
      let a = r(O);
      if (a > -1)
        return a;
    }
    return this.countColumn(n, n.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
};
var ci = new se();
function bR(t, e, i) {
  return x1(e.resolveInner(i).enterUnfinishedNodesBefore(i), i, t);
}
function vR(t) {
  return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
}
function XR(t) {
  let e = t.type.prop(ci);
  if (e)
    return e;
  let i = t.firstChild, n;
  if (i && (n = i.type.prop(se.closedBy))) {
    let O = t.lastChild, r = O && n.indexOf(O.name) > -1;
    return (a) => w1(a, true, 1, void 0, r && !vR(a) ? O.from : void 0);
  }
  return t.parent == null ? xR : null;
}
function x1(t, e, i) {
  for (; t; t = t.parent) {
    let n = XR(t);
    if (n)
      return n(Cp.create(i, e, t));
  }
  return null;
}
function xR() {
  return 0;
}
var Cp = class extends Jc {
  constructor(e, i, n) {
    super(e.state, e.options), this.base = e, this.pos = i, this.node = n;
  }
  /**
  @internal
  */
  static create(e, i, n) {
    return new Cp(e, i, n);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    let e = this.state.doc.lineAt(this.node.from);
    for (; ; ) {
      let i = this.node.resolve(e.from);
      for (; i.parent && i.parent.from == i.from; )
        i = i.parent;
      if (wR(i, this.node))
        break;
      e = this.state.doc.lineAt(i.from);
    }
    return this.lineIndent(e.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    let e = this.node.parent;
    return e ? x1(e, this.pos, this.base) : 0;
  }
};
function wR(t, e) {
  for (let i = e; i; i = i.parent)
    if (t == i)
      return true;
  return false;
}
function TR(t) {
  let e = t.node, i = e.childAfter(e.from), n = e.lastChild;
  if (!i)
    return null;
  let O = t.options.simulateBreak, r = t.state.doc.lineAt(i.from), a = O == null || O <= r.from ? r.to : Math.min(r.to, O);
  for (let o = i.to; ; ) {
    let s = e.childAfter(o);
    if (!s || s == n)
      return null;
    if (!s.type.isSkipped)
      return s.from < a ? i : null;
    o = s.to;
  }
}
function dO({ closing: t, align: e = true, units: i = 1 }) {
  return (n) => w1(n, e, i, t);
}
function w1(t, e, i, n, O) {
  let r = t.textAfter, a = r.match(/^\s*/)[0].length, o = n && r.slice(a, a + n.length) == n || O == t.pos + a, s = e ? TR(t) : null;
  return s ? o ? t.column(s.from) : t.column(s.to) : t.baseIndent + (o ? 0 : t.unit * i);
}
var Ep = (t) => t.baseIndent;
function gt({ except: t, units: e = 1 } = {}) {
  return (i) => {
    let n = t && t.test(i.textAfter);
    return i.baseIndent + (n ? 0 : e * i.unit);
  };
}
var kR = 200;
function _R() {
  return ye.transactionFilter.of((t) => {
    if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))
      return t;
    let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
    if (!e.length)
      return t;
    let i = t.newDoc, { head: n } = t.newSelection.main, O = i.lineAt(n);
    if (n > O.from + kR)
      return t;
    let r = i.sliceString(O.from, n);
    if (!e.some((l) => l.test(r)))
      return t;
    let { state: a } = t, o = -1, s = [];
    for (let { head: l } of a.selection.ranges) {
      let c = a.doc.lineAt(l);
      if (c.from == o)
        continue;
      o = c.from;
      let u = zp(a, c.from);
      if (u == null)
        continue;
      let h10 = /^\s*/.exec(c.text)[0], d = Jo(a, u);
      h10 != d && s.push({ from: c.from, to: c.from + h10.length, insert: d });
    }
    return s.length ? [t, { changes: s, sequential: true }] : t;
  });
}
var T1 = K.define();
var ui = new se();
function Mn(t) {
  let e = t.firstChild, i = t.lastChild;
  return e && e.to < i.from ? { from: e.to, to: i.type.isError ? t.to : i.from } : null;
}
function WR(t, e, i) {
  let n = Ye(t);
  if (n.length < i)
    return null;
  let O = n.resolveInner(i, 1), r = null;
  for (let a = O; a; a = a.parent) {
    if (a.to <= i || a.from > i)
      continue;
    if (r && a.from < e)
      break;
    let o = a.type.prop(ui);
    if (o && (a.to < n.length - 50 || n.length == t.doc.length || !YR(a))) {
      let s = o(a, t);
      s && s.from <= i && s.from >= e && s.to > i && (r = s);
    }
  }
  return r;
}
function YR(t) {
  let e = t.lastChild;
  return e && e.to == t.to && e.type.isError;
}
function nc(t, e, i) {
  for (let n of t.facet(T1)) {
    let O = n(t, e, i);
    if (O)
      return O;
  }
  return WR(t, e, i);
}
function k1(t, e) {
  let i = e.mapPos(t.from, 1), n = e.mapPos(t.to, -1);
  return i >= n ? void 0 : { from: i, to: n };
}
var eu = fe.define({ map: k1 });
var vs = fe.define({ map: k1 });
function _1(t) {
  let e = [];
  for (let { head: i } of t.state.selection.ranges)
    e.some((n) => n.from <= i && n.to >= i) || e.push(t.lineBlockAt(i));
  return e;
}
var ir = St.define({
  create() {
    return ne.none;
  },
  update(t, e) {
    t = t.map(e.changes);
    for (let i of e.effects)
      i.is(eu) && !RR(t, i.value.from, i.value.to) ? t = t.update({ add: [Kg.range(i.value.from, i.value.to)] }) : i.is(vs) && (t = t.update({
        filter: (n, O) => i.value.from != n || i.value.to != O,
        filterFrom: i.value.from,
        filterTo: i.value.to
      }));
    if (e.selection) {
      let i = false, { head: n } = e.selection.main;
      t.between(n, n, (O, r) => {
        O < n && r > n && (i = true);
      }), i && (t = t.update({
        filterFrom: n,
        filterTo: n,
        filter: (O, r) => r <= n || O >= n
      }));
    }
    return t;
  },
  provide: (t) => B.decorations.from(t),
  toJSON(t, e) {
    let i = [];
    return t.between(0, e.doc.length, (n, O) => {
      i.push(n, O);
    }), i;
  },
  fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let i = 0; i < t.length; ) {
      let n = t[i++], O = t[i++];
      if (typeof n != "number" || typeof O != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(Kg.range(n, O));
    }
    return ne.set(e, true);
  }
});
function Oc(t, e, i) {
  var n;
  let O = null;
  return (n = t.field(ir, false)) === null || n === void 0 || n.between(e, i, (r, a) => {
    (!O || O.from > r) && (O = { from: r, to: a });
  }), O;
}
function RR(t, e, i) {
  let n = false;
  return t.between(e, e, (O, r) => {
    O == e && r == i && (n = true);
  }), n;
}
function W1(t, e) {
  return t.field(ir, false) ? e : e.concat(fe.appendConfig.of(Z1()));
}
var ZR = (t) => {
  for (let e of _1(t)) {
    let i = nc(t.state, e.from, e.to);
    if (i)
      return t.dispatch({ effects: W1(t.state, [eu.of(i), Y1(t, i)]) }), true;
  }
  return false;
};
var UR = (t) => {
  if (!t.state.field(ir, false))
    return false;
  let e = [];
  for (let i of _1(t)) {
    let n = Oc(t.state, i.from, i.to);
    n && e.push(vs.of(n), Y1(t, n, false));
  }
  return e.length && t.dispatch({ effects: e }), e.length > 0;
};
function Y1(t, e, i = true) {
  let n = t.state.doc.lineAt(e.from).number, O = t.state.doc.lineAt(e.to).number;
  return B.announce.of(`${t.state.phrase(i ? "Folded lines" : "Unfolded lines")} ${n} ${t.state.phrase("to")} ${O}.`);
}
var VR = (t) => {
  let { state: e } = t, i = [];
  for (let n = 0; n < e.doc.length; ) {
    let O = t.lineBlockAt(n), r = nc(e, O.from, O.to);
    r && i.push(eu.of(r)), n = (r ? t.lineBlockAt(r.to) : O).to + 1;
  }
  return i.length && t.dispatch({ effects: W1(t.state, i) }), !!i.length;
};
var qR = (t) => {
  let e = t.state.field(ir, false);
  if (!e || !e.size)
    return false;
  let i = [];
  return e.between(0, t.state.doc.length, (n, O) => {
    i.push(vs.of({ from: n, to: O }));
  }), t.dispatch({ effects: i }), true;
};
var zR = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: ZR },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: UR },
  { key: "Ctrl-Alt-[", run: VR },
  { key: "Ctrl-Alt-]", run: qR }
];
var CR = {
  placeholderDOM: null,
  placeholderText: "…"
};
var R1 = K.define({
  combine(t) {
    return Xn(t, CR);
  }
});
function Z1(t) {
  let e = [ir, IR];
  return t && e.push(R1.of(t)), e;
}
var Kg = ne.replace({ widget: new class extends xn {
  toDOM(t) {
    let { state: e } = t, i = e.facet(R1), n = (r) => {
      let a = t.lineBlockAt(t.posAtDOM(r.target)), o = Oc(t.state, a.from, a.to);
      o && t.dispatch({ effects: vs.of(o) }), r.preventDefault();
    };
    if (i.placeholderDOM)
      return i.placeholderDOM(t, n);
    let O = document.createElement("span");
    return O.textContent = i.placeholderText, O.setAttribute("aria-label", e.phrase("folded code")), O.title = e.phrase("unfold"), O.className = "cm-foldPlaceholder", O.onclick = n, O;
  }
}() });
var ER = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => false
};
var af = class extends An {
  constructor(e, i) {
    super(), this.config = e, this.open = i;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let i = document.createElement("span");
    return i.textContent = this.open ? this.config.openText : this.config.closedText, i.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), i;
  }
};
function jR(t = {}) {
  let e = Object.assign(Object.assign({}, ER), t), i = new af(e, true), n = new af(e, false), O = it.fromClass(class {
    constructor(a) {
      this.from = a.viewport.from, this.markers = this.buildMarkers(a);
    }
    update(a) {
      (a.docChanged || a.viewportChanged || a.startState.facet(PO) != a.state.facet(PO) || a.startState.field(ir, false) != a.state.field(ir, false) || Ye(a.startState) != Ye(a.state) || e.foldingChanged(a)) && (this.markers = this.buildMarkers(a.view));
    }
    buildMarkers(a) {
      let o = new QO();
      for (let s of a.viewportLineBlocks) {
        let l = Oc(a.state, s.from, s.to) ? n : nc(a.state, s.from, s.to) ? i : null;
        l && o.add(s.from, s.from, l);
      }
      return o.finish();
    }
  }), { domEventHandlers: r } = e;
  return [
    O,
    LY({
      class: "cm-foldGutter",
      markers(a) {
        var o;
        return ((o = a.plugin(O)) === null || o === void 0 ? void 0 : o.markers) || We.empty;
      },
      initialSpacer() {
        return new af(e, false);
      },
      domEventHandlers: Object.assign(Object.assign({}, r), { click: (a, o, s) => {
        if (r.click && r.click(a, o, s))
          return true;
        let l = Oc(a.state, o.from, o.to);
        if (l)
          return a.dispatch({ effects: vs.of(l) }), true;
        let c = nc(a.state, o.from, o.to);
        return c ? (a.dispatch({ effects: eu.of(c) }), true) : false;
      } })
    }),
    Z1()
  ];
}
var IR = B.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
var Wa = class {
  constructor(e, i) {
    this.specs = e;
    let n;
    function O(o) {
      let s = gO.newName();
      return (n || (n = /* @__PURE__ */ Object.create(null)))["." + s] = o, s;
    }
    const r = typeof i.all == "string" ? i.all : i.all ? O(i.all) : void 0, a = i.scope;
    this.scope = a instanceof gi ? (o) => o.prop(uO) == a.data : a ? (o) => o == a : void 0, this.style = b1(e.map((o) => ({
      tag: o.tag,
      class: o.class || O(Object.assign({}, o, { tag: null }))
    })), {
      all: r
    }).style, this.module = n ? new gO(n) : null, this.themeType = i.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, i) {
    return new Wa(e, i || {});
  }
};
var ed = K.define();
var U1 = K.define({
  combine(t) {
    return t.length ? [t[0]] : null;
  }
});
function of(t) {
  let e = t.facet(ed);
  return e.length ? e : t.facet(U1);
}
function jp(t, e) {
  let i = [GR], n;
  return t instanceof Wa && (t.module && i.push(B.styleModule.of(t.module)), n = t.themeType), e != null && e.fallback ? i.push(U1.of(t)) : n ? i.push(ed.computeN([B.darkTheme], (O) => O.facet(B.darkTheme) == (n == "dark") ? [t] : [])) : i.push(ed.of(t)), i;
}
var AR = class {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = Ye(e.state), this.decorations = this.buildDeco(e, of(e.state));
  }
  update(e) {
    let i = Ye(e.state), n = of(e.state), O = n != of(e.startState);
    i.length < e.view.viewport.to && !O && i.type == this.tree.type ? this.decorations = this.decorations.map(e.changes) : (i != this.tree || e.viewportChanged || O) && (this.tree = i, this.decorations = this.buildDeco(e.view, n));
  }
  buildDeco(e, i) {
    if (!i || !this.tree.length)
      return ne.none;
    let n = new QO();
    for (let { from: O, to: r } of e.visibleRanges)
      gR(this.tree, i, (a, o, s) => {
        n.add(a, o, this.markCache[s] || (this.markCache[s] = ne.mark({ class: s })));
      }, O, r);
    return n.finish();
  }
};
var GR = wO.high(it.fromClass(AR, {
  decorations: (t) => t.decorations
}));
var LR = Wa.define([
  {
    tag: f.meta,
    color: "#404740"
  },
  {
    tag: f.link,
    textDecoration: "underline"
  },
  {
    tag: f.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: f.emphasis,
    fontStyle: "italic"
  },
  {
    tag: f.strong,
    fontWeight: "bold"
  },
  {
    tag: f.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: f.keyword,
    color: "#708"
  },
  {
    tag: [f.atom, f.bool, f.url, f.contentSeparator, f.labelName],
    color: "#219"
  },
  {
    tag: [f.literal, f.inserted],
    color: "#164"
  },
  {
    tag: [f.string, f.deleted],
    color: "#a11"
  },
  {
    tag: [f.regexp, f.escape, f.special(f.string)],
    color: "#e40"
  },
  {
    tag: f.definition(f.variableName),
    color: "#00f"
  },
  {
    tag: f.local(f.variableName),
    color: "#30a"
  },
  {
    tag: [f.typeName, f.namespace],
    color: "#085"
  },
  {
    tag: f.className,
    color: "#167"
  },
  {
    tag: [f.special(f.variableName), f.macroName],
    color: "#256"
  },
  {
    tag: f.definition(f.propertyName),
    color: "#00c"
  },
  {
    tag: f.comment,
    color: "#940"
  },
  {
    tag: f.invalid,
    color: "#f00"
  }
]);
var DR = B.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
});
var V1 = 1e4;
var q1 = "()[]{}";
var z1 = K.define({
  combine(t) {
    return Xn(t, {
      afterCursor: true,
      brackets: q1,
      maxScanDistance: V1,
      renderMatch: BR
    });
  }
});
var MR = ne.mark({ class: "cm-matchingBracket" });
var NR = ne.mark({ class: "cm-nonmatchingBracket" });
function BR(t) {
  let e = [], i = t.matched ? MR : NR;
  return e.push(i.range(t.start.from, t.start.to)), t.end && e.push(i.range(t.end.from, t.end.to)), e;
}
var FR = St.define({
  create() {
    return ne.none;
  },
  update(t, e) {
    if (!e.docChanged && !e.selection)
      return t;
    let i = [], n = e.state.facet(z1);
    for (let O of e.state.selection.ranges) {
      if (!O.empty)
        continue;
      let r = Qn(e.state, O.head, -1, n) || O.head > 0 && Qn(e.state, O.head - 1, 1, n) || n.afterCursor && (Qn(e.state, O.head, 1, n) || O.head < e.state.doc.length && Qn(e.state, O.head + 1, -1, n));
      r && (i = i.concat(n.renderMatch(r, e.state)));
    }
    return ne.set(i, true);
  },
  provide: (t) => B.decorations.from(t)
});
var HR = [
  FR,
  DR
];
function KR(t = {}) {
  return [z1.of(t), HR];
}
var Ip = new se();
function td(t, e, i) {
  let n = t.prop(e < 0 ? se.openedBy : se.closedBy);
  if (n)
    return n;
  if (t.name.length == 1) {
    let O = i.indexOf(t.name);
    if (O > -1 && O % 2 == (e < 0 ? 1 : 0))
      return [i[O + e]];
  }
  return null;
}
function id(t) {
  let e = t.type.prop(Ip);
  return e ? e(t.node) : t;
}
function Qn(t, e, i, n = {}) {
  let O = n.maxScanDistance || V1, r = n.brackets || q1, a = Ye(t), o = a.resolveInner(e, i);
  for (let s = o; s; s = s.parent) {
    let l = td(s.type, i, r);
    if (l && s.from < s.to) {
      let c = id(s);
      if (c && (i > 0 ? e >= c.from && e < c.to : e > c.from && e <= c.to))
        return JR(t, e, i, s, c, l, r);
    }
  }
  return eZ(t, e, i, a, o.type, O, r);
}
function JR(t, e, i, n, O, r, a) {
  let o = n.parent, s = { from: O.from, to: O.to }, l = 0, c = o == null ? void 0 : o.cursor();
  if (c && (i < 0 ? c.childBefore(n.from) : c.childAfter(n.to)))
    do
      if (i < 0 ? c.to <= n.from : c.from >= n.to) {
        if (l == 0 && r.indexOf(c.type.name) > -1 && c.from < c.to) {
          let u = id(c);
          return { start: s, end: u ? { from: u.from, to: u.to } : void 0, matched: true };
        } else if (td(c.type, i, a))
          l++;
        else if (td(c.type, -i, a)) {
          if (l == 0) {
            let u = id(c);
            return {
              start: s,
              end: u && u.from < u.to ? { from: u.from, to: u.to } : void 0,
              matched: false
            };
          }
          l--;
        }
      }
    while (i < 0 ? c.prevSibling() : c.nextSibling());
  return { start: s, matched: false };
}
function eZ(t, e, i, n, O, r, a) {
  let o = i < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), s = a.indexOf(o);
  if (s < 0 || s % 2 == 0 != i > 0)
    return null;
  let l = { from: i < 0 ? e - 1 : e, to: i > 0 ? e + 1 : e }, c = t.doc.iterRange(e, i > 0 ? t.doc.length : 0), u = 0;
  for (let h10 = 0; !c.next().done && h10 <= r; ) {
    let d = c.value;
    i < 0 && (h10 += d.length);
    let p = e + h10 * i;
    for (let $ = i > 0 ? 0 : d.length - 1, g = i > 0 ? d.length : -1; $ != g; $ += i) {
      let Q = a.indexOf(d[$]);
      if (!(Q < 0 || n.resolveInner(p + $, 1).type != O))
        if (Q % 2 == 0 == i > 0)
          u++;
        else {
          if (u == 1)
            return { start: l, end: { from: p + $, to: p + $ + 1 }, matched: Q >> 1 == s >> 1 };
          u--;
        }
    }
    i > 0 && (h10 += d.length);
  }
  return c.done ? { start: l, matched: false } : null;
}
function Jg(t, e, i, n = 0, O = 0) {
  e == null && (e = t.search(/[^\s\u00a0]/), e == -1 && (e = t.length));
  let r = O;
  for (let a = n; a < e; a++)
    t.charCodeAt(a) == 9 ? r += i - r % i : r++;
  return r;
}
var C1 = class {
  /**
  Create a stream.
  */
  constructor(e, i, n, O) {
    this.string = e, this.tabSize = i, this.indentUnit = n, this.overrideIndent = O, this.pos = 0, this.start = 0, this.lastColumnPos = 0, this.lastColumnValue = 0;
  }
  /**
  True if we are at the end of the line.
  */
  eol() {
    return this.pos >= this.string.length;
  }
  /**
  True if we are at the start of the line.
  */
  sol() {
    return this.pos == 0;
  }
  /**
  Get the next code unit after the current position, or undefined
  if we're at the end of the line.
  */
  peek() {
    return this.string.charAt(this.pos) || void 0;
  }
  /**
  Read the next code unit and advance `this.pos`.
  */
  next() {
    if (this.pos < this.string.length)
      return this.string.charAt(this.pos++);
  }
  /**
  Match the next character against the given string, regular
  expression, or predicate. Consume and return it if it matches.
  */
  eat(e) {
    let i = this.string.charAt(this.pos), n;
    if (typeof e == "string" ? n = i == e : n = i && (e instanceof RegExp ? e.test(i) : e(i)), n)
      return ++this.pos, i;
  }
  /**
  Continue matching characters that match the given string,
  regular expression, or predicate function. Return true if any
  characters were consumed.
  */
  eatWhile(e) {
    let i = this.pos;
    for (; this.eat(e); )
      ;
    return this.pos > i;
  }
  /**
  Consume whitespace ahead of `this.pos`. Return true if any was
  found.
  */
  eatSpace() {
    let e = this.pos;
    for (; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
      ++this.pos;
    return this.pos > e;
  }
  /**
  Move to the end of the line.
  */
  skipToEnd() {
    this.pos = this.string.length;
  }
  /**
  Move to directly before the given character, if found on the
  current line.
  */
  skipTo(e) {
    let i = this.string.indexOf(e, this.pos);
    if (i > -1)
      return this.pos = i, true;
  }
  /**
  Move back `n` characters.
  */
  backUp(e) {
    this.pos -= e;
  }
  /**
  Get the column position at `this.pos`.
  */
  column() {
    return this.lastColumnPos < this.start && (this.lastColumnValue = Jg(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue;
  }
  /**
  Get the indentation column of the current line.
  */
  indentation() {
    var e;
    return (e = this.overrideIndent) !== null && e !== void 0 ? e : Jg(this.string, null, this.tabSize);
  }
  /**
  Match the input against the given string or regular expression
  (which should start with a `^`). Return true or the regexp match
  if it matches.
  
  Unless `consume` is set to `false`, this will move `this.pos`
  past the matched text.
  
  When matching a string `caseInsensitive` can be set to true to
  make the match case-insensitive.
  */
  match(e, i, n) {
    if (typeof e == "string") {
      let O = (a) => n ? a.toLowerCase() : a, r = this.string.substr(this.pos, e.length);
      return O(r) == O(e) ? (i !== false && (this.pos += e.length), true) : null;
    } else {
      let O = this.string.slice(this.pos).match(e);
      return O && O.index > 0 ? null : (O && i !== false && (this.pos += O[0].length), O);
    }
  }
  /**
  Get the current token.
  */
  current() {
    return this.string.slice(this.start, this.pos);
  }
};
function tZ(t) {
  return {
    name: t.name || "",
    token: t.token,
    blankLine: t.blankLine || (() => {
    }),
    startState: t.startState || (() => true),
    copyState: t.copyState || iZ,
    indent: t.indent || (() => null),
    languageData: t.languageData || {},
    tokenTable: t.tokenTable || Gp
  };
}
function iZ(t) {
  if (typeof t != "object")
    return t;
  let e = {};
  for (let i in t) {
    let n = t[i];
    e[i] = n instanceof Array ? n.slice() : n;
  }
  return e;
}
var em = /* @__PURE__ */ new WeakMap();
var Ot = class extends gi {
  constructor(e) {
    let i = Kc(e.languageData), n = tZ(e), O, r = new class extends Hc {
      createParse(a, o, s) {
        return new OZ(O, a, o, s);
      }
    }();
    super(i, r, [X1.of((a, o) => this.getIndent(a, o))], e.name), this.topNode = oZ(i), O = this, this.streamParser = n, this.stateAfter = new se({ perNode: true }), this.tokenTable = e.tokenTable ? new A1(n.tokenTable) : aZ;
  }
  /**
  Define a stream language.
  */
  static define(e) {
    return new Ot(e);
  }
  getIndent(e, i) {
    let n = Ye(e.state), O = n.resolve(i);
    for (; O && O.type != this.topNode; )
      O = O.parent;
    if (!O)
      return null;
    let r, { overrideIndentation: a } = e.options;
    a && (r = em.get(e.state), r != null && r < i - 1e4 && (r = void 0));
    let o = Ap(this, n, 0, O.from, r ?? i), s, l;
    if (o ? (l = o.state, s = o.pos + 1) : (l = this.streamParser.startState(e.unit), s = 0), i - s > 1e4)
      return null;
    for (; s < i; ) {
      let u = e.state.doc.lineAt(s), h10 = Math.min(i, u.to);
      if (u.length) {
        let d = a ? a(u.from) : -1, p = new C1(u.text, e.state.tabSize, e.unit, d < 0 ? void 0 : d);
        for (; p.pos < h10 - u.from; )
          j1(this.streamParser.token, p, l);
      } else
        this.streamParser.blankLine(l, e.unit);
      if (h10 == i)
        break;
      s = u.to + 1;
    }
    let c = e.lineAt(i);
    return a && r == null && em.set(e.state, c.from), this.streamParser.indent(l, /^\s*(.*)/.exec(c.text)[1], e);
  }
  get allowsNesting() {
    return false;
  }
};
function Ap(t, e, i, n, O) {
  let r = i >= n && i + e.length <= O && e.prop(t.stateAfter);
  if (r)
    return { state: t.streamParser.copyState(r), pos: i + e.length };
  for (let a = e.children.length - 1; a >= 0; a--) {
    let o = e.children[a], s = i + e.positions[a], l = o instanceof ve && s < O && Ap(t, o, s, n, O);
    if (l)
      return l;
  }
  return null;
}
function E1(t, e, i, n, O) {
  if (O && i <= 0 && n >= e.length)
    return e;
  !O && e.type == t.topNode && (O = true);
  for (let r = e.children.length - 1; r >= 0; r--) {
    let a = e.positions[r], o = e.children[r], s;
    if (a < n && o instanceof ve) {
      if (!(s = E1(t, o, i - a, n - a, O)))
        break;
      return O ? new ve(e.type, e.children.slice(0, r).concat(s), e.positions.slice(0, r + 1), a + s.length) : s;
    }
  }
  return null;
}
function nZ(t, e, i, n) {
  for (let O of e) {
    let r = O.from + (O.openStart ? 25 : 0), a = O.to - (O.openEnd ? 25 : 0), o = r <= i && a > i && Ap(t, O.tree, 0 - O.offset, i, a), s;
    if (o && (s = E1(t, O.tree, i + O.offset, o.pos + O.offset, false)))
      return { state: o.state, tree: s };
  }
  return { state: t.streamParser.startState(n ? tr(n) : 4), tree: ve.empty };
}
var OZ = class {
  constructor(e, i, n, O) {
    this.lang = e, this.input = i, this.fragments = n, this.ranges = O, this.stoppedAt = null, this.chunks = [], this.chunkPos = [], this.chunk = [], this.chunkReused = void 0, this.rangeIndex = 0, this.to = O[O.length - 1].to;
    let r = er.get(), a = O[0].from, { state: o, tree: s } = nZ(e, n, a, r == null ? void 0 : r.state);
    this.state = o, this.parsedPos = this.chunkStart = a + s.length;
    for (let l = 0; l < s.children.length; l++)
      this.chunks.push(s.children[l]), this.chunkPos.push(s.positions[l]);
    r && this.parsedPos < r.viewport.from - 1e5 && (this.state = this.lang.streamParser.startState(tr(r.state)), r.skipUntilInView(this.parsedPos, r.viewport.from), this.parsedPos = r.viewport.from), this.moveRangeIndex();
  }
  advance() {
    let e = er.get(), i = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt), n = Math.min(
      i,
      this.chunkStart + 2048
      /* C.ChunkSize */
    );
    for (e && (n = Math.min(n, e.viewport.to)); this.parsedPos < n; )
      this.parseLine(e);
    return this.chunkStart < this.parsedPos && this.finishChunk(), this.parsedPos >= i ? this.finish() : e && this.parsedPos >= e.viewport.to ? (e.skipUntilInView(this.parsedPos, i), this.finish()) : null;
  }
  stopAt(e) {
    this.stoppedAt = e;
  }
  lineAfter(e) {
    let i = this.input.chunk(e);
    if (this.input.lineChunks)
      i == `
` && (i = "");
    else {
      let n = i.indexOf(`
`);
      n > -1 && (i = i.slice(0, n));
    }
    return e + i.length <= this.to ? i : i.slice(0, this.to - e);
  }
  nextLine() {
    let e = this.parsedPos, i = this.lineAfter(e), n = e + i.length;
    for (let O = this.rangeIndex; ; ) {
      let r = this.ranges[O].to;
      if (r >= n || (i = i.slice(0, r - (n - i.length)), O++, O == this.ranges.length))
        break;
      let a = this.ranges[O].from, o = this.lineAfter(a);
      i += o, n = a + o.length;
    }
    return { line: i, end: n };
  }
  skipGapsTo(e, i, n) {
    for (; ; ) {
      let O = this.ranges[this.rangeIndex].to, r = e + i;
      if (n > 0 ? O > r : O >= r)
        break;
      let a = this.ranges[++this.rangeIndex].from;
      i += a - O;
    }
    return i;
  }
  moveRangeIndex() {
    for (; this.ranges[this.rangeIndex].to < this.parsedPos; )
      this.rangeIndex++;
  }
  emitToken(e, i, n, O, r) {
    if (this.ranges.length > 1) {
      r = this.skipGapsTo(i, r, 1), i += r;
      let a = this.chunk.length;
      r = this.skipGapsTo(n, r, -1), n += r, O += this.chunk.length - a;
    }
    return this.chunk.push(e, i, n, O), r;
  }
  parseLine(e) {
    let { line: i, end: n } = this.nextLine(), O = 0, { streamParser: r } = this.lang, a = new C1(i, e ? e.state.tabSize : 4, e ? tr(e.state) : 2);
    if (a.eol())
      r.blankLine(this.state, a.indentUnit);
    else
      for (; !a.eol(); ) {
        let o = j1(r.token, a, this.state);
        if (o && (O = this.emitToken(this.lang.tokenTable.resolve(o), this.parsedPos + a.start, this.parsedPos + a.pos, 4, O)), a.start > 1e4)
          break;
      }
    this.parsedPos = n, this.moveRangeIndex(), this.parsedPos < this.to && this.parsedPos++;
  }
  finishChunk() {
    let e = ve.build({
      buffer: this.chunk,
      start: this.chunkStart,
      length: this.parsedPos - this.chunkStart,
      nodeSet: rZ,
      topID: 0,
      maxBufferLength: 2048,
      reused: this.chunkReused
    });
    e = new ve(e.type, e.children, e.positions, e.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]), this.chunks.push(e), this.chunkPos.push(this.chunkStart - this.ranges[0].from), this.chunk = [], this.chunkReused = void 0, this.chunkStart = this.parsedPos;
  }
  finish() {
    return new ve(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
  }
};
function j1(t, e, i) {
  e.start = e.pos;
  for (let n = 0; n < 10; n++) {
    let O = t(e, i);
    if (e.pos > e.start)
      return O;
  }
  throw new Error("Stream parser failed to advance stream.");
}
var Gp = /* @__PURE__ */ Object.create(null);
var es = [lt.none];
var rZ = new _a(es);
var tm = [];
var I1 = /* @__PURE__ */ Object.create(null);
for (let [t, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  I1[t] = G1(Gp, e);
var A1 = class {
  constructor(e) {
    this.extra = e, this.table = Object.assign(/* @__PURE__ */ Object.create(null), I1);
  }
  resolve(e) {
    return e ? this.table[e] || (this.table[e] = G1(this.extra, e)) : 0;
  }
};
var aZ = new A1(Gp);
function sf(t, e) {
  tm.indexOf(t) > -1 || (tm.push(t), console.warn(e));
}
function G1(t, e) {
  let i = null;
  for (let r of e.split(".")) {
    let a = t[r] || f[r];
    a ? typeof a == "function" ? i ? i = a(i) : sf(r, `Modifier ${r} used at start of tag`) : i ? sf(r, `Tag ${r} used as modifier`) : i = a : sf(r, `Unknown highlighting tag ${r}`);
  }
  if (!i)
    return 0;
  let n = e.replace(/ /g, "_"), O = lt.define({
    id: es.length,
    name: n,
    props: [ti({ [n]: i })]
  });
  return es.push(O), O.id;
}
function oZ(t) {
  let e = lt.define({ id: es.length, name: "Document", props: [uO.add(() => t)] });
  return es.push(e), e;
}
var sZ = (t) => {
  let { state: e } = t, i = e.doc.lineAt(e.selection.main.head), n = Dp(t.state, i.from);
  return n.line ? lZ(t) : n.block ? uZ(t) : false;
};
function Lp(t, e) {
  return ({ state: i, dispatch: n }) => {
    if (i.readOnly)
      return false;
    let O = t(e, i);
    return O ? (n(i.update(O)), true) : false;
  };
}
var lZ = Lp(
  dZ,
  0
  /* CommentOption.Toggle */
);
var cZ = Lp(
  L1,
  0
  /* CommentOption.Toggle */
);
var uZ = Lp(
  (t, e) => L1(t, e, hZ(e)),
  0
  /* CommentOption.Toggle */
);
function Dp(t, e) {
  let i = t.languageDataAt("commentTokens", e);
  return i.length ? i[0] : {};
}
var Ma = 50;
function fZ(t, { open: e, close: i }, n, O) {
  let r = t.sliceDoc(n - Ma, n), a = t.sliceDoc(O, O + Ma), o = /\s*$/.exec(r)[0].length, s = /^\s*/.exec(a)[0].length, l = r.length - o;
  if (r.slice(l - e.length, l) == e && a.slice(s, s + i.length) == i)
    return {
      open: { pos: n - o, margin: o && 1 },
      close: { pos: O + s, margin: s && 1 }
    };
  let c, u;
  O - n <= 2 * Ma ? c = u = t.sliceDoc(n, O) : (c = t.sliceDoc(n, n + Ma), u = t.sliceDoc(O - Ma, O));
  let h10 = /^\s*/.exec(c)[0].length, d = /\s*$/.exec(u)[0].length, p = u.length - d - i.length;
  return c.slice(h10, h10 + e.length) == e && u.slice(p, p + i.length) == i ? {
    open: {
      pos: n + h10 + e.length,
      margin: /\s/.test(c.charAt(h10 + e.length)) ? 1 : 0
    },
    close: {
      pos: O - d - i.length,
      margin: /\s/.test(u.charAt(p - 1)) ? 1 : 0
    }
  } : null;
}
function hZ(t) {
  let e = [];
  for (let i of t.selection.ranges) {
    let n = t.doc.lineAt(i.from), O = i.to <= n.to ? n : t.doc.lineAt(i.to), r = e.length - 1;
    r >= 0 && e[r].to > n.from ? e[r].to = O.to : e.push({ from: n.from, to: O.to });
  }
  return e;
}
function L1(t, e, i = e.selection.ranges) {
  let n = i.map((r) => Dp(e, r.from).block);
  if (!n.every((r) => r))
    return null;
  let O = i.map((r, a) => fZ(e, n[a], r.from, r.to));
  if (t != 2 && !O.every((r) => r))
    return { changes: e.changes(i.map((r, a) => O[a] ? [] : [{ from: r.from, insert: n[a].open + " " }, { from: r.to, insert: " " + n[a].close }])) };
  if (t != 1 && O.some((r) => r)) {
    let r = [];
    for (let a = 0, o; a < O.length; a++)
      if (o = O[a]) {
        let s = n[a], { open: l, close: c } = o;
        r.push({ from: l.pos - s.open.length, to: l.pos + l.margin }, { from: c.pos - c.margin, to: c.pos + s.close.length });
      }
    return { changes: r };
  }
  return null;
}
function dZ(t, e, i = e.selection.ranges) {
  let n = [], O = -1;
  for (let { from: r, to: a } of i) {
    let o = n.length, s = 1e9;
    for (let l = r; l <= a; ) {
      let c = e.doc.lineAt(l);
      if (c.from > O && (r == a || a > c.from)) {
        O = c.from;
        let u = Dp(e, c.from).line;
        if (!u)
          continue;
        let h10 = /^\s*/.exec(c.text)[0].length, d = h10 == c.length, p = c.text.slice(h10, h10 + u.length) == u ? h10 : -1;
        h10 < c.text.length && h10 < s && (s = h10), n.push({ line: c, comment: p, token: u, indent: h10, empty: d, single: false });
      }
      l = c.to + 1;
    }
    if (s < 1e9)
      for (let l = o; l < n.length; l++)
        n[l].indent < n[l].line.text.length && (n[l].indent = s);
    n.length == o + 1 && (n[o].single = true);
  }
  if (t != 2 && n.some((r) => r.comment < 0 && (!r.empty || r.single))) {
    let r = [];
    for (let { line: o, token: s, indent: l, empty: c, single: u } of n)
      (u || !c) && r.push({ from: o.from + l, insert: s + " " });
    let a = e.changes(r);
    return { changes: a, selection: e.selection.map(a, 1) };
  } else if (t != 1 && n.some((r) => r.comment >= 0)) {
    let r = [];
    for (let { line: a, comment: o, token: s } of n)
      if (o >= 0) {
        let l = a.from + o, c = l + s.length;
        a.text[c - a.from] == " " && c++, r.push({ from: l, to: c });
      }
    return { changes: r };
  }
  return null;
}
var nd = Dn.define();
var pZ = Dn.define();
var $Z = K.define();
var D1 = K.define({
  combine(t) {
    return Xn(t, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, i) => i
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, i) => (n, O) => e(n, O) || i(n, O)
    });
  }
});
function QZ(t) {
  let e = 0;
  return t.iterChangedRanges((i, n) => e = n), e;
}
var M1 = St.define({
  create() {
    return gn.empty;
  },
  update(t, e) {
    let i = e.state.facet(D1), n = e.annotation(nd);
    if (n) {
      let s = e.docChanged ? R.single(QZ(e.changes)) : void 0, l = ai.fromTransaction(e, s), c = n.side, u = c == 0 ? t.undone : t.done;
      return l ? u = rc(u, u.length, i.minDepth, l) : u = F1(u, e.startState.selection), new gn(c == 0 ? n.rest : u, c == 0 ? u : n.rest);
    }
    let O = e.annotation(pZ);
    if ((O == "full" || O == "before") && (t = t.isolate()), e.annotation(ht.addToHistory) === false)
      return e.changes.empty ? t : t.addMapping(e.changes.desc);
    let r = ai.fromTransaction(e), a = e.annotation(ht.time), o = e.annotation(ht.userEvent);
    return r ? t = t.addChanges(r, a, o, i, e) : e.selection && (t = t.addSelection(e.startState.selection, a, o, i.newGroupDelay)), (O == "full" || O == "after") && (t = t.isolate()), t;
  },
  toJSON(t) {
    return { done: t.done.map((e) => e.toJSON()), undone: t.undone.map((e) => e.toJSON()) };
  },
  fromJSON(t) {
    return new gn(t.done.map(ai.fromJSON), t.undone.map(ai.fromJSON));
  }
});
function gZ(t = {}) {
  return [
    M1,
    D1.of(t),
    B.domEventHandlers({
      beforeinput(e, i) {
        let n = e.inputType == "historyUndo" ? N1 : e.inputType == "historyRedo" ? Od : null;
        return n ? (e.preventDefault(), n(i)) : false;
      }
    })
  ];
}
function tu(t, e) {
  return function({ state: i, dispatch: n }) {
    if (!e && i.readOnly)
      return false;
    let O = i.field(M1, false);
    if (!O)
      return false;
    let r = O.pop(t, i, e);
    return r ? (n(r), true) : false;
  };
}
var N1 = tu(0, false);
var Od = tu(1, false);
var mZ = tu(0, true);
var SZ = tu(1, true);
var ai = class {
  constructor(e, i, n, O, r) {
    this.changes = e, this.effects = i, this.mapped = n, this.startSelection = O, this.selectionsAfter = r;
  }
  setSelAfter(e) {
    return new ai(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, i, n;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (i = this.mapped) === null || i === void 0 ? void 0 : i.toJSON(),
      startSelection: (n = this.startSelection) === null || n === void 0 ? void 0 : n.toJSON(),
      selectionsAfter: this.selectionsAfter.map((O) => O.toJSON())
    };
  }
  static fromJSON(e) {
    return new ai(e.changes && ct.fromJSON(e.changes), [], e.mapped && mn.fromJSON(e.mapped), e.startSelection && R.fromJSON(e.startSelection), e.selectionsAfter.map(R.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, i) {
    let n = Yi;
    for (let O of e.startState.facet($Z)) {
      let r = O(e);
      r.length && (n = n.concat(r));
    }
    return !n.length && e.changes.empty ? null : new ai(e.changes.invert(e.startState.doc), n, void 0, i || e.startState.selection, Yi);
  }
  static selection(e) {
    return new ai(void 0, Yi, void 0, void 0, e);
  }
};
function rc(t, e, i, n) {
  let O = e + 1 > i + 20 ? e - i - 1 : 0, r = t.slice(O, e);
  return r.push(n), r;
}
function PZ(t, e) {
  let i = [], n = false;
  return t.iterChangedRanges((O, r) => i.push(O, r)), e.iterChangedRanges((O, r, a, o) => {
    for (let s = 0; s < i.length; ) {
      let l = i[s++], c = i[s++];
      o >= l && a <= c && (n = true);
    }
  }), n;
}
function yZ(t, e) {
  return t.ranges.length == e.ranges.length && t.ranges.filter((i, n) => i.empty != e.ranges[n].empty).length === 0;
}
function B1(t, e) {
  return t.length ? e.length ? t.concat(e) : t : e;
}
var Yi = [];
var bZ = 200;
function F1(t, e) {
  if (t.length) {
    let i = t[t.length - 1], n = i.selectionsAfter.slice(Math.max(0, i.selectionsAfter.length - bZ));
    return n.length && n[n.length - 1].eq(e) ? t : (n.push(e), rc(t, t.length - 1, 1e9, i.setSelAfter(n)));
  } else
    return [ai.selection([e])];
}
function vZ(t) {
  let e = t[t.length - 1], i = t.slice();
  return i[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), i;
}
function lf(t, e) {
  if (!t.length)
    return t;
  let i = t.length, n = Yi;
  for (; i; ) {
    let O = XZ(t[i - 1], e, n);
    if (O.changes && !O.changes.empty || O.effects.length) {
      let r = t.slice(0, i);
      return r[i - 1] = O, r;
    } else
      e = O.mapped, i--, n = O.selectionsAfter;
  }
  return n.length ? [ai.selection(n)] : Yi;
}
function XZ(t, e, i) {
  let n = B1(t.selectionsAfter.length ? t.selectionsAfter.map((o) => o.map(e)) : Yi, i);
  if (!t.changes)
    return ai.selection(n);
  let O = t.changes.map(e), r = e.mapDesc(t.changes, true), a = t.mapped ? t.mapped.composeDesc(r) : r;
  return new ai(O, fe.mapEffects(t.effects, e), a, t.startSelection.map(r), n);
}
var xZ = /^(input\.type|delete)($|\.)/;
var gn = class {
  constructor(e, i, n = 0, O = void 0) {
    this.done = e, this.undone = i, this.prevTime = n, this.prevUserEvent = O;
  }
  isolate() {
    return this.prevTime ? new gn(this.done, this.undone) : this;
  }
  addChanges(e, i, n, O, r) {
    let a = this.done, o = a[a.length - 1];
    return o && o.changes && !o.changes.empty && e.changes && (!n || xZ.test(n)) && (!o.selectionsAfter.length && i - this.prevTime < O.newGroupDelay && O.joinToEvent(r, PZ(o.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    n == "input.type.compose") ? a = rc(a, a.length - 1, O.minDepth, new ai(e.changes.compose(o.changes), B1(e.effects, o.effects), o.mapped, o.startSelection, Yi)) : a = rc(a, a.length, O.minDepth, e), new gn(a, Yi, i, n);
  }
  addSelection(e, i, n, O) {
    let r = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Yi;
    return r.length > 0 && i - this.prevTime < O && n == this.prevUserEvent && n && /^select($|\.)/.test(n) && yZ(r[r.length - 1], e) ? this : new gn(F1(this.done, e), this.undone, i, n);
  }
  addMapping(e) {
    return new gn(lf(this.done, e), lf(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, i, n) {
    let O = e == 0 ? this.done : this.undone;
    if (O.length == 0)
      return null;
    let r = O[O.length - 1];
    if (n && r.selectionsAfter.length)
      return i.update({
        selection: r.selectionsAfter[r.selectionsAfter.length - 1],
        annotations: nd.of({ side: e, rest: vZ(O) }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: true
      });
    if (r.changes) {
      let a = O.length == 1 ? Yi : O.slice(0, O.length - 1);
      return r.mapped && (a = lf(a, r.mapped)), i.update({
        changes: r.changes,
        selection: r.startSelection,
        effects: r.effects,
        annotations: nd.of({ side: e, rest: a }),
        filter: false,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: true
      });
    } else
      return null;
  }
};
gn.empty = new gn(Yi, Yi);
var wZ = [
  { key: "Mod-z", run: N1, preventDefault: true },
  { key: "Mod-y", mac: "Mod-Shift-z", run: Od, preventDefault: true },
  { linux: "Ctrl-Shift-z", run: Od, preventDefault: true },
  { key: "Mod-u", run: mZ, preventDefault: true },
  { key: "Alt-u", mac: "Mod-Shift-u", run: SZ, preventDefault: true }
];
function Ya(t, e) {
  return R.create(t.ranges.map(e), t.mainIndex);
}
function wn(t, e) {
  return t.update({ selection: e, scrollIntoView: true, userEvent: "select" });
}
function an({ state: t, dispatch: e }, i) {
  let n = Ya(t.selection, i);
  return n.eq(t.selection) ? false : (e(wn(t, n)), true);
}
function iu(t, e) {
  return R.cursor(e ? t.to : t.from);
}
function H1(t, e) {
  return an(t, (i) => i.empty ? t.moveByChar(i, e) : iu(i, e));
}
function qt(t) {
  return t.textDirectionAt(t.state.selection.main.head) == Ne.LTR;
}
var K1 = (t) => H1(t, !qt(t));
var J1 = (t) => H1(t, qt(t));
function e0(t, e) {
  return an(t, (i) => i.empty ? t.moveByGroup(i, e) : iu(i, e));
}
var TZ = (t) => e0(t, !qt(t));
var kZ = (t) => e0(t, qt(t));
function _Z(t, e, i) {
  if (e.type.prop(i))
    return true;
  let n = e.to - e.from;
  return n && (n > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to))) || e.firstChild;
}
function nu(t, e, i) {
  let n = Ye(t).resolveInner(e.head), O = i ? se.closedBy : se.openedBy;
  for (let s = e.head; ; ) {
    let l = i ? n.childAfter(s) : n.childBefore(s);
    if (!l)
      break;
    _Z(t, l, O) ? n = l : s = i ? l.to : l.from;
  }
  let r = n.type.prop(O), a, o;
  return r && (a = i ? Qn(t, n.from, 1) : Qn(t, n.to, -1)) && a.matched ? o = i ? a.end.to : a.end.from : o = i ? n.to : n.from, R.cursor(o, i ? -1 : 1);
}
var WZ = (t) => an(t, (e) => nu(t.state, e, !qt(t)));
var YZ = (t) => an(t, (e) => nu(t.state, e, qt(t)));
function t0(t, e) {
  return an(t, (i) => {
    if (!i.empty)
      return iu(i, e);
    let n = t.moveVertically(i, e);
    return n.head != i.head ? n : t.moveToLineBoundary(i, e);
  });
}
var i0 = (t) => t0(t, false);
var n0 = (t) => t0(t, true);
function O0(t) {
  let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2, i = 0, n = 0, O;
  if (e) {
    for (let r of t.state.facet(B.scrollMargins)) {
      let a = r(t);
      a != null && a.top && (i = Math.max(a == null ? void 0 : a.top, i)), a != null && a.bottom && (n = Math.max(a == null ? void 0 : a.bottom, n));
    }
    O = t.scrollDOM.clientHeight - i - n;
  } else
    O = (t.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: i,
    marginBottom: n,
    selfScroll: e,
    height: Math.max(t.defaultLineHeight, O - 5)
  };
}
function r0(t, e) {
  let i = O0(t), { state: n } = t, O = Ya(n.selection, (a) => a.empty ? t.moveVertically(a, e, i.height) : iu(a, e));
  if (O.eq(n.selection))
    return false;
  let r;
  if (i.selfScroll) {
    let a = t.coordsAtPos(n.selection.main.head), o = t.scrollDOM.getBoundingClientRect(), s = o.top + i.marginTop, l = o.bottom - i.marginBottom;
    a && a.top > s && a.bottom < l && (r = B.scrollIntoView(O.main.head, { y: "start", yMargin: a.top - s }));
  }
  return t.dispatch(wn(n, O), { effects: r }), true;
}
var im = (t) => r0(t, false);
var rd = (t) => r0(t, true);
function TO(t, e, i) {
  let n = t.lineBlockAt(e.head), O = t.moveToLineBoundary(e, i);
  if (O.head == e.head && O.head != (i ? n.to : n.from) && (O = t.moveToLineBoundary(e, i, false)), !i && O.head == n.from && n.length) {
    let r = /^\s*/.exec(t.state.sliceDoc(n.from, Math.min(n.from + 100, n.to)))[0].length;
    r && e.head != n.from + r && (O = R.cursor(n.from + r));
  }
  return O;
}
var RZ = (t) => an(t, (e) => TO(t, e, true));
var ZZ = (t) => an(t, (e) => TO(t, e, false));
var UZ = (t) => an(t, (e) => TO(t, e, !qt(t)));
var VZ = (t) => an(t, (e) => TO(t, e, qt(t)));
var qZ = (t) => an(t, (e) => R.cursor(t.lineBlockAt(e.head).from, 1));
var zZ = (t) => an(t, (e) => R.cursor(t.lineBlockAt(e.head).to, -1));
function CZ(t, e, i) {
  let n = false, O = Ya(t.selection, (r) => {
    let a = Qn(t, r.head, -1) || Qn(t, r.head, 1) || r.head > 0 && Qn(t, r.head - 1, 1) || r.head < t.doc.length && Qn(t, r.head + 1, -1);
    if (!a || !a.end)
      return r;
    n = true;
    let o = a.start.from == r.head ? a.end.to : a.end.from;
    return i ? R.range(r.anchor, o) : R.cursor(o);
  });
  return n ? (e(wn(t, O)), true) : false;
}
var EZ = ({ state: t, dispatch: e }) => CZ(t, e, false);
function Ci(t, e) {
  let i = Ya(t.state.selection, (n) => {
    let O = e(n);
    return R.range(n.anchor, O.head, O.goalColumn, O.bidiLevel || void 0);
  });
  return i.eq(t.state.selection) ? false : (t.dispatch(wn(t.state, i)), true);
}
function a0(t, e) {
  return Ci(t, (i) => t.moveByChar(i, e));
}
var o0 = (t) => a0(t, !qt(t));
var s0 = (t) => a0(t, qt(t));
function l0(t, e) {
  return Ci(t, (i) => t.moveByGroup(i, e));
}
var jZ = (t) => l0(t, !qt(t));
var IZ = (t) => l0(t, qt(t));
var AZ = (t) => Ci(t, (e) => nu(t.state, e, !qt(t)));
var GZ = (t) => Ci(t, (e) => nu(t.state, e, qt(t)));
function c0(t, e) {
  return Ci(t, (i) => t.moveVertically(i, e));
}
var u0 = (t) => c0(t, false);
var f0 = (t) => c0(t, true);
function h0(t, e) {
  return Ci(t, (i) => t.moveVertically(i, e, O0(t).height));
}
var nm = (t) => h0(t, false);
var Om = (t) => h0(t, true);
var LZ = (t) => Ci(t, (e) => TO(t, e, true));
var DZ = (t) => Ci(t, (e) => TO(t, e, false));
var MZ = (t) => Ci(t, (e) => TO(t, e, !qt(t)));
var NZ = (t) => Ci(t, (e) => TO(t, e, qt(t)));
var BZ = (t) => Ci(t, (e) => R.cursor(t.lineBlockAt(e.head).from));
var FZ = (t) => Ci(t, (e) => R.cursor(t.lineBlockAt(e.head).to));
var rm = ({ state: t, dispatch: e }) => (e(wn(t, { anchor: 0 })), true);
var am = ({ state: t, dispatch: e }) => (e(wn(t, { anchor: t.doc.length })), true);
var om = ({ state: t, dispatch: e }) => (e(wn(t, { anchor: t.selection.main.anchor, head: 0 })), true);
var sm = ({ state: t, dispatch: e }) => (e(wn(t, { anchor: t.selection.main.anchor, head: t.doc.length })), true);
var HZ = ({ state: t, dispatch: e }) => (e(t.update({ selection: { anchor: 0, head: t.doc.length }, userEvent: "select" })), true);
var KZ = ({ state: t, dispatch: e }) => {
  let i = ru(t).map(({ from: n, to: O }) => R.range(n, Math.min(O + 1, t.doc.length)));
  return e(t.update({ selection: R.create(i), userEvent: "select" })), true;
};
var JZ = ({ state: t, dispatch: e }) => {
  let i = Ya(t.selection, (n) => {
    var O;
    let r = Ye(t).resolveInner(n.head, 1);
    for (; !(r.from < n.from && r.to >= n.to || r.to > n.to && r.from <= n.from || !(!((O = r.parent) === null || O === void 0) && O.parent)); )
      r = r.parent;
    return R.range(r.to, r.from);
  });
  return e(wn(t, i)), true;
};
var e5 = ({ state: t, dispatch: e }) => {
  let i = t.selection, n = null;
  return i.ranges.length > 1 ? n = R.create([i.main]) : i.main.empty || (n = R.create([R.cursor(i.main.head)])), n ? (e(wn(t, n)), true) : false;
};
function Ou(t, e) {
  if (t.state.readOnly)
    return false;
  let i = "delete.selection", { state: n } = t, O = n.changeByRange((r) => {
    let { from: a, to: o } = r;
    if (a == o) {
      let s = e(a);
      s < a ? (i = "delete.backward", s = Js(t, s, false)) : s > a && (i = "delete.forward", s = Js(t, s, true)), a = Math.min(a, s), o = Math.max(o, s);
    } else
      a = Js(t, a, false), o = Js(t, o, true);
    return a == o ? { range: r } : { changes: { from: a, to: o }, range: R.cursor(a) };
  });
  return O.changes.empty ? false : (t.dispatch(n.update(O, {
    scrollIntoView: true,
    userEvent: i,
    effects: i == "delete.selection" ? B.announce.of(n.phrase("Selection deleted")) : void 0
  })), true);
}
function Js(t, e, i) {
  if (t instanceof B)
    for (let n of t.state.facet(B.atomicRanges).map((O) => O(t)))
      n.between(e, e, (O, r) => {
        O < e && r > e && (e = i ? r : O);
      });
  return e;
}
var d0 = (t, e) => Ou(t, (i) => {
  let { state: n } = t, O = n.doc.lineAt(i), r, a;
  if (!e && i > O.from && i < O.from + 200 && !/[^ \t]/.test(r = O.text.slice(0, i - O.from))) {
    if (r[r.length - 1] == "	")
      return i - 1;
    let o = Ss(r, n.tabSize), s = o % tr(n) || tr(n);
    for (let l = 0; l < s && r[r.length - 1 - l] == " "; l++)
      i--;
    a = i;
  } else
    a = Mt(O.text, i - O.from, e, e) + O.from, a == i && O.number != (e ? n.doc.lines : 1) && (a += e ? 1 : -1);
  return a;
});
var ad = (t) => d0(t, false);
var p0 = (t) => d0(t, true);
var $0 = (t, e) => Ou(t, (i) => {
  let n = i, { state: O } = t, r = O.doc.lineAt(n), a = O.charCategorizer(n);
  for (let o = null; ; ) {
    if (n == (e ? r.to : r.from)) {
      n == i && r.number != (e ? O.doc.lines : 1) && (n += e ? 1 : -1);
      break;
    }
    let s = Mt(r.text, n - r.from, e) + r.from, l = r.text.slice(Math.min(n, s) - r.from, Math.max(n, s) - r.from), c = a(l);
    if (o != null && c != o)
      break;
    (l != " " || n != i) && (o = c), n = s;
  }
  return n;
});
var Q0 = (t) => $0(t, false);
var t5 = (t) => $0(t, true);
var g0 = (t) => Ou(t, (e) => {
  let i = t.lineBlockAt(e).to;
  return e < i ? i : Math.min(t.state.doc.length, e + 1);
});
var i5 = (t) => Ou(t, (e) => {
  let i = t.lineBlockAt(e).from;
  return e > i ? i : Math.max(0, e - 1);
});
var n5 = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return false;
  let i = t.changeByRange((n) => ({
    changes: { from: n.from, to: n.to, insert: Te.of(["", ""]) },
    range: R.cursor(n.from)
  }));
  return e(t.update(i, { scrollIntoView: true, userEvent: "input" })), true;
};
var O5 = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return false;
  let i = t.changeByRange((n) => {
    if (!n.empty || n.from == 0 || n.from == t.doc.length)
      return { range: n };
    let O = n.from, r = t.doc.lineAt(O), a = O == r.from ? O - 1 : Mt(r.text, O - r.from, false) + r.from, o = O == r.to ? O + 1 : Mt(r.text, O - r.from, true) + r.from;
    return {
      changes: { from: a, to: o, insert: t.doc.slice(O, o).append(t.doc.slice(a, O)) },
      range: R.cursor(o)
    };
  });
  return i.changes.empty ? false : (e(t.update(i, { scrollIntoView: true, userEvent: "move.character" })), true);
};
function ru(t) {
  let e = [], i = -1;
  for (let n of t.selection.ranges) {
    let O = t.doc.lineAt(n.from), r = t.doc.lineAt(n.to);
    if (!n.empty && n.to == r.from && (r = t.doc.lineAt(n.to - 1)), i >= O.number) {
      let a = e[e.length - 1];
      a.to = r.to, a.ranges.push(n);
    } else
      e.push({ from: O.from, to: r.to, ranges: [n] });
    i = r.number + 1;
  }
  return e;
}
function m0(t, e, i) {
  if (t.readOnly)
    return false;
  let n = [], O = [];
  for (let r of ru(t)) {
    if (i ? r.to == t.doc.length : r.from == 0)
      continue;
    let a = t.doc.lineAt(i ? r.to + 1 : r.from - 1), o = a.length + 1;
    if (i) {
      n.push({ from: r.to, to: a.to }, { from: r.from, insert: a.text + t.lineBreak });
      for (let s of r.ranges)
        O.push(R.range(Math.min(t.doc.length, s.anchor + o), Math.min(t.doc.length, s.head + o)));
    } else {
      n.push({ from: a.from, to: r.from }, { from: r.to, insert: t.lineBreak + a.text });
      for (let s of r.ranges)
        O.push(R.range(s.anchor - o, s.head - o));
    }
  }
  return n.length ? (e(t.update({
    changes: n,
    scrollIntoView: true,
    selection: R.create(O, t.selection.mainIndex),
    userEvent: "move.line"
  })), true) : false;
}
var r5 = ({ state: t, dispatch: e }) => m0(t, e, false);
var a5 = ({ state: t, dispatch: e }) => m0(t, e, true);
function S0(t, e, i) {
  if (t.readOnly)
    return false;
  let n = [];
  for (let O of ru(t))
    i ? n.push({ from: O.from, insert: t.doc.slice(O.from, O.to) + t.lineBreak }) : n.push({ from: O.to, insert: t.lineBreak + t.doc.slice(O.from, O.to) });
  return e(t.update({ changes: n, scrollIntoView: true, userEvent: "input.copyline" })), true;
}
var o5 = ({ state: t, dispatch: e }) => S0(t, e, false);
var s5 = ({ state: t, dispatch: e }) => S0(t, e, true);
var l5 = (t) => {
  if (t.state.readOnly)
    return false;
  let { state: e } = t, i = e.changes(ru(e).map(({ from: O, to: r }) => (O > 0 ? O-- : r < e.doc.length && r++, { from: O, to: r }))), n = Ya(e.selection, (O) => t.moveVertically(O, true)).map(i);
  return t.dispatch({ changes: i, selection: n, scrollIntoView: true, userEvent: "delete.line" }), true;
};
function c5(t, e) {
  if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let i = Ye(t).resolveInner(e), n = i.childBefore(e), O = i.childAfter(e), r;
  return n && O && n.to <= e && O.from >= e && (r = n.type.prop(se.closedBy)) && r.indexOf(O.name) > -1 && t.doc.lineAt(n.to).from == t.doc.lineAt(O.from).from ? { from: n.to, to: O.from } : null;
}
var u5 = P0(false);
var f5 = P0(true);
function P0(t) {
  return ({ state: e, dispatch: i }) => {
    if (e.readOnly)
      return false;
    let n = e.changeByRange((O) => {
      let { from: r, to: a } = O, o = e.doc.lineAt(r), s = !t && r == a && c5(e, r);
      t && (r = a = (a <= o.to ? o : e.doc.lineAt(a)).to);
      let l = new Jc(e, { simulateBreak: r, simulateDoubleBreak: !!s }), c = zp(l, r);
      for (c == null && (c = /^\s*/.exec(e.doc.lineAt(r).text)[0].length); a < o.to && /\s/.test(o.text[a - o.from]); )
        a++;
      s ? { from: r, to: a } = s : r > o.from && r < o.from + 100 && !/\S/.test(o.text.slice(0, r)) && (r = o.from);
      let u = ["", Jo(e, c)];
      return s && u.push(Jo(e, l.lineIndent(o.from, -1))), {
        changes: { from: r, to: a, insert: Te.of(u) },
        range: R.cursor(r + 1 + u[1].length)
      };
    });
    return i(e.update(n, { scrollIntoView: true, userEvent: "input" })), true;
  };
}
function Mp(t, e) {
  let i = -1;
  return t.changeByRange((n) => {
    let O = [];
    for (let a = n.from; a <= n.to; ) {
      let o = t.doc.lineAt(a);
      o.number > i && (n.empty || n.to > o.from) && (e(o, O, n), i = o.number), a = o.to + 1;
    }
    let r = t.changes(O);
    return {
      changes: O,
      range: R.range(r.mapPos(n.anchor, 1), r.mapPos(n.head, 1))
    };
  });
}
var h5 = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return false;
  let i = /* @__PURE__ */ Object.create(null), n = new Jc(t, { overrideIndentation: (r) => {
    let a = i[r];
    return a ?? -1;
  } }), O = Mp(t, (r, a, o) => {
    let s = zp(n, r.from);
    if (s == null)
      return;
    /\S/.test(r.text) || (s = 0);
    let l = /^\s*/.exec(r.text)[0], c = Jo(t, s);
    (l != c || o.from < r.from + l.length) && (i[r.from] = s, a.push({ from: r.from, to: r.from + l.length, insert: c }));
  });
  return O.changes.empty || e(t.update(O, { userEvent: "indent" })), true;
};
var y0 = ({ state: t, dispatch: e }) => t.readOnly ? false : (e(t.update(Mp(t, (i, n) => {
  n.push({ from: i.from, insert: t.facet(bs) });
}), { userEvent: "input.indent" })), true);
var b0 = ({ state: t, dispatch: e }) => t.readOnly ? false : (e(t.update(Mp(t, (i, n) => {
  let O = /^\s*/.exec(i.text)[0];
  if (!O)
    return;
  let r = Ss(O, t.tabSize), a = 0, o = Jo(t, Math.max(0, r - tr(t)));
  for (; a < O.length && a < o.length && O.charCodeAt(a) == o.charCodeAt(a); )
    a++;
  n.push({ from: i.from + a, to: i.from + O.length, insert: o.slice(a) });
}), { userEvent: "delete.dedent" })), true);
var d5 = [
  { key: "Ctrl-b", run: K1, shift: o0, preventDefault: true },
  { key: "Ctrl-f", run: J1, shift: s0 },
  { key: "Ctrl-p", run: i0, shift: u0 },
  { key: "Ctrl-n", run: n0, shift: f0 },
  { key: "Ctrl-a", run: qZ, shift: BZ },
  { key: "Ctrl-e", run: zZ, shift: FZ },
  { key: "Ctrl-d", run: p0 },
  { key: "Ctrl-h", run: ad },
  { key: "Ctrl-k", run: g0 },
  { key: "Ctrl-Alt-h", run: Q0 },
  { key: "Ctrl-o", run: n5 },
  { key: "Ctrl-t", run: O5 },
  { key: "Ctrl-v", run: rd }
];
var p5 = [
  { key: "ArrowLeft", run: K1, shift: o0, preventDefault: true },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: TZ, shift: jZ, preventDefault: true },
  { mac: "Cmd-ArrowLeft", run: UZ, shift: MZ, preventDefault: true },
  { key: "ArrowRight", run: J1, shift: s0, preventDefault: true },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: kZ, shift: IZ, preventDefault: true },
  { mac: "Cmd-ArrowRight", run: VZ, shift: NZ, preventDefault: true },
  { key: "ArrowUp", run: i0, shift: u0, preventDefault: true },
  { mac: "Cmd-ArrowUp", run: rm, shift: om },
  { mac: "Ctrl-ArrowUp", run: im, shift: nm },
  { key: "ArrowDown", run: n0, shift: f0, preventDefault: true },
  { mac: "Cmd-ArrowDown", run: am, shift: sm },
  { mac: "Ctrl-ArrowDown", run: rd, shift: Om },
  { key: "PageUp", run: im, shift: nm },
  { key: "PageDown", run: rd, shift: Om },
  { key: "Home", run: ZZ, shift: DZ, preventDefault: true },
  { key: "Mod-Home", run: rm, shift: om },
  { key: "End", run: RZ, shift: LZ, preventDefault: true },
  { key: "Mod-End", run: am, shift: sm },
  { key: "Enter", run: u5 },
  { key: "Mod-a", run: HZ },
  { key: "Backspace", run: ad, shift: ad },
  { key: "Delete", run: p0 },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: Q0 },
  { key: "Mod-Delete", mac: "Alt-Delete", run: t5 },
  { mac: "Mod-Backspace", run: i5 },
  { mac: "Mod-Delete", run: g0 }
].concat(d5.map((t) => ({ mac: t.key, run: t.run, shift: t.shift })));
var $5 = [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: WZ, shift: AZ },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: YZ, shift: GZ },
  { key: "Alt-ArrowUp", run: r5 },
  { key: "Shift-Alt-ArrowUp", run: o5 },
  { key: "Alt-ArrowDown", run: a5 },
  { key: "Shift-Alt-ArrowDown", run: s5 },
  { key: "Escape", run: e5 },
  { key: "Mod-Enter", run: f5 },
  { key: "Alt-l", mac: "Ctrl-l", run: KZ },
  { key: "Mod-i", run: JZ, preventDefault: true },
  { key: "Mod-[", run: b0 },
  { key: "Mod-]", run: y0 },
  { key: "Mod-Alt-\\", run: h5 },
  { key: "Shift-Mod-k", run: l5 },
  { key: "Shift-Mod-\\", run: EZ },
  { key: "Mod-/", run: sZ },
  { key: "Alt-A", run: cZ }
].concat(p5);
var Q5 = { key: "Tab", run: y0, shift: b0 };
function Ue() {
  var t = arguments[0];
  typeof t == "string" && (t = document.createElement(t));
  var e = 1, i = arguments[1];
  if (i && typeof i == "object" && i.nodeType == null && !Array.isArray(i)) {
    for (var n in i)
      if (Object.prototype.hasOwnProperty.call(i, n)) {
        var O = i[n];
        typeof O == "string" ? t.setAttribute(n, O) : O != null && (t[n] = O);
      }
    e++;
  }
  for (; e < arguments.length; e++)
    v0(t, arguments[e]);
  return t;
}
function v0(t, e) {
  if (typeof e == "string")
    t.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null)
      t.appendChild(e);
    else if (Array.isArray(e))
      for (var i = 0; i < e.length; i++)
        v0(t, e[i]);
    else
      throw new RangeError("Unsupported child node: " + e);
}
var lm = typeof String.prototype.normalize == "function" ? (t) => t.normalize("NFKD") : (t) => t;
var Oa = class {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, i, n = 0, O = e.length, r, a) {
    this.test = a, this.value = { from: 0, to: 0 }, this.done = false, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(n, O), this.bufferStart = n, this.normalize = r ? (o) => r(lm(o)) : lm, this.query = this.normalize(i);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Xt(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = true, this;
      let i = Pp(e), n = this.bufferStart + this.bufferPos;
      this.bufferPos += _i(e);
      let O = this.normalize(i);
      for (let r = 0, a = n; ; r++) {
        let o = O.charCodeAt(r), s = this.match(o, a);
        if (s)
          return this.value = s, this;
        if (r == O.length - 1)
          break;
        a == n && r < i.length && i.charCodeAt(r) == o && a++;
      }
    }
  }
  match(e, i) {
    let n = null;
    for (let O = 0; O < this.matches.length; O += 2) {
      let r = this.matches[O], a = false;
      this.query.charCodeAt(r) == e && (r == this.query.length - 1 ? n = { from: this.matches[O + 1], to: i + 1 } : (this.matches[O]++, a = true)), a || (this.matches.splice(O, 2), O -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? n = { from: i, to: i + 1 } : this.matches.push(1, i)), n && this.test && !this.test(n.from, n.to, this.buffer, this.bufferPos) && (n = null), n;
  }
};
typeof Symbol < "u" && (Oa.prototype[Symbol.iterator] = function() {
  return this;
});
var X0 = { from: -1, to: -1, match: /.*/.exec("") };
var Np = "gm" + (/x/.unicode == null ? "" : "u");
var x0 = class {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, i, n, O = 0, r = e.length) {
    if (this.text = e, this.to = r, this.curLine = "", this.done = false, this.value = X0, /\\[sWDnr]|\n|\r|\[\^/.test(i))
      return new w0(e, i, n, O, r);
    this.re = new RegExp(i, Np + (n != null && n.ignoreCase ? "i" : "")), this.test = n == null ? void 0 : n.test, this.iter = e.iter();
    let a = e.lineAt(O);
    this.curLineStart = a.from, this.matchPos = ac(e, O), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let i = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (i) {
        let n = this.curLineStart + i.index, O = n + i[0].length;
        if (this.matchPos = ac(this.text, O + (n == O ? 1 : 0)), n == this.curLineStart + this.curLine.length && this.nextLine(), (n < O || n > this.value.to) && (!this.test || this.test(n, O, i)))
          return this.value = { from: n, to: O, match: i }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = true, this;
    }
  }
};
var cf = /* @__PURE__ */ new WeakMap();
var Nr = class {
  constructor(e, i) {
    this.from = e, this.text = i;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, i, n) {
    let O = cf.get(e);
    if (!O || O.from >= n || O.to <= i) {
      let o = new Nr(i, e.sliceString(i, n));
      return cf.set(e, o), o;
    }
    if (O.from == i && O.to == n)
      return O;
    let { text: r, from: a } = O;
    return a > i && (r = e.sliceString(i, a) + r, a = i), O.to < n && (r += e.sliceString(O.to, n)), cf.set(e, new Nr(a, r)), new Nr(i, r.slice(i - a, n - a));
  }
};
var w0 = class {
  constructor(e, i, n, O, r) {
    this.text = e, this.to = r, this.done = false, this.value = X0, this.matchPos = ac(e, O), this.re = new RegExp(i, Np + (n != null && n.ignoreCase ? "i" : "")), this.test = n == null ? void 0 : n.test, this.flat = Nr.get(e, O, this.chunkEnd(
      O + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, i = this.re.exec(this.flat.text);
      if (i && !i[0] && i.index == e && (this.re.lastIndex = e + 1, i = this.re.exec(this.flat.text)), i) {
        let n = this.flat.from + i.index, O = n + i[0].length;
        if ((this.flat.to >= this.to || i.index + i[0].length <= this.flat.text.length - 10) && (!this.test || this.test(n, O, i)))
          return this.value = { from: n, to: O, match: i }, this.matchPos = ac(this.text, O + (n == O ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = true, this;
      this.flat = Nr.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
};
typeof Symbol < "u" && (x0.prototype[Symbol.iterator] = w0.prototype[Symbol.iterator] = function() {
  return this;
});
function g5(t) {
  try {
    return new RegExp(t, Np), true;
  } catch {
    return false;
  }
}
function ac(t, e) {
  if (e >= t.length)
    return e;
  let i = t.lineAt(e), n;
  for (; e < i.to && (n = i.text.charCodeAt(e - i.from)) >= 56320 && n < 57344; )
    e++;
  return e;
}
function od(t) {
  let e = Ue("input", { class: "cm-textfield", name: "line" }), i = Ue("form", {
    class: "cm-gotoLine",
    onkeydown: (O) => {
      O.keyCode == 27 ? (O.preventDefault(), t.dispatch({ effects: oc.of(false) }), t.focus()) : O.keyCode == 13 && (O.preventDefault(), n());
    },
    onsubmit: (O) => {
      O.preventDefault(), n();
    }
  }, Ue("label", t.state.phrase("Go to line"), ": ", e), " ", Ue("button", { class: "cm-button", type: "submit" }, t.state.phrase("go")));
  function n() {
    let O = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(e.value);
    if (!O)
      return;
    let { state: r } = t, a = r.doc.lineAt(r.selection.main.head), [, o, s, l, c] = O, u = l ? +l.slice(1) : 0, h10 = s ? +s : a.number;
    if (s && c) {
      let p = h10 / 100;
      o && (p = p * (o == "-" ? -1 : 1) + a.number / r.doc.lines), h10 = Math.round(r.doc.lines * p);
    } else
      s && o && (h10 = h10 * (o == "-" ? -1 : 1) + a.number);
    let d = r.doc.line(Math.max(1, Math.min(r.doc.lines, h10)));
    t.dispatch({
      effects: oc.of(false),
      selection: R.cursor(d.from + Math.max(0, Math.min(u, d.length))),
      scrollIntoView: true
    }), t.focus();
  }
  return { dom: i };
}
var oc = fe.define();
var cm = St.define({
  create() {
    return true;
  },
  update(t, e) {
    for (let i of e.effects)
      i.is(oc) && (t = i.value);
    return t;
  },
  provide: (t) => Ho.from(t, (e) => e ? od : null)
});
var m5 = (t) => {
  let e = Fo(t, od);
  if (!e) {
    let i = [oc.of(true)];
    t.state.field(cm, false) == null && i.push(fe.appendConfig.of([cm, S5])), t.dispatch({ effects: i }), e = Fo(t, od);
  }
  return e && e.dom.querySelector("input").focus(), true;
};
var S5 = B.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
});
var P5 = {
  highlightWordAroundCursor: false,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: false
};
var T0 = K.define({
  combine(t) {
    return Xn(t, P5, {
      highlightWordAroundCursor: (e, i) => e || i,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function y5(t) {
  let e = [w5, x5];
  return t && e.push(T0.of(t)), e;
}
var b5 = ne.mark({ class: "cm-selectionMatch" });
var v5 = ne.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function um(t, e, i, n) {
  return (i == 0 || t(e.sliceDoc(i - 1, i)) != Le.Word) && (n == e.doc.length || t(e.sliceDoc(n, n + 1)) != Le.Word);
}
function X5(t, e, i, n) {
  return t(e.sliceDoc(i, i + 1)) == Le.Word && t(e.sliceDoc(n - 1, n)) == Le.Word;
}
var x5 = it.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = t.state.facet(T0), { state: i } = t, n = i.selection;
    if (n.ranges.length > 1)
      return ne.none;
    let O = n.main, r, a = null;
    if (O.empty) {
      if (!e.highlightWordAroundCursor)
        return ne.none;
      let s = i.wordAt(O.head);
      if (!s)
        return ne.none;
      a = i.charCategorizer(O.head), r = i.sliceDoc(s.from, s.to);
    } else {
      let s = O.to - O.from;
      if (s < e.minSelectionLength || s > 200)
        return ne.none;
      if (e.wholeWords) {
        if (r = i.sliceDoc(O.from, O.to), a = i.charCategorizer(O.head), !(um(a, i, O.from, O.to) && X5(a, i, O.from, O.to)))
          return ne.none;
      } else if (r = i.sliceDoc(O.from, O.to).trim(), !r)
        return ne.none;
    }
    let o = [];
    for (let s of t.visibleRanges) {
      let l = new Oa(i.doc, r, s.from, s.to);
      for (; !l.next().done; ) {
        let { from: c, to: u } = l.value;
        if ((!a || um(a, i, c, u)) && (O.empty && c <= O.from && u >= O.to ? o.push(v5.range(c, u)) : (c >= O.to || u <= O.from) && o.push(b5.range(c, u)), o.length > e.maxMatches))
          return ne.none;
      }
    }
    return ne.set(o);
  }
}, {
  decorations: (t) => t.decorations
});
var w5 = B.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
});
var T5 = ({ state: t, dispatch: e }) => {
  let { selection: i } = t, n = R.create(i.ranges.map((O) => t.wordAt(O.head) || R.cursor(O.head)), i.mainIndex);
  return n.eq(i) ? false : (e(t.update({ selection: n })), true);
};
function k5(t, e) {
  let { main: i, ranges: n } = t.selection, O = t.wordAt(i.head), r = O && O.from == i.from && O.to == i.to;
  for (let a = false, o = new Oa(t.doc, e, n[n.length - 1].to); ; )
    if (o.next(), o.done) {
      if (a)
        return null;
      o = new Oa(t.doc, e, 0, Math.max(0, n[n.length - 1].from - 1)), a = true;
    } else {
      if (a && n.some((s) => s.from == o.value.from))
        continue;
      if (r) {
        let s = t.wordAt(o.value.from);
        if (!s || s.from != o.value.from || s.to != o.value.to)
          continue;
      }
      return o.value;
    }
}
var _5 = ({ state: t, dispatch: e }) => {
  let { ranges: i } = t.selection;
  if (i.some((r) => r.from === r.to))
    return T5({ state: t, dispatch: e });
  let n = t.sliceDoc(i[0].from, i[0].to);
  if (t.selection.ranges.some((r) => t.sliceDoc(r.from, r.to) != n))
    return false;
  let O = k5(t, n);
  return O ? (e(t.update({
    selection: t.selection.addRange(R.range(O.from, O.to), false),
    effects: B.scrollIntoView(O.to)
  })), true) : false;
};
var Bp = K.define({
  combine(t) {
    return Xn(t, {
      top: false,
      caseSensitive: false,
      literal: false,
      wholeWord: false,
      createPanel: (e) => new I5(e)
    });
  }
});
var k0 = class {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || g5(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (i, n) => n == "n" ? `
` : n == "r" ? "\r" : n == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new Z5(this) : new Y5(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, i = 0, n) {
    let O = e.doc ? e : ye.create({ doc: e });
    return n == null && (n = O.doc.length), this.regexp ? zr(this, O, i, n) : qr(this, O, i, n);
  }
};
var _0 = class {
  constructor(e) {
    this.spec = e;
  }
};
function qr(t, e, i, n) {
  return new Oa(e.doc, t.unquoted, i, n, t.caseSensitive ? void 0 : (O) => O.toLowerCase(), t.wholeWord ? W5(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function W5(t, e) {
  return (i, n, O, r) => ((r > i || r + O.length < n) && (r = Math.max(0, i - 2), O = t.sliceString(r, Math.min(t.length, n + 2))), (e(sc(O, i - r)) != Le.Word || e(lc(O, i - r)) != Le.Word) && (e(lc(O, n - r)) != Le.Word || e(sc(O, n - r)) != Le.Word));
}
var Y5 = class extends _0 {
  constructor(e) {
    super(e);
  }
  nextMatch(e, i, n) {
    let O = qr(this.spec, e, n, e.doc.length).nextOverlapping();
    return O.done && (O = qr(this.spec, e, 0, i).nextOverlapping()), O.done ? null : O.value;
  }
  // Searching in reverse is, rather than implementing inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, i, n) {
    for (let O = n; ; ) {
      let r = Math.max(i, O - 1e4 - this.spec.unquoted.length), a = qr(this.spec, e, r, O), o = null;
      for (; !a.nextOverlapping().done; )
        o = a.value;
      if (o)
        return o;
      if (r == i)
        return null;
      O -= 1e4;
    }
  }
  prevMatch(e, i, n) {
    return this.prevMatchInRange(e, 0, i) || this.prevMatchInRange(e, n, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, i) {
    let n = qr(this.spec, e, 0, e.doc.length), O = [];
    for (; !n.next().done; ) {
      if (O.length >= i)
        return null;
      O.push(n.value);
    }
    return O;
  }
  highlight(e, i, n, O) {
    let r = qr(this.spec, e, Math.max(0, i - this.spec.unquoted.length), Math.min(n + this.spec.unquoted.length, e.doc.length));
    for (; !r.next().done; )
      O(r.value.from, r.value.to);
  }
};
function zr(t, e, i, n) {
  return new x0(e.doc, t.search, {
    ignoreCase: !t.caseSensitive,
    test: t.wholeWord ? R5(e.charCategorizer(e.selection.main.head)) : void 0
  }, i, n);
}
function sc(t, e) {
  return t.slice(Mt(t, e, false), e);
}
function lc(t, e) {
  return t.slice(e, Mt(t, e));
}
function R5(t) {
  return (e, i, n) => !n[0].length || (t(sc(n.input, n.index)) != Le.Word || t(lc(n.input, n.index)) != Le.Word) && (t(lc(n.input, n.index + n[0].length)) != Le.Word || t(sc(n.input, n.index + n[0].length)) != Le.Word);
}
var Z5 = class extends _0 {
  nextMatch(e, i, n) {
    let O = zr(this.spec, e, n, e.doc.length).next();
    return O.done && (O = zr(this.spec, e, 0, i).next()), O.done ? null : O.value;
  }
  prevMatchInRange(e, i, n) {
    for (let O = 1; ; O++) {
      let r = Math.max(
        i,
        n - O * 1e4
        /* FindPrev.ChunkSize */
      ), a = zr(this.spec, e, r, n), o = null;
      for (; !a.next().done; )
        o = a.value;
      if (o && (r == i || o.from > r + 10))
        return o;
      if (r == i)
        return null;
    }
  }
  prevMatch(e, i, n) {
    return this.prevMatchInRange(e, 0, i) || this.prevMatchInRange(e, n, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace.replace(/\$([$&\d+])/g, (i, n) => n == "$" ? "$" : n == "&" ? e.match[0] : n != "0" && +n < e.match.length ? e.match[n] : i));
  }
  matchAll(e, i) {
    let n = zr(this.spec, e, 0, e.doc.length), O = [];
    for (; !n.next().done; ) {
      if (O.length >= i)
        return null;
      O.push(n.value);
    }
    return O;
  }
  highlight(e, i, n, O) {
    let r = zr(this.spec, e, Math.max(
      0,
      i - 250
      /* RegExp.HighlightMargin */
    ), Math.min(n + 250, e.doc.length));
    for (; !r.next().done; )
      O(r.value.from, r.value.to);
  }
};
var ts = fe.define();
var Fp = fe.define();
var pO = St.define({
  create(t) {
    return new uf(sd(t).create(), null);
  },
  update(t, e) {
    for (let i of e.effects)
      i.is(ts) ? t = new uf(i.value.create(), t.panel) : i.is(Fp) && (t = new uf(t.query, i.value ? Hp : null));
    return t;
  },
  provide: (t) => Ho.from(t, (e) => e.panel)
});
var uf = class {
  constructor(e, i) {
    this.query = e, this.panel = i;
  }
};
var U5 = ne.mark({ class: "cm-searchMatch" });
var V5 = ne.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
var q5 = it.fromClass(class {
  constructor(t) {
    this.view = t, this.decorations = this.highlight(t.state.field(pO));
  }
  update(t) {
    let e = t.state.field(pO);
    (e != t.startState.field(pO) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: t, panel: e }) {
    if (!e || !t.spec.valid)
      return ne.none;
    let { view: i } = this, n = new QO();
    for (let O = 0, r = i.visibleRanges, a = r.length; O < a; O++) {
      let { from: o, to: s } = r[O];
      for (; O < a - 1 && s > r[O + 1].from - 2 * 250; )
        s = r[++O].to;
      t.highlight(i.state, o, s, (l, c) => {
        let u = i.state.selection.ranges.some((h10) => h10.from == l && h10.to == c);
        n.add(l, c, u ? V5 : U5);
      });
    }
    return n.finish();
  }
}, {
  decorations: (t) => t.decorations
});
function Xs(t) {
  return (e) => {
    let i = e.state.field(pO, false);
    return i && i.query.spec.valid ? t(e, i) : W0(e);
  };
}
var cc = Xs((t, { query: e }) => {
  let { to: i } = t.state.selection.main, n = e.nextMatch(t.state, i, i);
  return n ? (t.dispatch({
    selection: { anchor: n.from, head: n.to },
    scrollIntoView: true,
    effects: Kp(t, n),
    userEvent: "select.search"
  }), true) : false;
});
var uc = Xs((t, { query: e }) => {
  let { state: i } = t, { from: n } = i.selection.main, O = e.prevMatch(i, n, n);
  return O ? (t.dispatch({
    selection: { anchor: O.from, head: O.to },
    scrollIntoView: true,
    effects: Kp(t, O),
    userEvent: "select.search"
  }), true) : false;
});
var z5 = Xs((t, { query: e }) => {
  let i = e.matchAll(t.state, 1e3);
  return !i || !i.length ? false : (t.dispatch({
    selection: R.create(i.map((n) => R.range(n.from, n.to))),
    userEvent: "select.search.matches"
  }), true);
});
var C5 = ({ state: t, dispatch: e }) => {
  let i = t.selection;
  if (i.ranges.length > 1 || i.main.empty)
    return false;
  let { from: n, to: O } = i.main, r = [], a = 0;
  for (let o = new Oa(t.doc, t.sliceDoc(n, O)); !o.next().done; ) {
    if (r.length > 1e3)
      return false;
    o.value.from == n && (a = r.length), r.push(R.range(o.value.from, o.value.to));
  }
  return e(t.update({
    selection: R.create(r, a),
    userEvent: "select.search.matches"
  })), true;
};
var fm = Xs((t, { query: e }) => {
  let { state: i } = t, { from: n, to: O } = i.selection.main;
  if (i.readOnly)
    return false;
  let r = e.nextMatch(i, n, n);
  if (!r)
    return false;
  let a = [], o, s, l = [];
  if (r.from == n && r.to == O && (s = i.toText(e.getReplacement(r)), a.push({ from: r.from, to: r.to, insert: s }), r = e.nextMatch(i, r.from, r.to), l.push(B.announce.of(i.phrase("replaced match on line $", i.doc.lineAt(n).number) + "."))), r) {
    let c = a.length == 0 || a[0].from >= r.to ? 0 : r.to - r.from - s.length;
    o = { anchor: r.from - c, head: r.to - c }, l.push(Kp(t, r));
  }
  return t.dispatch({
    changes: a,
    selection: o,
    scrollIntoView: !!o,
    effects: l,
    userEvent: "input.replace"
  }), true;
});
var E5 = Xs((t, { query: e }) => {
  if (t.state.readOnly)
    return false;
  let i = e.matchAll(t.state, 1e9).map((O) => {
    let { from: r, to: a } = O;
    return { from: r, to: a, insert: e.getReplacement(O) };
  });
  if (!i.length)
    return false;
  let n = t.state.phrase("replaced $ matches", i.length) + ".";
  return t.dispatch({
    changes: i,
    effects: B.announce.of(n),
    userEvent: "input.replace.all"
  }), true;
});
function Hp(t) {
  return t.state.facet(Bp).createPanel(t);
}
function sd(t, e) {
  var i, n, O, r;
  let a = t.selection.main, o = a.empty || a.to > a.from + 100 ? "" : t.sliceDoc(a.from, a.to);
  if (e && !o)
    return e;
  let s = t.facet(Bp);
  return new k0({
    search: ((i = e == null ? void 0 : e.literal) !== null && i !== void 0 ? i : s.literal) ? o : o.replace(/\n/g, "\\n"),
    caseSensitive: (n = e == null ? void 0 : e.caseSensitive) !== null && n !== void 0 ? n : s.caseSensitive,
    literal: (O = e == null ? void 0 : e.literal) !== null && O !== void 0 ? O : s.literal,
    wholeWord: (r = e == null ? void 0 : e.wholeWord) !== null && r !== void 0 ? r : s.wholeWord
  });
}
var W0 = (t) => {
  let e = t.state.field(pO, false);
  if (e && e.panel) {
    let i = Fo(t, Hp);
    if (!i)
      return false;
    let n = i.dom.querySelector("[main-field]");
    if (n && n != t.root.activeElement) {
      let O = sd(t.state, e.query.spec);
      O.valid && t.dispatch({ effects: ts.of(O) }), n.focus(), n.select();
    }
  } else
    t.dispatch({ effects: [
      Fp.of(true),
      e ? ts.of(sd(t.state, e.query.spec)) : fe.appendConfig.of(G5)
    ] });
  return true;
};
var Y0 = (t) => {
  let e = t.state.field(pO, false);
  if (!e || !e.panel)
    return false;
  let i = Fo(t, Hp);
  return i && i.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: Fp.of(false) }), true;
};
var j5 = [
  { key: "Mod-f", run: W0, scope: "editor search-panel" },
  { key: "F3", run: cc, shift: uc, scope: "editor search-panel", preventDefault: true },
  { key: "Mod-g", run: cc, shift: uc, scope: "editor search-panel", preventDefault: true },
  { key: "Escape", run: Y0, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: C5 },
  { key: "Alt-g", run: m5 },
  { key: "Mod-d", run: _5, preventDefault: true }
];
var I5 = class {
  constructor(e) {
    this.view = e;
    let i = this.query = e.state.field(pO).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Ue("input", {
      value: i.search,
      placeholder: fi(e, "Find"),
      "aria-label": fi(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Ue("input", {
      value: i.replace,
      placeholder: fi(e, "Replace"),
      "aria-label": fi(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Ue("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: i.caseSensitive,
      onchange: this.commit
    }), this.reField = Ue("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: i.regexp,
      onchange: this.commit
    }), this.wordField = Ue("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: i.wholeWord,
      onchange: this.commit
    });
    function n(O, r, a) {
      return Ue("button", { class: "cm-button", name: O, onclick: r, type: "button" }, a);
    }
    this.dom = Ue("div", { onkeydown: (O) => this.keydown(O), class: "cm-search" }, [
      this.searchField,
      n("next", () => cc(e), [fi(e, "next")]),
      n("prev", () => uc(e), [fi(e, "previous")]),
      n("select", () => z5(e), [fi(e, "all")]),
      Ue("label", null, [this.caseField, fi(e, "match case")]),
      Ue("label", null, [this.reField, fi(e, "regexp")]),
      Ue("label", null, [this.wordField, fi(e, "by word")]),
      ...e.state.readOnly ? [] : [
        Ue("br"),
        this.replaceField,
        n("replace", () => fm(e), [fi(e, "replace")]),
        n("replaceAll", () => E5(e), [fi(e, "replace all")])
      ],
      Ue("button", {
        name: "close",
        onclick: () => Y0(e),
        "aria-label": fi(e, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let e = new k0({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: ts.of(e) }));
  }
  keydown(e) {
    eY(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? uc : cc)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), fm(this.view));
  }
  update(e) {
    for (let i of e.transactions)
      for (let n of i.effects)
        n.is(ts) && !n.value.eq(this.query) && this.setQuery(n.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(Bp).top;
  }
};
function fi(t, e) {
  return t.state.phrase(e);
}
var el = 30;
var tl = /[\s\.,:;?!]/;
function Kp(t, { from: e, to: i }) {
  let n = t.state.doc.lineAt(e), O = t.state.doc.lineAt(i).to, r = Math.max(n.from, e - el), a = Math.min(O, i + el), o = t.state.sliceDoc(r, a);
  if (r != n.from) {
    for (let s = 0; s < el; s++)
      if (!tl.test(o[s + 1]) && tl.test(o[s])) {
        o = o.slice(s);
        break;
      }
  }
  if (a != O) {
    for (let s = o.length - 1; s > o.length - el; s--)
      if (!tl.test(o[s - 1]) && tl.test(o[s])) {
        o = o.slice(0, s);
        break;
      }
  }
  return B.announce.of(`${t.state.phrase("current match")}. ${o} ${t.state.phrase("on line")} ${n.number}.`);
}
var A5 = B.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
});
var G5 = [
  pO,
  wO.lowest(q5),
  A5
];
var R0 = class {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(e, i, n) {
    this.state = e, this.pos = i, this.explicit = n, this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let i = Ye(this.state).resolveInner(this.pos, -1);
    for (; i && e.indexOf(i.name) < 0; )
      i = i.parent;
    return i ? {
      from: i.from,
      to: this.pos,
      text: this.state.sliceDoc(i.from, this.pos),
      type: i.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let i = this.state.doc.lineAt(this.pos), n = Math.max(i.from, this.pos - 250), O = i.text.slice(n - i.from, this.pos - i.from), r = O.search(Z0(e, false));
    return r < 0 ? null : { from: n + r, to: this.pos, text: O.slice(r) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(e, i) {
    e == "abort" && this.abortListeners && this.abortListeners.push(i);
  }
};
function hm(t) {
  let e = Object.keys(t).join(""), i = /\w/.test(e);
  return i && (e = e.replace(/\w/g, "")), `[${i ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function L5(t) {
  let e = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null);
  for (let { label: O } of t) {
    e[O[0]] = true;
    for (let r = 1; r < O.length; r++)
      i[O[r]] = true;
  }
  let n = hm(e) + hm(i) + "*$";
  return [new RegExp("^" + n), new RegExp(n)];
}
function au(t) {
  let e = t.map((O) => typeof O == "string" ? { label: O } : O), [i, n] = e.every((O) => /^\w+$/.test(O.label)) ? [/\w*$/, /\w+$/] : L5(e);
  return (O) => {
    let r = O.matchBefore(n);
    return r || O.explicit ? { from: r ? r.from : O.pos, options: e, validFor: i } : null;
  };
}
function Jp(t, e) {
  return (i) => {
    for (let n = Ye(i.state).resolveInner(i.pos, -1); n; n = n.parent) {
      if (t.indexOf(n.name) > -1)
        return null;
      if (n.type.isTop)
        break;
    }
    return e(i);
  };
}
var dm = class {
  constructor(e, i, n) {
    this.completion = e, this.source = i, this.match = n;
  }
};
function $O(t) {
  return t.selection.main.head;
}
function Z0(t, e) {
  var i;
  let { source: n } = t, O = e && n[0] != "^", r = n[n.length - 1] != "$";
  return !O && !r ? t : new RegExp(`${O ? "^" : ""}(?:${n})${r ? "$" : ""}`, (i = t.flags) !== null && i !== void 0 ? i : t.ignoreCase ? "i" : "");
}
var U0 = Dn.define();
function D5(t, e, i, n) {
  return Object.assign(Object.assign({}, t.changeByRange((O) => {
    if (O == t.selection.main)
      return {
        changes: { from: i, to: n, insert: e },
        range: R.cursor(i + e.length)
      };
    let r = n - i;
    return !O.empty || r && t.sliceDoc(O.from - r, O.from) != t.sliceDoc(i, n) ? { range: O } : {
      changes: { from: O.from - r, to: O.from, insert: e },
      range: R.cursor(O.from - r + e.length)
    };
  })), { userEvent: "input.complete" });
}
function V0(t, e) {
  const i = e.completion.apply || e.completion.label;
  let n = e.source;
  typeof i == "string" ? t.dispatch(Object.assign(Object.assign({}, D5(t.state, i, n.from, n.to)), { annotations: U0.of(e.completion) })) : i(t, e.completion, n.from, n.to);
}
var pm = /* @__PURE__ */ new WeakMap();
function M5(t) {
  if (!Array.isArray(t))
    return t;
  let e = pm.get(t);
  return e || pm.set(t, e = au(t)), e;
}
var N5 = class {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [];
    for (let i = 0; i < e.length; ) {
      let n = Xt(e, i), O = _i(n);
      this.chars.push(n);
      let r = e.slice(i, i + O), a = r.toUpperCase();
      this.folded.push(Xt(a == r ? r.toLowerCase() : a, 0)), i += O;
    }
    this.astral = e.length != this.chars.length;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return null for no match, and otherwise an array that starts
  // with the match score, followed by any number of `from, to` pairs
  // indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return [0];
    if (e.length < this.pattern.length)
      return null;
    let { chars: i, folded: n, any: O, precise: r, byWord: a } = this;
    if (i.length == 1) {
      let m = Xt(e, 0), b = _i(m), P = b == e.length ? 0 : -100;
      if (m != i[0])
        if (m == n[0])
          P += -200;
        else
          return null;
      return [P, 0, b];
    }
    let o = e.indexOf(this.pattern);
    if (o == 0)
      return [e.length == this.pattern.length ? 0 : -100, 0, this.pattern.length];
    let s = i.length, l = 0;
    if (o < 0) {
      for (let m = 0, b = Math.min(e.length, 200); m < b && l < s; ) {
        let P = Xt(e, m);
        (P == i[l] || P == n[l]) && (O[l++] = m), m += _i(P);
      }
      if (l < s)
        return null;
    }
    let c = 0, u = 0, h10 = false, d = 0, p = -1, $ = -1, g = /[a-z]/.test(e), Q = true;
    for (let m = 0, b = Math.min(e.length, 200), P = 0; m < b && u < s; ) {
      let S = Xt(e, m);
      o < 0 && (c < s && S == i[c] && (r[c++] = m), d < s && (S == i[d] || S == n[d] ? (d == 0 && (p = m), $ = m + 1, d++) : d = 0));
      let y, v = S < 255 ? S >= 48 && S <= 57 || S >= 97 && S <= 122 ? 2 : S >= 65 && S <= 90 ? 1 : 0 : (y = Pp(S)) != y.toLowerCase() ? 1 : y != y.toUpperCase() ? 2 : 0;
      (!m || v == 1 && g || P == 0 && v != 0) && (i[u] == S || n[u] == S && (h10 = true) ? a[u++] = m : a.length && (Q = false)), P = v, m += _i(S);
    }
    return u == s && a[0] == 0 && Q ? this.result(-100 + (h10 ? -200 : 0), a, e) : d == s && p == 0 ? [-200 - e.length + ($ == e.length ? 0 : -100), 0, $] : o > -1 ? [-700 - e.length, o, o + this.pattern.length] : d == s ? [-200 + -700 - e.length, p, $] : u == s ? this.result(-100 + (h10 ? -200 : 0) + -700 + (Q ? 0 : -1100), a, e) : i.length == 2 ? null : this.result((O[0] ? -700 : 0) + -200 + -1100, O, e);
  }
  result(e, i, n) {
    let O = [e - n.length], r = 1;
    for (let a of i) {
      let o = a + (this.astral ? _i(Xt(n, a)) : 1);
      r > 1 && O[r - 1] == a ? O[r - 1] = o : (O[r++] = a, O[r++] = o);
    }
    return O;
  }
};
var Vi = K.define({
  combine(t) {
    return Xn(t, {
      activateOnTyping: true,
      selectOnOpen: true,
      override: null,
      closeOnBlur: true,
      maxRenderedOptions: 100,
      defaultKeymap: true,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: false,
      icons: true,
      addToOptions: [],
      compareCompletions: (e, i) => e.label.localeCompare(i.label),
      interactionDelay: 75
    }, {
      defaultKeymap: (e, i) => e && i,
      closeOnBlur: (e, i) => e && i,
      icons: (e, i) => e && i,
      tooltipClass: (e, i) => (n) => $m(e(n), i(n)),
      optionClass: (e, i) => (n) => $m(e(n), i(n)),
      addToOptions: (e, i) => e.concat(i)
    });
  }
});
function $m(t, e) {
  return t ? e ? t + " " + e : t : e;
}
function B5(t) {
  let e = t.addToOptions.slice();
  return t.icons && e.push({
    render(i) {
      let n = document.createElement("div");
      return n.classList.add("cm-completionIcon"), i.type && n.classList.add(...i.type.split(/\s+/g).map((O) => "cm-completionIcon-" + O)), n.setAttribute("aria-hidden", "true"), n;
    },
    position: 20
  }), e.push({
    render(i, n, O) {
      let r = document.createElement("span");
      r.className = "cm-completionLabel";
      let { label: a } = i, o = 0;
      for (let s = 1; s < O.length; ) {
        let l = O[s++], c = O[s++];
        l > o && r.appendChild(document.createTextNode(a.slice(o, l)));
        let u = r.appendChild(document.createElement("span"));
        u.appendChild(document.createTextNode(a.slice(l, c))), u.className = "cm-completionMatchedText", o = c;
      }
      return o < a.length && r.appendChild(document.createTextNode(a.slice(o))), r;
    },
    position: 50
  }, {
    render(i) {
      if (!i.detail)
        return null;
      let n = document.createElement("span");
      return n.className = "cm-completionDetail", n.textContent = i.detail, n;
    },
    position: 80
  }), e.sort((i, n) => i.position - n.position).map((i) => i.render);
}
function Qm(t, e, i) {
  if (t <= i)
    return { from: 0, to: t };
  if (e < 0 && (e = 0), e <= t >> 1) {
    let O = Math.floor(e / i);
    return { from: O * i, to: (O + 1) * i };
  }
  let n = Math.floor((t - e) / i);
  return { from: t - (n + 1) * i, to: t - n * i };
}
var F5 = class {
  constructor(e, i) {
    this.view = e, this.stateField = i, this.info = null, this.placeInfo = {
      read: () => this.measureInfo(),
      write: (o) => this.positionInfo(o),
      key: this
    }, this.space = null, this.currentClass = "";
    let n = e.state.field(i), { options: O, selected: r } = n.open, a = e.state.facet(Vi);
    this.optionContent = B5(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = Qm(O.length, r, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (o) => {
      for (let s = o.target, l; s && s != this.dom; s = s.parentNode)
        if (s.nodeName == "LI" && (l = /-(\d+)$/.exec(s.id)) && +l[1] < O.length) {
          V0(e, O[+l[1]]), o.preventDefault();
          return;
        }
    }), this.list = this.dom.appendChild(this.createListBox(O, n.id, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfo);
    });
  }
  mount() {
    this.updateSel();
  }
  update(e) {
    var i, n, O;
    let r = e.state.field(this.stateField), a = e.startState.field(this.stateField);
    this.updateTooltipClass(e.state), r != a && (this.updateSel(), ((i = r.open) === null || i === void 0 ? void 0 : i.disabled) != ((n = a.open) === null || n === void 0 ? void 0 : n.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!(!((O = r.open) === null || O === void 0) && O.disabled)));
  }
  updateTooltipClass(e) {
    let i = this.tooltipClass(e);
    if (i != this.currentClass) {
      for (let n of this.currentClass.split(" "))
        n && this.dom.classList.remove(n);
      for (let n of i.split(" "))
        n && this.dom.classList.add(n);
      this.currentClass = i;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfo);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), i = e.open;
    if ((i.selected > -1 && i.selected < this.range.from || i.selected >= this.range.to) && (this.range = Qm(i.options.length, i.selected, this.view.state.facet(Vi).maxRenderedOptions), this.list.remove(), this.list = this.dom.appendChild(this.createListBox(i.options, e.id, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfo);
    })), this.updateSelectedOption(i.selected)) {
      this.info && (this.info.remove(), this.info = null);
      let { completion: n } = i.options[i.selected], { info: O } = n;
      if (!O)
        return;
      let r = typeof O == "string" ? document.createTextNode(O) : O(n);
      if (!r)
        return;
      "then" in r ? r.then((a) => {
        a && this.view.state.field(this.stateField, false) == e && this.addInfoPane(a);
      }).catch((a) => Pi(this.view.state, a, "completion info")) : this.addInfoPane(r);
    }
  }
  addInfoPane(e) {
    let i = this.info = document.createElement("div");
    i.className = "cm-tooltip cm-completionInfo", i.appendChild(e), this.dom.appendChild(i), this.view.requestMeasure(this.placeInfo);
  }
  updateSelectedOption(e) {
    let i = null;
    for (let n = this.list.firstChild, O = this.range.from; n; n = n.nextSibling, O++)
      O == e ? n.hasAttribute("aria-selected") || (n.setAttribute("aria-selected", "true"), i = n) : n.hasAttribute("aria-selected") && n.removeAttribute("aria-selected");
    return i && K5(this.list, i), i;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let i = this.dom.getBoundingClientRect(), n = this.info.getBoundingClientRect(), O = e.getBoundingClientRect(), r = this.space;
    if (!r) {
      let p = this.dom.ownerDocument.defaultView || window;
      r = { left: 0, top: 0, right: p.innerWidth, bottom: p.innerHeight };
    }
    if (O.top > Math.min(r.bottom, i.bottom) - 10 || O.bottom < Math.max(r.top, i.top) + 10)
      return null;
    let a = this.view.textDirection == Ne.RTL, o = a, s = false, l, c = "", u = "", h10 = i.left - r.left, d = r.right - i.right;
    if (o && h10 < Math.min(n.width, d) ? o = false : !o && d < Math.min(n.width, h10) && (o = true), n.width <= (o ? h10 : d))
      c = Math.max(r.top, Math.min(O.top, r.bottom - n.height)) - i.top + "px", l = Math.min(400, o ? h10 : d) + "px";
    else {
      s = true, l = Math.min(
        400,
        (a ? i.right : r.right - i.left) - 30
        /* Info.Margin */
      ) + "px";
      let p = r.bottom - i.bottom;
      p >= n.height || p > i.top ? c = O.bottom - i.top + "px" : u = i.bottom - O.top + "px";
    }
    return {
      top: c,
      bottom: u,
      maxWidth: l,
      class: s ? a ? "left-narrow" : "right-narrow" : o ? "left" : "right"
    };
  }
  positionInfo(e) {
    this.info && (e ? (this.info.style.top = e.top, this.info.style.bottom = e.bottom, this.info.style.maxWidth = e.maxWidth, this.info.className = "cm-tooltip cm-completionInfo cm-completionInfo-" + e.class) : this.info.style.top = "-1e6px");
  }
  createListBox(e, i, n) {
    const O = document.createElement("ul");
    O.id = i, O.setAttribute("role", "listbox"), O.setAttribute("aria-expanded", "true"), O.setAttribute("aria-label", this.view.state.phrase("Completions"));
    for (let r = n.from; r < n.to; r++) {
      let { completion: a, match: o } = e[r];
      const s = O.appendChild(document.createElement("li"));
      s.id = i + "-" + r, s.setAttribute("role", "option");
      let l = this.optionClass(a);
      l && (s.className = l);
      for (let c of this.optionContent) {
        let u = c(a, this.view.state, o);
        u && s.appendChild(u);
      }
    }
    return n.from && O.classList.add("cm-completionListIncompleteTop"), n.to < e.length && O.classList.add("cm-completionListIncompleteBottom"), O;
  }
};
function H5(t) {
  return (e) => new F5(e, t);
}
function K5(t, e) {
  let i = t.getBoundingClientRect(), n = e.getBoundingClientRect();
  n.top < i.top ? t.scrollTop -= i.top - n.top : n.bottom > i.bottom && (t.scrollTop += n.bottom - i.bottom);
}
function gm(t) {
  return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
}
function J5(t, e) {
  let i = [], n = 0;
  for (let o of t)
    if (o.hasResult())
      if (o.result.filter === false) {
        let s = o.result.getMatch;
        for (let l of o.result.options) {
          let c = [1e9 - n++];
          if (s)
            for (let u of s(l))
              c.push(u);
          i.push(new dm(l, o, c));
        }
      } else {
        let s = new N5(e.sliceDoc(o.from, o.to)), l;
        for (let c of o.result.options)
          (l = s.match(c.label)) && (c.boost != null && (l[0] += c.boost), i.push(new dm(c, o, l)));
      }
  let O = [], r = null, a = e.facet(Vi).compareCompletions;
  for (let o of i.sort((s, l) => l.match[0] - s.match[0] || a(s.completion, l.completion)))
    !r || r.label != o.completion.label || r.detail != o.completion.detail || r.type != null && o.completion.type != null && r.type != o.completion.type || r.apply != o.completion.apply ? O.push(o) : gm(o.completion) > gm(r) && (O[O.length - 1] = o), r = o.completion;
  return O;
}
var jr = class {
  constructor(e, i, n, O, r, a) {
    this.options = e, this.attrs = i, this.tooltip = n, this.timestamp = O, this.selected = r, this.disabled = a;
  }
  setSelected(e, i) {
    return e == this.selected || e >= this.options.length ? this : new jr(this.options, mm(i, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, i, n, O, r) {
    let a = J5(e, i);
    if (!a.length)
      return O && e.some(
        (s) => s.state == 1
        /* State.Pending */
      ) ? new jr(O.options, O.attrs, O.tooltip, O.timestamp, O.selected, true) : null;
    let o = i.facet(Vi).selectOnOpen ? 0 : -1;
    if (O && O.selected != o && O.selected != -1) {
      let s = O.options[O.selected].completion;
      for (let l = 0; l < a.length; l++)
        if (a[l].completion == s) {
          o = l;
          break;
        }
    }
    return new jr(a, mm(n, o), {
      pos: e.reduce((s, l) => l.hasResult() ? Math.min(s, l.from) : s, 1e8),
      create: H5(Ti),
      above: r.aboveCursor
    }, O ? O.timestamp : Date.now(), o, false);
  }
  map(e) {
    return new jr(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
};
var fc = class {
  constructor(e, i, n) {
    this.active = e, this.id = i, this.open = n;
  }
  static start() {
    return new fc(i2, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: i } = e, n = i.facet(Vi), r = (n.override || i.languageDataAt("autocomplete", $O(i)).map(M5)).map((o) => (this.active.find((l) => l.source == o) || new ri(
      o,
      this.active.some(
        (l) => l.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, n));
    r.length == this.active.length && r.every((o, s) => o == this.active[s]) && (r = this.active);
    let a = this.open;
    a && e.docChanged && (a = a.map(e.changes)), e.selection || r.some((o) => o.hasResult() && e.changes.touchesRange(o.from, o.to)) || !e2(r, this.active) ? a = jr.build(r, i, this.id, a, n) : a && a.disabled && !r.some(
      (o) => o.state == 1
      /* State.Pending */
    ) && (a = null), !a && r.every(
      (o) => o.state != 1
      /* State.Pending */
    ) && r.some((o) => o.hasResult()) && (r = r.map((o) => o.hasResult() ? new ri(
      o.source,
      0
      /* State.Inactive */
    ) : o));
    for (let o of e.effects)
      o.is(z0) && (a = a && a.setSelected(o.value, this.id));
    return r == this.active && a == this.open ? this : new fc(r, this.id, a);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : t2;
  }
};
function e2(t, e) {
  if (t == e)
    return true;
  for (let i = 0, n = 0; ; ) {
    for (; i < t.length && !t[i].hasResult; )
      i++;
    for (; n < e.length && !e[n].hasResult; )
      n++;
    let O = i == t.length, r = n == e.length;
    if (O || r)
      return O == r;
    if (t[i++].result != e[n++].result)
      return false;
  }
}
var t2 = {
  "aria-autocomplete": "list"
};
function mm(t, e) {
  let i = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": t
  };
  return e > -1 && (i["aria-activedescendant"] = t + "-" + e), i;
}
var i2 = [];
function ld(t) {
  return t.isUserEvent("input.type") ? "input" : t.isUserEvent("delete.backward") ? "delete" : null;
}
var ri = class {
  constructor(e, i, n = -1) {
    this.source = e, this.state = i, this.explicitPos = n;
  }
  hasResult() {
    return false;
  }
  update(e, i) {
    let n = ld(e), O = this;
    n ? O = O.handleUserEvent(e, n, i) : e.docChanged ? O = O.handleChange(e) : e.selection && O.state != 0 && (O = new ri(
      O.source,
      0
      /* State.Inactive */
    ));
    for (let r of e.effects)
      if (r.is(e$))
        O = new ri(O.source, 1, r.value ? $O(e.state) : -1);
      else if (r.is(hc))
        O = new ri(
          O.source,
          0
          /* State.Inactive */
        );
      else if (r.is(q0))
        for (let a of r.value)
          a.source == O.source && (O = a);
    return O;
  }
  handleUserEvent(e, i, n) {
    return i == "delete" || !n.activateOnTyping ? this.map(e.changes) : new ri(
      this.source,
      1
      /* State.Pending */
    );
  }
  handleChange(e) {
    return e.changes.touchesRange($O(e.startState)) ? new ri(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new ri(this.source, this.state, e.mapPos(this.explicitPos));
  }
};
var wo = class extends ri {
  constructor(e, i, n, O, r) {
    super(e, 2, i), this.result = n, this.from = O, this.to = r;
  }
  hasResult() {
    return true;
  }
  handleUserEvent(e, i, n) {
    var O;
    let r = e.changes.mapPos(this.from), a = e.changes.mapPos(this.to, 1), o = $O(e.state);
    if ((this.explicitPos < 0 ? o <= r : o < this.from) || o > a || i == "delete" && $O(e.startState) == this.from)
      return new ri(
        this.source,
        i == "input" && n.activateOnTyping ? 1 : 0
        /* State.Inactive */
      );
    let s = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos), l;
    return n2(this.result.validFor, e.state, r, a) ? new wo(this.source, s, this.result, r, a) : this.result.update && (l = this.result.update(this.result, r, a, new R0(e.state, o, s >= 0))) ? new wo(this.source, s, l, l.from, (O = l.to) !== null && O !== void 0 ? O : $O(e.state)) : new ri(this.source, 1, s);
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to) ? new ri(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty ? this : new wo(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1));
  }
};
function n2(t, e, i, n) {
  if (!t)
    return false;
  let O = e.sliceDoc(i, n);
  return typeof t == "function" ? t(O, i, n, e) : Z0(t, true).test(O);
}
var e$ = fe.define();
var hc = fe.define();
var q0 = fe.define({
  map(t, e) {
    return t.map((i) => i.map(e));
  }
});
var z0 = fe.define();
var Ti = St.define({
  create() {
    return fc.start();
  },
  update(t, e) {
    return t.update(e);
  },
  provide: (t) => [
    Wp.from(t, (e) => e.tooltip),
    B.contentAttributes.from(t, (e) => e.attrs)
  ]
});
function il(t, e = "option") {
  return (i) => {
    let n = i.state.field(Ti, false);
    if (!n || !n.open || n.open.disabled || Date.now() - n.open.timestamp < i.state.facet(Vi).interactionDelay)
      return false;
    let O = 1, r;
    e == "page" && (r = IY(i, n.open.tooltip)) && (O = Math.max(2, Math.floor(r.dom.offsetHeight / r.dom.querySelector("li").offsetHeight) - 1));
    let { length: a } = n.open.options, o = n.open.selected > -1 ? n.open.selected + O * (t ? 1 : -1) : t ? 0 : a - 1;
    return o < 0 ? o = e == "page" ? 0 : a - 1 : o >= a && (o = e == "page" ? a - 1 : 0), i.dispatch({ effects: z0.of(o) }), true;
  };
}
var O2 = (t) => {
  let e = t.state.field(Ti, false);
  return t.state.readOnly || !e || !e.open || e.open.selected < 0 || Date.now() - e.open.timestamp < t.state.facet(Vi).interactionDelay ? false : (e.open.disabled || V0(t, e.open.options[e.open.selected]), true);
};
var r2 = (t) => t.state.field(Ti, false) ? (t.dispatch({ effects: e$.of(true) }), true) : false;
var a2 = (t) => {
  let e = t.state.field(Ti, false);
  return !e || !e.active.some(
    (i) => i.state != 0
    /* State.Inactive */
  ) ? false : (t.dispatch({ effects: hc.of(null) }), true);
};
var o2 = class {
  constructor(e, i) {
    this.active = e, this.context = i, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
};
var Sm = 50;
var s2 = 50;
var l2 = 1e3;
var c2 = it.fromClass(class {
  constructor(t) {
    this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.composing = 0;
    for (let e of t.state.field(Ti).active)
      e.state == 1 && this.startQuery(e);
  }
  update(t) {
    let e = t.state.field(Ti);
    if (!t.selectionSet && !t.docChanged && t.startState.field(Ti) == e)
      return;
    let i = t.transactions.some((n) => (n.selection || n.docChanged) && !ld(n));
    for (let n = 0; n < this.running.length; n++) {
      let O = this.running[n];
      if (i || O.updates.length + t.transactions.length > s2 && Date.now() - O.time > l2) {
        for (let r of O.context.abortListeners)
          try {
            r();
          } catch (a) {
            Pi(this.view.state, a);
          }
        O.context.abortListeners = null, this.running.splice(n--, 1);
      } else
        O.updates.push(...t.transactions);
    }
    if (this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), this.debounceUpdate = e.active.some((n) => n.state == 1 && !this.running.some((O) => O.active.source == n.source)) ? setTimeout(() => this.startUpdate(), Sm) : -1, this.composing != 0)
      for (let n of t.transactions)
        ld(n) == "input" ? this.composing = 2 : this.composing == 2 && n.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1;
    let { state: t } = this.view, e = t.field(Ti);
    for (let i of e.active)
      i.state == 1 && !this.running.some((n) => n.active.source == i.source) && this.startQuery(i);
  }
  startQuery(t) {
    let { state: e } = this.view, i = $O(e), n = new R0(e, i, t.explicitPos == i), O = new o2(t, n);
    this.running.push(O), Promise.resolve(t.source(n)).then((r) => {
      O.context.aborted || (O.done = r || null, this.scheduleAccept());
    }, (r) => {
      this.view.dispatch({ effects: hc.of(null) }), Pi(this.view.state, r);
    });
  }
  scheduleAccept() {
    this.running.every((t) => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), Sm));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var t;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], i = this.view.state.facet(Vi);
    for (let n = 0; n < this.running.length; n++) {
      let O = this.running[n];
      if (O.done === void 0)
        continue;
      if (this.running.splice(n--, 1), O.done) {
        let a = new wo(O.active.source, O.active.explicitPos, O.done, O.done.from, (t = O.done.to) !== null && t !== void 0 ? t : $O(O.updates.length ? O.updates[0].startState : this.view.state));
        for (let o of O.updates)
          a = a.update(o, i);
        if (a.hasResult()) {
          e.push(a);
          continue;
        }
      }
      let r = this.view.state.field(Ti).active.find((a) => a.source == O.active.source);
      if (r && r.state == 1)
        if (O.done == null) {
          let a = new ri(
            O.active.source,
            0
            /* State.Inactive */
          );
          for (let o of O.updates)
            a = a.update(o, i);
          a.state != 1 && e.push(a);
        } else
          this.startQuery(r);
    }
    e.length && this.view.dispatch({ effects: q0.of(e) });
  }
}, {
  eventHandlers: {
    blur() {
      let t = this.view.state.field(Ti, false);
      t && t.tooltip && this.view.state.facet(Vi).closeOnBlur && this.view.dispatch({ effects: hc.of(null) });
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: e$.of(false) }), 20), this.composing = 0;
    }
  }
});
var C0 = B.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer",
        padding: "1px 3px",
        lineHeight: 1.2
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: `${400}px`,
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30}px` },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30}px` },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
var u2 = class {
  constructor(e, i, n, O) {
    this.field = e, this.line = i, this.from = n, this.to = O;
  }
};
var t$ = class {
  constructor(e, i, n) {
    this.field = e, this.from = i, this.to = n;
  }
  map(e) {
    let i = e.mapPos(this.from, -1, wt.TrackDel), n = e.mapPos(this.to, 1, wt.TrackDel);
    return i == null || n == null ? null : new t$(this.field, i, n);
  }
};
var i$ = class {
  constructor(e, i) {
    this.lines = e, this.fieldPositions = i;
  }
  instantiate(e, i) {
    let n = [], O = [i], r = e.doc.lineAt(i), a = /^\s*/.exec(r.text)[0];
    for (let s of this.lines) {
      if (n.length) {
        let l = a, c = /^\t*/.exec(s)[0].length;
        for (let u = 0; u < c; u++)
          l += e.facet(bs);
        O.push(i + l.length - c), s = l + s.slice(c);
      }
      n.push(s), i += s.length + 1;
    }
    let o = this.fieldPositions.map((s) => new t$(s.field, O[s.line] + s.from, O[s.line] + s.to));
    return { text: n, ranges: o };
  }
  static parse(e) {
    let i = [], n = [], O = [], r;
    for (let a of e.split(/\r\n?|\n/)) {
      for (; r = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(a); ) {
        let o = r[1] ? +r[1] : null, s = r[2] || r[3] || "", l = -1;
        for (let c = 0; c < i.length; c++)
          (o != null ? i[c].seq == o : s && i[c].name == s) && (l = c);
        if (l < 0) {
          let c = 0;
          for (; c < i.length && (o == null || i[c].seq != null && i[c].seq < o); )
            c++;
          i.splice(c, 0, { seq: o, name: s }), l = c;
          for (let u of O)
            u.field >= l && u.field++;
        }
        O.push(new u2(l, n.length, r.index, r.index + s.length)), a = a.slice(0, r.index) + s + a.slice(r.index + r[0].length);
      }
      for (let o; o = /\\([{}])/.exec(a); ) {
        a = a.slice(0, o.index) + o[1] + a.slice(o.index + o[0].length);
        for (let s of O)
          s.line == n.length && s.from > o.index && (s.from--, s.to--);
      }
      n.push(a);
    }
    return new i$(n, O);
  }
};
var f2 = ne.widget({ widget: new class extends xn {
  toDOM() {
    let t = document.createElement("span");
    return t.className = "cm-snippetFieldPosition", t;
  }
  ignoreEvent() {
    return false;
  }
}() });
var h2 = ne.mark({ class: "cm-snippetField" });
var Ra = class {
  constructor(e, i) {
    this.ranges = e, this.active = i, this.deco = ne.set(e.map((n) => (n.from == n.to ? f2 : h2).range(n.from, n.to)));
  }
  map(e) {
    let i = [];
    for (let n of this.ranges) {
      let O = n.map(e);
      if (!O)
        return null;
      i.push(O);
    }
    return new Ra(i, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((i) => this.ranges.some((n) => n.field == this.active && n.from <= i.from && n.to >= i.to));
  }
};
var xs = fe.define({
  map(t, e) {
    return t && t.map(e);
  }
});
var d2 = fe.define();
var is = St.define({
  create() {
    return null;
  },
  update(t, e) {
    for (let i of e.effects) {
      if (i.is(xs))
        return i.value;
      if (i.is(d2) && t)
        return new Ra(t.ranges, i.value);
    }
    return t && e.docChanged && (t = t.map(e.changes)), t && e.selection && !t.selectionInsideField(e.selection) && (t = null), t;
  },
  provide: (t) => B.decorations.from(t, (e) => e ? e.deco : ne.none)
});
function n$(t, e) {
  return R.create(t.filter((i) => i.field == e).map((i) => R.range(i.from, i.to)));
}
function p2(t) {
  let e = i$.parse(t);
  return (i, n, O, r) => {
    let { text: a, ranges: o } = e.instantiate(i.state, O), s = {
      changes: { from: O, to: r, insert: Te.of(a) },
      scrollIntoView: true,
      annotations: U0.of(n)
    };
    if (o.length && (s.selection = n$(o, 0)), o.length > 1) {
      let l = new Ra(o, 0), c = s.effects = [xs.of(l)];
      i.state.field(is, false) === void 0 && c.push(fe.appendConfig.of([is, S2, P2, C0]));
    }
    i.dispatch(i.state.update(s));
  };
}
function E0(t) {
  return ({ state: e, dispatch: i }) => {
    let n = e.field(is, false);
    if (!n || t < 0 && n.active == 0)
      return false;
    let O = n.active + t, r = t > 0 && !n.ranges.some((a) => a.field == O + t);
    return i(e.update({
      selection: n$(n.ranges, O),
      effects: xs.of(r ? null : new Ra(n.ranges, O))
    })), true;
  };
}
var $2 = ({ state: t, dispatch: e }) => t.field(is, false) ? (e(t.update({ effects: xs.of(null) })), true) : false;
var Q2 = E0(1);
var g2 = E0(-1);
var m2 = [
  { key: "Tab", run: Q2, shift: g2 },
  { key: "Escape", run: $2 }
];
var Pm = K.define({
  combine(t) {
    return t.length ? t[0] : m2;
  }
});
var S2 = wO.highest(ka.compute([Pm], (t) => t.facet(Pm)));
function rt(t, e) {
  return Object.assign(Object.assign({}, e), { apply: p2(t) });
}
var P2 = B.domEventHandlers({
  mousedown(t, e) {
    let i = e.state.field(is, false), n;
    if (!i || (n = e.posAtCoords({ x: t.clientX, y: t.clientY })) == null)
      return false;
    let O = i.ranges.find((r) => r.from <= n && r.to >= n);
    return !O || O.field == i.active ? false : (e.dispatch({
      selection: n$(i.ranges, O.field),
      effects: xs.of(i.ranges.some((r) => r.field > O.field) ? new Ra(i.ranges, O.field) : null)
    }), true);
  }
});
var ns = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
};
var DO = fe.define({
  map(t, e) {
    let i = e.mapPos(t, -1, wt.TrackAfter);
    return i ?? void 0;
  }
});
var O$ = fe.define({
  map(t, e) {
    return e.mapPos(t);
  }
});
var r$ = new class extends KO {
}();
r$.startSide = 1;
r$.endSide = -1;
var j0 = St.define({
  create() {
    return We.empty;
  },
  update(t, e) {
    if (e.selection) {
      let i = e.state.doc.lineAt(e.selection.main.head).from, n = e.startState.doc.lineAt(e.startState.selection.main.head).from;
      i != e.changes.mapPos(n, -1) && (t = We.empty);
    }
    t = t.map(e.changes);
    for (let i of e.effects)
      i.is(DO) ? t = t.update({ add: [r$.range(i.value, i.value + 1)] }) : i.is(O$) && (t = t.update({ filter: (n) => n != i.value }));
    return t;
  }
});
function y2() {
  return [v2, j0];
}
var ff = "()[]{}<>";
function I0(t) {
  for (let e = 0; e < ff.length; e += 2)
    if (ff.charCodeAt(e) == t)
      return ff.charAt(e + 1);
  return Pp(t < 128 ? t : t + 1);
}
function A0(t, e) {
  return t.languageDataAt("closeBrackets", e)[0] || ns;
}
var b2 = typeof navigator == "object" && /Android\b/.test(navigator.userAgent);
var v2 = B.inputHandler.of((t, e, i, n) => {
  if ((b2 ? t.composing : t.compositionStarted) || t.state.readOnly)
    return false;
  let O = t.state.selection.main;
  if (n.length > 2 || n.length == 2 && _i(Xt(n, 0)) == 1 || e != O.from || i != O.to)
    return false;
  let r = w2(t.state, n);
  return r ? (t.dispatch(r), true) : false;
});
var X2 = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return false;
  let n = A0(t, t.selection.main.head).brackets || ns.brackets, O = null, r = t.changeByRange((a) => {
    if (a.empty) {
      let o = T2(t.doc, a.head);
      for (let s of n)
        if (s == o && ou(t.doc, a.head) == I0(Xt(s, 0)))
          return {
            changes: { from: a.head - s.length, to: a.head + s.length },
            range: R.cursor(a.head - s.length)
          };
    }
    return { range: O = a };
  });
  return O || e(t.update(r, { scrollIntoView: true, userEvent: "delete.backward" })), !O;
};
var x2 = [
  { key: "Backspace", run: X2 }
];
function w2(t, e) {
  let i = A0(t, t.selection.main.head), n = i.brackets || ns.brackets;
  for (let O of n) {
    let r = I0(Xt(O, 0));
    if (e == O)
      return r == O ? W2(t, O, n.indexOf(O + O + O) > -1, i) : k2(t, O, r, i.before || ns.before);
    if (e == r && G0(t, t.selection.main.from))
      return _2(t, O, r);
  }
  return null;
}
function G0(t, e) {
  let i = false;
  return t.field(j0).between(0, t.doc.length, (n) => {
    n == e && (i = true);
  }), i;
}
function ou(t, e) {
  let i = t.sliceString(e, e + 2);
  return i.slice(0, _i(Xt(i, 0)));
}
function T2(t, e) {
  let i = t.sliceString(e - 2, e);
  return _i(Xt(i, 0)) == i.length ? i : i.slice(1);
}
function k2(t, e, i, n) {
  let O = null, r = t.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: i, from: a.to }],
        effects: DO.of(a.to + e.length),
        range: R.range(a.anchor + e.length, a.head + e.length)
      };
    let o = ou(t.doc, a.head);
    return !o || /\s/.test(o) || n.indexOf(o) > -1 ? {
      changes: { insert: e + i, from: a.head },
      effects: DO.of(a.head + e.length),
      range: R.cursor(a.head + e.length)
    } : { range: O = a };
  });
  return O ? null : t.update(r, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function _2(t, e, i) {
  let n = null, O = t.selection.ranges.map((r) => r.empty && ou(t.doc, r.head) == i ? R.cursor(r.head + i.length) : n = r);
  return n ? null : t.update({
    selection: R.create(O, t.selection.mainIndex),
    scrollIntoView: true,
    effects: t.selection.ranges.map(({ from: r }) => O$.of(r))
  });
}
function W2(t, e, i, n) {
  let O = n.stringPrefixes || ns.stringPrefixes, r = null, a = t.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: e, from: o.to }],
        effects: DO.of(o.to + e.length),
        range: R.range(o.anchor + e.length, o.head + e.length)
      };
    let s = o.head, l = ou(t.doc, s), c;
    if (l == e) {
      if (ym(t, s))
        return {
          changes: { insert: e + e, from: s },
          effects: DO.of(s + e.length),
          range: R.cursor(s + e.length)
        };
      if (G0(t, s)) {
        let u = i && t.sliceDoc(s, s + e.length * 3) == e + e + e;
        return {
          range: R.cursor(s + e.length * (u ? 3 : 1)),
          effects: O$.of(s)
        };
      }
    } else {
      if (i && t.sliceDoc(s - 2 * e.length, s) == e + e && (c = bm(t, s - 2 * e.length, O)) > -1 && ym(t, c))
        return {
          changes: { insert: e + e + e + e, from: s },
          effects: DO.of(s + e.length),
          range: R.cursor(s + e.length)
        };
      if (t.charCategorizer(s)(l) != Le.Word && bm(t, s, O) > -1 && !Y2(t, s, e, O))
        return {
          changes: { insert: e + e, from: s },
          effects: DO.of(s + e.length),
          range: R.cursor(s + e.length)
        };
    }
    return { range: r = o };
  });
  return r ? null : t.update(a, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function ym(t, e) {
  let i = Ye(t).resolveInner(e + 1);
  return i.parent && i.from == e;
}
function Y2(t, e, i, n) {
  let O = Ye(t).resolveInner(e, -1), r = n.reduce((a, o) => Math.max(a, o.length), 0);
  for (let a = 0; a < 5; a++) {
    let o = t.sliceDoc(O.from, Math.min(O.to, O.from + i.length + r)), s = o.indexOf(i);
    if (!s || s > -1 && n.indexOf(o.slice(0, s)) > -1) {
      let c = O.firstChild;
      for (; c && c.from == O.from && c.to - c.from > i.length + s; ) {
        if (t.sliceDoc(c.to - i.length, c.to) == i)
          return false;
        c = c.firstChild;
      }
      return true;
    }
    let l = O.to == e && O.parent;
    if (!l)
      break;
    O = l;
  }
  return false;
}
function bm(t, e, i) {
  let n = t.charCategorizer(e);
  if (n(t.sliceDoc(e - 1, e)) != Le.Word)
    return e;
  for (let O of i) {
    let r = e - O.length;
    if (t.sliceDoc(r, e) == O && n(t.sliceDoc(r - 1, r)) != Le.Word)
      return r;
  }
  return -1;
}
function R2(t = {}) {
  return [
    Ti,
    Vi.of(t),
    c2,
    Z2,
    C0
  ];
}
var L0 = [
  { key: "Ctrl-Space", run: r2 },
  { key: "Escape", run: a2 },
  { key: "ArrowDown", run: il(true) },
  { key: "ArrowUp", run: il(false) },
  { key: "PageDown", run: il(true, "page") },
  { key: "PageUp", run: il(false, "page") },
  { key: "Enter", run: O2 }
];
var Z2 = wO.highest(ka.computeN([Vi], (t) => t.facet(Vi).defaultKeymap ? [L0] : []));
var U2 = class {
  constructor(e, i, n) {
    this.from = e, this.to = i, this.diagnostic = n;
  }
};
var AO = class {
  constructor(e, i, n) {
    this.diagnostics = e, this.panel = i, this.selected = n;
  }
  static init(e, i, n) {
    let O = e, r = n.facet(Ir).markerFilter;
    r && (O = r(O));
    let a = ne.set(O.map((o) => o.from == o.to || o.from == o.to - 1 && n.doc.lineAt(o.from).to == o.from ? ne.widget({
      widget: new L2(o),
      diagnostic: o
    }).range(o.from) : ne.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + o.severity },
      diagnostic: o
    }).range(o.from, o.to)), true);
    return new AO(a, i, ra(a));
  }
};
function ra(t, e = null, i = 0) {
  let n = null;
  return t.between(i, 1e9, (O, r, { spec: a }) => {
    if (!(e && a.diagnostic != e))
      return n = new U2(O, r, a.diagnostic), false;
  }), n;
}
function V2(t, e) {
  return !!(t.effects.some((i) => i.is(a$)) || t.changes.touchesRange(e.pos));
}
function D0(t, e) {
  return t.field(mi, false) ? e : e.concat(fe.appendConfig.of([
    mi,
    B.decorations.compute([mi], (i) => {
      let { selected: n, panel: O } = i.field(mi);
      return !n || !O || n.from == n.to ? ne.none : ne.set([
        z2.range(n.from, n.to)
      ]);
    }),
    jY(C2, { hideOn: V2 }),
    M2
  ]));
}
function q2(t, e) {
  return {
    effects: D0(t, [a$.of(e)])
  };
}
var a$ = fe.define();
var o$ = fe.define();
var M0 = fe.define();
var mi = St.define({
  create() {
    return new AO(ne.none, null, null);
  },
  update(t, e) {
    if (e.docChanged) {
      let i = t.diagnostics.map(e.changes), n = null;
      if (t.selected) {
        let O = e.changes.mapPos(t.selected.from, 1);
        n = ra(i, t.selected.diagnostic, O) || ra(i, null, O);
      }
      t = new AO(i, t.panel, n);
    }
    for (let i of e.effects)
      i.is(a$) ? t = AO.init(i.value, t.panel, e.state) : i.is(o$) ? t = new AO(t.diagnostics, i.value ? su.open : null, t.selected) : i.is(M0) && (t = new AO(t.diagnostics, t.panel, i.value));
    return t;
  },
  provide: (t) => [
    Ho.from(t, (e) => e.panel),
    B.decorations.from(t, (e) => e.diagnostics)
  ]
});
var z2 = ne.mark({ class: "cm-lintRange cm-lintRange-active" });
function C2(t, e, i) {
  let { diagnostics: n } = t.state.field(mi), O = [], r = 2e8, a = 0;
  n.between(e - (i < 0 ? 1 : 0), e + (i > 0 ? 1 : 0), (s, l, { spec: c }) => {
    e >= s && e <= l && (s == l || (e > s || i > 0) && (e < l || i < 0)) && (O.push(c.diagnostic), r = Math.min(s, r), a = Math.max(l, a));
  });
  let o = t.state.facet(Ir).tooltipFilter;
  return o && (O = o(O)), O.length ? {
    pos: r,
    end: a,
    above: t.state.doc.lineAt(r).to < a,
    create() {
      return { dom: E2(t, O) };
    }
  } : null;
}
function E2(t, e) {
  return Ue("ul", { class: "cm-tooltip-lint" }, e.map((i) => B0(t, i, false)));
}
var j2 = (t) => {
  let e = t.state.field(mi, false);
  (!e || !e.panel) && t.dispatch({ effects: D0(t.state, [o$.of(true)]) });
  let i = Fo(t, su.open);
  return i && i.dom.querySelector(".cm-panel-lint ul").focus(), true;
};
var vm = (t) => {
  let e = t.state.field(mi, false);
  return !e || !e.panel ? false : (t.dispatch({ effects: o$.of(false) }), true);
};
var I2 = (t) => {
  let e = t.state.field(mi, false);
  if (!e)
    return false;
  let i = t.state.selection.main, n = e.diagnostics.iter(i.to + 1);
  return !n.value && (n = e.diagnostics.iter(0), !n.value || n.from == i.from && n.to == i.to) ? false : (t.dispatch({ selection: { anchor: n.from, head: n.to }, scrollIntoView: true }), true);
};
var A2 = [
  { key: "Mod-Shift-m", run: j2, preventDefault: true },
  { key: "F8", run: I2 }
];
var G2 = it.fromClass(class {
  constructor(t) {
    this.view = t, this.timeout = -1, this.set = true;
    let { delay: e } = t.state.facet(Ir);
    this.lintTime = Date.now() + e, this.run = this.run.bind(this), this.timeout = setTimeout(this.run, e);
  }
  run() {
    let t = Date.now();
    if (t < this.lintTime - 10)
      setTimeout(this.run, this.lintTime - t);
    else {
      this.set = false;
      let { state: e } = this.view, { sources: i } = e.facet(Ir);
      Promise.all(i.map((n) => Promise.resolve(n(this.view)))).then((n) => {
        let O = n.reduce((r, a) => r.concat(a));
        this.view.state.doc == e.doc && this.view.dispatch(q2(this.view.state, O));
      }, (n) => {
        Pi(this.view.state, n);
      });
    }
  }
  update(t) {
    let e = t.state.facet(Ir);
    (t.docChanged || e != t.startState.facet(Ir)) && (this.lintTime = Date.now() + e.delay, this.set || (this.set = true, this.timeout = setTimeout(this.run, e.delay)));
  }
  force() {
    this.set && (this.lintTime = Date.now(), this.run());
  }
  destroy() {
    clearTimeout(this.timeout);
  }
});
var Ir = K.define({
  combine(t) {
    return Object.assign({ sources: t.map((e) => e.source) }, Xn(t.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null
    }));
  },
  enables: G2
});
function N0(t) {
  let e = [];
  if (t)
    e:
      for (let { name: i } of t) {
        for (let n = 0; n < i.length; n++) {
          let O = i[n];
          if (/[a-zA-Z]/.test(O) && !e.some((r) => r.toLowerCase() == O.toLowerCase())) {
            e.push(O);
            continue e;
          }
        }
        e.push("");
      }
  return e;
}
function B0(t, e, i) {
  var n;
  let O = i ? N0(e.actions) : [];
  return Ue("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, Ue("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage() : e.message), (n = e.actions) === null || n === void 0 ? void 0 : n.map((r, a) => {
    let o = false, s = (h10) => {
      if (h10.preventDefault(), o)
        return;
      o = true;
      let d = ra(t.state.field(mi).diagnostics, e);
      d && r.apply(t, d.from, d.to);
    }, { name: l } = r, c = O[a] ? l.indexOf(O[a]) : -1, u = c < 0 ? l : [
      l.slice(0, c),
      Ue("u", l.slice(c, c + 1)),
      l.slice(c + 1)
    ];
    return Ue("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: s,
      onmousedown: s,
      "aria-label": ` Action: ${l}${c < 0 ? "" : ` (access key "${O[a]})"`}.`
    }, u);
  }), e.source && Ue("div", { class: "cm-diagnosticSource" }, e.source));
}
var L2 = class extends xn {
  constructor(e) {
    super(), this.diagnostic = e;
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return Ue("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
};
var Xm = class {
  constructor(e, i) {
    this.diagnostic = i, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = B0(e, i, true), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
};
var su = class {
  constructor(e) {
    this.view = e, this.items = [];
    let i = (O) => {
      if (O.keyCode == 27)
        vm(this.view), this.view.focus();
      else if (O.keyCode == 38 || O.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (O.keyCode == 40 || O.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (O.keyCode == 36)
        this.moveSelection(0);
      else if (O.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (O.keyCode == 13)
        this.view.focus();
      else if (O.keyCode >= 65 && O.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: r } = this.items[this.selectedIndex], a = N0(r.actions);
        for (let o = 0; o < a.length; o++)
          if (a[o].toUpperCase().charCodeAt(0) == O.keyCode) {
            let s = ra(this.view.state.field(mi).diagnostics, r);
            s && r.actions[o].apply(e, s.from, s.to);
          }
      } else
        return;
      O.preventDefault();
    }, n = (O) => {
      for (let r = 0; r < this.items.length; r++)
        this.items[r].dom.contains(O.target) && this.moveSelection(r);
    };
    this.list = Ue("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: i,
      onclick: n
    }), this.dom = Ue("div", { class: "cm-panel-lint" }, this.list, Ue("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => vm(this.view)
    }, "×")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(mi).selected;
    if (!e)
      return -1;
    for (let i = 0; i < this.items.length; i++)
      if (this.items[i].diagnostic == e.diagnostic)
        return i;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: i } = this.view.state.field(mi), n = 0, O = false, r = null;
    for (e.between(0, this.view.state.doc.length, (a, o, { spec: s }) => {
      let l = -1, c;
      for (let u = n; u < this.items.length; u++)
        if (this.items[u].diagnostic == s.diagnostic) {
          l = u;
          break;
        }
      l < 0 ? (c = new Xm(this.view, s.diagnostic), this.items.splice(n, 0, c), O = true) : (c = this.items[l], l > n && (this.items.splice(n, l - n), O = true)), i && c.diagnostic == i.diagnostic ? c.dom.hasAttribute("aria-selected") || (c.dom.setAttribute("aria-selected", "true"), r = c) : c.dom.hasAttribute("aria-selected") && c.dom.removeAttribute("aria-selected"), n++;
    }); n < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      O = true, this.items.pop();
    this.items.length == 0 && (this.items.push(new Xm(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), O = true), r ? (this.list.setAttribute("aria-activedescendant", r.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: r.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: a, panel: o }) => {
        a.top < o.top ? this.list.scrollTop -= o.top - a.top : a.bottom > o.bottom && (this.list.scrollTop += a.bottom - o.bottom);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), O && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function i() {
      let n = e;
      e = n.nextSibling, n.remove();
    }
    for (let n of this.items)
      if (n.dom.parentNode == this.list) {
        for (; e != n.dom; )
          i();
        e = n.dom.nextSibling;
      } else
        this.list.insertBefore(n.dom, e);
    for (; e; )
      i();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let i = this.view.state.field(mi), n = ra(i.diagnostics, this.items[e].diagnostic);
    n && this.view.dispatch({
      selection: { anchor: n.from, head: n.to },
      scrollIntoView: true,
      effects: M0.of(n)
    });
  }
  static open(e) {
    return new su(e);
  }
};
function D2(t, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')`;
}
function hf(t) {
  return D2(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
var M2 = B.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: hf("#d11") },
  ".cm-lintRange-warning": { backgroundImage: hf("orange") },
  ".cm-lintRange-info": { backgroundImage: hf("#999") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
var N2 = (() => [
  HY(),
  eR(),
  QY(),
  gZ(),
  jR(),
  aY(),
  uY(),
  ye.allowMultipleSelections.of(true),
  _R(),
  jp(LR, { fallback: true }),
  KR(),
  y2(),
  R2(),
  WY(),
  ZY(),
  bY(),
  y5(),
  ka.of([
    ...x2,
    ...$5,
    ...j5,
    ...wZ,
    ...zR,
    ...L0,
    ...A2
  ])
])();
var B2 = Object.freeze({ autofocus: false, disabled: false, indentWithTab: true, tabSize: 2, placeholder: "", autoDestroy: true, extensions: [N2] });
var F2 = Symbol("vue-codemirror-global-config");
var Gt;
var H2 = function(t) {
  var e = t.onUpdate, i = t.onChange, n = t.onFocus, O = t.onBlur, r = function(a, o) {
    var s = {};
    for (var l in a)
      Object.prototype.hasOwnProperty.call(a, l) && o.indexOf(l) < 0 && (s[l] = a[l]);
    if (a != null && typeof Object.getOwnPropertySymbols == "function") {
      var c = 0;
      for (l = Object.getOwnPropertySymbols(a); c < l.length; c++)
        o.indexOf(l[c]) < 0 && Object.prototype.propertyIsEnumerable.call(a, l[c]) && (s[l[c]] = a[l[c]]);
    }
    return s;
  }(t, ["onUpdate", "onChange", "onFocus", "onBlur"]);
  return ye.create({ doc: r.doc, selection: r.selection, extensions: (Array.isArray(r.extensions) ? r.extensions : [r.extensions]).concat([B.updateListener.of(function(a) {
    e(a), a.docChanged && i(a.state.doc.toString(), a), a.focusChanged && (a.view.hasFocus ? n(a) : O(a));
  })]) });
};
var Cr = function(t) {
  var e = new ms();
  return { compartment: e, run: function(i) {
    e.get(t.state) ? t.dispatch({ effects: e.reconfigure(i) }) : t.dispatch({ effects: fe.appendConfig.of(e.of(i)) });
  } };
};
var xm = function(t, e) {
  var i = Cr(t), n = i.compartment, O = i.run;
  return function(r) {
    var a = n.get(t.state);
    O(r ?? a !== e ? e : []);
  };
};
var nl = { type: Boolean, default: void 0 };
var K2 = { autofocus: nl, disabled: nl, indentWithTab: nl, tabSize: Number, placeholder: String, style: Object, autoDestroy: nl, phrases: Object, root: Object, extensions: Array, selection: Object };
var J2 = { modelValue: { type: String, default: "" } };
var eU = Object.assign(Object.assign({}, K2), J2);
(function(t) {
  t.Change = "change", t.Update = "update", t.Focus = "focus", t.Blur = "blur", t.Ready = "ready", t.ModelUpdate = "update:modelValue";
})(Gt || (Gt = {}));
var GO = {};
GO[Gt.Change] = function(t, e) {
  return true;
}, GO[Gt.Update] = function(t) {
  return true;
}, GO[Gt.Focus] = function(t) {
  return true;
}, GO[Gt.Blur] = function(t) {
  return true;
}, GO[Gt.Ready] = function(t) {
  return true;
};
var F0 = {};
F0[Gt.ModelUpdate] = GO[Gt.Change];
var tU = Object.assign(Object.assign({}, GO), F0);
var iU = defineComponent({ name: "VueCodemirror", props: Object.assign({}, eU), emits: Object.assign({}, tU), setup: function(t, e) {
  var i = shallowRef(), n = shallowRef(), O = shallowRef(), r = Object.assign(Object.assign({}, B2), inject(F2, {})), a = computed(function() {
    var o = {};
    return Object.keys(toRaw(t)).forEach(function(s) {
      var l;
      s !== "modelValue" && (o[s] = (l = t[s]) !== null && l !== void 0 ? l : r[s]);
    }), o;
  });
  return onMounted(function() {
    var o;
    n.value = H2({ doc: t.modelValue, selection: a.value.selection, extensions: (o = r.extensions) !== null && o !== void 0 ? o : [], onFocus: function(l) {
      return e.emit(Gt.Focus, l);
    }, onBlur: function(l) {
      return e.emit(Gt.Blur, l);
    }, onUpdate: function(l) {
      return e.emit(Gt.Update, l);
    }, onChange: function(l, c) {
      l !== t.modelValue && (e.emit(Gt.Change, l, c), e.emit(Gt.ModelUpdate, l, c));
    } }), O.value = function(l) {
      return new B(Object.assign({}, l));
    }({ state: n.value, parent: i.value, root: a.value.root });
    var s = function(l) {
      var c = function() {
        return l.state.doc.toString();
      }, u = Cr(l).run, h10 = xm(l, [B.editable.of(false), ye.readOnly.of(true)]), d = xm(l, ka.of([Q5])), p = Cr(l).run, $ = Cr(l).run, g = Cr(l).run, Q = Cr(l).run;
      return { focus: function() {
        return l.focus();
      }, getDoc: c, setDoc: function(m) {
        m !== c() && l.dispatch({ changes: { from: 0, to: l.state.doc.length, insert: m } });
      }, reExtensions: u, toggleDisabled: h10, toggleIndentWithTab: d, setTabSize: function(m) {
        p([ye.tabSize.of(m), bs.of(" ".repeat(m))]);
      }, setPhrases: function(m) {
        $([ye.phrases.of(m)]);
      }, setPlaceholder: function(m) {
        g(wY(m));
      }, setStyle: function(m) {
        m === void 0 && (m = {}), Q(B.theme({ "&": Object.assign({}, m) }));
      } };
    }(O.value);
    watch(function() {
      return t.modelValue;
    }, function(l) {
      l !== s.getDoc() && s.setDoc(l);
    }), watch(function() {
      return t.extensions;
    }, function(l) {
      return s.reExtensions(l || []);
    }, { immediate: true }), watch(function() {
      return a.value.disabled;
    }, function(l) {
      return s.toggleDisabled(l);
    }, { immediate: true }), watch(function() {
      return a.value.indentWithTab;
    }, function(l) {
      return s.toggleIndentWithTab(l);
    }, { immediate: true }), watch(function() {
      return a.value.tabSize;
    }, function(l) {
      return s.setTabSize(l);
    }, { immediate: true }), watch(function() {
      return a.value.phrases;
    }, function(l) {
      return s.setPhrases(l || {});
    }, { immediate: true }), watch(function() {
      return a.value.placeholder;
    }, function(l) {
      return s.setPlaceholder(l);
    }, { immediate: true }), watch(function() {
      return a.value.style;
    }, function(l) {
      return s.setStyle(l);
    }, { immediate: true }), a.value.autofocus && s.focus(), e.emit(Gt.Ready, { state: n.value, view: O.value, container: i.value });
  }), onBeforeUnmount(function() {
    a.value.autoDestroy && O.value && function(o) {
      o.destroy();
    }(O.value);
  }), function() {
    return h("div", { class: "v-codemirror", style: { display: "contents" }, ref: i });
  };
} });
var nU = iU;
var OU = class cd {
  /// @internal
  constructor(e, i, n, O, r, a, o, s, l, c = 0, u) {
    this.p = e, this.stack = i, this.state = n, this.reducePos = O, this.pos = r, this.score = a, this.buffer = o, this.bufferBase = s, this.curContext = l, this.lookAhead = c, this.parent = u;
  }
  /// @internal
  toString() {
    return `[${this.stack.filter((e, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /// @internal
  static start(e, i, n = 0) {
    let O = e.parser.context;
    return new cd(e, [], i, n, n, 0, [], 0, O ? new wm(O, O.start) : null, 0, null);
  }
  /// The stack's current [context](#lr.ContextTracker) value, if
  /// any. Its type will depend on the context tracker's type
  /// parameter, or it will be `null` if there is no context
  /// tracker.
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /// @internal
  pushState(e, i) {
    this.stack.push(this.state, i, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /// @internal
  reduce(e) {
    var i;
    let n = e >> 19, O = e & 65535, { parser: r } = this.p, a = r.dynamicPrecedence(O);
    if (a && (this.score += a), n == 0) {
      this.pushState(r.getGoto(this.state, O, true), this.reducePos), O < r.minRepeatTerm && this.storeNode(O, this.reducePos, this.reducePos, 4, true), this.reduceContext(O, this.reducePos);
      return;
    }
    let o = this.stack.length - (n - 1) * 3 - (e & 262144 ? 6 : 0), s = o ? this.stack[o - 2] : this.p.ranges[0].from, l = this.reducePos - s;
    l >= 2e3 && !(!((i = this.p.parser.nodeSet.types[O]) === null || i === void 0) && i.isAnonymous) && (s == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = l) : this.p.lastBigReductionSize < l && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = s, this.p.lastBigReductionSize = l));
    let c = o ? this.stack[o - 1] : 0, u = this.bufferBase + this.buffer.length - c;
    if (O < r.minRepeatTerm || e & 131072) {
      let h10 = r.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(O, s, h10, u + 4, true);
    }
    if (e & 262144)
      this.state = this.stack[o];
    else {
      let h10 = this.stack[o - 3];
      this.state = r.getGoto(h10, O, true);
    }
    for (; this.stack.length > o; )
      this.stack.pop();
    this.reduceContext(O, s);
  }
  // Shift a value into the buffer
  /// @internal
  storeNode(e, i, n, O = 4, r = false) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let a = this, o = this.buffer.length;
      if (o == 0 && a.parent && (o = a.bufferBase - a.parent.bufferBase, a = a.parent), o > 0 && a.buffer[o - 4] == 0 && a.buffer[o - 1] > -1) {
        if (i == n)
          return;
        if (a.buffer[o - 2] >= i) {
          a.buffer[o - 2] = n;
          return;
        }
      }
    }
    if (!r || this.pos == n)
      this.buffer.push(e, i, n, O);
    else {
      let a = this.buffer.length;
      if (a > 0 && this.buffer[a - 4] != 0)
        for (; a > 0 && this.buffer[a - 2] > n; )
          this.buffer[a] = this.buffer[a - 4], this.buffer[a + 1] = this.buffer[a - 3], this.buffer[a + 2] = this.buffer[a - 2], this.buffer[a + 3] = this.buffer[a - 1], a -= 4, O > 4 && (O -= 4);
      this.buffer[a] = e, this.buffer[a + 1] = i, this.buffer[a + 2] = n, this.buffer[a + 3] = O;
    }
  }
  // Apply a shift action
  /// @internal
  shift(e, i, n) {
    let O = this.pos;
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if (e & 262144)
      this.pos = n, this.shiftContext(i, O), i <= this.p.parser.maxNode && this.buffer.push(i, O, n, 4);
    else {
      let r = e, { parser: a } = this.p;
      (n > this.pos || i <= a.maxNode) && (this.pos = n, a.stateFlag(
        r,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = n)), this.pushState(r, O), this.shiftContext(i, O), i <= a.maxNode && this.buffer.push(i, O, n, 4);
    }
  }
  // Apply an action
  /// @internal
  apply(e, i, n) {
    e & 65536 ? this.reduce(e) : this.shift(e, i, n);
  }
  // Add a prebuilt (reused) node into the buffer.
  /// @internal
  useNode(e, i) {
    let n = this.p.reused.length - 1;
    (n < 0 || this.p.reused[n] != e) && (this.p.reused.push(e), n++);
    let O = this.pos;
    this.reducePos = this.pos = O + e.length, this.pushState(i, O), this.buffer.push(
      n,
      O,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /// @internal
  split() {
    let e = this, i = e.buffer.length;
    for (; i > 0 && e.buffer[i - 2] > e.reducePos; )
      i -= 4;
    let n = e.buffer.slice(i), O = e.bufferBase + i;
    for (; e && O == e.bufferBase; )
      e = e.parent;
    return new cd(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, n, O, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /// @internal
  recoverByDelete(e, i) {
    let n = e <= this.p.parser.maxNode;
    n && this.storeNode(e, this.pos, i, 4), this.storeNode(0, this.pos, i, n ? 8 : 4), this.pos = this.reducePos = i, this.score -= 190;
  }
  /// Check if the given term would be able to be shifted (optionally
  /// after some reductions) on this stack. This can be useful for
  /// external tokenizers that want to make sure they only provide a
  /// given token when it applies.
  canShift(e) {
    for (let i = new rU(this); ; ) {
      let n = this.p.parser.stateSlot(
        i.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(i.state, e);
      if (n == 0)
        return false;
      if (!(n & 65536))
        return true;
      i.reduce(n);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /// @internal
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let i = this.p.parser.nextStates(this.state);
    if (i.length > 4 << 1 || this.stack.length >= 120) {
      let O = [];
      for (let r = 0, a; r < i.length; r += 2)
        (a = i[r + 1]) != this.state && this.p.parser.hasAction(a, e) && O.push(i[r], a);
      if (this.stack.length < 120)
        for (let r = 0; O.length < 4 << 1 && r < i.length; r += 2) {
          let a = i[r + 1];
          O.some((o, s) => s & 1 && o == a) || O.push(i[r], a);
        }
      i = O;
    }
    let n = [];
    for (let O = 0; O < i.length && n.length < 4; O += 2) {
      let r = i[O + 1];
      if (r == this.state)
        continue;
      let a = this.split();
      a.pushState(r, this.pos), a.storeNode(0, a.pos, a.pos, 4, true), a.shiftContext(i[O], this.pos), a.score -= 200, n.push(a);
    }
    return n;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /// @internal
  forceReduce() {
    let e = this.p.parser.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(e & 65536))
      return false;
    let { parser: i } = this.p;
    if (!i.validAction(this.state, e)) {
      let n = e >> 19, O = e & 65535, r = this.stack.length - n * 3;
      if (r < 0 || i.getGoto(this.stack[r], O, false) < 0)
        return false;
      this.storeNode(0, this.reducePos, this.reducePos, 4, true), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(e), true;
  }
  /// @internal
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, true);
        break;
      }
    return this;
  }
  /// Check whether this state has no further actions (assumed to be a direct descendant of the
  /// top state, since any other states must be able to continue
  /// somehow). @internal
  get deadEnd() {
    if (this.stack.length != 3)
      return false;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /// Restart the stack (put it back in its start state). Only safe
  /// when this.stack.length == 3 (state is directly below the top
  /// state). @internal
  restart() {
    this.state = this.stack[0], this.stack.length = 0;
  }
  /// @internal
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return false;
    for (let i = 0; i < this.stack.length; i += 3)
      if (this.stack[i] != e.stack[i])
        return false;
    return true;
  }
  /// Get the parser used by this stack.
  get parser() {
    return this.p.parser;
  }
  /// Test whether a given dialect (by numeric ID, as exported from
  /// the terms file) is enabled.
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, i) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(i)));
  }
  reduceContext(e, i) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(i)));
  }
  /// @internal
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
  }
  /// @internal
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let i = new wm(this.curContext.tracker, e);
      i.hash != this.curContext.hash && this.emitContext(), this.curContext = i;
    }
  }
  /// @internal
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /// @internal
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
};
var wm = class {
  constructor(e, i) {
    this.tracker = e, this.context = i, this.hash = e.strict ? e.hash(i) : 0;
  }
};
var Tm;
(function(t) {
  t[t.Insert = 200] = "Insert", t[t.Delete = 190] = "Delete", t[t.Reduce = 100] = "Reduce", t[t.MaxNext = 4] = "MaxNext", t[t.MaxInsertStackDepth = 300] = "MaxInsertStackDepth", t[t.DampenInsertStackDepth = 120] = "DampenInsertStackDepth", t[t.MinBigReduction = 2e3] = "MinBigReduction";
})(Tm || (Tm = {}));
var rU = class {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let i = e & 65535, n = e >> 19;
    n == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (n - 1) * 3;
    let O = this.start.p.parser.getGoto(this.stack[this.base - 3], i, true);
    this.state = O;
  }
};
var dc = class {
  constructor(e, i, n) {
    this.stack = e, this.pos = i, this.index = n, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, i = e.bufferBase + e.buffer.length) {
    return new dc(e, i, i - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new dc(this.stack, this.pos, this.index);
  }
};
function Qo(t, e = Uint16Array) {
  if (typeof t != "string")
    return t;
  let i = null;
  for (let n = 0, O = 0; n < t.length; ) {
    let r = 0;
    for (; ; ) {
      let a = t.charCodeAt(n++), o = false;
      if (a == 126) {
        r = 65535;
        break;
      }
      a >= 92 && a--, a >= 34 && a--;
      let s = a - 32;
      if (s >= 46 && (s -= 46, o = true), r += s, o)
        break;
      r *= 46;
    }
    i ? i[O++] = r : i = new e(r);
  }
  return i;
}
var Rl = class {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
};
var km = new Rl();
var aU = class {
  /// @internal
  constructor(e, i) {
    this.input = e, this.ranges = i, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = km, this.rangeIndex = 0, this.pos = this.chunkPos = i[0].from, this.range = i[0], this.end = i[i.length - 1].to, this.readNext();
  }
  /// @internal
  resolveOffset(e, i) {
    let n = this.range, O = this.rangeIndex, r = this.pos + e;
    for (; r < n.from; ) {
      if (!O)
        return null;
      let a = this.ranges[--O];
      r -= n.from - a.to, n = a;
    }
    for (; i < 0 ? r > n.to : r >= n.to; ) {
      if (O == this.ranges.length - 1)
        return null;
      let a = this.ranges[++O];
      r += a.from - n.to, n = a;
    }
    return r;
  }
  /// @internal
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let i of this.ranges)
      if (i.to > e)
        return Math.max(e, i.from);
    return this.end;
  }
  /// Look at a code unit near the stream position. `.peek(0)` equals
  /// `.next`, `.peek(-1)` gives you the previous character, and so
  /// on.
  ///
  /// Note that looking around during tokenizing creates dependencies
  /// on potentially far-away content, which may reduce the
  /// effectiveness incremental parsing—when looking forward—or even
  /// cause invalid reparses when looking backward more than 25 code
  /// units, since the library does not track lookbehind.
  peek(e) {
    let i = this.chunkOff + e, n, O;
    if (i >= 0 && i < this.chunk.length)
      n = this.pos + e, O = this.chunk.charCodeAt(i);
    else {
      let r = this.resolveOffset(e, 1);
      if (r == null)
        return -1;
      if (n = r, n >= this.chunk2Pos && n < this.chunk2Pos + this.chunk2.length)
        O = this.chunk2.charCodeAt(n - this.chunk2Pos);
      else {
        let a = this.rangeIndex, o = this.range;
        for (; o.to <= n; )
          o = this.ranges[++a];
        this.chunk2 = this.input.chunk(this.chunk2Pos = n), n + this.chunk2.length > o.to && (this.chunk2 = this.chunk2.slice(0, o.to - n)), O = this.chunk2.charCodeAt(0);
      }
    }
    return n >= this.token.lookAhead && (this.token.lookAhead = n + 1), O;
  }
  /// Accept a token. By default, the end of the token is set to the
  /// current stream position, but you can pass an offset (relative to
  /// the stream position) to change that.
  acceptToken(e, i = 0) {
    let n = i ? this.resolveOffset(i, -1) : this.pos;
    if (n == null || n < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = n;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: i } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = i, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), i = this.pos + e.length;
      this.chunk = i > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /// Move the stream forward N (defaults to 1) code units. Returns
  /// the new value of [`next`](#lr.InputStream.next).
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /// @internal
  reset(e, i) {
    if (i ? (this.token = i, i.start = e, i.lookAhead = e + 1, i.value = i.extended = -1) : this.token = km, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /// @internal
  read(e, i) {
    if (e >= this.chunkPos && i <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, i - this.chunkPos);
    if (e >= this.chunk2Pos && i <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, i - this.chunk2Pos);
    if (e >= this.range.from && i <= this.range.to)
      return this.input.read(e, i);
    let n = "";
    for (let O of this.ranges) {
      if (O.from >= i)
        break;
      O.to > e && (n += this.input.read(Math.max(O.from, e), Math.min(O.to, i)));
    }
    return n;
  }
};
var Br = class {
  constructor(e, i) {
    this.data = e, this.id = i;
  }
  token(e, i) {
    let { parser: n } = i.p;
    H0(this.data, e, i, this.id, n.data, n.tokenPrecTable);
  }
};
Br.prototype.contextual = Br.prototype.fallback = Br.prototype.extend = false;
var ud = class {
  constructor(e, i, n) {
    this.precTable = i, this.elseToken = n, this.data = typeof e == "string" ? Qo(e) : e;
  }
  token(e, i) {
    let n = e.pos, O;
    for (; O = e.pos, H0(this.data, e, i, 0, this.data, this.precTable), !(e.token.value > -1); ) {
      if (this.elseToken == null)
        return;
      if (e.next < 0)
        break;
      e.advance(), e.reset(O + 1, e.token);
    }
    O > n && (e.reset(n, e.token), e.acceptToken(this.elseToken, O - n));
  }
};
ud.prototype.contextual = Br.prototype.fallback = Br.prototype.extend = false;
var Ie = class {
  /// Create a tokenizer. The first argument is the function that,
  /// given an input stream, scans for the types of tokens it
  /// recognizes at the stream's position, and calls
  /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  /// one.
  constructor(e, i = {}) {
    this.token = e, this.contextual = !!i.contextual, this.fallback = !!i.fallback, this.extend = !!i.extend;
  }
};
function H0(t, e, i, n, O, r) {
  let a = 0, o = 1 << n, { dialect: s } = i.p.parser;
  e:
    for (; o & t[a]; ) {
      let l = t[a + 1];
      for (let d = a + 3; d < l; d += 2)
        if ((t[d + 1] & o) > 0) {
          let p = t[d];
          if (s.allows(p) && (e.token.value == -1 || e.token.value == p || oU(p, e.token.value, O, r))) {
            e.acceptToken(p);
            break;
          }
        }
      let c = e.next, u = 0, h10 = t[a + 2];
      if (e.next < 0 && h10 > u && t[l + h10 * 3 - 3] == 65535 && t[l + h10 * 3 - 3] == 65535) {
        a = t[l + h10 * 3 - 1];
        continue e;
      }
      for (; u < h10; ) {
        let d = u + h10 >> 1, p = l + d + (d << 1), $ = t[p], g = t[p + 1] || 65536;
        if (c < $)
          h10 = d;
        else if (c >= g)
          u = d + 1;
        else {
          a = t[p + 2], e.advance();
          continue e;
        }
      }
      break;
    }
}
function _m(t, e, i) {
  for (let n = e, O; (O = t[n]) != 65535; n++)
    if (O == i)
      return n - e;
  return -1;
}
function oU(t, e, i, n) {
  let O = _m(i, n, e);
  return O < 0 || _m(i, n, t) < O;
}
var Di = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
var df = null;
var Wm;
(function(t) {
  t[t.Margin = 25] = "Margin";
})(Wm || (Wm = {}));
function Ym(t, e, i) {
  let n = t.cursor(ze.IncludeAnonymous);
  for (n.moveTo(e); ; )
    if (!(i < 0 ? n.childBefore(e) : n.childAfter(e)))
      for (; ; ) {
        if ((i < 0 ? n.to < e : n.from > e) && !n.type.isError)
          return i < 0 ? Math.max(0, Math.min(
            n.to - 1,
            e - 25
            /* Safety.Margin */
          )) : Math.min(t.length, Math.max(
            n.from + 1,
            e + 25
            /* Safety.Margin */
          ));
        if (i < 0 ? n.prevSibling() : n.nextSibling())
          break;
        if (!n.parent())
          return i < 0 ? 0 : t.length;
      }
}
var sU = class {
  constructor(e, i) {
    this.fragments = e, this.nodeSet = i, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? Ym(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? Ym(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let i = this.trees.length - 1;
      if (i < 0)
        return this.nextFragment(), null;
      let n = this.trees[i], O = this.index[i];
      if (O == n.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let r = n.children[O], a = this.start[i] + n.positions[O];
      if (a > e)
        return this.nextStart = a, null;
      if (r instanceof ve) {
        if (a == e) {
          if (a < this.safeFrom)
            return null;
          let o = a + r.length;
          if (o <= this.safeTo) {
            let s = r.prop(se.lookAhead);
            if (!s || o + s < this.fragment.to)
              return r;
          }
        }
        this.index[i]++, a + r.length >= Math.max(this.safeFrom, e) && (this.trees.push(r), this.start.push(a), this.index.push(0));
      } else
        this.index[i]++, this.nextStart = a + r.length;
    }
  }
};
var lU = class {
  constructor(e, i) {
    this.stream = i, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((n) => new Rl());
  }
  getActions(e) {
    let i = 0, n = null, { parser: O } = e.p, { tokenizers: r } = O, a = O.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), o = e.curContext ? e.curContext.hash : 0, s = 0;
    for (let l = 0; l < r.length; l++) {
      if (!(1 << l & a))
        continue;
      let c = r[l], u = this.tokens[l];
      if (!(n && !c.fallback) && ((c.contextual || u.start != e.pos || u.mask != a || u.context != o) && (this.updateCachedToken(u, c, e), u.mask = a, u.context = o), u.lookAhead > u.end + 25 && (s = Math.max(u.lookAhead, s)), u.value != 0)) {
        let h10 = i;
        if (u.extended > -1 && (i = this.addActions(e, u.extended, u.end, i)), i = this.addActions(e, u.value, u.end, i), !c.extend && (n = u, i > h10))
          break;
      }
    }
    for (; this.actions.length > i; )
      this.actions.pop();
    return s && e.setLookAhead(s), !n && e.pos == this.stream.end && (n = new Rl(), n.value = e.p.parser.eofTerm, n.start = n.end = e.pos, i = this.addActions(e, n.value, n.end, i)), this.mainToken = n, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let i = new Rl(), { pos: n, p: O } = e;
    return i.start = n, i.end = Math.min(n + 1, O.stream.end), i.value = n == O.stream.end ? O.parser.eofTerm : 0, i;
  }
  updateCachedToken(e, i, n) {
    let O = this.stream.clipPos(n.pos);
    if (i.token(this.stream.reset(O, e), n), e.value > -1) {
      let { parser: r } = n.p;
      for (let a = 0; a < r.specialized.length; a++)
        if (r.specialized[a] == e.value) {
          let o = r.specializers[a](this.stream.read(e.start, e.end), n);
          if (o >= 0 && n.p.parser.dialect.allows(o >> 1)) {
            o & 1 ? e.extended = o >> 1 : e.value = o >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(O + 1);
  }
  putAction(e, i, n, O) {
    for (let r = 0; r < O; r += 3)
      if (this.actions[r] == e)
        return O;
    return this.actions[O++] = e, this.actions[O++] = i, this.actions[O++] = n, O;
  }
  addActions(e, i, n, O) {
    let { state: r } = e, { parser: a } = e.p, { data: o } = a;
    for (let s = 0; s < 2; s++)
      for (let l = a.stateSlot(
        r,
        s ? 2 : 1
        /* ParseState.Actions */
      ); ; l += 3) {
        if (o[l] == 65535)
          if (o[l + 1] == 1)
            l = Un(o, l + 2);
          else {
            O == 0 && o[l + 1] == 2 && (O = this.putAction(Un(o, l + 2), i, n, O));
            break;
          }
        o[l] == i && (O = this.putAction(Un(o, l + 1), i, n, O));
      }
    return O;
  }
};
var Rm;
(function(t) {
  t[t.Distance = 5] = "Distance", t[t.MaxRemainingPerStep = 3] = "MaxRemainingPerStep", t[t.MinBufferLengthPrune = 500] = "MinBufferLengthPrune", t[t.ForceReduceLimit = 10] = "ForceReduceLimit", t[t.CutDepth = 15e3] = "CutDepth", t[t.CutTo = 9e3] = "CutTo", t[t.MaxLeftAssociativeReductionCount = 300] = "MaxLeftAssociativeReductionCount", t[t.MaxStackCount = 12] = "MaxStackCount";
})(Rm || (Rm = {}));
var cU = class {
  constructor(e, i, n, O) {
    this.parser = e, this.input = i, this.ranges = O, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new aU(i, O), this.tokens = new lU(e, this.stream), this.topTerm = e.top[1];
    let { from: r } = O[0];
    this.stacks = [OU.start(this, e.top[0], r)], this.fragments = n.length && this.stream.end - r > e.bufferLength * 4 ? new sU(n, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, i = this.minStackPos, n = this.stacks = [], O, r;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [a] = e;
      for (; a.forceReduce() && a.stack.length && a.stack[a.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let a = 0; a < e.length; a++) {
      let o = e[a];
      for (; ; ) {
        if (this.tokens.mainToken = null, o.pos > i)
          n.push(o);
        else {
          if (this.advanceStack(o, n, e))
            continue;
          {
            O || (O = [], r = []), O.push(o);
            let s = this.tokens.getMainToken(o);
            r.push(s.value, s.end);
          }
        }
        break;
      }
    }
    if (!n.length) {
      let a = O && fU(O);
      if (a)
        return this.stackToTree(a);
      if (this.parser.strict)
        throw Di && O && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + i);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && O) {
      let a = this.stoppedAt != null && O[0].pos > this.stoppedAt ? O[0] : this.runRecovery(O, r, n);
      if (a)
        return this.stackToTree(a.forceAll());
    }
    if (this.recovering) {
      let a = this.recovering == 1 ? 1 : this.recovering * 3;
      if (n.length > a)
        for (n.sort((o, s) => s.score - o.score); n.length > a; )
          n.pop();
      n.some((o) => o.reducePos > i) && this.recovering--;
    } else if (n.length > 1) {
      e:
        for (let a = 0; a < n.length - 1; a++) {
          let o = n[a];
          for (let s = a + 1; s < n.length; s++) {
            let l = n[s];
            if (o.sameState(l) || o.buffer.length > 500 && l.buffer.length > 500)
              if ((o.score - l.score || o.buffer.length - l.buffer.length) > 0)
                n.splice(s--, 1);
              else {
                n.splice(a--, 1);
                continue e;
              }
          }
        }
      n.length > 12 && n.splice(
        12,
        n.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = n[0].pos;
    for (let a = 1; a < n.length; a++)
      n[a].pos < this.minStackPos && (this.minStackPos = n[a].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, i, n) {
    let O = e.pos, { parser: r } = this, a = Di ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && O > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let l = e.curContext && e.curContext.tracker.strict, c = l ? e.curContext.hash : 0;
      for (let u = this.fragments.nodeAt(O); u; ) {
        let h10 = this.parser.nodeSet.types[u.type.id] == u.type ? r.getGoto(e.state, u.type.id) : -1;
        if (h10 > -1 && u.length && (!l || (u.prop(se.contextHash) || 0) == c))
          return e.useNode(u, h10), Di && console.log(a + this.stackID(e) + ` (via reuse of ${r.getName(u.type.id)})`), true;
        if (!(u instanceof ve) || u.children.length == 0 || u.positions[0] > 0)
          break;
        let d = u.children[0];
        if (d instanceof ve && u.positions[0] == 0)
          u = d;
        else
          break;
      }
    }
    let o = r.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (o > 0)
      return e.reduce(o), Di && console.log(a + this.stackID(e) + ` (via always-reduce ${r.getName(
        o & 65535
        /* Action.ValueMask */
      )})`), true;
    if (e.stack.length >= 15e3)
      for (; e.stack.length > 9e3 && e.forceReduce(); )
        ;
    let s = this.tokens.getActions(e);
    for (let l = 0; l < s.length; ) {
      let c = s[l++], u = s[l++], h10 = s[l++], d = l == s.length || !n, p = d ? e : e.split();
      if (p.apply(c, u, h10), Di && console.log(a + this.stackID(p) + ` (via ${c & 65536 ? `reduce of ${r.getName(
        c & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${r.getName(u)} @ ${O}${p == e ? "" : ", split"})`), d)
        return true;
      p.pos > O ? i.push(p) : n.push(p);
    }
    return false;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, i) {
    let n = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return false;
      if (e.pos > n)
        return Zm(e, i), true;
    }
  }
  runRecovery(e, i, n) {
    let O = null, r = false;
    for (let a = 0; a < e.length; a++) {
      let o = e[a], s = i[a << 1], l = i[(a << 1) + 1], c = Di ? this.stackID(o) + " -> " : "";
      if (o.deadEnd && (r || (r = true, o.restart(), Di && console.log(c + this.stackID(o) + " (restarted)"), this.advanceFully(o, n))))
        continue;
      let u = o.split(), h10 = c;
      for (let d = 0; u.forceReduce() && d < 10 && (Di && console.log(h10 + this.stackID(u) + " (via force-reduce)"), !this.advanceFully(u, n)); d++)
        Di && (h10 = this.stackID(u) + " -> ");
      for (let d of o.recoverByInsert(s))
        Di && console.log(c + this.stackID(d) + " (via recover-insert)"), this.advanceFully(d, n);
      this.stream.end > o.pos ? (l == o.pos && (l++, s = 0), o.recoverByDelete(s, l), Di && console.log(c + this.stackID(o) + ` (via recover-delete ${this.parser.getName(s)})`), Zm(o, n)) : (!O || O.score < o.score) && (O = o);
    }
    return O;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), ve.build({
      buffer: dc.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let i = (df || (df = /* @__PURE__ */ new WeakMap())).get(e);
    return i || df.set(e, i = String.fromCodePoint(this.nextStackID++)), i + e;
  }
};
function Zm(t, e) {
  for (let i = 0; i < e.length; i++) {
    let n = e[i];
    if (n.pos == t.pos && n.sameState(t)) {
      e[i].score < t.score && (e[i] = t);
      return;
    }
  }
  e.push(t);
}
var uU = class {
  constructor(e, i, n) {
    this.source = e, this.flags = i, this.disabled = n;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
};
var pf = (t) => t;
var lu = class {
  /// Define a context tracker.
  constructor(e) {
    this.start = e.start, this.shift = e.shift || pf, this.reduce = e.reduce || pf, this.reuse = e.reuse || pf, this.hash = e.hash || (() => 0), this.strict = e.strict !== false;
  }
};
var Jt = class extends Hc {
  /// @internal
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (${14})`);
    let i = e.nodeNames.split(" ");
    this.minRepeatTerm = i.length;
    for (let o = 0; o < e.repeatNodeCount; o++)
      i.push("");
    let n = Object.keys(e.topRules).map((o) => e.topRules[o][1]), O = [];
    for (let o = 0; o < i.length; o++)
      O.push([]);
    function r(o, s, l) {
      O[o].push([s, s.deserialize(String(l))]);
    }
    if (e.nodeProps)
      for (let o of e.nodeProps) {
        let s = o[0];
        typeof s == "string" && (s = se[s]);
        for (let l = 1; l < o.length; ) {
          let c = o[l++];
          if (c >= 0)
            r(c, s, o[l++]);
          else {
            let u = o[l + -c];
            for (let h10 = -c; h10 > 0; h10--)
              r(o[l++], s, u);
            l++;
          }
        }
      }
    this.nodeSet = new _a(i.map((o, s) => lt.define({
      name: s >= this.minRepeatTerm ? void 0 : o,
      id: s,
      props: O[s],
      top: n.indexOf(s) > -1,
      error: s == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(s) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = false, this.bufferLength = g1;
    let a = Qo(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let o = 0; o < this.specializerSpecs.length; o++)
      this.specialized[o] = this.specializerSpecs[o].term;
    this.specializers = this.specializerSpecs.map(Um), this.states = Qo(e.states, Uint32Array), this.data = Qo(e.stateData), this.goto = Qo(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((o) => typeof o == "number" ? new Br(a, o) : o), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, i, n) {
    let O = new cU(this, e, i, n);
    for (let r of this.wrappers)
      O = r(O, e, i, n);
    return O;
  }
  /// Get a goto table entry @internal
  getGoto(e, i, n = false) {
    let O = this.goto;
    if (i >= O[0])
      return -1;
    for (let r = O[i + 1]; ; ) {
      let a = O[r++], o = a & 1, s = O[r++];
      if (o && n)
        return s;
      for (let l = r + (a >> 1); r < l; r++)
        if (O[r] == e)
          return s;
      if (o)
        return -1;
    }
  }
  /// Check if this state has an action for a given terminal @internal
  hasAction(e, i) {
    let n = this.data;
    for (let O = 0; O < 2; O++)
      for (let r = this.stateSlot(
        e,
        O ? 2 : 1
        /* ParseState.Actions */
      ), a; ; r += 3) {
        if ((a = n[r]) == 65535)
          if (n[r + 1] == 1)
            a = n[r = Un(n, r + 2)];
          else {
            if (n[r + 1] == 2)
              return Un(n, r + 2);
            break;
          }
        if (a == i || a == 0)
          return Un(n, r + 1);
      }
    return 0;
  }
  /// @internal
  stateSlot(e, i) {
    return this.states[e * 6 + i];
  }
  /// @internal
  stateFlag(e, i) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & i) > 0;
  }
  /// @internal
  validAction(e, i) {
    if (i == this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ))
      return true;
    for (let n = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; n += 3) {
      if (this.data[n] == 65535)
        if (this.data[n + 1] == 1)
          n = Un(this.data, n + 2);
        else
          return false;
      if (i == Un(this.data, n + 1))
        return true;
    }
  }
  /// Get the states that can follow this one through shift actions or
  /// goto jumps. @internal
  nextStates(e) {
    let i = [];
    for (let n = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; n += 3) {
      if (this.data[n] == 65535)
        if (this.data[n + 1] == 1)
          n = Un(this.data, n + 2);
        else
          break;
      if (!(this.data[n + 2] & 1)) {
        let O = this.data[n + 1];
        i.some((r, a) => a & 1 && r == O) || i.push(this.data[n], O);
      }
    }
    return i;
  }
  /// Configure the parser. Returns a new parser instance that has the
  /// given settings modified. Settings not provided in `config` are
  /// kept from the original parser.
  configure(e) {
    let i = Object.assign(Object.create(Jt.prototype), this);
    if (e.props && (i.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let n = this.topRules[e.top];
      if (!n)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      i.top = n;
    }
    return e.tokenizers && (i.tokenizers = this.tokenizers.map((n) => {
      let O = e.tokenizers.find((r) => r.from == n);
      return O ? O.to : n;
    })), e.specializers && (i.specializers = this.specializers.slice(), i.specializerSpecs = this.specializerSpecs.map((n, O) => {
      let r = e.specializers.find((o) => o.from == n.external);
      if (!r)
        return n;
      let a = Object.assign(Object.assign({}, n), { external: r.to });
      return i.specializers[O] = Um(a), a;
    })), e.contextTracker && (i.context = e.contextTracker), e.dialect && (i.dialect = this.parseDialect(e.dialect)), e.strict != null && (i.strict = e.strict), e.wrap && (i.wrappers = i.wrappers.concat(e.wrap)), e.bufferLength != null && (i.bufferLength = e.bufferLength), i;
  }
  /// Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  /// are registered for this parser.
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /// Returns the name associated with a given term. This will only
  /// work for all terms when the parser was generated with the
  /// `--names` option. By default, only the names of tagged terms are
  /// stored.
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /// The eof term id is always allocated directly after the node
  /// types. @internal
  get eofTerm() {
    return this.maxNode + 1;
  }
  /// The type of top node produced by the parser.
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /// @internal
  dynamicPrecedence(e) {
    let i = this.dynamicPrecedences;
    return i == null ? 0 : i[e] || 0;
  }
  /// @internal
  parseDialect(e) {
    let i = Object.keys(this.dialects), n = i.map(() => false);
    if (e)
      for (let r of e.split(" ")) {
        let a = i.indexOf(r);
        a >= 0 && (n[a] = true);
      }
    let O = null;
    for (let r = 0; r < i.length; r++)
      if (!n[r])
        for (let a = this.dialects[i[r]], o; (o = this.data[a++]) != 65535; )
          (O || (O = new Uint8Array(this.maxTerm + 1)))[o] = 1;
    return new uU(e, n, O);
  }
  /// Used by the output of the parser generator. Not available to
  /// user code. @hide
  static deserialize(e) {
    return new Jt(e);
  }
};
function Un(t, e) {
  return t[e] | t[e + 1] << 16;
}
function fU(t) {
  let e = null;
  for (let i of t) {
    let n = i.p.stoppedAt;
    (i.pos == i.p.stream.end || n != null && i.pos > n) && i.p.parser.stateFlag(
      i.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < i.score) && (e = i);
  }
  return e;
}
function Um(t) {
  if (t.external) {
    let e = t.extend ? 1 : 0;
    return (i, n) => t.external(i, n) << 1 | e;
  }
  return t.get;
}
var hU = 54;
var dU = 1;
var pU = 55;
var $U = 2;
var QU = 56;
var gU = 3;
var Vm = 4;
var mU = 5;
var pc = 6;
var K0 = 7;
var J0 = 8;
var eX = 9;
var tX = 10;
var SU = 11;
var PU = 12;
var yU = 13;
var $f = 57;
var bU = 14;
var qm = 58;
var vU = 20;
var XU = 22;
var iX = 23;
var xU = 24;
var fd = 26;
var nX = 27;
var wU = 28;
var TU = 31;
var kU = 34;
var OX = 36;
var _U = 37;
var WU = 0;
var YU = 1;
var RU = {
  area: true,
  base: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true,
  menuitem: true
};
var ZU = {
  dd: true,
  li: true,
  optgroup: true,
  option: true,
  p: true,
  rp: true,
  rt: true,
  tbody: true,
  td: true,
  tfoot: true,
  th: true,
  tr: true
};
var zm = {
  dd: { dd: true, dt: true },
  dt: { dd: true, dt: true },
  li: { li: true },
  option: { option: true, optgroup: true },
  optgroup: { optgroup: true },
  p: {
    address: true,
    article: true,
    aside: true,
    blockquote: true,
    dir: true,
    div: true,
    dl: true,
    fieldset: true,
    footer: true,
    form: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    header: true,
    hgroup: true,
    hr: true,
    menu: true,
    nav: true,
    ol: true,
    p: true,
    pre: true,
    section: true,
    table: true,
    ul: true
  },
  rp: { rp: true, rt: true },
  rt: { rp: true, rt: true },
  tbody: { tbody: true, tfoot: true },
  td: { td: true, th: true },
  tfoot: { tbody: true },
  th: { td: true, th: true },
  thead: { tbody: true, tfoot: true },
  tr: { tr: true }
};
function UU(t) {
  return t == 45 || t == 46 || t == 58 || t >= 65 && t <= 90 || t == 95 || t >= 97 && t <= 122 || t >= 161;
}
function rX(t) {
  return t == 9 || t == 10 || t == 13 || t == 32;
}
var Cm = null;
var Em = null;
var jm = 0;
function hd(t, e) {
  let i = t.pos + e;
  if (jm == i && Em == t)
    return Cm;
  let n = t.peek(e);
  for (; rX(n); )
    n = t.peek(++e);
  let O = "";
  for (; UU(n); )
    O += String.fromCharCode(n), n = t.peek(++e);
  return Em = t, jm = i, Cm = O ? O.toLowerCase() : n == VU || n == qU ? void 0 : null;
}
var aX = 60;
var $c = 62;
var s$ = 47;
var VU = 63;
var qU = 33;
var zU = 45;
function Im(t, e) {
  this.name = t, this.parent = e, this.hash = e ? e.hash : 0;
  for (let i = 0; i < t.length; i++)
    this.hash += (this.hash << 4) + t.charCodeAt(i) + (t.charCodeAt(i) << 8);
}
var CU = [pc, tX, K0, J0, eX];
var EU = new lu({
  start: null,
  shift(t, e, i, n) {
    return CU.indexOf(e) > -1 ? new Im(hd(n, 1) || "", t) : t;
  },
  reduce(t, e) {
    return e == vU && t ? t.parent : t;
  },
  reuse(t, e, i, n) {
    let O = e.type.id;
    return O == pc || O == OX ? new Im(hd(n, 1) || "", t) : t;
  },
  hash(t) {
    return t ? t.hash : 0;
  },
  strict: false
});
var jU = new Ie((t, e) => {
  if (t.next != aX) {
    t.next < 0 && e.context && t.acceptToken($f);
    return;
  }
  t.advance();
  let i = t.next == s$;
  i && t.advance();
  let n = hd(t, 0);
  if (n === void 0)
    return;
  if (!n)
    return t.acceptToken(i ? bU : pc);
  let O = e.context ? e.context.name : null;
  if (i) {
    if (n == O)
      return t.acceptToken(SU);
    if (O && ZU[O])
      return t.acceptToken($f, -2);
    if (e.dialectEnabled(WU))
      return t.acceptToken(PU);
    for (let r = e.context; r; r = r.parent)
      if (r.name == n)
        return;
    t.acceptToken(yU);
  } else {
    if (n == "script")
      return t.acceptToken(K0);
    if (n == "style")
      return t.acceptToken(J0);
    if (n == "textarea")
      return t.acceptToken(eX);
    if (RU.hasOwnProperty(n))
      return t.acceptToken(tX);
    O && zm[O] && zm[O][n] ? t.acceptToken($f, -1) : t.acceptToken(pc);
  }
}, { contextual: true });
var IU = new Ie((t) => {
  for (let e = 0, i = 0; ; i++) {
    if (t.next < 0) {
      i && t.acceptToken(qm);
      break;
    }
    if (t.next == zU)
      e++;
    else if (t.next == $c && e >= 2) {
      i > 3 && t.acceptToken(qm, -2);
      break;
    } else
      e = 0;
    t.advance();
  }
});
function AU(t) {
  for (; t; t = t.parent)
    if (t.name == "svg" || t.name == "math")
      return true;
  return false;
}
var GU = new Ie((t, e) => {
  if (t.next == s$ && t.peek(1) == $c) {
    let i = e.dialectEnabled(YU) || AU(e.context);
    t.acceptToken(i ? mU : Vm, 2);
  } else
    t.next == $c && t.acceptToken(Vm, 1);
});
function l$(t, e, i) {
  let n = 2 + t.length;
  return new Ie((O) => {
    for (let r = 0, a = 0, o = 0; ; o++) {
      if (O.next < 0) {
        o && O.acceptToken(e);
        break;
      }
      if (r == 0 && O.next == aX || r == 1 && O.next == s$ || r >= 2 && r < n && O.next == t.charCodeAt(r - 2))
        r++, a++;
      else if ((r == 2 || r == n) && rX(O.next))
        a++;
      else if (r == n && O.next == $c) {
        o > a ? O.acceptToken(e, -a) : O.acceptToken(i, -(a - 2));
        break;
      } else if ((O.next == 10 || O.next == 13) && o) {
        O.acceptToken(e, 1);
        break;
      } else
        r = a = 0;
      O.advance();
    }
  });
}
var LU = l$("script", hU, dU);
var DU = l$("style", pU, $U);
var MU = l$("textarea", QU, gU);
var NU = ti({
  "Text RawText": f.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": f.angleBracket,
  TagName: f.tagName,
  "MismatchedCloseTag/TagName": [f.tagName, f.invalid],
  AttributeName: f.attributeName,
  "AttributeValue UnquotedAttributeValue": f.attributeValue,
  Is: f.definitionOperator,
  "EntityReference CharacterReference": f.character,
  Comment: f.blockComment,
  ProcessingInst: f.processingInstruction,
  DoctypeDecl: f.documentMeta
});
var BU = Jt.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%WQ&rO,59fO%`Q&rO,59iO%hQ&rO,59lO%sQ&rO,59nOOOa'#D^'#D^O%{OaO'#CxO&WOaO,59[OOOb'#D_'#D_O&`ObO'#C{O&kObO,59[OOOd'#D`'#D`O&sOdO'#DOO'OOdO,59[OOO`'#Da'#DaO'WO!rO,59[O'_Q#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'dO$fO,59oOOO`,59o,59oO'lQ#|O,59qO'qQ#|O,59rOOO`-E7W-E7WO'vQ&rO'#CsOOQW'#DZ'#DZO(UQ&rO1G.wOOOa1G.w1G.wO(^Q&rO1G/QOOOb1G/Q1G/QO(fQ&rO1G/TOOOd1G/T1G/TO(nQ&rO1G/WOOO`1G/W1G/WOOO`1G/Y1G/YO(yQ&rO1G/YOOOa-E7[-E7[O)RQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)WQ#tO'#C|OOOd-E7^-E7^O)]Q#tO'#DPOOO`-E7_-E7_O)bQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O)gQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rOOO`7+$t7+$tO)rQ#|O,59eO)wQ#|O,59hO)|Q#|O,59kOOO`1G/X1G/XO*RO7[O'#CvO*dOMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O*uO7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+WOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: "+s~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OhyO~OS!OOhyO~OS!QOhyO~OS!SOT!TOhyO~OS!TOhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXhgXTgX~OS!fOhyO~OS!gOhyO~OS!hOhyO~OS!iOT!jOhyO~OS!jOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{}!P!R!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!UeZ!e{}!P!R!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: EU,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"]
  ],
  propSources: [NU],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "#%g!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs4ysv-_vw5iwxJ^x}-_}!OKP!O!P-_!P!Q$q!Q![-_![!]!!O!]!^-_!^!_!&W!_!`#$o!`!a&X!a!c-_!c!}!!O!}#R-_#R#S!!O#S#T3V#T#o!!O#o#s-_#s$f$q$f%W-_%W%o!!O%o%p-_%p&a!!O&a&b-_&b1p!!O1p4U-_4U4d!!O4d4e-_4e$IS!!O$IS$I`-_$I`$Ib!!O$Ib$Kh-_$Kh%#t!!O%#t&/x-_&/x&Et!!O&Et&FV-_&FV;'S!!O;'S;:j!&Q;:j;=`4s<%l?&r-_?&r?Ah!!O?Ah?BY$q?BY?Mn!!O?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_1n!_!a&X!a#S-_#S#T3V#T#s-_#s$f$q$f;'S-_;'S;=`4s<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/echSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!^!_0p!a#S/^#S#T0p#T#s/^#s$f+P$f;'S/^;'S;=`1h<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0uXhSqr0psw0px!P0p!Q!_0p!a#s0p$f;'S0p;'S;=`1b<%l?Ah0p?BY?Mn0pS1eP;=`<%l0p[1kP;=`<%l/^!U1wbhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!U3SP;=`<%l1n!V3bchS`P!a`!cpOq&Xqr3Vrs&}sv3Vvw0pwx(tx!P3V!P!Q&X!Q!^3V!^!_1n!_!a&X!a#s3V#s$f&X$f;'S3V;'S;=`4m<%l?Ah3V?Ah?BY&X?BY?Mn3V?MnO&X!V4pP;=`<%l3V!_4vP;=`<%l-_!Z5SV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_5rjhSkWc!ROX7dXZ8qZ[7d[^8q^p7dqr:crs8qst@Ttw:cwx8qx!P:c!P!Q7d!Q!]:c!]!^/^!^!_=p!_!a8q!a#S:c#S#T=p#T#s:c#s$f7d$f;'S:c;'S;=`?}<%l?Ah:c?Ah?BY7d?BY?Mn:c?MnO7d!Z7ibkWOX7dXZ8qZ[7d[^8q^p7dqr7drs8qst+Ptw7dwx8qx!]7d!]!^9f!^!a8q!a#S7d#S#T8q#T;'S7d;'S;=`:]<%lO7d!R8tVOp8qqs8qt!]8q!]!^9Z!^;'S8q;'S;=`9`<%lO8q!R9`Oa!R!R9cP;=`<%l8q!Z9mYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z:`P;=`<%l7d!_:jjhSkWOX7dXZ8qZ[7d[^8q^p7dqr:crs8qst/^tw:cwx8qx!P:c!P!Q7d!Q!]:c!]!^<[!^!_=p!_!a8q!a#S:c#S#T=p#T#s:c#s$f7d$f;'S:c;'S;=`?}<%l?Ah:c?Ah?BY7d?BY?Mn:c?MnO7d!_<echSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!^!_0p!a#S/^#S#T0p#T#s/^#s$f+P$f;'S/^;'S;=`1h<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V=udhSOp8qqr=prs8qst0ptw=pwx8qx!P=p!P!Q8q!Q!]=p!]!^?T!^!_=p!_!a8q!a#s=p#s$f8q$f;'S=p;'S;=`?w<%l?Ah=p?Ah?BY8q?BY?Mn=p?MnO8q!V?[XhSa!Rqr0psw0px!P0p!Q!_0p!a#s0p$f;'S0p;'S;=`1b<%l?Ah0p?BY?Mn0p!V?zP;=`<%l=p!_@QP;=`<%l:c!_@[ihSkWOXAyXZCTZ[Ay[^CT^pAyqrDrrsCTswDrwxCTx!PDr!P!QAy!Q!]Dr!]!^/^!^!_G|!_!aCT!a#SDr#S#TG|#T#sDr#s$fAy$f;'SDr;'S;=`JW<%l?AhDr?Ah?BYAy?BY?MnDr?MnOAy!ZBOakWOXAyXZCTZ[Ay[^CT^pAyqrAyrsCTswAywxCTx!]Ay!]!^Cu!^!aCT!a#SAy#S#TCT#T;'SAy;'S;=`Dl<%lOAy!RCWUOpCTq!]CT!]!^Cj!^;'SCT;'S;=`Co<%lOCT!RCoOb!R!RCrP;=`<%lCT!ZC|YkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZDoP;=`<%lAy!_DyihSkWOXAyXZCTZ[Ay[^CT^pAyqrDrrsCTswDrwxCTx!PDr!P!QAy!Q!]Dr!]!^Fh!^!_G|!_!aCT!a#SDr#S#TG|#T#sDr#s$fAy$f;'SDr;'S;=`JW<%l?AhDr?Ah?BYAy?BY?MnDr?MnOAy!_FqchSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!^!_0p!a#S/^#S#T0p#T#s/^#s$f+P$f;'S/^;'S;=`1h<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VHRchSOpCTqrG|rsCTswG|wxCTx!PG|!P!QCT!Q!]G|!]!^I^!^!_G|!_!aCT!a#sG|#s$fCT$f;'SG|;'S;=`JQ<%l?AhG|?Ah?BYCT?BY?MnG|?MnOCT!VIeXhSb!Rqr0psw0px!P0p!Q!_0p!a#s0p$f;'S0p;'S;=`1b<%l?Ah0p?BY?Mn0p!VJTP;=`<%lG|!_JZP;=`<%lDr!ZJgW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aK^lhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMU!O!P-_!P!Q$q!Q!^-_!^!_1n!_!a&X!a#S-_#S#T3V#T#s-_#s$f$q$f;'S-_;'S;=`4s<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aMckhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_1n!_!`&X!`!a! W!a#S-_#S#T3V#T#s-_#s$f$q$f;'S-_;'S;=`4s<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!T! cX`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!a!!_!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!O!!O!O!P!!O!P!Q$q!Q![!!O![!]!!O!]!^-_!^!_1n!_!a&X!a!c-_!c!}!!O!}#R-_#R#S!!O#S#T3V#T#o!!O#o#s-_#s$f$q$f$}-_$}%O!!O%O%W-_%W%o!!O%o%p-_%p&a!!O&a&b-_&b1p!!O1p4U!!O4U4d!!O4d4e-_4e$IS!!O$IS$I`-_$I`$Ib!!O$Ib$Je-_$Je$Jg!!O$Jg$Kh-_$Kh%#t!!O%#t&/x-_&/x&Et!!O&Et&FV-_&FV;'S!!O;'S;:j!&Q;:j;=`4s<%l?&r-_?&r?Ah!!O?Ah?BY$q?BY?Mn!!O?MnO$q!a!&TP;=`<%l!!O!V!&achS!a`!cpOq*Vqr!'lrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!b!Ey!b#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!'uhhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex}1n}!O!)a!O!P1n!P!Q*V!Q!_1n!_!a*V!a!f1n!f!g!,]!g#W1n#W#X!<y#X#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!)jdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex}1n}!O!*x!O!P1n!P!Q*V!Q!_1n!_!a*V!a#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!+TbhS!a`!cp!dPOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!,fdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!q1n!q!r!-t!r#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!-}dhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!e1n!e!f!/]!f#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!/fdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!v1n!v!w!0t!w#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!0}dhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!{1n!{!|!2]!|#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!2fdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!r1n!r!s!3t!s#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!3}dhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!g1n!g!h!5]!h#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!5fchS!a`!cpOq!6qqr!5]rs!7hsv!5]vw!;`wx!9[x!P!5]!P!Q!6q!Q!_!5]!_!`!6q!`!a!:j!a#s!5]#s$f!6q$f;'S!5];'S;=`!<s<%l?Ah!5]?Ah?BY!6q?BY?Mn!5]?MnO!6q!R!6xY!a`!cpOr!6qrs!7hsv!6qvw!8Swx!9[x!`!6q!`!a!:j!a;'S!6q;'S;=`!;Y<%lO!6qq!7mV!cpOv!7hvx!8Sx!`!7h!`!a!8q!a;'S!7h;'S;=`!9U<%lO!7hP!8VTO!`!8S!`!a!8f!a;'S!8S;'S;=`!8k<%lO!8SP!8kO{PP!8nP;=`<%l!8Sq!8xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!9XP;=`<%l!7ha!9aX!a`Or!9[rs!8Ssv!9[vw!8Sw!`!9[!`!a!9|!a;'S!9[;'S;=`!:d<%lO!9[a!:TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!:gP;=`<%l!9[!R!:sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;]P;=`<%l!6qT!;ebhSOq!8Sqr!;`rs!8Ssw!;`wx!8Sx!P!;`!P!Q!8S!Q!_!;`!_!`!8S!`!a!8f!a#s!;`#s$f!8S$f;'S!;`;'S;=`!<m<%l?Ah!;`?Ah?BY!8S?BY?Mn!;`?MnO!8ST!<pP;=`<%l!;`!V!<vP;=`<%l!5]!V!=SdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#c1n#c#d!>b#d#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!>kdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#V1n#V#W!?y#W#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!@SdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#h1n#h#i!Ab#i#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!AkdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#m1n#m#n!By#n#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!CSdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#d1n#d#e!Db#e#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!DkdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#X1n#X#Y!5]#Y#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!FSchS!a`!cpOq!G_qr!Eyrs!HUsv!Eyvw!Ncwx!Jvx!P!Ey!P!Q!G_!Q!_!Ey!_!a!G_!a!b##T!b#s!Ey#s$f!G_$f;'S!Ey;'S;=`#$i<%l?Ah!Ey?Ah?BY!G_?BY?Mn!Ey?MnO!G_!R!GfY!a`!cpOr!G_rs!HUsv!G_vw!Hpwx!Jvx!a!G_!a!b!Lv!b;'S!G_;'S;=`!N]<%lO!G_q!HZV!cpOv!HUvx!Hpx!a!HU!a!b!Iq!b;'S!HU;'S;=`!Jp<%lO!HUP!HsTO!a!Hp!a!b!IS!b;'S!Hp;'S;=`!Ik<%lO!HpP!IVTO!`!Hp!`!a!If!a;'S!Hp;'S;=`!Ik<%lO!HpP!IkOxPP!InP;=`<%l!Hpq!IvV!cpOv!HUvx!Hpx!`!HU!`!a!J]!a;'S!HU;'S;=`!Jp<%lO!HUq!JdS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!JsP;=`<%l!HUa!J{X!a`Or!Jvrs!Hpsv!Jvvw!Hpw!a!Jv!a!b!Kh!b;'S!Jv;'S;=`!Lp<%lO!Jva!KmX!a`Or!Jvrs!Hpsv!Jvvw!Hpw!`!Jv!`!a!LY!a;'S!Jv;'S;=`!Lp<%lO!Jva!LaT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!LsP;=`<%l!Jv!R!L}Y!a`!cpOr!G_rs!HUsv!G_vw!Hpwx!Jvx!`!G_!`!a!Mm!a;'S!G_;'S;=`!N]<%lO!G_!R!MvV!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!N`P;=`<%l!G_T!NhbhSOq!Hpqr!Ncrs!Hpsw!Ncwx!Hpx!P!Nc!P!Q!Hp!Q!_!Nc!_!a!Hp!a!b# p!b#s!Nc#s$f!Hp$f;'S!Nc;'S;=`#!}<%l?Ah!Nc?Ah?BY!Hp?BY?Mn!Nc?MnO!HpT# ubhSOq!Hpqr!Ncrs!Hpsw!Ncwx!Hpx!P!Nc!P!Q!Hp!Q!_!Nc!_!`!Hp!`!a!If!a#s!Nc#s$f!Hp$f;'S!Nc;'S;=`#!}<%l?Ah!Nc?Ah?BY!Hp?BY?Mn!Nc?MnO!HpT##QP;=`<%l!Nc!V##^chS!a`!cpOq!G_qr!Eyrs!HUsv!Eyvw!Ncwx!Jvx!P!Ey!P!Q!G_!Q!_!Ey!_!`!G_!`!a!Mm!a#s!Ey#s$f!G_$f;'S!Ey;'S;=`#$i<%l?Ah!Ey?Ah?BY!G_?BY?Mn!Ey?MnO!G_!V#$lP;=`<%l!Ey!V#$zXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [LU, DU, MU, GU, jU, IU, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 485 },
  tokenPrec: 487
});
function oX(t, e) {
  let i = /* @__PURE__ */ Object.create(null);
  for (let n of t.getChildren(iX)) {
    let O = n.getChild(xU), r = n.getChild(fd) || n.getChild(nX);
    O && (i[e.read(O.from, O.to)] = r ? r.type.id == fd ? e.read(r.from + 1, r.to - 1) : e.read(r.from, r.to) : "");
  }
  return i;
}
function Am(t, e) {
  let i = t.getChild(XU);
  return i ? e.read(i.from, i.to) : " ";
}
function Qf(t, e, i) {
  let n;
  for (let O of i)
    if (!O.attrs || O.attrs(n || (n = oX(t.node.parent.firstChild, e))))
      return { parser: O.parser };
  return null;
}
function sX(t = [], e = []) {
  let i = [], n = [], O = [], r = [];
  for (let o of t)
    (o.tag == "script" ? i : o.tag == "style" ? n : o.tag == "textarea" ? O : r).push(o);
  let a = e.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let o of e)
    (a[o.name] || (a[o.name] = [])).push(o);
  return Vp((o, s) => {
    var c;
    let l = o.type.id;
    if (l == wU)
      return Qf(o, s, i);
    if (l == TU)
      return Qf(o, s, n);
    if (l == kU)
      return Qf(o, s, O);
    if (l == OX && r.length) {
      let u = o.node, h10 = Am(u, s), d;
      for (let p of r)
        if (p.tag == h10 && (!p.attrs || p.attrs(d || (d = oX(u, s))))) {
          let $ = u.parent.lastChild;
          return { parser: p.parser, overlay: [{ from: o.to, to: $.type.id == _U ? $.from : u.parent.to }] };
        }
    }
    if (a && l == iX) {
      let u = o.node, h10;
      if (h10 = u.firstChild) {
        let d = a[s.read(h10.from, h10.to)];
        if (d)
          for (let p of d) {
            if (p.tagName && p.tagName != Am(u.parent, s))
              continue;
            let $ = u.lastChild;
            if ($.type.id == fd) {
              let g = $.from + 1, Q = $.to - ((c = $.lastChild) != null && c.isError ? 0 : 1);
              if (Q > g)
                return { parser: p.parser, overlay: [{ from: g, to: Q }] };
            } else if ($.type.id == nX)
              return { parser: p.parser, overlay: [{ from: $.from, to: $.to }] };
          }
      }
    }
    return null;
  });
}
var FU = 94;
var Gm = 1;
var HU = 95;
var KU = 96;
var Lm = 2;
var lX = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
];
var JU = 58;
var eV = 40;
var cX = 95;
var tV = 91;
var Zl = 45;
var iV = 46;
var nV = 35;
var OV = 37;
function Qc(t) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t >= 161;
}
function rV(t) {
  return t >= 48 && t <= 57;
}
var aV = new Ie((t, e) => {
  for (let i = false, n = 0, O = 0; ; O++) {
    let { next: r } = t;
    if (Qc(r) || r == Zl || r == cX || i && rV(r))
      !i && (r != Zl || O > 0) && (i = true), n === O && r == Zl && n++, t.advance();
    else {
      i && t.acceptToken(r == eV ? HU : n == 2 && e.canShift(Lm) ? Lm : KU);
      break;
    }
  }
});
var oV = new Ie((t) => {
  if (lX.includes(t.peek(-1))) {
    let { next: e } = t;
    (Qc(e) || e == cX || e == nV || e == iV || e == tV || e == JU || e == Zl) && t.acceptToken(FU);
  }
});
var sV = new Ie((t) => {
  if (!lX.includes(t.peek(-1))) {
    let { next: e } = t;
    if (e == OV && (t.advance(), t.acceptToken(Gm)), Qc(e)) {
      do
        t.advance();
      while (Qc(t.next));
      t.acceptToken(Gm);
    }
  }
});
var lV = ti({
  "AtKeyword import charset namespace keyframes media supports": f.definitionKeyword,
  "from to selector": f.keyword,
  NamespaceName: f.namespace,
  KeyframeName: f.labelName,
  TagName: f.tagName,
  ClassName: f.className,
  PseudoClassName: f.constant(f.className),
  IdName: f.labelName,
  "FeatureName PropertyName": f.propertyName,
  AttributeName: f.attributeName,
  NumberLiteral: f.number,
  KeywordQuery: f.keyword,
  UnaryQueryOp: f.operatorKeyword,
  "CallTag ValueName": f.atom,
  VariableName: f.variableName,
  Callee: f.operatorKeyword,
  Unit: f.unit,
  "UniversalSelector NestingSelector": f.definitionOperator,
  MatchOp: f.compareOperator,
  "ChildOp SiblingOp, LogicOp": f.logicOperator,
  BinOp: f.arithmeticOperator,
  Important: f.modifier,
  Comment: f.blockComment,
  ParenthesizedContent: f.special(f.name),
  ColorLiteral: f.color,
  StringLiteral: f.string,
  ":": f.punctuation,
  "PseudoOp #": f.derefOperator,
  "; ,": f.separator,
  "( )": f.paren,
  "[ ]": f.squareBracket,
  "{ }": f.brace
});
var cV = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, "nth-last-of-type": 32, dir: 32, "host-context": 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 134 };
var uV = { __proto__: null, "@import": 114, "@media": 138, "@charset": 142, "@namespace": 146, "@keyframes": 152, "@supports": 164 };
var fV = { __proto__: null, not: 128, only: 128, from: 158, to: 160 };
var hV = Jt.deserialize({
  version: 14,
  states: "7WQYQ[OOO#_Q[OOOOQP'#Cd'#CdOOQP'#Cc'#CcO#fQ[O'#CfO$YQXO'#CaO$aQ[O'#ChO$lQ[O'#DPO$qQ[O'#DTOOQP'#Ed'#EdO$vQdO'#DeO%bQ[O'#DrO$vQdO'#DtO%sQ[O'#DvO&OQ[O'#DyO&TQ[O'#EPO&cQ[O'#EROOQS'#Ec'#EcOOQS'#ET'#ETQYQ[OOO&jQXO'#CdO'_QWO'#DaO'dQWO'#EjO'oQ[O'#EjQOQWOOOOQP'#Cg'#CgOOQP,59Q,59QO#fQ[O,59QO'yQ[O'#EWO(eQWO,58{O(mQ[O,59SO$lQ[O,59kO$qQ[O,59oO'yQ[O,59sO'yQ[O,59uO'yQ[O,59vO(xQ[O'#D`OOQS,58{,58{OOQP'#Ck'#CkOOQO'#C}'#C}OOQP,59S,59SO)PQWO,59SO)UQWO,59SOOQP'#DR'#DROOQP,59k,59kOOQO'#DV'#DVO)ZQ`O,59oOOQS'#Cp'#CpO$vQdO'#CqO)cQvO'#CsO*pQtO,5:POOQO'#Cx'#CxO)UQWO'#CwO+UQWO'#CyOOQS'#Eg'#EgOOQO'#Dh'#DhO+ZQ[O'#DoO+iQWO'#EkO&TQ[O'#DmO+wQWO'#DpOOQO'#El'#ElO(hQWO,5:^O+|QpO,5:`OOQS'#Dx'#DxO,UQWO,5:bO,ZQ[O,5:bOOQO'#D{'#D{O,cQWO,5:eO,hQWO,5:kO,pQWO,5:mOOQS-E8R-E8RO$vQdO,59{O,xQ[O'#EYO-VQWO,5;UO-VQWO,5;UOOQP1G.l1G.lO-|QXO,5:rOOQO-E8U-E8UOOQS1G.g1G.gOOQP1G.n1G.nO)PQWO1G.nO)UQWO1G.nOOQP1G/V1G/VO.ZQ`O1G/ZO.tQXO1G/_O/[QXO1G/aO/rQXO1G/bO0YQWO,59zO0_Q[O'#DOO0fQdO'#CoOOQP1G/Z1G/ZO$vQdO1G/ZO0mQpO,59]OOQS,59_,59_O$vQdO,59aO0uQWO1G/kOOQS,59c,59cO0zQ!bO,59eO1SQWO'#DhO1_QWO,5:TO1dQWO,5:ZO&TQ[O,5:VO&TQ[O'#EZO1lQWO,5;VO1wQWO,5:XO'yQ[O,5:[OOQS1G/x1G/xOOQS1G/z1G/zOOQS1G/|1G/|O2YQWO1G/|O2_QdO'#D|OOQS1G0P1G0POOQS1G0V1G0VOOQS1G0X1G0XO2mQtO1G/gOOQO,5:t,5:tO3TQ[O,5:tOOQO-E8W-E8WO3bQWO1G0pOOQP7+$Y7+$YOOQP7+$u7+$uO$vQdO7+$uOOQS1G/f1G/fO3mQXO'#EiO3tQWO,59jO3yQtO'#EUO4nQdO'#EfO4xQWO,59ZO4}QpO7+$uOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%V7+%VO5VQWO1G/PO$vQdO1G/oOOQO1G/u1G/uOOQO1G/q1G/qO5[QWO,5:uOOQO-E8X-E8XO5jQXO1G/vOOQS7+%h7+%hO5qQYO'#CsO(hQWO'#E[O5yQdO,5:hOOQS,5:h,5:hO6XQtO'#EXO$vQdO'#EXO7VQdO7+%ROOQO7+%R7+%ROOQO1G0`1G0`O7jQpO<<HaO7rQWO,5;TOOQP1G/U1G/UOOQS-E8S-E8SO$vQdO'#EVO7zQWO,5;QOOQT1G.u1G.uOOQP<<Ha<<HaOOQS7+$k7+$kO8SQdO7+%ZOOQO7+%b7+%bOOQS,5:v,5:vOOQS-E8Y-E8YOOQS1G0S1G0SO8ZQtO,5:sOOQS-E8V-E8VOOQO<<Hm<<HmOOQPAN={AN={O9XQdO,5:qOOQO-E8T-E8TOOQO<<Hu<<Hu",
  stateData: "9i~O#UOSROS~OUXOXXO]UO^UOtVOxWO!Y`O!ZYO!gZO!i[O!k]O!n^O!t_O#SQO#XSO~OQeOUXOXXO]UO^UOtVOxWO!Y`O!ZYO!gZO!i[O!k]O!n^O!t_O#SdO#XSO~O#P#^P~P!ZO#SiO~O]nO^nOplOtoOxpO|qO!PsO#QrO#XkO~O!RtO~P#kO`zO#RwO#SvO~O#S{O~O#S}O~OQ!WOb!QOf!WOh!WOn!VO#R!TO#S!PO#[!RO~Ob!YO!b![O!e!]O#S!XO!R#_P~Oh!bOn!VO#S!aO~O#S!dO~Ob!YO!b![O!e!]O#S!XO~O!W#_P~P%bO]WX]!UX^WXpWXtWXxWX|WX!PWX!RWX#QWX#XWX~O]!iO~O!W!jO#P#^X!Q#^X~O#P#^X!Q#^X~P!ZOUXOXXO]UO^UOtVOxWO#SQO#XSO~OplO!RtO~O`!sO#RwO#SvO~O!Q#^P~P!ZOb!zO~Ob!{O~Ov!|Oz!}O~OP#PObgXjgX!WgX!bgX!egX#SgXagXQgXfgXhgXngXpgX!VgX#PgX#RgX#[gXvgX!QgX~Ob!YOj#QO!b![O!e!]O#S!XO!W#_P~Ob#TO~Ob!YO!b![O!e!]O#S#UO~Op#YO!`#XO!R#_X!W#_X~Ob#]O~Oj#QO!W#_O~O!W#`O~Oh#aOn!VO~O!R#bO~O!RtO!`#XO~O!RtO!W#eO~O!W!|X#P!|X!Q!|X~P!ZO!W!jO#P#^a!Q#^a~O]nO^nOtoOxpO|qO!PsO#QrO#XkO~Op!za!R!zaa!za~P-bOv#lOz#mO~O]nO^nOtoOxpO#XkO~Op{i|{i!P{i!R{i#Q{ia{i~P.cOp}i|}i!P}i!R}i#Q}ia}i~P.cOp!Oi|!Oi!P!Oi!R!Oi#Q!Oia!Oi~P.cO!Q#nO~Oa#]P~P'yOa#YP~P$vOa#uOj#QO~O!W#wO~Oh#xOo#xO~O]!^Xa![X!`![X~O]#yO~Oa#zO!`#XO~Op#YO!R#_a!W#_a~O!`#XOp!aa!R!aa!W!aaa!aa~O!W$PO~O!Q$TO!q$RO!r$RO#[$QO~Oj#QOp$VO!V$XO!W!Ti#P!Ti!Q!Ti~P$vO!W!|a#P!|a!Q!|a~P!ZO!W!jO#P#^i!Q#^i~Oa#]X~P#kOa$]O~Oj#QOQ!xXa!xXb!xXf!xXh!xXn!xXp!xX#R!xX#S!xX#[!xX~Op$_Oa#YX~P$vOa$aO~Oj#QOv$bO~Oa$cO~O!`#XOp!}a!R!}a!W!}a~Oa$eO~P-bOP#PO!RgX~O!Q$hO!q$RO!r$RO#[$QO~Oj#QOQ!{Xb!{Xf!{Xh!{Xn!{Xp!{X!V!{X!W!{X#P!{X#R!{X#S!{X#[!{X!Q!{X~Op$VO!V$kO!W!Tq#P!Tq!Q!Tq~P$vOj#QOv$lO~OplOa#]a~Op$_Oa#Ya~Oa$oO~P$vOj#QOQ!{ab!{af!{ah!{an!{ap!{a!V!{a!W!{a#P!{a#R!{a#S!{a#[!{a!Q!{a~Oa!yap!ya~P$vOo#[j!Pj~",
  goto: ",`#aPPPPP#bP#k#zP#k$Z#kPP$aPPP$g$p$pP%SP$pP$p%j%|PPP&f&l#kP&rP#kP&xP#kP#k#kPPP'O'b'oPP#bPP'v'v(Q'vP'vP'v'vP#bP#bP#bP(T#bP(W(ZPP#bP#bP(^(m({)R)])c)m)sPPPPPP)y*SP*o*rP+h+k+q+z_aOPcgt!j#hkXOPcglqrst!j!z#]#hkROPcglqrst!j!z#]#hQjSR!mkQxUR!qnQ!qzQ#S!UR#k!sq!WY[!Q!i!{!}#Q#f#m#r#y$V$W$_$d$mp!WY[!Q!i!{!}#Q#f#m#r#y$V$W$_$d$mT$R#b$Sq!UY[!Q!i!{!}#Q#f#m#r#y$V$W$_$d$mp!WY[!Q!i!{!}#Q#f#m#r#y$V$W$_$d$mQ!b]R#a!cQyUR!rnQ!qyR#k!rQ|VR!toQ!OWR!upQuTQ!pmQ#^!_Q#d!fQ#e!gR$f$RSfPtQ!lgQ#g!jR$Y#hZePgt!j#ha!^Z_`!S!Y![#X#YR#V!YR!c]R!e^R#c!eQcOSgPtU!hcg#hR#h!jQ#r!{U$^#r$d$mQ$d#yR$m$_Q$`#rR$n$`QmTS!om$[R$[#oQ$W#fR$j$WQ!kfS#i!k#jR#j!lQ#Z!ZR#}#ZQ$S#bR$g$S_bOPcgt!j#h^TOPcgt!j#hQ!nlQ!vqQ!wrQ!xsQ#o!zR$O#]R#s!{Q!SYQ!`[Q#O!QQ#f!i[#q!{#r#y$_$d$mQ#t!}Q#v#QS$U#f$WQ$Z#mR$i$VR#p!zQhPR!ytQ!_ZQ!g`R#R!SU!ZZ`!SQ!f_Q#W!YQ#[![Q#{#XR#|#Y",
  nodeNames: "⚠ Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent , PseudoClassName ArgList IdSelector # IdName ] AttributeSelector [ AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList from to SupportsStatement supports AtRule Styles",
  maxTerm: 108,
  nodeProps: [
    ["openedBy", 17, "(", 48, "{"],
    ["closedBy", 18, ")", 49, "}"]
  ],
  propSources: [lV],
  skippedNodes: [0, 3],
  repeatNodeCount: 8,
  tokenData: "Lq~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Cu![!]Dp!]!^El!^!_$}!_!`E}!`!aF`!a!b$}!b!cG[!c!}$}!}#OHt#O#P$}#P#QIV#Q#R6d#R#T$}#T#UIh#U#c$}#c#dJy#d#o$}#o#pK`#p#q6d#q#rKq#r#sLS#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`Lk<%lO$}W%QSOy%^z;'S%^;'S;=`%o<%lO%^W%cSoWOy%^z;'S%^;'S;=`%o<%lO%^W%rP;=`<%l%^~%zh#U~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#U~oWOX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^^)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^^)sUoWOy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^^*[UoWOy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^^*sUoWOy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^^+[UoWOy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^^+sUoWOy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^^,[UoWOy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^^,sUoWOy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^^-[UoWOy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^^-uS!VUoWOy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.R_/zYtPOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^^0oYoWOy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^^1dYoWOy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^^2ZYfUoWOy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^^3QYfUoWOy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^^3uYoWOy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^^4lYfUoWOy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^^5aYoWOy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^^6WSfUoWOy%^z;'S%^;'S;=`%o<%lO%^Y6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^Y7QSzQoWOy%^z;'S%^;'S;=`%o<%lO%^X7cSXPOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7o_9cSbVOy%^z;'S%^;'S;=`%o<%lO%^~9tOa~_9{UUPjSOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^_:fWjS!PPOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^^;TUoWOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^^;nYoW#[UOy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^^<cYoWOy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^^=WUoWOy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^^=qUoW#[UOy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^^>[[oW#[UOy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^_?VSpVOy%^z;'S%^;'S;=`%o<%lO%^^?hWjSOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^_@VU#XPOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjSOy%^z{@}{;'S%^;'S;=`%o<%lO%^~ASUoWOy@}yzAfz{Bm{;'S@};'S;=`Co<%lO@}~AiTOzAfz{Ax{;'SAf;'S;=`Bg<%lOAf~A{VOzAfz{Ax{!PAf!P!QBb!Q;'SAf;'S;=`Bg<%lOAf~BgOR~~BjP;=`<%lAf~BrWoWOy@}yzAfz{Bm{!P@}!P!QC[!Q;'S@};'S;=`Co<%lO@}~CcSoWR~Oy%^z;'S%^;'S;=`%o<%lO%^~CrP;=`<%l@}^Cz[#[UOy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^XDuU]POy%^z![%^![!]EX!];'S%^;'S;=`%o<%lO%^XE`S^PoWOy%^z;'S%^;'S;=`%o<%lO%^_EqS!WVOy%^z;'S%^;'S;=`%o<%lO%^YFSSzQOy%^z;'S%^;'S;=`%o<%lO%^XFeU|POy%^z!`%^!`!aFw!a;'S%^;'S;=`%o<%lO%^XGOS|PoWOy%^z;'S%^;'S;=`%o<%lO%^XG_WOy%^z!c%^!c!}Gw!}#T%^#T#oGw#o;'S%^;'S;=`%o<%lO%^XHO[!YPoWOy%^z}%^}!OGw!O!Q%^!Q![Gw![!c%^!c!}Gw!}#T%^#T#oGw#o;'S%^;'S;=`%o<%lO%^XHySxPOy%^z;'S%^;'S;=`%o<%lO%^^I[SvUOy%^z;'S%^;'S;=`%o<%lO%^XIkUOy%^z#b%^#b#cI}#c;'S%^;'S;=`%o<%lO%^XJSUoWOy%^z#W%^#W#XJf#X;'S%^;'S;=`%o<%lO%^XJmS!`PoWOy%^z;'S%^;'S;=`%o<%lO%^XJ|UOy%^z#f%^#f#gJf#g;'S%^;'S;=`%o<%lO%^XKeS!RPOy%^z;'S%^;'S;=`%o<%lO%^_KvS!QVOy%^z;'S%^;'S;=`%o<%lO%^ZLXU!PPOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^WLnP;=`<%l$}",
  tokenizers: [oV, sV, aV, 0, 1, 2, 3],
  topRules: { StyleSheet: [0, 4], Styles: [1, 84] },
  specialized: [{ term: 95, get: (t) => cV[t] || -1 }, { term: 56, get: (t) => uV[t] || -1 }, { term: 96, get: (t) => fV[t] || -1 }],
  tokenPrec: 1123
});
var gf = null;
function mf() {
  if (!gf && typeof document == "object" && document.body) {
    let { style: t } = document.body, e = [], i = /* @__PURE__ */ new Set();
    for (let n in t)
      n != "cssText" && n != "cssFloat" && typeof t[n] == "string" && (/[A-Z]/.test(n) && (n = n.replace(/[A-Z]/g, (O) => "-" + O.toLowerCase())), i.has(n) || (e.push(n), i.add(n)));
    gf = e.sort().map((n) => ({ type: "property", label: n }));
  }
  return gf || [];
}
var Dm = [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((t) => ({ type: "class", label: t }));
var Mm = [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((t) => ({ type: "keyword", label: t })).concat([
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((t) => ({ type: "constant", label: t })));
var dV = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((t) => ({ type: "type", label: t }));
var Kn = /^[\w-]*/;
var pV = (t) => {
  let { state: e, pos: i } = t, n = Ye(e).resolveInner(i, -1);
  if (n.name == "PropertyName")
    return { from: n.from, options: mf(), validFor: Kn };
  if (n.name == "ValueName")
    return { from: n.from, options: Mm, validFor: Kn };
  if (n.name == "PseudoClassName")
    return { from: n.from, options: Dm, validFor: Kn };
  if (n.name == "TagName") {
    for (let { parent: a } = n; a; a = a.parent)
      if (a.name == "Block")
        return { from: n.from, options: mf(), validFor: Kn };
    return { from: n.from, options: dV, validFor: Kn };
  }
  if (!t.explicit)
    return null;
  let O = n.resolve(i), r = O.childBefore(i);
  return r && r.name == ":" && O.name == "PseudoClassSelector" ? { from: i, options: Dm, validFor: Kn } : r && r.name == ":" && O.name == "Declaration" || O.name == "ArgList" ? { from: i, options: Mm, validFor: Kn } : O.name == "Block" ? { from: i, options: mf(), validFor: Kn } : null;
};
var gc = Kt.define({
  name: "css",
  parser: hV.configure({
    props: [
      ci.add({
        Declaration: gt()
      }),
      ui.add({
        Block: Mn
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function uX() {
  return new li(gc, gc.data.of({ autocomplete: pV }));
}
var Nm = 301;
var Bm = 1;
var $V = 2;
var Fm = 302;
var QV = 304;
var gV = 305;
var mV = 3;
var SV = 4;
var PV = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
];
var fX = 125;
var yV = 59;
var Hm = 47;
var bV = 42;
var vV = 43;
var XV = 45;
var xV = new lu({
  start: false,
  shift(t, e) {
    return e == mV || e == SV || e == QV ? t : e == gV;
  },
  strict: false
});
var wV = new Ie((t, e) => {
  let { next: i } = t;
  (i == fX || i == -1 || e.context) && e.canShift(Fm) && t.acceptToken(Fm);
}, { contextual: true, fallback: true });
var TV = new Ie((t, e) => {
  let { next: i } = t, n;
  PV.indexOf(i) > -1 || i == Hm && ((n = t.peek(1)) == Hm || n == bV) || i != fX && i != yV && i != -1 && !e.context && e.canShift(Nm) && t.acceptToken(Nm);
}, { contextual: true });
var kV = new Ie((t, e) => {
  let { next: i } = t;
  if ((i == vV || i == XV) && (t.advance(), i == t.next)) {
    t.advance();
    let n = !e.context && e.canShift(Bm);
    t.acceptToken(n ? Bm : $V);
  }
}, { contextual: true });
var _V = ti({
  "get set async static": f.modifier,
  "for while do if else switch try catch finally return throw break continue default case": f.controlKeyword,
  "in of await yield void typeof delete instanceof": f.operatorKeyword,
  "let var const function class extends": f.definitionKeyword,
  "import export from": f.moduleKeyword,
  "with debugger as new": f.keyword,
  TemplateString: f.special(f.string),
  super: f.atom,
  BooleanLiteral: f.bool,
  this: f.self,
  null: f.null,
  Star: f.modifier,
  VariableName: f.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": f.function(f.variableName),
  VariableDefinition: f.definition(f.variableName),
  Label: f.labelName,
  PropertyName: f.propertyName,
  PrivatePropertyName: f.special(f.propertyName),
  "CallExpression/MemberExpression/PropertyName": f.function(f.propertyName),
  "FunctionDeclaration/VariableDefinition": f.function(f.definition(f.variableName)),
  "ClassDeclaration/VariableDefinition": f.definition(f.className),
  PropertyDefinition: f.definition(f.propertyName),
  PrivatePropertyDefinition: f.definition(f.special(f.propertyName)),
  UpdateOp: f.updateOperator,
  LineComment: f.lineComment,
  BlockComment: f.blockComment,
  Number: f.number,
  String: f.string,
  Escape: f.escape,
  ArithOp: f.arithmeticOperator,
  LogicOp: f.logicOperator,
  BitOp: f.bitwiseOperator,
  CompareOp: f.compareOperator,
  RegExp: f.regexp,
  Equals: f.definitionOperator,
  Arrow: f.function(f.punctuation),
  ": Spread": f.punctuation,
  "( )": f.paren,
  "[ ]": f.squareBracket,
  "{ }": f.brace,
  "InterpolationStart InterpolationEnd": f.special(f.brace),
  ".": f.derefOperator,
  ", ;": f.separator,
  "@": f.meta,
  TypeName: f.typeName,
  TypeDefinition: f.definition(f.typeName),
  "type enum interface implements namespace module declare": f.definitionKeyword,
  "abstract global Privacy readonly override": f.modifier,
  "is keyof unique infer": f.operatorKeyword,
  JSXAttributeValue: f.attributeValue,
  JSXText: f.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": f.angleBracket,
  "JSXIdentifier JSXNameSpacedName": f.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": f.attributeName,
  "JSXBuiltin/JSXIdentifier": f.standard(f.tagName)
});
var WV = { __proto__: null, export: 14, as: 19, from: 27, default: 30, async: 35, function: 36, extends: 46, this: 50, true: 58, false: 58, null: 70, void: 74, typeof: 78, super: 96, new: 130, delete: 146, yield: 155, await: 159, class: 164, public: 219, private: 219, protected: 219, readonly: 221, instanceof: 240, satisfies: 243, in: 244, const: 246, import: 278, keyof: 333, unique: 337, infer: 343, is: 379, abstract: 399, implements: 401, type: 403, let: 406, var: 408, interface: 415, enum: 419, namespace: 425, module: 427, declare: 431, global: 435, for: 456, of: 465, while: 468, with: 472, do: 476, if: 480, else: 482, switch: 486, case: 492, try: 498, catch: 502, finally: 506, return: 510, throw: 514, break: 518, continue: 522, debugger: 526 };
var YV = { __proto__: null, async: 117, get: 119, set: 121, public: 181, private: 181, protected: 181, static: 183, abstract: 185, override: 187, readonly: 193, accessor: 195, new: 383 };
var RV = { __proto__: null, "<": 137 };
var ZV = Jt.deserialize({
  version: 14,
  states: "$BhO`QUOOO%QQUOOO'TQWOOP(_OSOOO*mQ(CjO'#CfO*tOpO'#CgO+SO!bO'#CgO+bO07`O'#DZO-sQUO'#DaO.TQUO'#DlO%QQUO'#DvO0[QUO'#EOOOQ(CY'#EW'#EWO0rQSO'#ETOOQO'#I_'#I_O0zQSO'#GjOOQO'#Eh'#EhO1VQSO'#EgO1[QSO'#EgO3^Q(CjO'#JbO5}Q(CjO'#JcO6kQSO'#FVO6pQ#tO'#FnOOQ(CY'#F_'#F_O6{O&jO'#F_O7ZQ,UO'#FuO8qQSO'#FtOOQ(CY'#Jc'#JcOOQ(CW'#Jb'#JbOOQQ'#J|'#J|O8vQSO'#IOO8{Q(C[O'#IPOOQQ'#JO'#JOOOQQ'#IT'#ITQ`QUOOO%QQUO'#DnO9TQUO'#DzO%QQUO'#D|O9[QSO'#GjO9aQ,UO'#ClO9oQSO'#EfO9zQSO'#EqO:PQ,UO'#F^O:nQSO'#GjO:sQSO'#GnO;OQSO'#GnO;^QSO'#GqO;^QSO'#GrO;^QSO'#GtO9[QSO'#GwO;}QSO'#GzO=`QSO'#CbO=pQSO'#HXO=xQSO'#H_O=xQSO'#HaO`QUO'#HcO=xQSO'#HeO=xQSO'#HhO=}QSO'#HnO>SQ(C]O'#HtO%QQUO'#HvO>_Q(C]O'#HxO>jQ(C]O'#HzO8{Q(C[O'#H|O>uQ(CjO'#CfO?wQWO'#DfQOQSOOO@_QSO'#EPO9aQ,UO'#EfO@jQSO'#EfO@uQ`O'#F^OOQQ'#Cd'#CdOOQ(CW'#Dk'#DkOOQ(CW'#Jf'#JfO%QQUO'#JfOBOQWO'#E_OOQ(CW'#E^'#E^OBYQ(C`O'#E_OBtQWO'#ESOOQO'#Ji'#JiOCYQWO'#ESOCgQWO'#E_OC}QWO'#EeODQQWO'#E_O@}QWO'#E_OBtQWO'#E_PDkO?MpO'#C`POOO)CDm)CDmOOOO'#IU'#IUODvOpO,59ROOQ(CY,59R,59ROOOO'#IV'#IVOEUO!bO,59RO%QQUO'#D]OOOO'#IX'#IXOEdO07`O,59uOOQ(CY,59u,59uOErQUO'#IYOFVQSO'#JdOHXQbO'#JdO+pQUO'#JdOH`QSO,59{OHvQSO'#EhOITQSO'#JqOI`QSO'#JpOI`QSO'#JpOIhQSO,5;UOImQSO'#JoOOQ(CY,5:W,5:WOItQUO,5:WOKuQ(CjO,5:bOLfQSO,5:jOLkQSO'#JmOMeQ(C[O'#JnO:sQSO'#JmOMlQSO'#JmOMtQSO,5;TOMyQSO'#JmOOQ(CY'#Cf'#CfO%QQUO'#EOONmQ`O,5:oOOQO'#Jj'#JjOOQO-E<]-E<]O9[QSO,5=UO! TQSO,5=UO! YQUO,5;RO!#]Q,UO'#EcO!$pQSO,5;RO!&YQ,UO'#DpO!&aQUO'#DuO!&kQWO,5;[O!&sQWO,5;[O%QQUO,5;[OOQQ'#E}'#E}OOQQ'#FP'#FPO%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]OOQQ'#FT'#FTO!'RQUO,5;nOOQ(CY,5;s,5;sOOQ(CY,5;t,5;tO!)UQSO,5;tOOQ(CY,5;u,5;uO%QQUO'#IeO!)^Q(C[O,5<bO!#]Q,UO,5;]O!){Q,UO,5;]O%QQUO,5;qO!*SQ#tO'#FdO!+PQ#tO'#JuO!*kQ#tO'#JuO!+WQ#tO'#JuOOQO'#Ju'#JuO!+lQ#tO,5;|OOOO,5<Y,5<YO!+}QUO'#FpOOOO'#Id'#IdO6{O&jO,5;yO!,UQ#tO'#FrOOQ(CY,5;y,5;yO!,uQ7[O'#CrOOQ(CY'#Cv'#CvO!-YQSO'#CvO!-_O07`O'#CzO!-{Q,UO,5<_O!.SQSO,5<aO!/iQMhO'#GPO!/vQSO'#GQO!/{QSO'#GQO!0QQMhO'#GUO!1PQWO'#GYO!1rQ7[O'#J]OOQ(CY'#J]'#J]O!1|QSO'#J[O!2[QSO'#JZO!2dQSO'#CqOOQ(CY'#Ct'#CtOOQ(CY'#DO'#DOOOQ(CY'#DQ'#DQO0uQSO'#DSO!$uQ,UO'#FwO!$uQ,UO'#FyO!2lQSO'#F{O!2qQSO'#F|O!/{QSO'#GSO!$uQ,UO'#GXO!2vQSO'#EiO!3bQSO,5<`O`QUO,5>jOOQQ'#JW'#JWOOQQ,5>k,5>kOOQQ-E<R-E<RO!5aQ(CjO,5:YO!7}Q(CjO,5:fO%QQUO,5:fO!:hQ(CjO,5:hOOQ(CW'#Co'#CoO!;XQ,UO,5=UO!;gQ(C[O'#JXO8qQSO'#JXO=}QSO,59WO!;xQWO,59WO!<QQ,UO,59WO9aQ,UO,59WO!<]QSO,5;RO!<eQSO'#HWO!<vQSO'#KQO%QQUO,5;vO!=OQWO,5;xO!=TQSO,5=qO!=YQSO,5=qO!=_QSO,5=qO8{Q(C[O,5=qO!=mQSO'#EjO!>gQWO'#EkOOQ(CW'#Jo'#JoO!>nQ(C[O'#J}O8{Q(C[O,5=YO;^QSO,5=`OOQO'#Cr'#CrO!>yQWO,5=]O!?RQ,UO,5=^O!?^QSO,5=`O!?cQ`O,5=cO=}QSO'#G|O9[QSO'#HOO!?kQSO'#HOO9aQ,UO'#HRO!?pQSO'#HROOQQ,5=f,5=fO!?uQSO'#HSO!?}QSO'#ClO!@SQSO,58|O!@^QSO,58|O!BfQUO,58|OOQQ,58|,58|O!BsQ(C[O,58|O%QQUO,58|O!COQUO'#HZOOQQ'#H['#H[OOQQ'#H]'#H]O`QUO,5=sO!C`QSO,5=sO`QUO,5=yO`QUO,5={O!CeQSO,5=}O`QUO,5>PO!CjQSO,5>SO!CoQUO,5>YOOQQ,5>`,5>`O%QQUO,5>`O8{Q(C[O,5>bOOQQ,5>d,5>dO!GvQSO,5>dOOQQ,5>f,5>fO!GvQSO,5>fOOQQ,5>h,5>hO!G{QWO'#DXO%QQUO'#JfO!HjQWO'#JfO!IXQWO'#DgO!IjQWO'#DgO!K{QUO'#DgO!LSQSO'#JeO!L[QSO,5:QO!LaQSO'#ElO!LoQSO'#JrO!LwQSO,5;VO!L|QWO'#DgO!MZQWO'#EROOQ(CY,5:k,5:kO%QQUO,5:kO!MbQSO,5:kO=}QSO,5;QO!;xQWO,5;QO!<QQ,UO,5;QO9aQ,UO,5;QO!MjQSO,5@QO!MoQ!LQO,5:oO!NrQ(C`O,5:yOBtQWO,5:nO# ^QWO,5:nO# kQWO,5:yO#!RQWO,5:yO#!lQWO,5:yOBtQWO,5:yO=}QSO,5:nOOQ(CW'#Eb'#EbOOQO,5:y,5:yO%QQUO,5:yO##]Q(C[O,5:yO##hQ(C[O,5:yO!;xQWO,5:nOOQO,5;P,5;PO##vQ(C[O,5:yPOOO'#IS'#ISP#$[O?MpO,58zPOOO,58z,58zOOOO-E<S-E<SOOQ(CY1G.m1G.mOOOO-E<T-E<TO#$gQ`O,59wOOOO-E<V-E<VOOQ(CY1G/a1G/aO#$lQbO,5>tO+pQUO,5>tOOQO,5>z,5>zO#$vQUO'#IYOOQO-E<W-E<WO#%TQSO,5@OO#%]QbO,5@OO#%dQSO,5@[OOQ(CY1G/g1G/gO%QQUO,5@]O#%lQSO'#I`OOQO-E<^-E<^O#%dQSO,5@[OOQ(CW1G0p1G0pOOQ(CY1G/r1G/rOOQ(CY1G0U1G0UO#&QQSO,5@XO:sQSO,5@XO#&YQSO,5@XO%QQUO,5@YO#&hQ(C[O,5@YO#&yQ(C[O,5@YO#'QQSO'#IbO#&QQSO,5@XOOQ(CW1G0o1G0oO!&kQWO,5:qO!&vQWO,5:qOOQO,5:s,5:sO#'oQSO,5:sO#'wQ,UO1G2pO9[QSO1G2pOOQ(CY1G0m1G0mO#(VQ(CjO1G0mO#)[Q(ChO,5:}OOQ(CY'#GO'#GOO#)xQ(CjO'#J]O! YQUO1G0mO#,QQ,UO'#JgO#,[QSO,5:[O#,aQbO'#JhO%QQUO'#JhO#,kQSO,5:aOOQ(CY'#DX'#DXOOQ(CY1G0v1G0vO%QQUO1G0vOOQ(CY1G1`1G1`O#,pQSO1G0vO#/XQ(CjO1G0wO#/`Q(CjO1G0wO#1yQ(CjO1G0wO#2QQ(CjO1G0wO#4[Q(CjO1G0wO#4rQ(CjO1G0wO#7lQ(CjO1G0wO#7sQ(CjO1G0wO#:^Q(CjO1G0wO#:eQ(CjO1G0wO#<]Q(CjO1G0wO#?]Q$IUO'#CfO#AZQ$IUO1G1YO#CXQ$IUO'#JcO!)XQSO1G1`O#ClQ(CjO,5?POOQ(CW-E<c-E<cO#D`Q(CjO1G0wOOQ(CY1G0w1G0wO#FkQ(CjO1G1]O#G_Q#tO,5<QO#GgQ#tO,5<RO#GoQ#tO'#FiO#HWQSO'#FhOOQO'#Jv'#JvOOQO'#Ic'#IcO#H]Q#tO1G1hOOQ(CY1G1h1G1hOOOO1G1s1G1sO#HnQ$IUO'#JbO#HxQSO,5<[O!'RQUO,5<[OOOO-E<b-E<bOOQ(CY1G1e1G1eO#H}QWO'#JuOOQ(CY,5<^,5<^O#IVQWO,5<^OOQ(CY,59b,59bO!#]Q,UO'#C|OOOO'#IW'#IWO#I[O07`O,59fOOQ(CY,59f,59fO%QQUO1G1yO!2qQSO'#IgO#IgQSO,5<rOOQ(CY,5<o,5<oOOQO'#Ge'#GeO!$uQ,UO,5=OOOQO'#Gg'#GgO!$uQ,UO,5=QO!#]Q,UO,5=SOOQO1G1{1G1{O#IuQ`O'#CoO#JYQ`O,5<kO#JaQSO'#JyO9[QSO'#JyO#JoQSO,5<mO!$uQ,UO,5<lO#JtQSO'#GRO#KPQSO,5<lO#KUQ`O'#GOO#KcQ`O'#JzO#KmQSO'#JzO!#]Q,UO'#JzO#KrQSO,5<pO#KwQWO'#GZO!0zQWO'#GZO#LYQSO'#G]O#L_QSO'#G_O!/{QSO'#GbO#LdQ(C[O'#IiO#LoQWO,5<tOOQ(CY,5<t,5<tO#LvQWO'#GZO#MUQWO'#G[O#M^QWO'#G[OOQ(CY,5=T,5=TO!$uQ,UO,5?vO!$uQ,UO,5?vO#McQSO'#IjO#MnQSO,5?uO#MvQSO,59]O#NgQ,UO,59nOOQ(CY,59n,59nO$ YQ,UO,5<cO$ {Q,UO,5<eO?oQSO,5<gOOQ(CY,5<h,5<hO$!VQSO,5<nO$![Q,UO,5<sO! YQUO1G1zO$!lQSO1G1zOOQQ1G4U1G4UOOQ(CY1G/t1G/tO!)UQSO1G/tO$$kQ(CjO1G0QOOQQ1G2p1G2pO!#]Q,UO1G2pO%QQUO1G2pO$%[QSO1G2pO$%gQ,UO'#EcOOQ(CW,5?s,5?sO$%qQ(C[O,5?sOOQQ1G.r1G.rO=}QSO1G.rO!;xQWO1G.rO!<QQ,UO1G.rO$&SQSO1G0mO$&XQSO'#CfO$&dQSO'#KRO$&lQSO,5=rO$&qQSO'#KRO$&vQSO'#KRO$'RQSO'#IrO$'aQSO,5@lO$'iQbO1G1bOOQ(CY1G1d1G1dO9[QSO1G3]O?oQSO1G3]O$'pQSO1G3]O$'uQSO1G3]OOQQ1G3]1G3]O:sQSO'#JpO:sQSO'#ElO%QQUO'#ElO:sQSO'#IlO$'zQ(C[O,5@iOOQQ1G2t1G2tO!?^QSO1G2zO!#]Q,UO1G2wO$(VQSO1G2wOOQQ1G2x1G2xO!#]Q,UO1G2xO$([QSO1G2xO$(dQWO'#GvOOQQ1G2z1G2zO!0zQWO'#InO!?cQ`O1G2}OOQQ1G2}1G2}OOQQ,5=h,5=hO$(lQ,UO,5=jO9[QSO,5=jO#L_QSO,5=mO8qQSO,5=mO!;xQWO,5=mO!<QQ,UO,5=mO9aQ,UO,5=mO$(zQSO'#KPO$)VQSO,5=nOOQQ1G.h1G.hO$)[Q(C[O1G.hO?oQSO1G.hO$)gQSO1G.hO8{Q(C[O1G.hO$)rQbO,5@nO$*VQSO,5@nO$*bQUO,5=uO$*iQSO,5=uO:sQSO,5@nOOQQ1G3_1G3_O`QUO1G3_OOQQ1G3e1G3eOOQQ1G3g1G3gO=xQSO1G3iO$*nQUO1G3kO$.oQUO'#HjOOQQ1G3n1G3nO$.|QSO'#HpO=}QSO'#HrOOQQ1G3t1G3tO$/UQUO1G3tO8{Q(C[O1G3zOOQQ1G3|1G3|OOQ(CW'#GV'#GVO8{Q(C[O1G4OO8{Q(C[O1G4QO$3YQSO,5@QO!'RQUO,5;WO:sQSO,5;WO=}QSO,5:RO!'RQUO,5:RO!;xQWO,5:RO$3_Q$IUO,5:ROOQO,5;W,5;WO$3iQWO'#IZO$4PQSO,5@POOQ(CY1G/l1G/lO$4XQWO'#IaO$4cQSO,5@^OOQ(CW1G0q1G0qO!IjQWO,5:ROOQO'#I^'#I^O$4kQWO,5:mOOQ(CY,5:m,5:mO!MeQSO1G0VOOQ(CY1G0V1G0VO%QQUO1G0VOOQ(CY1G0l1G0lO=}QSO1G0lO!;xQWO1G0lO!<QQ,UO1G0lOOQ(CW1G5l1G5lO=}QSO1G0YOOQO1G0e1G0eO%QQUO1G0eO$4rQ(C[O1G0eO$4}Q(C[O1G0eO!;xQWO1G0YOBtQWO1G0YO$5]Q(C`O1G0eO$5wQWO1G0YOBtQWO1G0eO$6UQWO1G0eO$6lQWO1G0eO$7VQ(C[O1G0eOOQO1G0Y1G0YO$7kQ(CjO1G0ePOOO-E<Q-E<QPOOO1G.f1G.fOOOO1G/c1G/cO$7uQ`O,5<bO$7}QbO1G4`OOQO1G4f1G4fO%QQUO,5>tO$8XQSO1G5jO$8aQSO1G5vO$8iQbO1G5wO:sQSO,5>zO$8sQSO1G5sO$8sQSO1G5sO:sQSO1G5sO$8{Q(CjO1G5tO%QQUO1G5tO$9]Q(C[O1G5tO$9nQSO,5>|O:sQSO,5>|OOQO,5>|,5>|O$:SQSO,5>|OOQO-E<`-E<`OOQO1G0]1G0]OOQO1G0_1G0_O!)XQSO1G0_OOQQ7+([7+([O!#]Q,UO7+([O%QQUO7+([O$:bQSO7+([O$:mQ,UO7+([O$:{Q(CjO,59nO$=TQ(CjO,5<cO$?`Q(CjO,5<eO$AkQ(CjO,5<sOOQ(CY7+&X7+&XO$C|Q(CjO7+&XO$DpQ,UO'#I[O$DzQSO,5@ROOQ(CY1G/v1G/vO$ESQUO'#I]O$EaQSO,5@SO$EiQbO,5@SOOQ(CY1G/{1G/{O$EsQSO7+&bOOQ(CY7+&b7+&bO$ExQ$IUO,5:bO%QQUO7+&tO$FSQ$IUO,5:YO$FaQ$IUO,5:fO$FkQ$IUO,5:hOOQ(CY7+&z7+&zOOQO1G1l1G1lOOQO1G1m1G1mO$FuQ#tO,5<TO!'RQUO,5<SOOQO-E<a-E<aOOQ(CY7+'S7+'SOOOO7+'_7+'_OOOO1G1v1G1vO$GQQSO1G1vOOQ(CY1G1x1G1xO$GVQ`O,59hOOOO-E<U-E<UOOQ(CY1G/Q1G/QO$G^Q(CjO7+'eOOQ(CY,5?R,5?RO$HQQSO,5?ROOQ(CY1G2^1G2^P$HVQSO'#IgPOQ(CY-E<e-E<eO$HyQ,UO1G2jO$IlQ,UO1G2lO$IvQ`O1G2nOOQ(CY1G2V1G2VO$I}QSO'#IfO$J]QSO,5@eO$J]QSO,5@eO$JeQSO,5@eO$JpQSO,5@eOOQO1G2X1G2XO$KOQ,UO1G2WO!$uQ,UO1G2WO$K`QMhO'#IhO$KpQSO,5@fO!#]Q,UO,5@fO$KxQ`O,5@fOOQ(CY1G2[1G2[OOQ(CW,5<u,5<uOOQ(CW,5<v,5<vO$LSQSO,5<vOBoQSO,5<vO!;xQWO,5<uOOQO'#G^'#G^O$LXQSO,5<wOOQ(CW,5<y,5<yO$LSQSO,5<|OOQO,5?T,5?TOOQO-E<g-E<gOOQ(CY1G2`1G2`O!0zQWO,5<uO$LaQSO,5<vO#LYQSO,5<wO!0zQWO,5<vO$LlQ,UO1G5bO$LvQ,UO1G5bOOQO,5?U,5?UOOQO-E<h-E<hOOQO1G.w1G.wO!=OQWO,59pO%QQUO,59pO$MTQSO1G2RO!$uQ,UO1G2YO$MYQ(CjO7+'fOOQ(CY7+'f7+'fO! YQUO7+'fOOQ(CY7+%`7+%`O$M|Q`O'#J{O!MeQSO7+([O$NWQbO7+([O$:eQSO7+([O$N_Q(ChO'#CfO$NrQ(ChO,5<zO% dQSO,5<zOOQ(CW1G5_1G5_OOQQ7+$^7+$^O=}QSO7+$^O!;xQWO7+$^O! YQUO7+&XO% iQSO'#IqO% }QSO,5@mOOQO1G3^1G3^O9[QSO,5@mO% }QSO,5@mO%!VQSO,5@mOOQO,5?^,5?^OOQO-E<p-E<pOOQ(CY7+&|7+&|O%![QSO7+(wO8{Q(C[O7+(wO9[QSO7+(wO?oQSO7+(wO%!aQSO,5;WOOQ(CW,5?W,5?WOOQ(CW-E<j-E<jOOQQ7+(f7+(fO%!fQ(ChO7+(cO!#]Q,UO7+(cO%!pQ`O7+(dOOQQ7+(d7+(dO!#]Q,UO7+(dO%!wQSO'#KOO%#SQSO,5=bOOQO,5?Y,5?YOOQO-E<l-E<lOOQQ7+(i7+(iO%$`QWO'#HPOOQQ1G3U1G3UO!#]Q,UO1G3UO%QQUO1G3UO%$gQSO1G3UO%$rQ,UO1G3UO8{Q(C[O1G3XO#L_QSO1G3XO8qQSO1G3XO!;xQWO1G3XO!<QQ,UO1G3XO%%QQSO'#IpO%%]QSO,5@kO%%eQWO,5@kOOQ(CW1G3Y1G3YOOQQ7+$S7+$SO?oQSO7+$SO8{Q(C[O7+$SO%%pQSO7+$SO%QQUO1G6YO%QQUO1G6ZO%%uQUO1G3aO%%|QSO1G3aO%&RQUO1G3aO%&YQ(C[O1G6YOOQQ7+(y7+(yO8{Q(C[O7+)TO`QUO7+)VOOQQ'#KU'#KUOOQQ'#Is'#IsO%&dQUO,5>UOOQQ,5>U,5>UO%QQUO'#HkO%&qQSO'#HmOOQQ,5>[,5>[O:sQSO,5>[OOQQ,5>^,5>^OOQQ7+)`7+)`OOQQ7+)f7+)fOOQQ7+)j7+)jOOQQ7+)l7+)lO%&vQWO1G5lO%'[Q$IUO1G0rO%'fQSO1G0rOOQO1G/m1G/mO%'qQ$IUO1G/mO=}QSO1G/mO!'RQUO'#DgOOQO,5>u,5>uOOQO-E<X-E<XOOQO,5>{,5>{OOQO-E<_-E<_O!;xQWO1G/mOOQO-E<[-E<[OOQ(CY1G0X1G0XOOQ(CY7+%q7+%qO!MeQSO7+%qOOQ(CY7+&W7+&WO=}QSO7+&WO!;xQWO7+&WOOQO7+%t7+%tO$7kQ(CjO7+&POOQO7+&P7+&PO%QQUO7+&PO%'{Q(C[O7+&PO=}QSO7+%tO!;xQWO7+%tO%(WQ(C[O7+&POBtQWO7+%tO%(fQ(C[O7+&PO%(zQ(C`O7+&PO%)UQWO7+%tOBtQWO7+&PO%)cQWO7+&PO%)yQSO7++_O%)yQSO7++_O%*RQ(CjO7++`O%QQUO7++`OOQO1G4h1G4hO:sQSO1G4hO%*cQSO1G4hOOQO7+%y7+%yO!MeQSO<<KvO$NWQbO<<KvO%*qQSO<<KvOOQQ<<Kv<<KvO!#]Q,UO<<KvO%QQUO<<KvO%*yQSO<<KvO%+UQ(CjO1G2jO%-aQ(CjO1G2lO%/lQ(CjO1G2WO%1}Q,UO,5>vOOQO-E<Y-E<YO%2XQbO,5>wO%QQUO,5>wOOQO-E<Z-E<ZO%2cQSO1G5nOOQ(CY<<I|<<I|O%2kQ$IUO1G0mO%4uQ$IUO1G0wO%4|Q$IUO1G0wO%7QQ$IUO1G0wO%7XQ$IUO1G0wO%8|Q$IUO1G0wO%9dQ$IUO1G0wO%;wQ$IUO1G0wO%<OQ$IUO1G0wO%>SQ$IUO1G0wO%>ZQ$IUO1G0wO%@RQ$IUO1G0wO%@fQ(CjO<<J`O%AkQ$IUO1G0wO%CaQ$IUO'#J]O%EdQ$IUO1G1]O%EqQ$IUO1G0QO!'RQUO'#FkOOQO'#Jw'#JwOOQO1G1o1G1oO%E{QSO1G1nO%FQQ$IUO,5?POOOO7+'b7+'bOOOO1G/S1G/SOOQ(CY1G4m1G4mO!$uQ,UO7+(YO%F[QSO,5?QO9[QSO,5?QOOQO-E<d-E<dO%FjQSO1G6PO%FjQSO1G6PO%FrQSO1G6PO%F}Q,UO7+'rO%G_Q`O,5?SO%GiQSO,5?SO!#]Q,UO,5?SOOQO-E<f-E<fO%GnQ`O1G6QO%GxQSO1G6QOOQ(CW1G2b1G2bO$LSQSO1G2bOOQ(CW1G2a1G2aO%HQQSO1G2cO!#]Q,UO1G2cOOQ(CW1G2h1G2hO!;xQWO1G2aOBoQSO1G2bO%HVQSO1G2cO%H_QSO1G2bO!$uQ,UO7+*|OOQ(CY1G/[1G/[O%HjQSO1G/[OOQ(CY7+'m7+'mO%HoQ,UO7+'tO%IPQ(CjO<<KQOOQ(CY<<KQ<<KQO!#]Q,UO'#IkO%IsQSO,5@gO!#]Q,UO1G2fOOQQ<<Gx<<GxO=}QSO<<GxO%I{Q(CjO<<IsOOQ(CY<<Is<<IsOOQO,5?],5?]O%JoQSO,5?]O$&vQSO,5?]OOQO-E<o-E<oO%JtQSO1G6XO%JtQSO1G6XO9[QSO1G6XO?oQSO<<LcOOQQ<<Lc<<LcO%J|QSO<<LcO8{Q(C[O<<LcO%KRQSO1G0rOOQQ<<K}<<K}O%!fQ(ChO<<K}OOQQ<<LO<<LOO%!pQ`O<<LOO%KWQWO'#ImO%KcQSO,5@jO!'RQUO,5@jOOQQ1G2|1G2|O%KkQ(C`O'#JfO%LVQUO'#JfO%L^QWO'#E_O%LwQ(C[O'#E_OBYQ(C`O'#E_O(VQWO'#HQOOQO'#Io'#IoO8{Q(C[O'#IoO%M]QWO,5=kOOQQ,5=k,5=kO%MuQWO'#E_O%LmQWO'#E_O%M|QWO'#E_O%NgQWO'#E_O& WQWO'#HQO& iQSO7+(pO& nQSO7+(pOOQQ7+(p7+(pO!#]Q,UO7+(pO%QQUO7+(pO& vQSO7+(pOOQQ7+(s7+(sO8{Q(C[O7+(sO#L_QSO7+(sO8qQSO7+(sO!;xQWO7+(sO&!RQSO,5?[OOQO-E<n-E<nOOQO'#HT'#HTO&!^QSO1G6VO8{Q(C[O<<GnOOQQ<<Gn<<GnO?oQSO<<GnO&!fQSO7++tO&!kQSO7++uOOQQ7+({7+({O&!pQSO7+({O&!uQUO7+({O&!|QSO7+({O%QQUO7++tO%QQUO7++uOOQQ<<Lo<<LoOOQQ<<Lq<<LqOOQQ-E<q-E<qOOQQ1G3p1G3pO&#RQSO,5>VOOQQ,5>X,5>XO&#WQSO1G3vO:sQSO7+&^O!'RQUO7+&^OOQO7+%X7+%XO&#]Q$IUO1G5wO=}QSO7+%XOOQ(CY<<I]<<I]OOQ(CY<<Ir<<IrO=}QSO<<IrOOQO<<Ik<<IkO$7kQ(CjO<<IkO%QQUO<<IkOOQO<<I`<<I`O=}QSO<<I`O&#gQ(C[O<<IkO!;xQWO<<I`O&#rQ(C[O<<IkOBtQWO<<I`O&$QQ(C[O<<IkO&$fQ(C`O<<IkO&$pQWO<<I`OBtQWO<<IkO&$}QSO<<NyO&%VQ(CjO<<NzOOQO7+*S7+*SO:sQSO7+*SOOQQANAbANAbO&%gQSOANAbO!#]Q,UOANAbO!MeQSOANAbO$NWQbOANAbO%QQUOANAbO&%oQ(CjO7+'rO&(QQ(CjO7+'tO&*cQbO1G4cO&*mQ$IUO7+&XO&*zQ$IUO,59nO&,}Q$IUO,5<cO&/QQ$IUO,5<eO&1TQ$IUO,5<sO&2yQ$IUO7+'eO&3WQ$IUO7+'fO&3eQSO,5<VOOQO7+'Y7+'YO&3jQ,UO<<KtOOQO1G4l1G4lO&3qQSO1G4lO&3|QSO1G4lO&4[QSO7++kO&4[QSO7++kO!#]Q,UO1G4nO&4dQ`O1G4nO&4nQSO7++lOOQ(CW7+'|7+'|O$LSQSO7+'}O&4vQ`O7+'}OOQ(CW7+'{7+'{O$LSQSO7+'|O&4}QSO7+'}O!#]Q,UO7+'}OBoQSO7+'|O&5SQ,UO<<NhOOQ(CY7+$v7+$vO&5^Q`O,5?VOOQO-E<i-E<iO&5hQ(ChO7+(QOOQQAN=dAN=dO9[QSO1G4wOOQO1G4w1G4wO&5xQSO1G4wO&5}QSO7++sO&5}QSO7++sO8{Q(C[OANA}O?oQSOANA}OOQQANA}ANA}OOQQANAiANAiOOQQANAjANAjO&6VQSO,5?XOOQO-E<k-E<kO&6bQ$IUO1G6UO#L_QSO,5=lO8qQSO,5=lO&8rQbO'#CfO&8|QWO,5:yO&9WQWO,5:yO&9eQWO,5:yO!;xQWO,5=lOOQO,5?Z,5?ZOOQO-E<m-E<mOOQQ1G3V1G3VO%LVQUO,5<wO%KkQ(C`O,5=lO!NrQ(C`O,5:yO(VQWO,5=lO&9xQWO,5=lO&:ZQWO,5:yOOQQ<<L[<<L[O!#]Q,UO<<L[O& iQSO<<L[O&:tQSO<<L[O%QQUO<<L[OOQQ<<L_<<L_O8{Q(C[O<<L_O#L_QSO<<L_O8qQSO<<L_O&:|QWO1G4vO&;XQSO7++qOOQQAN=YAN=YO8{Q(C[OAN=YOOQQ<= `<= `OOQQ<= a<= aOOQQ<<Lg<<LgO&;aQSO<<LgO&;fQUO<<LgO&;mQSO<= `O&;rQSO<= aOOQQ1G3q1G3qO=}QSO7+)bO&;wQSO<<IxO&<SQ$IUO<<IxOOQO<<Hs<<HsOOQ(CYAN?^AN?^OOQOAN?VAN?VO$7kQ(CjOAN?VOOQOAN>zAN>zO%QQUOAN?VO=}QSOAN>zO&<^Q(C[OAN?VO!;xQWOAN>zO&<iQ(C[OAN?VOBtQWOAN>zO&<wQ(C[OAN?VOOQO<<Mn<<MnOOQQG26|G26|O!#]Q,UOG26|O!MeQSOG26|O&=]QSOG26|O$NWQbOG26|O&=eQ$IUO<<J`O&=rQ$IUO1G2WO&?hQ$IUO1G2jO&AkQ$IUO1G2lO&CnQ$IUO<<KQO&C{Q$IUO<<IsOOQO1G1q1G1qO!$uQ,UOANA`OOQO7+*W7+*WO&DYQSO7+*WO&DeQSO<= VO&DmQ`O7+*YOOQ(CW<<Ki<<KiO$LSQSO<<KiOOQ(CW<<Kh<<KhO&DwQ`O<<KiO$LSQSO<<KhOOQO7+*c7+*cO9[QSO7+*cO&EOQSO<= _OOQQG27iG27iO8{Q(C[OG27iO!'RQUO1G4sO&EWQSO7++pO8{Q(C[O1G3WO#L_QSO1G3WO&E`QWO1G0eO&EjQWO1G0eO8qQSO1G3WO!;xQWO1G3WO(VQWO1G3WO%KkQ(C`O1G3WO$5]Q(C`O1G0eO&EwQWO1G3WO& iQSOANAvOOQQANAvANAvO!#]Q,UOANAvO&FYQSOANAvOOQQANAyANAyO8{Q(C[OANAyO#L_QSOANAyOOQO'#HU'#HUOOQO7+*b7+*bOOQQG22tG22tOOQQANBRANBRO&FbQSOANBROOQQANDzANDzOOQQAND{AND{OOQQ<<L|<<L|O!'RQUOAN?dOOQOG24qG24qO$7kQ(CjOG24qOOQOG24fG24fO%QQUOG24qO=}QSOG24fO&FgQ(C[OG24qO!;xQWOG24fO&FrQ(C[OG24qO!MeQSOLD,hOOQQLD,hLD,hO!#]Q,UOLD,hO&GQQSOLD,hO&GYQ$IUO7+'rO&IOQ$IUO7+'tO&JtQ,UOG26zOOQO<<Mr<<MrOOQ(CWANATANATO$LSQSOANATOOQ(CWANASANASOOQO<<M}<<M}OOQQLD-TLD-TO&KUQ$IUO7+*_OOQO7+(r7+(rO8{Q(C[O7+(rO&K`QWO7+&PO#L_QSO7+(rO8qQSO7+(rO!;xQWO7+(rO(VQWO7+(rOOQQG27bG27bO& iQSOG27bO!#]Q,UOG27bOOQQG27eG27eO8{Q(C[OG27eOOQQG27mG27mO&KjQ$IUOG25OOOQOLD*]LD*]O$7kQ(CjOLD*]OOQOLD*QLD*QO%QQUOLD*]O=}QSOLD*QO&KtQ(C[OLD*]OOQQ!$(!S!$(!SO!MeQSO!$(!SO!#]Q,UO!$(!SO&LPQ(CjOG26zOOQ(CWG26oG26oOOQO<<L^<<L^O8{Q(C[O<<L^O#L_QSO<<L^O8qQSO<<L^O!;xQWO<<L^OOQQLD,|LD,|O& iQSOLD,|OOQQLD-PLD-POOQO!$'Mw!$'MwO$7kQ(CjO!$'MwOOQO!$'Ml!$'MlO%QQUO!$'MwOOQQ!)9En!)9EnO!MeQSO!)9EnOOQOANAxANAxO8{Q(C[OANAxO#L_QSOANAxO8qQSOANAxOOQQ!$(!h!$(!hOOQO!)9Cc!)9CcO$7kQ(CjO!)9CcOOQQ!.K;Y!.K;YO&NbQ$IUOG26zOOQOG27dG27dO8{Q(C[OG27dO#L_QSOG27dOOQO!.K8}!.K8}OOQOLD-OLD-OO8{Q(C[OLD-OOOQO!$(!j!$(!jO!'RQUO'#DvO0rQSO'#ETO'!WQbO'#JbO!'RQUO'#DnO'!_QUO'#DzO!'RQUO'#D|O'!fQbO'#CfO'$|QbO'#CfO'%^QUO,5;RO!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO'#IeO''aQSO,5<bO''iQ,UO,5;]O'(|Q,UO,5;]O!'RQUO,5;qO0uQSO'#DSO0uQSO'#DSO!#]Q,UO'#FwO''iQ,UO'#FwO!#]Q,UO'#FyO''iQ,UO'#FyO!#]Q,UO'#GXO''iQ,UO'#GXO!'RQUO,5:fO!'RQUO,5@]O'%^QUO1G0mO')TQ$IUO'#CfO!'RQUO1G1yO!#]Q,UO,5=OO''iQ,UO,5=OO!#]Q,UO,5=QO''iQ,UO,5=QO!#]Q,UO,5<lO''iQ,UO,5<lO'%^QUO1G1zO!'RQUO7+&tO!#]Q,UO1G2WO''iQ,UO1G2WO!#]Q,UO1G2YO''iQ,UO1G2YO'%^QUO7+'fO'%^QUO7+&XO!#]Q,UOANA`O''iQ,UOANA`O')_QSO'#EgO')dQSO'#EgO')lQSO'#FVO')qQSO'#EqO')vQSO'#JqO'*RQSO'#JoO'*^QSO,5;RO'*cQ,UO,5<_O'*jQSO'#GQO'*oQSO'#GQO'*tQSO,5<`O'*|QSO,5;RO'+UQ$IUO1G1YO'+]QSO,5<lO'+bQSO,5<lO'+gQSO,5<nO'+lQSO,5<nO'+qQSO1G1zO'+vQSO1G0mO'+{Q,UO<<KtO',SQ,UO<<KtO7ZQ,UO'#FuO8qQSO'#FtO@jQSO'#EfO!'RQUO,5;nO!/{QSO'#GQO!/{QSO'#GQO!/{QSO'#GSO!/{QSO'#GSO!$uQ,UO7+(YO!$uQ,UO7+(YO$IvQ`O1G2nO$IvQ`O1G2nO!#]Q,UO,5=SO!#]Q,UO,5=S",
  stateData: "'-[~O'lOS'mOSROS'nRQ~OPYOQYOV!TO^pOaxObwOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!XXO!csO!hZO!kYO!lYO!mYO!otO!quO!tvO!x]O#o}O$PzO$TfO%_{O%a!OO%c|O%d|O%g!PO%i!QO%l!RO%m!RO%o!SO%|!UO&S!VO&U!WO&W!XO&Y!YO&]!ZO&c![O&i!]O&k!^O&m!_O&o!`O&q!aO'sSO'uTO'xUO(QVO(_[O(liO~OPYOQYOa!gOb!fOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!cO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$P!hO$TfO's!bO'uTO'xUO(QVO(_[O(liO~O^!qOl!kO|!lO![!rO!]!pO!^!pO!x;oO!|!vO!}!tO#O!uO#P!sO#S!wO#T!wO't!iO'uTO'xUO(T!jO(_!nO~O'n!xO~OPYXXYX^YXkYXyYXzYX|YX!VYX!eYX!fYX!hYX!lYX#WYX#ccX#fYX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#pYX#rYX#tYX#uYX#zYX'jYX(QYX(`YX(gYX(hYX~O!a$yX~P(dO[!zO'u!|O'v!zO'w!|O~O[!}O'w!|O'x!|O'y!}O~Oq#PO!O#QO(R#QO(S#SO~OPYOQYOa!gOb!fOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!cO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$P!hO$TfO's;tO'uTO'xUO(QVO(_[O(liO~O!U#WO!V#TO!S(WP!S(dP~P+pO!W#`O~P`OPYOQYOa!gOb!fOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!cO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$P!hO$TfO'uTO'xUO(QVO(_[O(liO~O!U#fO!x]O#a#iO#b#fO's;uO!g(aP~P.[O!h#kO's#jO~O!t#oO!x]O%_#pO~O#c#qO~O!a#rO#c#qO~OP$YOX$aOk#}Oy#vOz#wO|#xO!V$^O!e$PO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O#j$OO#k$PO#l$PO#m$`O#n$PO#p$QO#r$SO#t$UO#u$VO(QVO(`$WO(g#yO(h#zO~O^(UX'j(UX'h(UX!g(UX!S(UX!X(UX%`(UX!a(UX~P1dO#W$bO#z$bOP(VXX(VXk(VXy(VXz(VX|(VX!V(VX!e(VX!h(VX!l(VX#f(VX#g(VX#h(VX#i(VX#j(VX#k(VX#l(VX#m(VX#n(VX#p(VX#r(VX#t(VX#u(VX(Q(VX(`(VX(g(VX(h(VX!X(VX%`(VX~O^(VX!f(VX'j(VX'h(VX!S(VX!g(VXo(VX!a(VX~P3zO#W$bO~O$V$dO$X$cO$`$iO~O!X$jO$TfO$c$kO$e$mO~Oi%POk$qOl$pOm$pOs%QOu%ROw%SO|$xO!X$yO!c%XO!h$uO#b%YO$P%VO$l%TO$n%UO$q%WO's$oO'uTO'xUO'|%OO(Q$rOd'}P~O!h%ZO~O!a%]O~O^%^O'j%^O~O't!iO~P%QO's%eO~O!h%ZO's%eO't!iO'|%OO~Ob%lO!h%ZO's%eO~O#n$PO~Oy%qO!X%nO!h%pO%a%tO's%eO't!iO'uTO'xUO](tP~O!t#oO~O|%vO!X%wO's%eO~O|%vO!X%wO%i%{O's%eO~O's%|O~O#o}O%a!OO%c|O%d|O%g!PO%i!QO%l!RO%m!RO~Oa&VOb&UO!t&SO%_&TO%q&RO~P;cOa&YObwO!X&XO!tvO!x]O#o}O%_{O%c|O%d|O%g!PO%i!QO%l!RO%m!RO%o!SO~O_&]O#W&`O%a&ZO't!iO~P<bO!h&aO!q&eO~O!h#kO~O!XXO~O^%^O'i&mO'j%^O~O^%^O'i&pO'j%^O~O^%^O'i&rO'j%^O~O'hYX!SYXoYX!gYX&QYX!XYX%`YX!aYX~P(dO!['PO!]&xO!^&xO't!iO'uTO'xUO~Ol&vO|&uO!U&yO(T&tO!W(XP!W(fP~P?cOg'SO!X'QO's%eO~Ob'XO!h%ZO's%eO~Oy%qO!h%pO~Ol!kO|!lO!['^O!]']O!^']O!}'`O#O'`O#P'_O#S'bO#T'bO't!iO'uTO'xUO(T!jO(_!nO~O!x;oO!|'aO~P@}O^%^O!a#rO!h%ZO!l'hO#W'fO'j%^O'|%OO(`'dO~Ol!kO|!lO'uTO'xUO(T!jO(_!nO~O!]']O!^']O't!iO~PBtO!['^O!]']O!^']O#S'bO#T'bO't!iO~PBtO!XXO!['^O!]']O!^']O#P'_O#S'bO#T'bO't!iO~PBtO'o'lO'p'lO'q'nO~O[!zO'u'pO'v!zO'w'pO~O[!}O'w'pO'x'pO'y!}O~Oq#PO!O#QO(R#QO(S'tO~O!U'vO!S&|X!S'SX!V&|X!V'SX~P+pO!V'xO!S(WX~OP$YOX$aOk#}Oy#vOz#wO|#xO!V'xO!e$PO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O#j$OO#k$PO#l$PO#m$`O#n$PO#p$QO#r$SO#t$UO#u$VO(QVO(`$WO(g#yO(h#zO~O!S(WX~PF_O!S'}O~O!S(cX!V(cX!a(cX!g(cX(`(cX~O#W(cX#c#[X!W(cX~PHeO#W(OO!S(eX!V(eX~O!V(PO!S(dX~O!S(SO~O#W$bO~PHeO!W(TO~P`Oy#vOz#wO|#xO!f#tO!h#uO(QVOP!jaX!jak!ja!V!ja!e!ja!l!ja#f!ja#g!ja#h!ja#i!ja#j!ja#k!ja#l!ja#m!ja#n!ja#p!ja#r!ja#t!ja#u!ja(`!ja(g!ja(h!ja~O^!ja'j!ja'h!ja!S!ja!g!jao!ja!X!ja%`!ja!a!ja~PI{O!g(UO~O|%vO!X%wO!x]O#a(XO#b(WO's%eO~O!a#rO#W(YO(`'dO!V(bX^(bX'j(bX~O!g(bX~PMPO!V(]O!g(aX~O!g(_O~O|%vO!X%wO#b(WO's%eO~Oy(`Oz(aO!f#tO!h#uO!x!wa|!wa~O!t!wa%_!wa!X!wa#a!wa#b!wa's!wa~PNXO!t(eO~OPYOQYOa!gOb!fOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!XXO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$P!hO$TfO's!bO'uTO'xUO(QVO(_[O(liO~Oi%POk$qOl$pOm$pOs%QOu%ROw<XO|$xO!X$yO!c=cO!h$uO#b<_O$P%VO$l<ZO$n<]O$q%WO's(iO'uTO'xUO'|%OO(Q$rO~O#c(kO~Oi%POk$qOl$pOm$pOs%QOu%ROw%SO|$xO!X$yO!c%XO!h$uO#b%YO$P%VO$l%TO$n%UO$q%WO's(iO'uTO'xUO'|%OO(Q$rO~Od(ZP~P!$uO!U(oO!g([P~P%QO(T(qO(_[O~O|(sO!h#uO(T(qO(_[O~OP;nOQ;nOa=_Ob!fOikOk;nOlkOmkOskOu;nOw;nO|WO!QkO!RkO!X!cO!c;qO!hZO!k;nO!l;nO!m;nO!o;rO!q;sO!t!eO$P!hO$TfO's)RO'uTO'xUO(QVO(_[O(l=]O~Oz)UO!h#uO~O!V$^O^$ja'j$ja'h$ja!g$ja!S$ja!X$ja%`$ja!a$ja~O#o)YO~P!#]Oy)]O!a)[O!X$WX$S$WX$V$WX$X$WX$`$WX~O!a)[O!X(iX$S(iX$V(iX$X(iX$`(iX~Oy)]O~P!*kOy)]O!X(iX$S(iX$V(iX$X(iX$`(iX~O!X)_O$S)cO$V)^O$X)^O$`)dO~O!U)gO~P!'RO$V$dO$X$cO$`)kO~Og$rXy$rX|$rX!f$rX(g$rX(h$rX~OdfXd$rXgfX!VfX#WfX~P!,aOl)mO~Oq)nO(R)oO(S)qO~Og)zOy)sO|)tO(g)vO(h)xO~Od)rO~P!-jOd){O~Oi%POk$qOl$pOm$pOs%QOu%ROw<XO|$xO!X$yO!c=cO!h$uO#b<_O$P%VO$l<ZO$n<]O$q%WO'uTO'xUO'|%OO(Q$rO~O!U*PO's)|O!g(mP~P!.XO#c*RO~O!h*SO~O!U*XO's*UO!S(nP~P!.XOk*eO|*]O![*cO!]*[O!^*[O!h*SO#S*dO%V*_O't!iO(T!jO~O!W*bO~P!0_O!f#tOg(PXy(PX|(PX(g(PX(h(PX!V(PX#W(PX~Od(PX#x(PX~P!1WOg*hO#W*gOd(OX!V(OX~O!V*iOd'}X~O's%|Od'}P~O!h*pO~O's(iO~O|%vO!U#fO!X%wO!x]O#a#iO#b#fO's%eO!g(aP~O!a#rO#c*tO~OP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O#j$OO#k$PO#l$PO#m$`O#n$PO#p$QO#r$SO#t$UO#u$VO(QVO(`$WO(g#yO(h#zO~O^!ba!V!ba'j!ba'h!ba!S!ba!g!bao!ba!X!ba%`!ba!a!ba~P!3jOy#vOz#wO|#xO!f#tO!h#uO(QVOP!naX!nak!na!V!na!e!na!l!na#f!na#g!na#h!na#i!na#j!na#k!na#l!na#m!na#n!na#p!na#r!na#t!na#u!na(`!na(g!na(h!na~O^!na'j!na'h!na!S!na!g!nao!na!X!na%`!na!a!na~P!6TOy#vOz#wO|#xO!f#tO!h#uO(QVOP!paX!pak!pa!V!pa!e!pa!l!pa#f!pa#g!pa#h!pa#i!pa#j!pa#k!pa#l!pa#m!pa#n!pa#p!pa#r!pa#t!pa#u!pa(`!pa(g!pa(h!pa~O^!pa'j!pa'h!pa!S!pa!g!pao!pa!X!pa%`!pa!a!pa~P!8nOg*|O!X'QO%`*{O'|%OO~O!a+OO!X'{X^'{X!V'{X'j'{X~O!h%ZO'|%OO~O!h%ZO's%eO'|%OO~O!a#rO#c(kO~O%a+[O's+WO'uTO'xUO!W(uP~O!V+]O](tX~O(T(qO~OX+aO~O]+bO~O!X%nO's%eO't!iO](tP~O|%vO!U+fO!V(PO!X%wO's%eO!S(dP~Ol&|O|+hO!U+gO'uTO'xUO(T(qO~O!W(fP~P!>RO!V+iO^(qX'j(qX~O#W+mO'|%OO~Og+pO!X$yO'|%OO~O!X+rO~Oy+tO!XXO~O!t+yO~Ob,OO~O's#jO!W(sP~Ob%lO~O%a!OO's%|O~P<bOX,UO],TO~OPYOQYOaxObwOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!csO!hZO!kYO!lYO!mYO!otO!quO!tvO!x]O$TfO%_{O'uTO'xUO(QVO(_[O(liO~O!X!cO$P!hO's!bO~P!@fO],TO^%^O'j%^O~O^,YO#o,[O%c,[O%d,[O~P%QO!h&aO~O&S,aO~O!X,cO~O&e,eO&g,fOP&baQ&baV&ba^&baa&bab&bai&bak&bal&bam&bas&bau&baw&ba|&ba!Q&ba!R&ba!X&ba!c&ba!h&ba!k&ba!l&ba!m&ba!o&ba!q&ba!t&ba!x&ba#o&ba$P&ba$T&ba%_&ba%a&ba%c&ba%d&ba%g&ba%i&ba%l&ba%m&ba%o&ba%|&ba&S&ba&U&ba&W&ba&Y&ba&]&ba&c&ba&i&ba&k&ba&m&ba&o&ba&q&ba'h&ba's&ba'u&ba'x&ba(Q&ba(_&ba(l&ba!W&ba&Z&ba_&ba&`&ba~O's,kO~O!V{X!V!_X!W{X!W!_X!a{X!a!_X!h!_X#W{X'|!_X~O!a,pO#W,oO!V#`X!V(YX!W#`X!W(YX!a(YX!h(YX'|(YX~O!a,rO!h%ZO'|%OO!V!ZX!W!ZX~Ol!kO|!lO'uTO'xUO(T!jO~OP;nOQ;nOa=_Ob!fOikOk;nOlkOmkOskOu;nOw;nO|WO!QkO!RkO!X!cO!c;qO!hZO!k;nO!l;nO!m;nO!o;rO!q;sO!t!eO$P!hO$TfO'uTO'xUO(QVO(_[O(l=]O~O's<dO~P!I{O!V,vO!W(XX~O!W,xO~O!a,pO#W,oO!V#`X!W#`X~O!V,yO!W(fX~O!W,{O~O!],|O!^,|O't!iO~P!IjO!W-PO~P'TOg-SO!X'QO~O!S-XO~Ol!wa![!wa!]!wa!^!wa!|!wa!}!wa#O!wa#P!wa#S!wa#T!wa't!wa'u!wa'x!wa(T!wa(_!wa~PNXO^%^O!a#rO!h%ZO!l-^O#W-[O'j%^O'|%OO(`'dO~O!]-`O!^-`O't!iO~PBtO![-bO!]-`O!^-`O#S-cO#T-cO't!iO~PBtO![-bO!]-`O!^-`O#P-dO#S-cO#T-cO't!iO~PBtO![-bO!]-`O!^-`O!}-eO#O-eO#P-dO#S-cO#T-cO't!iO~PBtO^%^O#W-[O'j%^O~O^%^O!a#rO#W-[O'j%^O~O^%^O!a#rO!l-^O#W-[O'j%^O(`'dO~O'o'lO'p'lO'q-jO~Oo-kO~O!S&|a!V&|a~P!3jO!U-oO!S&|X!V&|X~P%QO!V'xO!S(Wa~O!S(Wa~PF_O!V(PO!S(da~O|%vO!U-sO!X%wO's%eO!S'SX!V'SX~O!V(]O!g(aa~O|%vO!X%wO#b-vO's%eO~O#W-xO!V(ba!g(ba^(ba'j(ba~O!a#rO~P#&hO|%vO!U-{O!X%wO!x]O#a-}O#b-{O's%eO!V'UX!g'UX~Oz.RO!h#uO~Og.UO!X'QO%`.TO'|%OO~O^#Zi!V#Zi'j#Zi'h#Zi!S#Zi!g#Zio#Zi!X#Zi%`#Zi!a#Zi~P!3jOg=iOy)sO|)tO(g)vO(h)xO~O#c#Va^#Va#W#Va'j#Va!V#Va!g#Va!X#Va!S#Va~P#(yO#c(PXP(PXX(PX^(PXk(PXz(PX!e(PX!h(PX!l(PX#f(PX#g(PX#h(PX#i(PX#j(PX#k(PX#l(PX#m(PX#n(PX#p(PX#r(PX#t(PX#u(PX'j(PX(Q(PX(`(PX!g(PX!S(PX'h(PXo(PX!X(PX%`(PX!a(PX~P!1WO!V._Od(ZX~P!-jOd.aO~O!V.bO!g([X~P!3jO!g.eO~O!S.gO~OP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO(QVOX#ei^#eik#ei!V#ei!e#ei#g#ei#h#ei#i#ei#j#ei#k#ei#l#ei#m#ei#n#ei#p#ei#r#ei#t#ei#u#ei'j#ei(`#ei(g#ei(h#ei'h#ei!S#ei!g#eio#ei!X#ei%`#ei!a#ei~O#f#ei~P#,uO#f#{O~P#,uOP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O(QVOX#ei^#ei!V#ei!e#ei#j#ei#k#ei#l#ei#m#ei#n#ei#p#ei#r#ei#t#ei#u#ei'j#ei(`#ei(g#ei(h#ei'h#ei!S#ei!g#eio#ei!X#ei%`#ei!a#ei~Ok#ei~P#/gOk#}O~P#/gOP$YOk#}Oy#vOz#wO|#xO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O#j$OO(QVO^#ei!V#ei#p#ei#r#ei#t#ei#u#ei'j#ei(`#ei(g#ei(h#ei'h#ei!S#ei!g#eio#ei!X#ei%`#ei!a#ei~OX#ei!e#ei#k#ei#l#ei#m#ei#n#ei~P#2XOX$aO!e$PO#k$PO#l$PO#m$`O#n$PO~P#2XOP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O#j$OO#k$PO#l$PO#m$`O#n$PO#p$QO(QVO^#ei!V#ei#r#ei#t#ei#u#ei'j#ei(`#ei(h#ei'h#ei!S#ei!g#eio#ei!X#ei%`#ei!a#ei~O(g#ei~P#5YO(g#yO~P#5YOP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O#j$OO#k$PO#l$PO#m$`O#n$PO#p$QO#r$SO(QVO(g#yO^#ei!V#ei#t#ei#u#ei'j#ei(`#ei'h#ei!S#ei!g#eio#ei!X#ei%`#ei!a#ei~O(h#ei~P#7zO(h#zO~P#7zOP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O#j$OO#k$PO#l$PO#m$`O#n$PO#p$QO#r$SO#t$UO(QVO(g#yO(h#zO~O^#ei!V#ei#u#ei'j#ei(`#ei'h#ei!S#ei!g#eio#ei!X#ei%`#ei!a#ei~P#:lOPYXXYXkYXyYXzYX|YX!eYX!fYX!hYX!lYX#WYX#ccX#fYX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#pYX#rYX#tYX#uYX#zYX(QYX(`YX(gYX(hYX!VYX!WYX~O#xYX~P#=VOP$YOX<VOk;yOy#vOz#wO|#xO!e;{O!f#tO!h#uO!l$YO#f;wO#g;xO#h;xO#i;xO#j;zO#k;{O#l;{O#m<UO#n;{O#p;|O#r<OO#t<QO#u<RO(QVO(`$WO(g#yO(h#zO~O#x.iO~P#?dOP(VXX(VXk(VXy(VXz(VX|(VX!e(VX!f(VX!h(VX!l(VX#f(VX#g(VX#h(VX#i(VX#j(VX#k(VX#l(VX#m(VX#p(VX#r(VX#t(VX#u(VX(Q(VX(`(VX(g(VX(h(VX!V(VX~O#W<WO#z<WO#n(VX#x(VX!W(VX~P#AbO^'Xa!V'Xa'j'Xa'h'Xa!g'Xa!S'Xao'Xa!X'Xa%`'Xa!a'Xa~P!3jOP#eiX#ei^#eik#eiz#ei!V#ei!e#ei!f#ei!h#ei!l#ei#f#ei#g#ei#h#ei#i#ei#j#ei#k#ei#l#ei#m#ei#n#ei#p#ei#r#ei#t#ei#u#ei'j#ei(Q#ei(`#ei'h#ei!S#ei!g#eio#ei!X#ei%`#ei!a#ei~P#(yO^#yi!V#yi'j#yi'h#yi!S#yi!g#yio#yi!X#yi%`#yi!a#yi~P!3jO$V.nO$X.nO~O$V.oO$X.oO~O!a)[O#W.pO!X$]X$S$]X$V$]X$X$]X$`$]X~O!U.qO~O!X)_O$S.sO$V)^O$X)^O$`.tO~O!V<SO!W(UX~P#?dO!W.uO~O!a)[O$`(iX~O$`.wO~Oq)nO(R)oO(S.zO~Ol.}O!S/OO'uTO'xUO~O!VcX!acX!gcX!g$rX(`cX~P!,aO!g/UO~P#(yO!V/VO!a#rO(`'dO!g(mX~O!g/[O~O!U*PO's%eO!g(mP~O#c/^O~O!S$rX!V$rX!a$yX~P!,aO!V/_O!S(nX~P#(yO!a/aO~O!S/cO~Ok/gO!a#rO!h%ZO'|%OO(`'dO~O's/iO~O!a+OO~O^%^O!V/mO'j%^O~O!W/oO~P!0_O!]/pO!^/pO't!iO(T!jO~O|/rO(T!jO~O#S/sO~O's%|Od'^X!V'^X~O!V*iOd'}a~Od/xO~Oy/yOz/yO|/zOgva(gva(hva!Vva#Wva~Odva#xva~P#M{Oy)sO|)tOg$ka(g$ka(h$ka!V$ka#W$ka~Od$ka#x$ka~P#NqOy)sO|)tOg$ma(g$ma(h$ma!V$ma#W$ma~Od$ma#x$ma~P$ dO#c/|O~Od${a!V${a#W${a#x${a~P!-jO#c0PO~Oy#vOz#wO|#xO!f#tO!h#uO(QVOP!niX!nik!ni!V!ni!e!ni!l!ni#f!ni#g!ni#h!ni#i!ni#j!ni#k!ni#l!ni#m!ni#n!ni#p!ni#r!ni#t!ni#u!ni(`!ni(g!ni(h!ni~O^!ni'j!ni'h!ni!S!ni!g!nio!ni!X!ni%`!ni!a!ni~P$!qOg.UO!X'QO%`.TO~Oi0WO's0VO~P!.[O!a+OO!X'{a^'{a!V'{a'j'{a~O#c0^O~OXYX!VcX!WcX~O!V0_O!W(uX~O!W0aO~OX0bO~O's+WO'uTO'xUO~O!X%nO's%eO]'fX!V'fX~O!V+]O](ta~O!g0gO~P!3jOX0jO~O]0kO~O!V+iO^(qa'j(qa~O#W0qO~Og0tO!X$yO~O(T(qO!W(rP~Og0}O!X0zO%`0|O'|%OO~OX1XO!V1VO!W(sX~O!W1YO~O]1[O^%^O'j%^O~O's#jO'uTO'xUO~O#W$bO#n1_O#z$bO&Q1`O^(VX~P#AbO#W$bO#n1_O&Q1`O~O^1aO~P%QO^1cO~O&Z1gOP&XiQ&XiV&Xi^&Xia&Xib&Xii&Xik&Xil&Xim&Xis&Xiu&Xiw&Xi|&Xi!Q&Xi!R&Xi!X&Xi!c&Xi!h&Xi!k&Xi!l&Xi!m&Xi!o&Xi!q&Xi!t&Xi!x&Xi#o&Xi$P&Xi$T&Xi%_&Xi%a&Xi%c&Xi%d&Xi%g&Xi%i&Xi%l&Xi%m&Xi%o&Xi%|&Xi&S&Xi&U&Xi&W&Xi&Y&Xi&]&Xi&c&Xi&i&Xi&k&Xi&m&Xi&o&Xi&q&Xi'h&Xi's&Xi'u&Xi'x&Xi(Q&Xi(_&Xi(l&Xi!W&Xi_&Xi&`&Xi~O_1mO!W1kO&`1lO~P`O!XXO!h1oO~O&g,fOP&biQ&biV&bi^&bia&bib&bii&bik&bil&bim&bis&biu&biw&bi|&bi!Q&bi!R&bi!X&bi!c&bi!h&bi!k&bi!l&bi!m&bi!o&bi!q&bi!t&bi!x&bi#o&bi$P&bi$T&bi%_&bi%a&bi%c&bi%d&bi%g&bi%i&bi%l&bi%m&bi%o&bi%|&bi&S&bi&U&bi&W&bi&Y&bi&]&bi&c&bi&i&bi&k&bi&m&bi&o&bi&q&bi'h&bi's&bi'u&bi'x&bi(Q&bi(_&bi(l&bi!W&bi&Z&bi_&bi&`&bi~O!S1uO~O!V!Za!W!Za~P#?dOl!kO|!lO!U1{O(T!jO!V&}X!W&}X~P?cO!V,vO!W(Xa~O!V'TX!W'TX~P!>RO!V,yO!W(fa~O!W2SO~P'TO^%^O#W2]O'j%^O~O^%^O!a#rO#W2]O'j%^O~O^%^O!a#rO!h%ZO!l2aO#W2]O'j%^O'|%OO(`'dO~O!]2bO!^2bO't!iO~PBtO![2eO!]2bO!^2bO#S2fO#T2fO't!iO~PBtO![2eO!]2bO!^2bO#P2gO#S2fO#T2fO't!iO~PBtO^%^O!a#rO!l2aO#W2]O'j%^O(`'dO~O^%^O'j%^O~P!3jO!V$^Oo$ja~O!S&|i!V&|i~P!3jO!V'xO!S(Wi~O!V(PO!S(di~O!S(ei!V(ei~P!3jO!V(]O!g(ai~O!V(bi!g(bi^(bi'j(bi~P!3jO#W2kO!V(bi!g(bi^(bi'j(bi~O|%vO!X%wO!x]O#a2nO#b2mO's%eO~O|%vO!X%wO#b2mO's%eO~Og2uO!X'QO%`2tO~Og2uO!X'QO%`2tO'|%OO~O#cvaPvaXva^vakva!eva!fva!hva!lva#fva#gva#hva#iva#jva#kva#lva#mva#nva#pva#rva#tva#uva'jva(Qva(`va!gva!Sva'hvaova!Xva%`va!ava~P#M{O#c$kaP$kaX$ka^$kak$kaz$ka!e$ka!f$ka!h$ka!l$ka#f$ka#g$ka#h$ka#i$ka#j$ka#k$ka#l$ka#m$ka#n$ka#p$ka#r$ka#t$ka#u$ka'j$ka(Q$ka(`$ka!g$ka!S$ka'h$kao$ka!X$ka%`$ka!a$ka~P#NqO#c$maP$maX$ma^$mak$maz$ma!e$ma!f$ma!h$ma!l$ma#f$ma#g$ma#h$ma#i$ma#j$ma#k$ma#l$ma#m$ma#n$ma#p$ma#r$ma#t$ma#u$ma'j$ma(Q$ma(`$ma!g$ma!S$ma'h$mao$ma!X$ma%`$ma!a$ma~P$ dO#c${aP${aX${a^${ak${az${a!V${a!e${a!f${a!h${a!l${a#f${a#g${a#h${a#i${a#j${a#k${a#l${a#m${a#n${a#p${a#r${a#t${a#u${a'j${a(Q${a(`${a!g${a!S${a'h${a#W${ao${a!X${a%`${a!a${a~P#(yO^#Zq!V#Zq'j#Zq'h#Zq!S#Zq!g#Zqo#Zq!X#Zq%`#Zq!a#Zq~P!3jOd'OX!V'OX~P!$uO!V._Od(Za~O!U2}O!V'PX!g'PX~P%QO!V.bO!g([a~O!V.bO!g([a~P!3jO!S3QO~O#x!ja!W!ja~PI{O#x!ba!V!ba!W!ba~P#?dO#x!na!W!na~P!6TO#x!pa!W!pa~P!8nO!X3dO$TfO$^3eO~O!W3iO~Oo3jO~P#(yO^$gq!V$gq'j$gq'h$gq!S$gq!g$gqo$gq!X$gq%`$gq!a$gq~P!3jO!S3kO~Ol.}O'uTO'xUO~Oy)sO|)tO(h)xOg%Wi(g%Wi!V%Wi#W%Wi~Od%Wi#x%Wi~P$HbOy)sO|)tOg%Yi(g%Yi(h%Yi!V%Yi#W%Yi~Od%Yi#x%Yi~P$ITO(`$WO~P#(yO!U3nO's%eO!V'YX!g'YX~O!V/VO!g(ma~O!V/VO!a#rO!g(ma~O!V/VO!a#rO(`'dO!g(ma~Od$ti!V$ti#W$ti#x$ti~P!-jO!U3vO's*UO!S'[X!V'[X~P!.XO!V/_O!S(na~O!V/_O!S(na~P#(yO!a#rO~O!a#rO#n4OO~Ok4RO!a#rO(`'dO~Od(Oi!V(Oi~P!-jO#W4UOd(Oi!V(Oi~P!-jO!g4XO~O^$hq!V$hq'j$hq'h$hq!S$hq!g$hqo$hq!X$hq%`$hq!a$hq~P!3jO!V4]O!X(oX~P#(yO!f#tO~P3zO!X$rX%TYX^$rX!V$rX'j$rX~P!,aO%T4_OghXyhX|hX!XhX(ghX(hhX^hX!VhX'jhX~O%T4_O~O%a4fO's+WO'uTO'xUO!V'eX!W'eX~O!V0_O!W(ua~OX4jO~O]4kO~O!S4oO~O^%^O'j%^O~P#(yO!X$yO~P#(yO!V4tO#W4vO!W(rX~O!W4wO~Ol!kO|4yO![5WO!]4}O!^4}O!x;oO!|5VO!}5UO#O5UO#P5TO#S5SO#T!wO't!iO'uTO'xUO(T!jO(_!nO~O!W5RO~P%#XOg5]O!X0zO%`5[O~Og5]O!X0zO%`5[O'|%OO~O's#jO!V'dX!W'dX~O!V1VO!W(sa~O'uTO'xUO(T5fO~O]5jO~O!g5mO~P%QO^5oO~O^5oO~P%QO#n5qO&Q5rO~PMPO_1mO!W5vO&`1lO~P`O!a5xO~O!a5zO!V(Yi!W(Yi!a(Yi!h(Yi'|(Yi~O!V#`i!W#`i~P#?dO#W5{O!V#`i!W#`i~O!V!Zi!W!Zi~P#?dO^%^O#W6UO'j%^O~O^%^O!a#rO#W6UO'j%^O~O^%^O!a#rO!l6ZO#W6UO'j%^O(`'dO~O!h%ZO'|%OO~P%(fO!]6[O!^6[O't!iO~PBtO![6_O!]6[O!^6[O#S6`O#T6`O't!iO~PBtO!V(]O!g(aq~O!V(bq!g(bq^(bq'j(bq~P!3jO|%vO!X%wO#b6dO's%eO~O!X'QO%`6gO~Og6jO!X'QO%`6gO~O#c%WiP%WiX%Wi^%Wik%Wiz%Wi!e%Wi!f%Wi!h%Wi!l%Wi#f%Wi#g%Wi#h%Wi#i%Wi#j%Wi#k%Wi#l%Wi#m%Wi#n%Wi#p%Wi#r%Wi#t%Wi#u%Wi'j%Wi(Q%Wi(`%Wi!g%Wi!S%Wi'h%Wio%Wi!X%Wi%`%Wi!a%Wi~P$HbO#c%YiP%YiX%Yi^%Yik%Yiz%Yi!e%Yi!f%Yi!h%Yi!l%Yi#f%Yi#g%Yi#h%Yi#i%Yi#j%Yi#k%Yi#l%Yi#m%Yi#n%Yi#p%Yi#r%Yi#t%Yi#u%Yi'j%Yi(Q%Yi(`%Yi!g%Yi!S%Yi'h%Yio%Yi!X%Yi%`%Yi!a%Yi~P$ITO#c$tiP$tiX$ti^$tik$tiz$ti!V$ti!e$ti!f$ti!h$ti!l$ti#f$ti#g$ti#h$ti#i$ti#j$ti#k$ti#l$ti#m$ti#n$ti#p$ti#r$ti#t$ti#u$ti'j$ti(Q$ti(`$ti!g$ti!S$ti'h$ti#W$tio$ti!X$ti%`$ti!a$ti~P#(yOd'Oa!V'Oa~P!-jO!V'Pa!g'Pa~P!3jO!V.bO!g([i~O#x#Zi!V#Zi!W#Zi~P#?dOP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO(QVOX#eik#ei!e#ei#g#ei#h#ei#i#ei#j#ei#k#ei#l#ei#m#ei#n#ei#p#ei#r#ei#t#ei#u#ei#x#ei(`#ei(g#ei(h#ei!V#ei!W#ei~O#f#ei~P%2xO#f;wO~P%2xOP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO#f;wO#g;xO#h;xO#i;xO(QVOX#ei!e#ei#j#ei#k#ei#l#ei#m#ei#n#ei#p#ei#r#ei#t#ei#u#ei#x#ei(`#ei(g#ei(h#ei!V#ei!W#ei~Ok#ei~P%5TOk;yO~P%5TOP$YOk;yOy#vOz#wO|#xO!f#tO!h#uO!l$YO#f;wO#g;xO#h;xO#i;xO#j;zO(QVO#p#ei#r#ei#t#ei#u#ei#x#ei(`#ei(g#ei(h#ei!V#ei!W#ei~OX#ei!e#ei#k#ei#l#ei#m#ei#n#ei~P%7`OX<VO!e;{O#k;{O#l;{O#m<UO#n;{O~P%7`OP$YOX<VOk;yOy#vOz#wO|#xO!e;{O!f#tO!h#uO!l$YO#f;wO#g;xO#h;xO#i;xO#j;zO#k;{O#l;{O#m<UO#n;{O#p;|O(QVO#r#ei#t#ei#u#ei#x#ei(`#ei(h#ei!V#ei!W#ei~O(g#ei~P%9zO(g#yO~P%9zOP$YOX<VOk;yOy#vOz#wO|#xO!e;{O!f#tO!h#uO!l$YO#f;wO#g;xO#h;xO#i;xO#j;zO#k;{O#l;{O#m<UO#n;{O#p;|O#r<OO(QVO(g#yO#t#ei#u#ei#x#ei(`#ei!V#ei!W#ei~O(h#ei~P%<VO(h#zO~P%<VOP$YOX<VOk;yOy#vOz#wO|#xO!e;{O!f#tO!h#uO!l$YO#f;wO#g;xO#h;xO#i;xO#j;zO#k;{O#l;{O#m<UO#n;{O#p;|O#r<OO#t<QO(QVO(g#yO(h#zO~O#u#ei#x#ei(`#ei!V#ei!W#ei~P%>bO^#vy!V#vy'j#vy'h#vy!S#vy!g#vyo#vy!X#vy%`#vy!a#vy~P!3jOg=jOy)sO|)tO(g)vO(h)xO~OP#eiX#eik#eiz#ei!e#ei!f#ei!h#ei!l#ei#f#ei#g#ei#h#ei#i#ei#j#ei#k#ei#l#ei#m#ei#n#ei#p#ei#r#ei#t#ei#u#ei#x#ei(Q#ei(`#ei!V#ei!W#ei~P%AYO!f#tOP(PXX(PXg(PXk(PXy(PXz(PX|(PX!e(PX!h(PX!l(PX#f(PX#g(PX#h(PX#i(PX#j(PX#k(PX#l(PX#m(PX#n(PX#p(PX#r(PX#t(PX#u(PX#x(PX(Q(PX(`(PX(g(PX(h(PX!V(PX!W(PX~O#x#yi!V#yi!W#yi~P#?dO#x!ni!W!ni~P$!qO!W6vO~O!V'Xa!W'Xa~P#?dO!a#rO(`'dO!V'Ya!g'Ya~O!V/VO!g(mi~O!V/VO!a#rO!g(mi~Od$tq!V$tq#W$tq#x$tq~P!-jO!S'[a!V'[a~P#(yO!a6}O~O!V/_O!S(ni~P#(yO!V/_O!S(ni~O!S7RO~O!a#rO#n7WO~Ok7XO!a#rO(`'dO~O!S7ZO~Od$vq!V$vq#W$vq#x$vq~P!-jO^$hy!V$hy'j$hy'h$hy!S$hy!g$hyo$hy!X$hy%`$hy!a$hy~P!3jO!V4]O!X(oa~O^#Zy!V#Zy'j#Zy'h#Zy!S#Zy!g#Zyo#Zy!X#Zy%`#Zy!a#Zy~P!3jOX7`O~O!V0_O!W(ui~O]7fO~O!a5zO~O(T(qO!V'aX!W'aX~O!V4tO!W(ra~O!h%ZO'|%OO^(YX!a(YX!l(YX#W(YX'j(YX(`(YX~O's7oO~P.[O!x;oO!|7rO!}7qO#O7qO#P7pO#S'bO#T'bO~PBtO^%^O!a#rO!l'hO#W'fO'j%^O(`'dO~O!W7vO~P%#XOl!kO'uTO'xUO(T!jO(_!nO~O|7wO~P%MdO![7{O!]7zO!^7zO#P7pO#S'bO#T'bO't!iO~PBtO![7{O!]7zO!^7zO!}7|O#O7|O#P7pO#S'bO#T'bO't!iO~PBtO!]7zO!^7zO't!iO(T!jO(_!nO~O!X0zO~O!X0zO%`8OO~Og8RO!X0zO%`8OO~OX8WO!V'da!W'da~O!V1VO!W(si~O!g8[O~O!g8]O~O!g8^O~O!g8^O~P%QO^8`O~O!a8cO~O!g8dO~O!V(ei!W(ei~P#?dO^%^O#W8lO'j%^O~O^%^O!a#rO#W8lO'j%^O~O^%^O!a#rO!l8pO#W8lO'j%^O(`'dO~O!h%ZO'|%OO~P&$QO!]8qO!^8qO't!iO~PBtO!V(]O!g(ay~O!V(by!g(by^(by'j(by~P!3jO!X'QO%`8uO~O#c$tqP$tqX$tq^$tqk$tqz$tq!V$tq!e$tq!f$tq!h$tq!l$tq#f$tq#g$tq#h$tq#i$tq#j$tq#k$tq#l$tq#m$tq#n$tq#p$tq#r$tq#t$tq#u$tq'j$tq(Q$tq(`$tq!g$tq!S$tq'h$tq#W$tqo$tq!X$tq%`$tq!a$tq~P#(yO#c$vqP$vqX$vq^$vqk$vqz$vq!V$vq!e$vq!f$vq!h$vq!l$vq#f$vq#g$vq#h$vq#i$vq#j$vq#k$vq#l$vq#m$vq#n$vq#p$vq#r$vq#t$vq#u$vq'j$vq(Q$vq(`$vq!g$vq!S$vq'h$vq#W$vqo$vq!X$vq%`$vq!a$vq~P#(yO!V'Pi!g'Pi~P!3jO#x#Zq!V#Zq!W#Zq~P#?dOy/yOz/yO|/zOPvaXvagvakva!eva!fva!hva!lva#fva#gva#hva#iva#jva#kva#lva#mva#nva#pva#rva#tva#uva#xva(Qva(`va(gva(hva!Vva!Wva~Oy)sO|)tOP$kaX$kag$kak$kaz$ka!e$ka!f$ka!h$ka!l$ka#f$ka#g$ka#h$ka#i$ka#j$ka#k$ka#l$ka#m$ka#n$ka#p$ka#r$ka#t$ka#u$ka#x$ka(Q$ka(`$ka(g$ka(h$ka!V$ka!W$ka~Oy)sO|)tOP$maX$mag$mak$maz$ma!e$ma!f$ma!h$ma!l$ma#f$ma#g$ma#h$ma#i$ma#j$ma#k$ma#l$ma#m$ma#n$ma#p$ma#r$ma#t$ma#u$ma#x$ma(Q$ma(`$ma(g$ma(h$ma!V$ma!W$ma~OP${aX${ak${az${a!e${a!f${a!h${a!l${a#f${a#g${a#h${a#i${a#j${a#k${a#l${a#m${a#n${a#p${a#r${a#t${a#u${a#x${a(Q${a(`${a!V${a!W${a~P%AYO#x$gq!V$gq!W$gq~P#?dO#x$hq!V$hq!W$hq~P#?dO!W9PO~O#x9QO~P!-jO!a#rO!V'Yi!g'Yi~O!a#rO(`'dO!V'Yi!g'Yi~O!V/VO!g(mq~O!S'[i!V'[i~P#(yO!V/_O!S(nq~O!S9WO~P#(yO!S9WO~Od(Oy!V(Oy~P!-jO!V'_a!X'_a~P#(yO!X%Sq^%Sq!V%Sq'j%Sq~P#(yOX9]O~O!V0_O!W(uq~O#W9aO!V'aa!W'aa~O!V4tO!W(ri~P#?dOPYXXYXkYXyYXzYX|YX!SYX!VYX!eYX!fYX!hYX!lYX#WYX#ccX#fYX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#pYX#rYX#tYX#uYX#zYX(QYX(`YX(gYX(hYX~O!a%QX#n%QX~P&6lO#S-cO#T-cO~PBtO#P9eO#S-cO#T-cO~PBtO!}9fO#O9fO#P9eO#S-cO#T-cO~PBtO!]9iO!^9iO't!iO(T!jO(_!nO~O![9lO!]9iO!^9iO#P9eO#S-cO#T-cO't!iO~PBtO!X0zO%`9oO~O'uTO'xUO(T9tO~O!V1VO!W(sq~O!g9wO~O!g9wO~P%QO!g9yO~O!g9zO~O#W9|O!V#`y!W#`y~O!V#`y!W#`y~P#?dO^%^O#W:QO'j%^O~O^%^O!a#rO#W:QO'j%^O~O^%^O!a#rO!l:UO#W:QO'j%^O(`'dO~O!X'QO%`:XO~O#x#vy!V#vy!W#vy~P#?dOP$tiX$tik$tiz$ti!e$ti!f$ti!h$ti!l$ti#f$ti#g$ti#h$ti#i$ti#j$ti#k$ti#l$ti#m$ti#n$ti#p$ti#r$ti#t$ti#u$ti#x$ti(Q$ti(`$ti!V$ti!W$ti~P%AYOy)sO|)tO(h)xOP%WiX%Wig%Wik%Wiz%Wi!e%Wi!f%Wi!h%Wi!l%Wi#f%Wi#g%Wi#h%Wi#i%Wi#j%Wi#k%Wi#l%Wi#m%Wi#n%Wi#p%Wi#r%Wi#t%Wi#u%Wi#x%Wi(Q%Wi(`%Wi(g%Wi!V%Wi!W%Wi~Oy)sO|)tOP%YiX%Yig%Yik%Yiz%Yi!e%Yi!f%Yi!h%Yi!l%Yi#f%Yi#g%Yi#h%Yi#i%Yi#j%Yi#k%Yi#l%Yi#m%Yi#n%Yi#p%Yi#r%Yi#t%Yi#u%Yi#x%Yi(Q%Yi(`%Yi(g%Yi(h%Yi!V%Yi!W%Yi~O#x$hy!V$hy!W$hy~P#?dO#x#Zy!V#Zy!W#Zy~P#?dO!a#rO!V'Yq!g'Yq~O!V/VO!g(my~O!S'[q!V'[q~P#(yO!S:`O~P#(yO!V0_O!W(uy~O!V4tO!W(rq~O#S2fO#T2fO~PBtO#P:gO#S2fO#T2fO~PBtO!]:kO!^:kO't!iO(T!jO(_!nO~O!X0zO%`:nO~O!g:qO~O^%^O#W:vO'j%^O~O^%^O!a#rO#W:vO'j%^O~O!X'QO%`:{O~OP$tqX$tqk$tqz$tq!e$tq!f$tq!h$tq!l$tq#f$tq#g$tq#h$tq#i$tq#j$tq#k$tq#l$tq#m$tq#n$tq#p$tq#r$tq#t$tq#u$tq#x$tq(Q$tq(`$tq!V$tq!W$tq~P%AYOP$vqX$vqk$vqz$vq!e$vq!f$vq!h$vq!l$vq#f$vq#g$vq#h$vq#i$vq#j$vq#k$vq#l$vq#m$vq#n$vq#p$vq#r$vq#t$vq#u$vq#x$vq(Q$vq(`$vq!V$vq!W$vq~P%AYOd%[!Z!V%[!Z#W%[!Z#x%[!Z~P!-jO!V'aq!W'aq~P#?dO#S6`O#T6`O~PBtO!V#`!Z!W#`!Z~P#?dO^%^O#W;ZO'j%^O~O#c%[!ZP%[!ZX%[!Z^%[!Zk%[!Zz%[!Z!V%[!Z!e%[!Z!f%[!Z!h%[!Z!l%[!Z#f%[!Z#g%[!Z#h%[!Z#i%[!Z#j%[!Z#k%[!Z#l%[!Z#m%[!Z#n%[!Z#p%[!Z#r%[!Z#t%[!Z#u%[!Z'j%[!Z(Q%[!Z(`%[!Z!g%[!Z!S%[!Z'h%[!Z#W%[!Zo%[!Z!X%[!Z%`%[!Z!a%[!Z~P#(yOP%[!ZX%[!Zk%[!Zz%[!Z!e%[!Z!f%[!Z!h%[!Z!l%[!Z#f%[!Z#g%[!Z#h%[!Z#i%[!Z#j%[!Z#k%[!Z#l%[!Z#m%[!Z#n%[!Z#p%[!Z#r%[!Z#t%[!Z#u%[!Z#x%[!Z(Q%[!Z(`%[!Z!V%[!Z!W%[!Z~P%AYOo(UX~P1dO't!iO~P!'RO!ScX!VcX#WcX~P&6lOPYXXYXkYXyYXzYX|YX!VYX!VcX!eYX!fYX!hYX!lYX#WYX#WcX#ccX#fYX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#pYX#rYX#tYX#uYX#zYX(QYX(`YX(gYX(hYX~O!acX!gYX!gcX(`cX~P'!sOP;nOQ;nOa=_Ob!fOikOk;nOlkOmkOskOu;nOw;nO|WO!QkO!RkO!XXO!c;qO!hZO!k;nO!l;nO!m;nO!o;rO!q;sO!t!eO$P!hO$TfO's)RO'uTO'xUO(QVO(_[O(l=]O~O!V<SO!W$ja~Oi%POk$qOl$pOm$pOs%QOu%ROw<YO|$xO!X$yO!c=dO!h$uO#b<`O$P%VO$l<[O$n<^O$q%WO's(iO'uTO'xUO'|%OO(Q$rO~O#o)YO~P''iO!WYX!WcX~P'!sO#c;vO~O!a#rO#c;vO~O#W<WO~O#n;{O~O#W<bO!V(eX!W(eX~O#W<WO!V(cX!W(cX~O#c<cO~Od<eO~P!-jO#c<jO~O#c<kO~O!a#rO#c<lO~O!a#rO#c<cO~O#x<mO~P#?dO#c<nO~O#c<oO~O#c<pO~O#c<qO~O#c<rO~O#c<sO~O#x<tO~P!-jO#x<uO~P!-jO$T~!f!|#O#P#S#a#b#m(l$l$n$q%T%_%`%a%g%i%l%m%o%q~'nR$T(l#g!R'l't#hl#f#iky'm(T'm's$V$X$V~",
  goto: "$/X(yPPPP(zP(}P)_P+a/fPPPP6iPP7OP<|@mPAQPAQPPPAQPBpPAQPAQPAQPBtPPByPCdPH`PPPHdPPPPHdKfPPPKlMlPHdP!!SPPPP!$eHdPPPHdPHdP!&vHdP!*]!+_!+dP!,U!,Y!,UPPPP!/f!1kPP!1t!3OP!+_HdHd!6b!9m!>v!>v!BnPPP!BuHdPPPPPPPPPPP!FTP!GiPPHd!HyPHdPHdHdHdHdPHd!J`PP!MiP#!nP#!r#!|##Q##QP!MfP##U##UP#&ZP#&_HdHd#&e#)iAQPAQPAQAQP#*sAQAQ#,mAQ#.zAQ#0nAQAQ#1[#3W#3W#3[#3d#3W#3lP#3WPAQ#4hAQ#5pAQAQ6iPPP#6{PP#7e#7eP#7eP#7z#7ePP#8QP#7wP#7w#8d!1p#7w#9O#9U6f(}#9X(}P#9`#9`#9`P(}P(}P(}P(}PP(}P#9f#9iP#9i(}P#9mP#9pP(}P(}P(}P(}P(}P(}(}PP#9v#9|#:W#:^#:d#:j#:p#;O#;U#;[#;f#;l#<h#<w#<}#=a#=g#=m#={#>b#?r#@Q#@W#@^#@d#@j#@t#@z#AQ#A[#An#AtPPPPPPPPPP#AzPPPPPPP#Bn#FYP#Gu#G|#HUPPPP#L`$ U$'t$'w$'z$)w$)z$)}$*UPP$*[$*`$+X$,X$,]$,qPP$,u$,{$-PP$-S$-W$-Z$.P$.g$.l$.o$.r$.x$.{$/P$/TR!yRmpOXr!X#a%]&d&f&g&i,^,c1g1jU!pQ'Q-OQ%ctQ%kwQ%rzQ&[!TS&x!c,vQ'W!f[']!m!r!s!t!u!vS*[$y*aQ+U%lQ+c%tQ+}&UQ,|'PQ-W'XW-`'^'_'`'aQ/p*cQ1U,OU2b-b-d-eS4}0z5QS6[2e2gU7z5U5V5WQ8q6_S9i7{7|Q:k9lR<a;r%QdOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&d&f&g&i&m&u'S'f'v'x(O(Y(k(o(s)r*t+h,Y,^,c-S-[-o-x.b.i/z0P0^0}1_1`1a1c1g1j1l2]2k2}4y5]5o5q5r6U7w8R8`8l:Q:v;ZS#m];o!r)T$X$j&y)g,o,r.q1{3d4v5{9a9|;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`Q*l%SQ+Z%nQ,P&XQ,W&aQ.X<XQ0T*|Q0X+OQ0d+[Q1^,UQ2q.UQ4e0_Q5d1VQ6i2uQ6o<YQ7b4fR8x6j'OkOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'f'v'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`#S!kQ!m!p!r!s!t!u!v!w&x'P'Q']'^'_'`'a'b,v,|-O-`-b-c-d-e0z2b2e2f2g4z5Q5S5T5U5V6[6_6`7p7q7r7|8q9e9f:g$Y$pi#r#t$`$a$u$x%T%U%Y)n)w)y)z*R*X*g*h*{+O+m+p.T._/^/_/a/|0q0t0|2t3l3v4O4U4]4_5[6g6}7W8O8u9Q9o:X:n:{<U<V<Z<[<]<^<_<`<f<g<h<i<j<k<n<o<p<q<t<u=]=e=f=i=jQ%uzQ&v!cS&|%w,yQ+Z%nS.})t/PQ/{*pQ0d+[Q0i+bQ1],TQ1^,UQ4e0_Q4n0kQ5g1XQ5h1[Q7b4fQ7e4kQ8Z5jQ9`7fR9u8WpmOXr!T!X#a%]&Z&d&f&g&i,^,c1g1jR,R&]&x`OPXYrstux!X!^!g!l#P#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u'S'f'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=_=`[#YWZ#T#W&y'vQ%fvQ%jwS%oz%t!U%x|}#d#f#i%Z%v(P(W(X(]+f+g+i,[,p-s-v-z-{-}1o2m2n5z6dQ&Q!RQ'T!eQ'V!fQ(d#oS*O$u*SS+T%k%lQ+X%nQ+x&SQ+|&US-V'W'XQ.W(eQ/Z*PQ0]+UQ0c+[Q0e+]Q0h+aQ1P+yS1T+},OQ2X-WQ3m/VQ4d0_Q4h0bQ4m0jQ5c1UQ6z3nQ7a4fQ7d4jQ9[7`R:b9]v$wi#t%T%U%Y)w)y*R*g*h._/^/|3l4U9Q=]=e=f!`%hw!f!o%j%k%l&w'V'W'X'['i*Z+T+U,s-V-W-_-a/h0]2Q2X2`2d4Q6Y6^8o:TQ*}%fQ+n%}Q+q&OQ+{&UQ.V(dQ1O+xU1S+|+},OQ2v.WQ5^1PS5b1T1US7n4x4|Q8V5cU9g7s7x7yU:i9h9j9kQ;R:jQ;a;S!z=a#r$`$a$u$x)n)z*X*{+O+m+p.T/_/a0q0t0|2t3v4O4]4_5[6g6}7W8O8u9o:X:n:{<Z<]<_<f<h<j<n<p<t=i=jg=b<U<V<[<^<`<g<i<k<o<q<uW$|i%O*i=]S%}!O&ZQ&O!PQ&P!QR+l%{$Z${i#r#t$`$a$u$x%T%U%Y)n)w)y)z*R*X*g*h*{+O+m+p.T._/^/_/a/|0q0t0|2t3l3v4O4U4]4_5[6g6}7W8O8u9Q9o:X:n:{<U<V<Z<[<]<^<_<`<f<g<h<i<j<k<n<o<p<q<t<u=]=e=f=i=jT)o$r)pV*m%S<X<YU&|!c%w,yS(r#v#wQ+`%qS.P(`(aQ0u+rQ4V/yR7j4t'OkOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'f'v'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`$o$]c#V#b%a%b%d'u'{(g(n(v(w(x(y(z({(|(})O)P)Q)S)V)Z)e*y+_,t-h-m-r-w.^.d.h.j.k.l.{/}1v1y2Z2j2|3R3S3T3U3V3W3X3Y3Z3[3]3^3_3b3c3h4Z4b5}6T6b6m6n6s6t7l8f8j8y8}9O:O:d:r:t;X;d;p=ST#QV#R'PkOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'f'v'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`Q&z!cR1|,v!z!kQ!c!m!p!r!s!t!u!v!w&x'P'Q']'^'_'`'a'b,v,|-O-`-b-c-d-e2b2e2f2g4z5S5T6[6_6`7p7q7r8q9e9f:gS*Z$y*aS/h*[*cQ/q*dQ0w+tQ4Q/pQ4T/sS4x0z5QS7s4}5WS7x5U5VS9h7z7{Q9j7|S:j9i9lR;S:klpOXr!X#a%]&d&f&g&i,^,c1g1jQ&k![Q'j!tS(f#q;vQ+R%iQ+v&QQ+w&RQ-T'UQ-g'cS.](k<cS0O*t<lQ0Z+SQ0y+uQ1n,eQ1p,fQ1x,qQ2V-UQ2Y-YS4[0P<rQ4`0[S4c0^<sQ5|1zQ6Q2WQ6V2_Q7_4aQ8g6OQ8h6RQ8k6WQ9{8dQ:P8mQ:u:RR;Y:w$j$[c#V#b%b%d'u'{(g(n(v(w(x(y(z({(|(})O)P)Q)S)V)Z)e*y+_,t-h-m-r-w.^.d.h.k.l.{/}1v1y2Z2j2|3R3S3T3U3V3W3X3Y3Z3[3]3^3_3b3c3h4Z4b5}6T6b6m6n6s6t7l8f8j8y8}9O:O:d:r:t;X;d;p=SS(c#l'ZU*f$z(j3aS*x%a.jQ2r0TQ6f2qQ8w6iR:Y8x$j$Zc#V#b%b%d'u'{(g(n(v(w(x(y(z({(|(})O)P)Q)S)V)Z)e*y+_,t-h-m-r-w.^.d.h.k.l.{/}1v1y2Z2j2|3R3S3T3U3V3W3X3Y3Z3[3]3^3_3b3c3h4Z4b5}6T6b6m6n6s6t7l8f8j8y8}9O:O:d:r:t;X;d;p=SS(b#l'ZS(t#w$[S*w%a.jS.Q(a(cQ.m)UQ0Q*xR2o.R'OkOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'f'v'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`S#m];oQ&f!VQ&g!WQ&i!YQ&j!ZR1f,aQ'R!eQ*z%fQ-R'TS.S(d*}Q2T-QW2s.V.W0S0UQ6P2UU6e2p2r2vS8t6f6hS:W8v8wS:y:V:YQ;[:zR;e;]V!qQ'Q-O!_^OQXZ_r!T!X!m#a#d%Z%]&Z&]&d&f&g&i'Q(],^,c-O-z0z1g1j4z5QT#m];o%[yOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'f'v'x(O(Y(k(o(s)r*t*|+h,Y,^,c-S-[-o-x.U.b.i/z0P0^0}1_1`1a1c1g1j1l2]2k2u2}4y5]5o5q5r6U6j7w8R8`8l:Q:v;ZS(r#v#wS.P(`(a!s<y$X$j&y)g,o,r.q1{3d4v5{9a9|;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`U!oQ'Q-OY'[!m!s!t!u!vS'i!p!rW'k!w4z5S5TS-_']'^U-a'_'`'aW-f'b7p7q7rS2`-`-bU2c-c9e9fS2d-d-eS4|0z5QS6Y2b2eS6]2f:gQ6^2gS7s4}5WS7y5U5VS8o6[6_Q8r6`S9h7z7{Q9k7|Q:T8qS:j9i9lR;S:kU!qQ'Q-OT5O0z5QU'h!o4{4|S([#e1dU-^'['k7yQ/Y*OQ/f*ZU2a-a-f9kQ3r/ZS3{/g/qS6Z2c2dQ6y3mS7U4R4TS8p6]6^Q9S6zQ9Z7XR:U8rQ#sbU'g!o4{4|S(Z#e1dQ*u%[Q+P%gQ+V%mW-]'['h'k7yQ-y([Q/X*OQ/e*ZQ/k*^Q0Y+QQ1Q+zW2^-^-a-f9kS3q/Y/ZS3z/f/qQ3}/jQ4P/lQ5`1RU6X2a2c2dQ6x3mQ6|3rS7Q3{4TQ7V4SQ8T5aU8n6Z6]6^S9R6y6zQ9V7RQ9X7UQ9c7mQ9r8US:S8p8rQ:^9SQ:_9WQ:a9ZQ:f9dQ:p9sQ:x:UQ:}:`Q;P:hQ;_;QQ;h;`Q;l;iQ<|<wQ=X=QR=Y=R%[aOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'f'v'x(O(Y(k(o(s)r*t*|+h,Y,^,c-S-[-o-x.U.b.i/z0P0^0}1_1`1a1c1g1j1l2]2k2u2}4y5]5o5q5r6U6j7w8R8`8l:Q:v;ZS#sx!g!r<v$X$j&y)g,o,r.q1{3d4v5{9a9|;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`R<|=_%[bOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'f'v'x(O(Y(k(o(s)r*t*|+h,Y,^,c-S-[-o-x.U.b.i/z0P0^0}1_1`1a1c1g1j1l2]2k2u2}4y5]5o5q5r6U6j7w8R8`8l:Q:v;ZQ%[j!`%gw!f!o%j%k%l&w'V'W'X'['i*Z+T+U,s-V-W-_-a/h0]2Q2X2`2d4Q6Y6^8o:TS%mx!gQ+Q%hQ+z&UW1R+{+|+},OU5a1S1T1US7m4x4|S8U5b5cW9d7n7s7x7yQ9s8VW:h9g9h9j9kS;Q:i:jS;`;R;SQ;i;a!r<w$X$j&y)g,o,r.q1{3d4v5{9a9|;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`Q=Q=^R=R=_%OeOPXYrstu!X!^!l#P#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&d&f&g&i&m&u'S'f'x(O(Y(k(o(s)r*t*|+h,Y,^,c-S-[-o-x.U.b.i/z0P0^0}1_1`1a1c1g1j1l2]2k2u2}4y5]5o5q5r6U6j7w8R8`8l:Q:v;ZY#_WZ#T#W'v!U%x|}#d#f#i%Z%v(P(W(X(]+f+g+i,[,p-s-v-z-{-}1o2m2n5z6dQ,X&a!p<x$X$j)g,o,r.q1{3d4v5{9a9|;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`R<{&yS&}!c%wR2O,y%QdOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&d&f&g&i&m&u'S'f'v'x(O(Y(k(o(s)r*t+h,Y,^,c-S-[-o-x.b.i/z0P0^0}1_1`1a1c1g1j1l2]2k2}4y5]5o5q5r6U7w8R8`8l:Q:v;Z!r)T$X$j&y)g,o,r.q1{3d4v5{9a9|;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`Q,W&aQ0T*|Q2q.UQ6i2uR8x6j!l$Rc#V%a'u'{(g(n(})O)P)Q)V)Z+_-h-m-r-w.^.d.{/}2Z2j2|3_4Z4b6T6b6m8j:O:t;X;d;p!T;})S)e,t.j1v1y3R3Z3[3]3^3b3h5}6n6s6t7l8f8y8}9O:d:r=S!h$Tc#V%a'u'{(g(n)P)Q)V)Z+_-h-m-r-w.^.d.{/}2Z2j2|3_4Z4b6T6b6m8j:O:t;X;d;p!P<P)S)e,t.j1v1y3R3]3^3b3h5}6n6s6t7l8f8y8}9O:d:r=S!d$Xc#V%a'u'{(g(n)V)Z+_-h-m-r-w.^.d.{/}2Z2j2|3_4Z4b6T6b6m8j:O:t;X;d;pQ3l/Tz=`)S)e,t.j1v1y3R3b3h5}6n6s6t7l8f8y8}9O:d:r=SQ=e=gR=f=h'OkOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'f'v'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`S$kh$lR3e.p'VgOPWXYZhrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j$l%]%c%p&]&`&a&d&f&g&i&m&u&y'S'f'v'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.p.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`T$gf$mQ$efS)^$h)bR)j$mT$ff$mT)`$h)b'VhOPWXYZhrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j$l%]%c%p&]&`&a&d&f&g&i&m&u&y'S'f'v'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.p.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`T$kh$lQ$nhR)i$l%[jOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'f'v'x(O(Y(k(o(s)r*t*|+h,Y,^,c-S-[-o-x.U.b.i/z0P0^0}1_1`1a1c1g1j1l2]2k2u2}4y5]5o5q5r6U6j7w8R8`8l:Q:v;Z!s=^$X$j&y)g,o,r.q1{3d4v5{9a9|;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`#alOPXZr!X!^!l#P#a#k#x$j%]&]&`&a&d&f&g&i&m&u'S(s)g*|+h,Y,^,c-S.U.q/z0}1_1`1a1c1g1j1l2u3d4y5]5o5q5r6j7w8R8`v$zi#t%T%U%Y)w)y*R*g*h._/^/|3l4U9Q=]=e=f!z(j#r$`$a$u$x)n)z*X*{+O+m+p.T/_/a0q0t0|2t3v4O4]4_5[6g6}7W8O8u9o:X:n:{<Z<]<_<f<h<j<n<p<t=i=jQ*q%WQ.|)sg3a<U<V<[<^<`<g<i<k<o<q<uv$vi#t%T%U%Y)w)y*R*g*h._/^/|3l4U9Q=]=e=fQ*T$wS*^$y*aQ*r%XQ/l*_!z=O#r$`$a$u$x)n)z*X*{+O+m+p.T/_/a0q0t0|2t3v4O4]4_5[6g6}7W8O8u9o:X:n:{<Z<]<_<f<h<j<n<p<t=i=jf=P<U<V<[<^<`<g<i<k<o<q<uQ=T=aQ=U=bQ=V=cR=W=dv$zi#t%T%U%Y)w)y*R*g*h._/^/|3l4U9Q=]=e=f!z(j#r$`$a$u$x)n)z*X*{+O+m+p.T/_/a0q0t0|2t3v4O4]4_5[6g6}7W8O8u9o:X:n:{<Z<]<_<f<h<j<n<p<t=i=jg3a<U<V<[<^<`<g<i<k<o<q<ulnOXr!X#a%]&d&f&g&i,^,c1g1jQ*W$xQ,l&pQ,m&rR3u/_$Y${i#r#t$`$a$u$x%T%U%Y)n)w)y)z*R*X*g*h*{+O+m+p.T._/^/_/a/|0q0t0|2t3l3v4O4U4]4_5[6g6}7W8O8u9Q9o:X:n:{<U<V<Z<[<]<^<_<`<f<g<h<i<j<k<n<o<p<q<t<u=]=e=f=i=jQ+o&OQ0s+qQ4r0rR7i4sT*`$y*aS*`$y*aT5P0z5QS/j*]4yT4S/r7wQ+P%gQ/k*^Q0Y+QQ1Q+zQ5`1RQ8T5aQ9c7mQ9r8UQ:f9dQ:p9sQ;P:hQ;_;QQ;h;`R;l;in)w$s(l*s/]/t/u2z3s4Y6w7Y:]<}=Z=[!W<f(h)X)}*V.[.x/T/b0R0p0r2y3t3x4q4s6k6l7O7S7[7^9U9Y:|=g=h]<g3`6r8z:Z:[;fp)y$s(l*s/R/]/t/u2z3s4Y6w7Y:]<}=Z=[!Y<h(h)X)}*V.[.x/T/b0R0p0r2w2y3t3x4q4s6k6l7O7S7[7^9U9Y:|=g=h_<i3`6r8z8{:Z:[;fpmOXr!T!X#a%]&Z&d&f&g&i,^,c1g1jQ&W!SR,Y&apmOXr!T!X#a%]&Z&d&f&g&i,^,c1g1jR&W!SQ+s&PR0o+lqmOXr!T!X#a%]&Z&d&f&g&i,^,c1g1jQ0{+xS5Z1O1PU7}5X5Y5^S9n8P8QS:l9m9pQ;T:mR;b;UQ&_!TR,S&ZR5g1XS%oz%tR0e+]Q&d!UR,^&eR,d&jT1h,c1jR,h&kQ,g&kR1q,hQ'm!xR-i'mQrOQ#aXT%`r#aQ!{TR'o!{Q#OUR'q#OQ)p$rR.y)pQ#RVR's#RQ#UWU'y#U'z-pQ'z#VR-p'{Q,w&zR1},wQ.`(lR2{.`Q.c(nS3O.c3PR3P.dQ-O'QR2R-Or_OXr!T!X#a%]&Z&]&d&f&g&i,^,c1g1jU!mQ'Q-OS#dZ%ZY#n_!m#d-z4zQ-z(]T4z0z5QS#[W%vU(Q#[(R-qQ(R#]R-q'|Q,z&}R2P,zQ(^#gQ-t(VW.O(^-t2h6aQ2h-uR6a2iQ)b$hR.r)bQ$lhR)h$lQ$_cU)W$_-l<TQ-l;pR<T)eQ/W*OW3o/W3p6{9TU3p/X/Y/ZS6{3q3rR9T6|#m)u$s(h(l)X)}*V*n*o*s.Y.Z.[.x/R/S/T/]/b/t/u0R0p0r2w2x2y2z3`3s3t3x4Y4q4s6k6l6p6q6r6w7O7S7Y7[7^8z8{8|9U9Y:Z:[:]:|;f<}=Z=[=g=hQ/`*VU3w/`3y7PQ3y/bR7P3xQ*a$yR/n*aQ*j$}R/w*jQ4^0RR7]4^Q+j%yR0n+jQ4u0uS7k4u9bR9b7lQ+u&QR0x+uQ5Q0zR7u5QQ1W,PS5e1W8XR8X5gQ0`+XW4g0`4i7c9^Q4i0cQ7c4hR9^7dQ+^%oR0f+^Q1j,cR5u1jWqOXr#aQ&h!XQ*v%]Q,]&dQ,_&fQ,`&gQ,b&iQ1e,^S1h,c1jR5t1gQ%_oQ&l!]Q&o!_Q&q!`Q&s!aU'e!o4{4|Q+e%uQ+k%zQ,R&_Q,j&nY-Z'['g'h'k7yQ/m*`S1Z,S,VQ1r,iQ1s,lQ1t,m[2[-]-^-a-f-h9kQ4l0iQ4p0pQ5_1QQ5i1]Q5s1fY6S2Z2^2a2c2dQ7g4nQ7h4qQ7t5PQ8S5`Q8Y5hY8i6T6X6Z6]6^Q9_7eQ9q8TQ9v8ZW9}8j8n8p8rQ:c9`Q:e9cQ:o9rU:s:O:S:UQ;O:fQ;V:pS;W:t:xQ;^;PQ;c;XQ;g;_Q;j;dQ;k;hR;m;lQ%iwQ'U!fQ'c!oU+S%j%k%lQ,q&wU-U'V'W'XS-Y'['iQ/d*ZS0[+T+UQ1z,sS2W-V-WS2_-_-aQ3|/hQ4a0]Q6O2QQ6R2XS6W2`2dQ7T4QS8m6Y6^Q:R8oR:w:TS$ti=]R*k%OU$}i%O=]R/v*iQ$siS(h#r+OQ(l#tS)X$`$aQ)}$uQ*V$xQ*n%TQ*o%UQ*s%YQ.Y<ZQ.Z<]Q.[<_Q.x)nQ/R)wQ/S)yQ/T)zQ/]*RQ/b*XQ/t*gQ/u*hh0R*{.T0|2t5[6g8O8u9o:X:n:{Q0p+mQ0r+pQ2w<fQ2x<hQ2y<jQ2z._S3`<U<VQ3s/^Q3t/_Q3x/aQ4Y/|Q4q0qQ4s0tQ6k<nQ6l<pQ6p<[Q6q<^Q6r<`Q6w3lQ7O3vQ7S4OQ7Y4UQ7[4]Q7^4_Q8z<kQ8{<gQ8|<iQ9U6}Q9Y7WQ:Z<oQ:[<qQ:]9QQ:|<tQ;f<uQ<}=]Q=Z=eQ=[=fQ=g=iR=h=jloOXr!X#a%]&d&f&g&i,^,c1g1jQ!dPS#cZ#kQ&n!^U'Y!l4y7wQ'r#PQ(u#xQ)f$jS,V&]&`Q,Z&aQ,i&mQ,n&uQ-Q'SQ.f(sQ.v)gQ0U*|Q0l+hQ1b,YQ2U-SQ2r.UQ3g.qQ4W/zQ5Y0}Q5k1_Q5l1`Q5n1aQ5p1cQ5w1lQ6f2uQ6u3dQ8Q5]Q8_5oQ8a5qQ8b5rQ8w6jQ9p8RR9x8`#UcOPXZr!X!^!l#a#k#x%]&]&`&a&d&f&g&i&m&u'S(s*|+h,Y,^,c-S.U/z0}1_1`1a1c1g1j1l2u4y5]5o5q5r6j7w8R8`Q#VWQ#bYQ%asQ%btQ%duS'u#T'xQ'{#WQ(g#qQ(n#uQ(v#{Q(w#|Q(x#}Q(y$OQ(z$PQ({$QQ(|$RQ(}$SQ)O$TQ)P$UQ)Q$VQ)S$XQ)V$^Q)Z$bW)e$j)g.q3dQ*y%cQ+_%pS,t&y1{Q-h'fS-m'v-oQ-r(OQ-w(YQ.^(kQ.d(oQ.h;nQ.j;qQ.k;rQ.l;sQ.{)rQ/}*tQ1v,oQ1y,rQ2Z-[Q2j-xQ2|.bQ3R;vQ3S;wQ3T;xQ3U;yQ3V;zQ3W;{Q3X;|Q3Y;}Q3Z<OQ3[<PQ3]<QQ3^<RQ3_.iQ3b<WQ3c<aQ3h<SQ4Z0PQ4b0^Q5}<bQ6T2]Q6b2kQ6m2}Q6n<cQ6s<eQ6t<lQ7l4vQ8f5{Q8j6UQ8y<mQ8}<rQ9O<sQ:O8lQ:d9aQ:r9|Q:t:QQ;X:vQ;d;ZQ;p#PR=S=`R#XWR&{!cU!oQ'Q-OS&w!c,vY'[!m!s!t!u!vS'i!p!r['k!w4z5S5T5U5VS,s&x'PS-_']'^U-a'_'`'aY-f'b7p7q7r7|Q2Q,|S2`-`-bU2c-c9e9fS2d-d-eS4{0z5QS6Y2b2eS6]2f:gQ6^2gS8o6[6_Q8r6`R:T8qR(m#tR(p#uQ!dQT,}'Q-OQ#l]R'Z;oT#hZ%ZS#gZ%ZU%y|},[U(V#d#f#iS-u(W(XQ-|(]Q0m+iQ2i-vU2l-z-{-}S6c2m2nR8s6d`#ZW#T#W%v'v(P+f-st#eZ|}#d#f#i%Z(W(X(]+i-v-z-{-}2m2n6dQ1d,[Q1w,pQ5y1oQ8e5zT<z&y+gT#^W%vS#]W%vS'w#T(PS'|#W+fS,u&y+gT-n'v-sT'O!c%wQ$hfR)l$mT)a$h)bR3f.pT*Q$u*SR*Y$xQ0S*{Q2p.TQ5X0|Q6h2tQ8P5[Q8v6gQ9m8OQ:V8uQ:m9oQ:z:XQ;U:nR;]:{lpOXr!X#a%]&d&f&g&i,^,c1g1jQ&^!TR,R&ZV%z|},[R0v+rR,Q&XQ%szR+d%tR+Y%nT&b!U&eT&c!U&eT1i,c1j",
  nodeNames: "⚠ ArithOp ArithOp LineComment BlockComment Script ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody MethodDeclaration AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 362,
  context: xV,
  nodeProps: [
    ["group", -26, 6, 14, 16, 62, 198, 202, 205, 206, 208, 211, 214, 225, 227, 233, 235, 237, 239, 242, 248, 254, 256, 258, 260, 262, 264, 265, "Statement", -32, 10, 11, 25, 28, 29, 35, 45, 48, 49, 51, 56, 64, 72, 76, 78, 80, 81, 102, 103, 112, 113, 130, 133, 135, 136, 137, 138, 140, 141, 161, 162, 164, "Expression", -23, 24, 26, 30, 34, 36, 38, 165, 167, 169, 170, 172, 173, 174, 176, 177, 178, 180, 181, 182, 192, 194, 196, 197, "Type", -3, 84, 95, 101, "ClassItem"],
    ["openedBy", 31, "InterpolationStart", 50, "[", 54, "{", 69, "(", 142, "JSXStartTag", 154, "JSXStartTag JSXStartCloseTag"],
    ["closedBy", 33, "InterpolationEnd", 44, "]", 55, "}", 70, ")", 143, "JSXSelfCloseEndTag JSXEndTag", 159, "JSXEndTag"]
  ],
  propSources: [_V],
  skippedNodes: [0, 3, 4, 268],
  repeatNodeCount: 32,
  tokenData: "$>y(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tu>PuvBavwDxwxGgxyMvyz! Qz{!![{|!%O|}!&]}!O!%O!O!P!'g!P!Q!1w!Q!R#0t!R![#3T![!]#@T!]!^#Aa!^!_#Bk!_!`#GS!`!a#In!a!b#N{!b!c$$z!c!}>P!}#O$&U#O#P$'`#P#Q$,w#Q#R$.R#R#S>P#S#T$/`#T#o$0j#o#p$4z#p#q$5p#q#r$7Q#r#s$8^#s$f%Z$f$g+g$g#BY>P#BY#BZ$9h#BZ$IS>P$IS$I_$9h$I_$I|>P$I|$I}$<s$I}$JO$<s$JO$JT>P$JT$JU$9h$JU$KV>P$KV$KW$9h$KW&FU>P&FU&FV$9h&FV;'S>P;'S;=`BZ<%l?HT>P?HT?HU$9h?HUO>P(n%d_$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$c&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$c&j'y!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU'y!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$c&j'vpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU'vpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX'vp'y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$c&j'vp'y!b'l(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST'w#S$c&j'm(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$c&j'vp'y!b'm(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$c&j!l$Ip'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#p$Id$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#p$Id$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2b3l_'u$(n$c&j'y!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k*r4r_$c&j'y!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k)`5vX$c&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q)`6jT$^#t$c&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#t6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y#t7bO$^#t#t7eP;=`<%l6y)`7kP;=`<%l5q*r7w]$^#t$c&j'y!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}%W8uZ'y!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p%W9oU$^#t'y!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}%W:UP;=`<%l8p*r:[P;=`<%l4k#%|:hg$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}st%Ztu<Puw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}<P!}#O%Z#O#P&c#P#R%Z#R#S<P#S#T%Z#T#o<P#o#p*g#p$g%Z$g;'S<P;'S;=`=y<%lO<P#%|<[i$c&j(_!L^'vp'y!bOY%ZYZ&cZr%Zrs&}st%Ztu<Puw%Zwx(rx!Q%Z!Q![<P![!^%Z!^!_*g!_!c%Z!c!}<P!}#O%Z#O#P&c#P#R%Z#R#S<P#S#T%Z#T#o<P#o#p*g#p$g%Z$g;'S<P;'S;=`=y<%lO<P#%|=|P;=`<%l<P(CS>`k$c&j'vp'y!b(T!LY's&;d$V#tOY%ZYZ&cZr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$g%Z$g;'S>P;'S;=`BZ<%lO>P+d@`k$c&j'vp'y!b$V#tOY%ZYZ&cZr%Zrs&}st%Ztu@Tuw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![@T![!^%Z!^!_*g!_!c%Z!c!}@T!}#O%Z#O#P&c#P#R%Z#R#S@T#S#T%Z#T#o@T#o#p*g#p$g%Z$g;'S@T;'S;=`BT<%lO@T+dBWP;=`<%l@T(CSB^P;=`<%l>P%#SBl`$c&j'vp'y!b#h$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SCy_$c&j#z$Id'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%DfETa(h%<v$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sv%ZvwFYwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SFe`$c&j#t$Id'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2bGp_'x$)`$c&j'vpOYHoYZIuZrHorsIuswHowxKVx!^Ho!^!_LX!_#OHo#O#PIu#P#oHo#o#pLX#p;'SHo;'S;=`Mp<%lOHo*QHv_$c&j'vpOYHoYZIuZrHorsIuswHowxKVx!^Ho!^!_LX!_#OHo#O#PIu#P#oHo#o#pLX#p;'SHo;'S;=`Mp<%lOHo)`IzX$c&jOwIuwx6cx!^Iu!^!_Jg!_#oIu#o#pJg#p;'SIu;'S;=`KP<%lOIu#tJjTOwJgwx7]x;'SJg;'S;=`Jy<%lOJg#tJ|P;=`<%lJg)`KSP;=`<%lIu*QK`]$^#t$c&j'vpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r$fL^Z'vpOYLXYZJgZrLXrsJgswLXwxMPx#OLX#O#PJg#P;'SLX;'S;=`Mj<%lOLX$fMWU$^#t'vpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r$fMmP;=`<%lLX*QMsP;=`<%lHo(*QNR_!h(!b$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l! ]_!gM|$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!!ib$c&j'vp'y!b't#)d#i$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!#q{!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!#|`$c&j'vp'y!b#f$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!%Z`$c&j'vp'y!bk&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!&h_!V&;l$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!'rc$c&j'vp'y!by'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!(}!P!Q%Z!Q![!+g![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!)Wa$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!*]!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!*h_!UMt$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!+rg$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!+g![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S!+g#S#X%Z#X#Y!-Z#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!-dg$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!.{|}%Z}!O!.{!O!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!/Uc$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!0lc$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!2Sf$c&j'vp'y!b#g$IdOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}xz!3hz{#$s{!P!3h!P!Q#&Y!Q!^!3h!^!_!Mh!_!`#-x!`!a#/_!a!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(r!3sb$c&j'vp'y!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(Q!5U`$c&j'y!b!RSOY!4{YZ&cZw!4{wx!6Wx!P!4{!P!Q!=o!Q!^!4{!^!_!?g!_!}!4{!}#O!Bn#O#P!<w#P#o!4{#o#p!?g#p;'S!4{;'S;=`!Cw<%lO!4{&n!6_^$c&j!RSOY!6WYZ&cZ!P!6W!P!Q!7Z!Q!^!6W!^!_!8g!_!}!6W!}#O!;U#O#P!<w#P#o!6W#o#p!8g#p;'S!6W;'S;=`!=i<%lO!6W&n!7ba$c&j!RSO!^&c!_#Z&c#Z#[!7Z#[#]&c#]#^!7Z#^#a&c#a#b!7Z#b#g&c#g#h!7Z#h#i&c#i#j!7Z#j#m&c#m#n!7Z#n#o&c#p;'S&c;'S;=`&w<%lO&cS!8lX!RSOY!8gZ!P!8g!P!Q!9X!Q!}!8g!}#O!9p#O#P!:o#P;'S!8g;'S;=`!;O<%lO!8gS!9^U!RS#Z#[!9X#]#^!9X#a#b!9X#g#h!9X#i#j!9X#m#n!9XS!9sVOY!9pZ#O!9p#O#P!:Y#P#Q!8g#Q;'S!9p;'S;=`!:i<%lO!9pS!:]SOY!9pZ;'S!9p;'S;=`!:i<%lO!9pS!:lP;=`<%l!9pS!:rSOY!8gZ;'S!8g;'S;=`!;O<%lO!8gS!;RP;=`<%l!8g&n!;Z[$c&jOY!;UYZ&cZ!^!;U!^!_!9p!_#O!;U#O#P!<P#P#Q!6W#Q#o!;U#o#p!9p#p;'S!;U;'S;=`!<q<%lO!;U&n!<UX$c&jOY!;UYZ&cZ!^!;U!^!_!9p!_#o!;U#o#p!9p#p;'S!;U;'S;=`!<q<%lO!;U&n!<tP;=`<%l!;U&n!<|X$c&jOY!6WYZ&cZ!^!6W!^!_!8g!_#o!6W#o#p!8g#p;'S!6W;'S;=`!=i<%lO!6W&n!=lP;=`<%l!6W(Q!=xi$c&j'y!b!RSOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!=o#[#]&}#]#^!=o#^#a&}#a#b!=o#b#g&}#g#h!=o#h#i&}#i#j!=o#j#m&}#m#n!=o#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!?nZ'y!b!RSOY!?gZw!?gwx!8gx!P!?g!P!Q!@a!Q!}!?g!}#O!Ap#O#P!:o#P;'S!?g;'S;=`!Bh<%lO!?g!f!@hb'y!b!RSOY'}Zw'}x#O'}#P#Z'}#Z#[!@a#[#]'}#]#^!@a#^#a'}#a#b!@a#b#g'}#g#h!@a#h#i'}#i#j!@a#j#m'}#m#n!@a#n;'S'};'S;=`(f<%lO'}!f!AuX'y!bOY!ApZw!Apwx!9px#O!Ap#O#P!:Y#P#Q!?g#Q;'S!Ap;'S;=`!Bb<%lO!Ap!f!BeP;=`<%l!Ap!f!BkP;=`<%l!?g(Q!Bu^$c&j'y!bOY!BnYZ&cZw!Bnwx!;Ux!^!Bn!^!_!Ap!_#O!Bn#O#P!<P#P#Q!4{#Q#o!Bn#o#p!Ap#p;'S!Bn;'S;=`!Cq<%lO!Bn(Q!CtP;=`<%l!Bn(Q!CzP;=`<%l!4{'`!DW`$c&j'vp!RSOY!C}YZ&cZr!C}rs!6Ws!P!C}!P!Q!EY!Q!^!C}!^!_!GQ!_!}!C}!}#O!JX#O#P!<w#P#o!C}#o#p!GQ#p;'S!C};'S;=`!Kb<%lO!C}'`!Eci$c&j'vp!RSOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!EY#[#](r#]#^!EY#^#a(r#a#b!EY#b#g(r#g#h!EY#h#i(r#i#j!EY#j#m(r#m#n!EY#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!GXZ'vp!RSOY!GQZr!GQrs!8gs!P!GQ!P!Q!Gz!Q!}!GQ!}#O!IZ#O#P!:o#P;'S!GQ;'S;=`!JR<%lO!GQt!HRb'vp!RSOY)rZr)rs#O)r#P#Z)r#Z#[!Gz#[#])r#]#^!Gz#^#a)r#a#b!Gz#b#g)r#g#h!Gz#h#i)r#i#j!Gz#j#m)r#m#n!Gz#n;'S)r;'S;=`*Z<%lO)rt!I`X'vpOY!IZZr!IZrs!9ps#O!IZ#O#P!:Y#P#Q!GQ#Q;'S!IZ;'S;=`!I{<%lO!IZt!JOP;=`<%l!IZt!JUP;=`<%l!GQ'`!J`^$c&j'vpOY!JXYZ&cZr!JXrs!;Us!^!JX!^!_!IZ!_#O!JX#O#P!<P#P#Q!C}#Q#o!JX#o#p!IZ#p;'S!JX;'S;=`!K[<%lO!JX'`!K_P;=`<%l!JX'`!KeP;=`<%l!C}(r!Ksk$c&j'vp'y!b!RSOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[!Kh#[#]%Z#]#^!Kh#^#a%Z#a#b!Kh#b#g%Z#g#h!Kh#h#i%Z#i#j!Kh#j#m%Z#m#n!Kh#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W!Mq]'vp'y!b!RSOY!MhZr!Mhrs!?gsw!Mhwx!GQx!P!Mh!P!Q!Nj!Q!}!Mh!}#O#!U#O#P!:o#P;'S!Mh;'S;=`##U<%lO!Mh#W!Nse'vp'y!b!RSOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[!Nj#[#]*g#]#^!Nj#^#a*g#a#b!Nj#b#g*g#g#h!Nj#h#i*g#i#j!Nj#j#m*g#m#n!Nj#n;'S*g;'S;=`+Z<%lO*g#W#!]Z'vp'y!bOY#!UZr#!Urs!Apsw#!Uwx!IZx#O#!U#O#P!:Y#P#Q!Mh#Q;'S#!U;'S;=`##O<%lO#!U#W##RP;=`<%l#!U#W##XP;=`<%l!Mh(r##e`$c&j'vp'y!bOY##[YZ&cZr##[rs!Bnsw##[wx!JXx!^##[!^!_#!U!_#O##[#O#P!<P#P#Q!3h#Q#o##[#o#p#!U#p;'S##[;'S;=`#$g<%lO##[(r#$jP;=`<%l##[(r#$pP;=`<%l!3h(CS#%Qb$c&j'vp'y!b'n(;d!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(CS#&e_$c&j'vp'y!bR(;dOY#&YYZ&cZr#&Yrs#'dsw#&Ywx#*tx!^#&Y!^!_#,s!_#O#&Y#O#P#(f#P#o#&Y#o#p#,s#p;'S#&Y;'S;=`#-r<%lO#&Y(Bb#'m]$c&j'y!bR(;dOY#'dYZ&cZw#'dwx#(fx!^#'d!^!_#)w!_#O#'d#O#P#(f#P#o#'d#o#p#)w#p;'S#'d;'S;=`#*n<%lO#'d(AO#(mX$c&jR(;dOY#(fYZ&cZ!^#(f!^!_#)Y!_#o#(f#o#p#)Y#p;'S#(f;'S;=`#)q<%lO#(f(;d#)_SR(;dOY#)YZ;'S#)Y;'S;=`#)k<%lO#)Y(;d#)nP;=`<%l#)Y(AO#)tP;=`<%l#(f(<v#*OW'y!bR(;dOY#)wZw#)wwx#)Yx#O#)w#O#P#)Y#P;'S#)w;'S;=`#*h<%lO#)w(<v#*kP;=`<%l#)w(Bb#*qP;=`<%l#'d(Ap#*}]$c&j'vpR(;dOY#*tYZ&cZr#*trs#(fs!^#*t!^!_#+v!_#O#*t#O#P#(f#P#o#*t#o#p#+v#p;'S#*t;'S;=`#,m<%lO#*t(<U#+}W'vpR(;dOY#+vZr#+vrs#)Ys#O#+v#O#P#)Y#P;'S#+v;'S;=`#,g<%lO#+v(<U#,jP;=`<%l#+v(Ap#,pP;=`<%l#*t(=h#,|Y'vp'y!bR(;dOY#,sZr#,srs#)wsw#,swx#+vx#O#,s#O#P#)Y#P;'S#,s;'S;=`#-l<%lO#,s(=h#-oP;=`<%l#,s(CS#-uP;=`<%l#&Y%#W#.Vb$c&j#z$Id'vp'y!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h+h#/lb$S#t$c&j'vp'y!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h$/l#1Pp$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!+g!P!Q%Z!Q![#3T![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S#3T#S#U%Z#U#V#6_#V#X%Z#X#Y!-Z#Y#b%Z#b#c#5T#c#d#9g#d#l%Z#l#m#<i#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#3`k$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!+g!P!Q%Z!Q![#3T![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S#3T#S#X%Z#X#Y!-Z#Y#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#5`_$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#6hd$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#7v!R!S#7v!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#7v#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#8Rf$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#7v!R!S#7v!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#7v#S#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#9pc$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#:{!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#:{#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;We$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#:{!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#:{#S#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#<rg$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#>Z![!^%Z!^!_*g!_!c%Z!c!i#>Z!i#O%Z#O#P&c#P#R%Z#R#S#>Z#S#T%Z#T#Z#>Z#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>fi$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#>Z![!^%Z!^!_*g!_!c%Z!c!i#>Z!i#O%Z#O#P&c#P#R%Z#R#S#>Z#S#T%Z#T#Z#>Z#Z#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#@b_!a$b$c&j#x%<f'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Al_^l$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS#Bz^'|!*v!e'.r'vp'y!b$T)d(lSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Cv!Q!^*g!^!_#Dl!_!`#F^!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#DPX$e&j'vp'y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#DuZ#j$Id'vp'y!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Eh!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#EqX#z$Id'vp'y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#FgX#k$Id'vp'y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh#G_a#W%?x$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a#Hd!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W#Ho_#c$Ih$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#I}adBf#k$Id$`#|$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`#KS!`!a#L^!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#K__#k$Id$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#Lia#j$Id$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`!a#Mn!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#My`#j$Id$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$ Wc(`$Ip$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$!c!P!^%Z!^!_*g!_!a%Z!a!b$#m!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$!n_z'#p$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$#x`$c&j#u$Id'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$%V_!x!Ln$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$&a_|(8n$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$'eZ$c&jO!^$(W!^!_$(n!_#i$(W#i#j$(s#j#l$(W#l#m$*f#m#o$(W#o#p$(n#p;'S$(W;'S;=`$,q<%lO$(W(n$(_T[#S$c&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$(sO[#S(n$(x[$c&jO!Q&c!Q![$)n![!^&c!_!c&c!c!i$)n!i#T&c#T#Z$)n#Z#o&c#o#p$,U#p;'S&c;'S;=`&w<%lO&c(n$)sZ$c&jO!Q&c!Q![$*f![!^&c!_!c&c!c!i$*f!i#T&c#T#Z$*f#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$*kZ$c&jO!Q&c!Q![$+^![!^&c!_!c&c!c!i$+^!i#T&c#T#Z$+^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$+cZ$c&jO!Q&c!Q![$(W![!^&c!_!c&c!c!i$(W!i#T&c#T#Z$(W#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$,XR!Q![$,b!c!i$,b#T#Z$,b#S$,eS!Q![$,b!c!i$,b#T#Z$,b#q#r$(n(n$,tP;=`<%l$(W!'l$-S_!SM|$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$.^`#r$Id$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$/k_$c&j'vp'y!b(Q&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$0yk$c&j'vp'y!b(T!LY's&;d$X#tOY%ZYZ&cZr%Zrs&}st%Ztu$0juw%Zwx(rx}%Z}!O$2n!O!Q%Z!Q![$0j![!^%Z!^!_*g!_!c%Z!c!}$0j!}#O%Z#O#P&c#P#R%Z#R#S$0j#S#T%Z#T#o$0j#o#p*g#p$g%Z$g;'S$0j;'S;=`$4t<%lO$0j+d$2yk$c&j'vp'y!b$X#tOY%ZYZ&cZr%Zrs&}st%Ztu$2nuw%Zwx(rx}%Z}!O$2n!O!Q%Z!Q![$2n![!^%Z!^!_*g!_!c%Z!c!}$2n!}#O%Z#O#P&c#P#R%Z#R#S$2n#S#T%Z#T#o$2n#o#p*g#p$g%Z$g;'S$2n;'S;=`$4n<%lO$2n+d$4qP;=`<%l$2n(CS$4wP;=`<%l$0j!5p$5TX!X!3l'vp'y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Df$5{a(g%<v$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$#m#q;'S%Z;'S;=`+a<%lO%Z%#`$7__!W$I`o`$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$8i_!mS$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$9y|$c&j'vp'y!b'l(;d(T!LY's&;d$V#tOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$f%Z$f$g+g$g#BY>P#BY#BZ$9h#BZ$IS>P$IS$I_$9h$I_$JT>P$JT$JU$9h$JU$KV>P$KV$KW$9h$KW&FU>P&FU&FV$9h&FV;'S>P;'S;=`BZ<%l?HT>P?HT?HU$9h?HUO>P(CS$=Uk$c&j'vp'y!b'm(;d(T!LY's&;d$V#tOY%ZYZ&cZr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$g%Z$g;'S>P;'S;=`BZ<%lO>P",
  tokenizers: [TV, kV, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, wV, new ud("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOq~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!O~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(S~~", 141, 325), new ud("j~RQYZXz{^~^O'p~~aP!P!Qd~iO'q~~", 25, 307)],
  topRules: { Script: [0, 5], SingleExpression: [1, 266], SingleClassItem: [2, 267] },
  dialects: { jsx: 13213, ts: 13215 },
  dynamicPrecedences: { 76: 1, 78: 1, 162: 1, 190: 1 },
  specialized: [{ term: 311, get: (t) => WV[t] || -1 }, { term: 327, get: (t) => YV[t] || -1 }, { term: 67, get: (t) => RV[t] || -1 }],
  tokenPrec: 13238
});
var UV = [
  rt("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  rt("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  rt("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  rt("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  rt("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  rt(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  rt("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  rt(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  rt(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  rt('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  rt('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
];
var Km = new P1();
var hX = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function Na(t) {
  return (e, i) => {
    let n = e.node.getChild("VariableDefinition");
    return n && i(n, t), true;
  };
}
var VV = ["FunctionDeclaration"];
var qV = {
  FunctionDeclaration: Na("function"),
  ClassDeclaration: Na("class"),
  ClassExpression: () => true,
  EnumDeclaration: Na("constant"),
  TypeAliasDeclaration: Na("type"),
  NamespaceDeclaration: Na("namespace"),
  VariableDefinition(t, e) {
    t.matchContext(VV) || e(t, "variable");
  },
  TypeDefinition(t, e) {
    e(t, "type");
  },
  __proto__: null
};
function dX(t, e) {
  let i = Km.get(e);
  if (i)
    return i;
  let n = [], O = true;
  function r(a, o) {
    let s = t.sliceString(a.from, a.to);
    n.push({ label: s, type: o });
  }
  return e.cursor(ze.IncludeAnonymous).iterate((a) => {
    if (O)
      O = false;
    else if (a.name) {
      let o = qV[a.name];
      if (o && o(a, r) || hX.has(a.name))
        return false;
    } else if (a.to - a.from > 8192) {
      for (let o of dX(t, a.node))
        n.push(o);
      return false;
    }
  }), Km.set(e, n), n;
}
var Jm = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/;
var pX = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName"
];
function zV(t) {
  let e = Ye(t.state).resolveInner(t.pos, -1);
  if (pX.indexOf(e.name) > -1)
    return null;
  let i = e.name == "VariableName" || e.to - e.from < 20 && Jm.test(t.state.sliceDoc(e.from, e.to));
  if (!i && !t.explicit)
    return null;
  let n = [];
  for (let O = e; O; O = O.parent)
    hX.has(O.name) && (n = n.concat(dX(t.state.doc, O)));
  return {
    options: n,
    from: i ? e.from : t.pos,
    validFor: Jm
  };
}
var En = Kt.define({
  name: "javascript",
  parser: ZV.configure({
    props: [
      ci.add({
        IfStatement: gt({ except: /^\s*({|else\b)/ }),
        TryStatement: gt({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: Ep,
        SwitchBody: (t) => {
          let e = t.textAfter, i = /^\s*\}/.test(e), n = /^\s*(case|default)\b/.test(e);
          return t.baseIndent + (i ? 0 : n ? 1 : 2) * t.unit;
        },
        Block: dO({ closing: "}" }),
        ArrowFunction: (t) => t.baseIndent + t.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": gt({ except: /^{/ }),
        JSXElement(t) {
          let e = /^\s*<\//.test(t.textAfter);
          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
        },
        JSXEscape(t) {
          let e = /\s*\}/.test(t.textAfter);
          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(t) {
          return t.column(t.node.from) + t.unit;
        }
      }),
      ui.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression": Mn,
        BlockComment(t) {
          return { from: t.from + 2, to: t.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
});
var $X = {
  test: (t) => /^JSX/.test(t.name),
  facet: Kc({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
};
var QX = En.configure({ dialect: "ts" }, "typescript");
var gX = En.configure({
  dialect: "jsx",
  props: [qp.add((t) => t.isTop ? [$X] : void 0)]
});
var mX = En.configure({
  dialect: "jsx ts",
  props: [qp.add((t) => t.isTop ? [$X] : void 0)]
}, "typescript");
var CV = "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map((t) => ({ label: t, type: "keyword" }));
function go(t = {}) {
  let e = t.jsx ? t.typescript ? mX : gX : t.typescript ? QX : En;
  return new li(e, [
    En.data.of({
      autocomplete: Jp(pX, au(UV.concat(CV)))
    }),
    En.data.of({
      autocomplete: zV
    }),
    t.jsx ? IV : []
  ]);
}
function EV(t) {
  for (; ; ) {
    if (t.name == "JSXOpenTag" || t.name == "JSXSelfClosingTag" || t.name == "JSXFragmentTag")
      return t;
    if (!t.parent)
      return null;
    t = t.parent;
  }
}
function eS(t, e, i = t.length) {
  for (let n = e == null ? void 0 : e.firstChild; n; n = n.nextSibling)
    if (n.name == "JSXIdentifier" || n.name == "JSXBuiltin" || n.name == "JSXNamespacedName" || n.name == "JSXMemberExpression")
      return t.sliceString(n.from, Math.min(n.to, i));
  return "";
}
var jV = typeof navigator == "object" && /Android\b/.test(navigator.userAgent);
var IV = B.inputHandler.of((t, e, i, n) => {
  if ((jV ? t.composing : t.compositionStarted) || t.state.readOnly || e != i || n != ">" && n != "/" || !En.isActiveAt(t.state, e, -1))
    return false;
  let { state: O } = t, r = O.changeByRange((a) => {
    var o, s;
    let { head: l } = a, c = Ye(O).resolveInner(l, -1), u;
    if (c.name == "JSXStartTag" && (c = c.parent), n == ">" && c.name == "JSXFragmentTag")
      return { range: R.cursor(l + 1), changes: { from: l, insert: "></>" } };
    if (n == "/" && c.name == "JSXFragmentTag") {
      let h10 = c.parent, d = h10 == null ? void 0 : h10.parent;
      if (h10.from == l - 1 && ((o = d.lastChild) === null || o === void 0 ? void 0 : o.name) != "JSXEndTag" && (u = eS(O.doc, d == null ? void 0 : d.firstChild, l))) {
        let p = `/${u}>`;
        return { range: R.cursor(l + p.length), changes: { from: l, insert: p } };
      }
    } else if (n == ">") {
      let h10 = EV(c);
      if (h10 && ((s = h10.lastChild) === null || s === void 0 ? void 0 : s.name) != "JSXEndTag" && O.sliceDoc(l, l + 2) != "</" && (u = eS(O.doc, h10, l)))
        return { range: R.cursor(l + 1), changes: { from: l, insert: `></${u}>` } };
    }
    return { range: a };
  });
  return r.changes.empty ? false : (t.dispatch(r, { userEvent: "input.type", scrollIntoView: true }), true);
});
var Ba = ["_blank", "_self", "_top", "_parent"];
var Sf = ["ascii", "utf-8", "utf-16", "latin1", "latin1"];
var Pf = ["get", "post", "put", "delete"];
var yf = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"];
var hi = ["true", "false"];
var ie = {};
var AV = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: Ba,
      hreflang: null
    }
  },
  abbr: ie,
  address: ie,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: ie,
  aside: ie,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: ie,
  base: { attrs: { href: null, target: Ba } },
  bdi: ie,
  bdo: ie,
  blockquote: { attrs: { cite: null } },
  body: ie,
  br: ie,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: yf,
      formmethod: Pf,
      formnovalidate: ["novalidate"],
      formtarget: Ba,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: ie,
  center: ie,
  cite: ie,
  code: ie,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: ie,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: ie,
  div: ie,
  dl: ie,
  dt: ie,
  em: ie,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: ie,
  figure: ie,
  footer: ie,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": Sf,
      autocomplete: ["on", "off"],
      enctype: yf,
      method: Pf,
      novalidate: ["novalidate"],
      target: Ba
    }
  },
  h1: ie,
  h2: ie,
  h3: ie,
  h4: ie,
  h5: ie,
  h6: ie,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: ie,
  hgroup: ie,
  hr: ie,
  html: {
    attrs: { manifest: null }
  },
  i: ie,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: yf,
      formmethod: Pf,
      formnovalidate: ["novalidate"],
      formtarget: Ba,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: ie,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: ie,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: ie,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: Sf,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: ie,
  noscript: ie,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: ie,
  param: { attrs: { name: null, value: null } },
  pre: ie,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: ie,
  rt: ie,
  ruby: ie,
  samp: ie,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: Sf
    }
  },
  section: ie,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: ie,
  source: { attrs: { src: null, type: null, media: null } },
  span: ie,
  strong: ie,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: ie,
  summary: ie,
  sup: ie,
  table: ie,
  tbody: ie,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: ie,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: ie,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: ie,
  time: { attrs: { datetime: null } },
  title: ie,
  tr: ie,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: ie,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: ie
};
var SX = {
  accesskey: null,
  class: null,
  contenteditable: hi,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: hi,
  autocorrect: hi,
  autocapitalize: hi,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": hi,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": hi,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": hi,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": hi,
  "aria-hidden": hi,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": hi,
  "aria-multiselectable": hi,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": hi,
  "aria-relevant": null,
  "aria-required": hi,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
};
var PX = "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((t) => "on" + t);
for (let t of PX)
  SX[t] = null;
var mc = class {
  constructor(e, i) {
    this.tags = Object.assign(Object.assign({}, AV), e), this.globalAttrs = Object.assign(Object.assign({}, SX), i), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
};
mc.default = new mc();
function aa(t, e, i = t.length) {
  if (!e)
    return "";
  let n = e.firstChild, O = n && n.getChild("TagName");
  return O ? t.sliceString(O.from, Math.min(O.to, i)) : "";
}
function cu(t, e = false) {
  for (let i = t.parent; i; i = i.parent)
    if (i.name == "Element")
      if (e)
        e = false;
      else
        return i;
  return null;
}
function yX(t, e, i) {
  let n = i.tags[aa(t, cu(e, true))];
  return (n == null ? void 0 : n.children) || i.allTags;
}
function c$(t, e) {
  let i = [];
  for (let n = e; n = cu(n); ) {
    let O = aa(t, n);
    if (O && n.lastChild.name == "CloseTag")
      break;
    O && i.indexOf(O) < 0 && (e.name == "EndTag" || e.from >= n.firstChild.to) && i.push(O);
  }
  return i;
}
var bX = /^[:\-\.\w\u00b7-\uffff]*$/;
function tS(t, e, i, n, O) {
  let r = /\s*>/.test(t.sliceDoc(O, O + 5)) ? "" : ">";
  return {
    from: n,
    to: O,
    options: yX(t.doc, i, e).map((a) => ({ label: a, type: "type" })).concat(c$(t.doc, i).map((a, o) => ({
      label: "/" + a,
      apply: "/" + a + r,
      type: "type",
      boost: 99 - o
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function iS(t, e, i, n) {
  let O = /\s*>/.test(t.sliceDoc(n, n + 5)) ? "" : ">";
  return {
    from: i,
    to: n,
    options: c$(t.doc, e).map((r, a) => ({ label: r, apply: r + O, type: "type", boost: 99 - a })),
    validFor: bX
  };
}
function GV(t, e, i, n) {
  let O = [], r = 0;
  for (let a of yX(t.doc, i, e))
    O.push({ label: "<" + a, type: "type" });
  for (let a of c$(t.doc, i))
    O.push({ label: "</" + a + ">", type: "type", boost: 99 - r++ });
  return { from: n, to: n, options: O, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function LV(t, e, i, n, O) {
  let r = cu(i), a = r ? e.tags[aa(t.doc, r)] : null, o = a && a.attrs ? Object.keys(a.attrs) : [], s = a && a.globalAttrs === false ? o : o.length ? o.concat(e.globalAttrNames) : e.globalAttrNames;
  return {
    from: n,
    to: O,
    options: s.map((l) => ({ label: l, type: "property" })),
    validFor: bX
  };
}
function DV(t, e, i, n, O) {
  var r;
  let a = (r = i.parent) === null || r === void 0 ? void 0 : r.getChild("AttributeName"), o = [], s;
  if (a) {
    let l = t.sliceDoc(a.from, a.to), c = e.globalAttrs[l];
    if (!c) {
      let u = cu(i), h10 = u ? e.tags[aa(t.doc, u)] : null;
      c = (h10 == null ? void 0 : h10.attrs) && h10.attrs[l];
    }
    if (c) {
      let u = t.sliceDoc(n, O).toLowerCase(), h10 = '"', d = '"';
      /^['"]/.test(u) ? (s = u[0] == '"' ? /^[^"]*$/ : /^[^']*$/, h10 = "", d = t.sliceDoc(O, O + 1) == u[0] ? "" : u[0], u = u.slice(1), n++) : s = /^[^\s<>='"]*$/;
      for (let p of c)
        o.push({ label: p, apply: h10 + p + d, type: "constant" });
    }
  }
  return { from: n, to: O, options: o, validFor: s };
}
function MV(t, e) {
  let { state: i, pos: n } = e, O = Ye(i).resolveInner(n), r = O.resolve(n, -1);
  for (let a = n, o; O == r && (o = r.childBefore(a)); ) {
    let s = o.lastChild;
    if (!s || !s.type.isError || s.from < s.to)
      break;
    O = r = o, a = s.from;
  }
  return r.name == "TagName" ? r.parent && /CloseTag$/.test(r.parent.name) ? iS(i, r, r.from, n) : tS(i, t, r, r.from, n) : r.name == "StartTag" ? tS(i, t, r, n, n) : r.name == "StartCloseTag" || r.name == "IncompleteCloseTag" ? iS(i, r, n, n) : e.explicit && (r.name == "OpenTag" || r.name == "SelfClosingTag") || r.name == "AttributeName" ? LV(i, t, r, r.name == "AttributeName" ? r.from : n, n) : r.name == "Is" || r.name == "AttributeValue" || r.name == "UnquotedAttributeValue" ? DV(i, t, r, r.name == "Is" ? n : r.from, n) : e.explicit && (O.name == "Element" || O.name == "Text" || O.name == "Document") ? GV(i, t, r, n) : null;
}
function NV(t) {
  let { extraTags: e, extraGlobalAttributes: i } = t, n = i || e ? new mc(e, i) : mc.default;
  return (O) => MV(n, O);
}
var vX = [
  {
    tag: "script",
    attrs: (t) => t.type == "text/typescript" || t.lang == "ts",
    parser: QX.parser
  },
  {
    tag: "script",
    attrs: (t) => t.type == "text/babel" || t.type == "text/jsx",
    parser: gX.parser
  },
  {
    tag: "script",
    attrs: (t) => t.type == "text/typescript-jsx",
    parser: mX.parser
  },
  {
    tag: "script",
    attrs(t) {
      return !t.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(t.type);
    },
    parser: En.parser
  },
  {
    tag: "style",
    attrs(t) {
      return (!t.lang || t.lang == "css") && (!t.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(t.type));
    },
    parser: gc.parser
  }
];
var XX = [
  {
    name: "style",
    parser: gc.parser.configure({ top: "Styles" })
  }
].concat(PX.map((t) => ({ name: t, parser: En.parser })));
var Ul = Kt.define({
  name: "html",
  parser: BU.configure({
    props: [
      ci.add({
        Element(t) {
          let e = /^(\s*)(<\/)?/.exec(t.textAfter);
          return t.node.to <= t.pos + e[0].length ? t.continue() : t.lineIndent(t.node.from) + (e[2] ? 0 : t.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(t) {
          return t.column(t.node.from) + t.unit;
        },
        Document(t) {
          if (t.pos + /\s*/.exec(t.textAfter)[0].length < t.node.to)
            return t.continue();
          let e = null, i;
          for (let n = t.node; ; ) {
            let O = n.lastChild;
            if (!O || O.name != "Element" || O.to != n.to)
              break;
            e = n = O;
          }
          return e && !((i = e.lastChild) && (i.name == "CloseTag" || i.name == "SelfClosingTag")) ? t.lineIndent(e.from) + t.unit : null;
        }
      }),
      ui.add({
        Element(t) {
          let e = t.firstChild, i = t.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: i.name == "CloseTag" ? i.from : t.to };
        }
      }),
      Ip.add({
        "OpenTag CloseTag": (t) => t.getChild("TagName")
      })
    ],
    wrap: sX(vX, XX)
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
});
function u$(t = {}) {
  let e = "", i;
  t.matchClosingTags === false && (e = "noMatch"), t.selfClosingTags === true && (e = (e ? e + " " : "") + "selfClosing"), (t.nestedLanguages && t.nestedLanguages.length || t.nestedAttributes && t.nestedAttributes.length) && (i = sX((t.nestedLanguages || []).concat(vX), (t.nestedAttributes || []).concat(XX)));
  let n = i || e ? Ul.configure({ dialect: e, wrap: i }) : Ul;
  return new li(n, [
    Ul.data.of({ autocomplete: NV(t) }),
    t.autoCloseTags !== false ? BV : [],
    go().support,
    uX().support
  ]);
}
var nS = new Set("area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" "));
var BV = B.inputHandler.of((t, e, i, n) => {
  if (t.composing || t.state.readOnly || e != i || n != ">" && n != "/" || !Ul.isActiveAt(t.state, e, -1))
    return false;
  let { state: O } = t, r = O.changeByRange((a) => {
    var o, s, l;
    let { head: c } = a, u = Ye(O).resolveInner(c, -1), h10;
    if ((u.name == "TagName" || u.name == "StartTag") && (u = u.parent), n == ">" && u.name == "OpenTag") {
      if (((s = (o = u.parent) === null || o === void 0 ? void 0 : o.lastChild) === null || s === void 0 ? void 0 : s.name) != "CloseTag" && (h10 = aa(O.doc, u.parent, c)) && !nS.has(h10)) {
        let d = t.state.doc.sliceString(c, c + 1) === ">", p = `${d ? "" : ">"}</${h10}>`;
        return { range: R.cursor(c + 1), changes: { from: c + (d ? 1 : 0), insert: p } };
      }
    } else if (n == "/" && u.name == "OpenTag") {
      let d = u.parent, p = d == null ? void 0 : d.parent;
      if (d.from == c - 1 && ((l = p.lastChild) === null || l === void 0 ? void 0 : l.name) != "CloseTag" && (h10 = aa(O.doc, p, c)) && !nS.has(h10)) {
        let $ = t.state.doc.sliceString(c, c + 1) === ">", g = `/${h10}${$ ? "" : ">"}`, Q = c + g.length + ($ ? 1 : 0);
        return { range: R.cursor(Q), changes: { from: c, insert: g } };
      }
    }
    return { range: a };
  });
  return r.changes.empty ? false : (t.dispatch(r, { userEvent: "input.type", scrollIntoView: true }), true);
});
var FV = 1;
var xX = 189;
var wX = 190;
var HV = 191;
var KV = 192;
var JV = 193;
var eq = 194;
var tq = 22;
var iq = 23;
var nq = 47;
var Oq = 48;
var rq = 53;
var aq = 54;
var oq = 55;
var sq = 57;
var lq = 58;
var cq = 59;
var uq = 60;
var fq = 61;
var hq = 63;
var dq = 230;
var pq = 71;
var $q = 255;
var Qq = 121;
var gq = 142;
var mq = 143;
var Sq = 146;
var Os = 10;
var rs = 13;
var f$ = 32;
var uu = 9;
var h$ = 35;
var Pq = 40;
var yq = 46;
var bq = /* @__PURE__ */ new Set([
  iq,
  nq,
  Oq,
  $q,
  hq,
  Qq,
  aq,
  oq,
  dq,
  uq,
  fq,
  lq,
  cq,
  pq,
  gq,
  mq,
  Sq
]);
var vq = new Ie((t, e) => {
  if (t.next < 0)
    t.acceptToken(eq);
  else if (!(t.next != Os && t.next != rs))
    if (e.context.depth < 0)
      t.acceptToken(KV, 1);
    else {
      t.advance();
      let i = 0;
      for (; t.next == f$ || t.next == uu; )
        t.advance(), i++;
      let n = t.next == Os || t.next == rs || t.next == h$;
      t.acceptToken(n ? JV : HV, -i);
    }
}, { contextual: true, fallback: true });
var Xq = new Ie((t, e) => {
  let i = e.context.depth;
  if (i < 0)
    return;
  let n = t.peek(-1);
  if ((n == Os || n == rs) && e.context.depth >= 0) {
    let O = 0, r = 0;
    for (; ; ) {
      if (t.next == f$)
        O++;
      else if (t.next == uu)
        O += 8 - O % 8;
      else
        break;
      t.advance(), r++;
    }
    O != i && t.next != Os && t.next != rs && t.next != h$ && (O < i ? t.acceptToken(wX, -r) : t.acceptToken(xX));
  }
});
function dd(t, e) {
  this.parent = t, this.depth = e, this.hash = (t ? t.hash + t.hash << 8 : 0) + e + (e << 4);
}
var xq = new dd(null, 0);
function wq(t) {
  let e = 0;
  for (let i = 0; i < t.length; i++)
    e += t.charCodeAt(i) == uu ? 8 - e % 8 : 1;
  return e;
}
var Tq = new lu({
  start: xq,
  reduce(t, e) {
    return t.depth < 0 && bq.has(e) ? t.parent : t;
  },
  shift(t, e, i, n) {
    return e == xX ? new dd(t, wq(n.read(n.pos, i.pos))) : e == wX ? t.parent : e == tq || e == rq || e == sq ? new dd(t, -1) : t;
  },
  hash(t) {
    return t.hash;
  }
});
var kq = new Ie((t) => {
  for (let e = 0; e < 5; e++) {
    if (t.next != "print".charCodeAt(e))
      return;
    t.advance();
  }
  if (!/\w/.test(String.fromCharCode(t.next)))
    for (let e = 0; ; e++) {
      let i = t.peek(e);
      if (!(i == f$ || i == uu)) {
        i != Pq && i != yq && i != Os && i != rs && i != h$ && t.acceptToken(FV);
        return;
      }
    }
});
var _q = ti({
  'async "*" "**" FormatConversion FormatSpec': f.modifier,
  "for while if elif else try except finally return raise break continue with pass assert await yield match case": f.controlKeyword,
  "in not and or is del": f.operatorKeyword,
  "from def class global nonlocal lambda": f.definitionKeyword,
  import: f.moduleKeyword,
  "with as print": f.keyword,
  Boolean: f.bool,
  None: f.null,
  VariableName: f.variableName,
  "CallExpression/VariableName": f.function(f.variableName),
  "FunctionDefinition/VariableName": f.function(f.definition(f.variableName)),
  "ClassDefinition/VariableName": f.definition(f.className),
  PropertyName: f.propertyName,
  "CallExpression/MemberExpression/PropertyName": f.function(f.propertyName),
  Comment: f.lineComment,
  Number: f.number,
  String: f.string,
  FormatString: f.special(f.string),
  UpdateOp: f.updateOperator,
  "ArithOp!": f.arithmeticOperator,
  BitOp: f.bitwiseOperator,
  CompareOp: f.compareOperator,
  AssignOp: f.definitionOperator,
  Ellipsis: f.punctuation,
  At: f.meta,
  "( )": f.paren,
  "[ ]": f.squareBracket,
  "{ }": f.brace,
  ".": f.derefOperator,
  ", ;": f.separator
});
var Wq = { __proto__: null, await: 40, or: 50, and: 52, in: 56, not: 58, is: 60, if: 66, else: 68, lambda: 72, yield: 90, from: 92, async: 98, for: 100, None: 152, True: 154, False: 154, del: 168, pass: 172, break: 176, continue: 180, return: 184, raise: 192, import: 196, as: 198, global: 202, nonlocal: 204, assert: 208, elif: 218, while: 222, try: 228, except: 230, finally: 232, with: 236, def: 240, class: 250, match: 261, case: 267 };
var Yq = Jt.deserialize({
  version: 14,
  states: "!L`O`Q$IXOOO%fQ$I[O'#G|OOQ$IS'#Cm'#CmOOQ$IS'#Cn'#CnO'UQ$IWO'#ClO(wQ$I[O'#G{OOQ$IS'#G|'#G|OOQ$IS'#DS'#DSOOQ$IS'#G{'#G{O)eQ$IWO'#CsO)uQ$IWO'#DdO*VQ$IWO'#DhOOQ$IS'#Ds'#DsO*jO`O'#DsO*rOpO'#DsO*zO!bO'#DtO+VO#tO'#DtO+bO&jO'#DtO+mO,UO'#DtO-oQ$I[O'#GmOOQ$IS'#Gm'#GmO'UQ$IWO'#GlO/RQ$I[O'#GlOOQ$IS'#E]'#E]O/jQ$IWO'#E^OOQ$IS'#Gk'#GkO/tQ$IWO'#GjOOQ$IV'#Gj'#GjO0PQ$IWO'#FPOOQ$IS'#GX'#GXO0UQ$IWO'#FOOOQ$IV'#Hx'#HxOOQ$IV'#Gi'#GiOOQ$IT'#Fh'#FhQ`Q$IXOOO'UQ$IWO'#CoO0dQ$IWO'#C{O0kQ$IWO'#DPO0yQ$IWO'#HQO1ZQ$I[O'#EQO'UQ$IWO'#EROOQ$IS'#ET'#ETOOQ$IS'#EV'#EVOOQ$IS'#EX'#EXO1oQ$IWO'#EZO2VQ$IWO'#E_O0PQ$IWO'#EaO2jQ$I[O'#EaO0PQ$IWO'#EdO/jQ$IWO'#EgO/jQ$IWO'#EkO/jQ$IWO'#EnO2uQ$IWO'#EpO2|Q$IWO'#EuO3XQ$IWO'#EqO/jQ$IWO'#EuO0PQ$IWO'#EwO0PQ$IWO'#E|O3^Q$IWO'#FROOQ$IS'#Cc'#CcOOQ$IS'#Cd'#CdOOQ$IS'#Ce'#CeOOQ$IS'#Cf'#CfOOQ$IS'#Cg'#CgOOQ$IS'#Ch'#ChOOQ$IS'#Cj'#CjO'UQ$IWO,58|O'UQ$IWO,58|O'UQ$IWO,58|O'UQ$IWO,58|O'UQ$IWO,58|O'UQ$IWO,58|O3eQ$IWO'#DmOOQ$IS,5:W,5:WO3xQ$IWO'#H[OOQ$IS,5:Z,5:ZO4VQ%1`O,5:ZO4[Q$I[O,59WO0dQ$IWO,59`O0dQ$IWO,59`O0dQ$IWO,59`O6zQ$IWO,59`O7PQ$IWO,59`O7WQ$IWO,59hO7_Q$IWO'#G{O8eQ$IWO'#GzOOQ$IS'#Gz'#GzOOQ$IS'#DY'#DYO8|Q$IWO,59_O'UQ$IWO,59_O9[Q$IWO,59_O9aQ$IWO,5:PO'UQ$IWO,5:POOQ$IS,5:O,5:OO9oQ$IWO,5:OO9tQ$IWO,5:VO'UQ$IWO,5:VO'UQ$IWO,5:TOOQ$IS,5:S,5:SO:VQ$IWO,5:SO:[Q$IWO,5:UOOOO'#Fp'#FpO:aO`O,5:_OOQ$IS,5:_,5:_OOOO'#Fq'#FqO:iOpO,5:_O:qQ$IWO'#DuOOOO'#Fr'#FrO;RO!bO,5:`OOQ$IS,5:`,5:`OOOO'#Fu'#FuO;^O#tO,5:`OOOO'#Fv'#FvO;iO&jO,5:`OOOO'#Fw'#FwO;tO,UO,5:`OOQ$IS'#Fx'#FxO<PQ$I[O,5:dO>qQ$I[O,5=WO?[Q%GlO,5=WO?{Q$I[O,5=WOOQ$IS,5:x,5:xO@dQ$IXO'#GQOAsQ$IWO,5;TOOQ$IV,5=U,5=UOBOQ$I[O'#HtOBgQ$IWO,5;kOOQ$IS-E:V-E:VOOQ$IV,5;j,5;jO3SQ$IWO'#EwOOQ$IT-E9f-E9fOBoQ$I[O,59ZODvQ$I[O,59gOEaQ$IWO'#G}OElQ$IWO'#G}O0PQ$IWO'#G}OEwQ$IWO'#DROFPQ$IWO,59kOFUQ$IWO'#HRO'UQ$IWO'#HRO/jQ$IWO,5=lOOQ$IS,5=l,5=lO/jQ$IWO'#D|OOQ$IS'#D}'#D}OFsQ$IWO'#FzOGTQ$IWO,58zOGTQ$IWO,58zO)hQ$IWO,5:jOGcQ$I[O'#HTOOQ$IS,5:m,5:mOOQ$IS,5:u,5:uOGvQ$IWO,5:yOHXQ$IWO,5:{OOQ$IS'#F}'#F}OHgQ$I[O,5:{OHuQ$IWO,5:{OHzQ$IWO'#HwOOQ$IS,5;O,5;OOIYQ$IWO'#HsOOQ$IS,5;R,5;RO3XQ$IWO,5;VO3XQ$IWO,5;YOIkQ$I[O'#HyO'UQ$IWO'#HyOIuQ$IWO,5;[O2uQ$IWO,5;[O/jQ$IWO,5;aO0PQ$IWO,5;cOIzQ$IXO'#ElOKTQ$IZO,5;]ONiQ$IWO'#HzO3XQ$IWO,5;aONtQ$IWO,5;cONyQ$IWO,5;hO! RQ$I[O,5;mO'UQ$IWO,5;mO!#uQ$I[O1G.hO!#|Q$I[O1G.hO!&mQ$I[O1G.hO!&wQ$I[O1G.hO!)bQ$I[O1G.hO!)uQ$I[O1G.hO!*YQ$IWO'#HZO!*hQ$I[O'#GmO/jQ$IWO'#HZO!*rQ$IWO'#HYOOQ$IS,5:X,5:XO!*zQ$IWO,5:XO!+PQ$IWO'#H]O!+[Q$IWO'#H]O!+oQ$IWO,5=vOOQ$IS'#Dq'#DqOOQ$IS1G/u1G/uOOQ$IS1G.z1G.zO!,oQ$I[O1G.zO!,vQ$I[O1G.zO0dQ$IWO1G.zO!-cQ$IWO1G/SOOQ$IS'#DX'#DXO/jQ$IWO,59rOOQ$IS1G.y1G.yO!-jQ$IWO1G/cO!-zQ$IWO1G/cO!.SQ$IWO1G/dO'UQ$IWO'#HSO!.XQ$IWO'#HSO!.^Q$I[O1G.yO!.nQ$IWO,59gO!/tQ$IWO,5=rO!0UQ$IWO,5=rO!0^Q$IWO1G/kO!0cQ$I[O1G/kOOQ$IS1G/j1G/jO!0sQ$IWO,5=mO!1jQ$IWO,5=mO/jQ$IWO1G/oO!2XQ$IWO1G/qO!2^Q$I[O1G/qO!2nQ$I[O1G/oOOQ$IS1G/n1G/nOOQ$IS1G/p1G/pOOOO-E9n-E9nOOQ$IS1G/y1G/yOOOO-E9o-E9oO!3OQ$IWO'#HhO/jQ$IWO'#HhO!3^Q$IWO,5:aOOOO-E9p-E9pOOQ$IS1G/z1G/zOOOO-E9s-E9sOOOO-E9t-E9tOOOO-E9u-E9uOOQ$IS-E9v-E9vO!3iQ%GlO1G2rO!4YQ$I[O1G2rO'UQ$IWO,5<eOOQ$IS,5<e,5<eOOQ$IS-E9w-E9wOOQ$IS,5<l,5<lOOQ$IS-E:O-E:OOOQ$IV1G0o1G0oO0PQ$IWO'#F|O!4qQ$I[O,5>`OOQ$IS1G1V1G1VO!5YQ$IWO1G1VOOQ$IS'#DT'#DTO/jQ$IWO,5=iOOQ$IS,5=i,5=iO!5_Q$IWO'#FiO!5jQ$IWO,59mO!5rQ$IWO1G/VO!5|Q$I[O,5=mOOQ$IS1G3W1G3WOOQ$IS,5:h,5:hO!6mQ$IWO'#GlOOQ$IS,5<f,5<fOOQ$IS-E9x-E9xO!7OQ$IWO1G.fOOQ$IS1G0U1G0UO!7^Q$IWO,5=oO!7nQ$IWO,5=oO/jQ$IWO1G0eO/jQ$IWO1G0eO0PQ$IWO1G0gOOQ$IS-E9{-E9{O!8PQ$IWO1G0gO!8[Q$IWO1G0gO!8aQ$IWO,5>cO!8oQ$IWO,5>cO!8}Q$IWO,5>_O!9eQ$IWO,5>_O!9vQ$IZO1G0qO!=XQ$IZO1G0tO!@gQ$IWO,5>eO!@qQ$IWO,5>eO!@yQ$I[O,5>eO/jQ$IWO1G0vO!ATQ$IWO1G0vO3XQ$IWO1G0{ONtQ$IWO1G0}OOQ$IV,5;W,5;WO!AYQ$IYO,5;WO!A_Q$IZO1G0wO!DsQ$IWO'#GUO3XQ$IWO1G0wO3XQ$IWO1G0wO!EQQ$IWO,5>fO!E_Q$IWO,5>fO0PQ$IWO,5>fOOQ$IV1G0{1G0{O!EgQ$IWO'#EyO!ExQ%1`O1G0}OOQ$IV1G1S1G1SO3XQ$IWO1G1SO!FQQ$IWO'#FTOOQ$IV1G1X1G1XO! RQ$I[O1G1XOOQ$IS,5=u,5=uOOQ$IS'#Dn'#DnO/jQ$IWO,5=uO!FVQ$IWO,5=tO!FjQ$IWO,5=tOOQ$IS1G/s1G/sO!FrQ$IWO,5=wO!GSQ$IWO,5=wO!G[Q$IWO,5=wO!GoQ$IWO,5=wO!HPQ$IWO,5=wOOQ$IS1G3b1G3bOOQ$IS7+$f7+$fO!5rQ$IWO7+$nO!IrQ$IWO1G.zO!IyQ$IWO1G.zOOQ$IS1G/^1G/^OOQ$IS,5<V,5<VO'UQ$IWO,5<VOOQ$IS7+$}7+$}O!JQQ$IWO7+$}OOQ$IS-E9i-E9iOOQ$IS7+%O7+%OO!JbQ$IWO,5=nO'UQ$IWO,5=nOOQ$IS7+$e7+$eO!JgQ$IWO7+$}O!JoQ$IWO7+%OO!JtQ$IWO1G3^OOQ$IS7+%V7+%VO!KUQ$IWO1G3^O!K^Q$IWO7+%VOOQ$IS,5<U,5<UO'UQ$IWO,5<UO!KcQ$IWO1G3XOOQ$IS-E9h-E9hO!LYQ$IWO7+%ZOOQ$IS7+%]7+%]O!LhQ$IWO1G3XO!MVQ$IWO7+%]O!M[Q$IWO1G3_O!MlQ$IWO1G3_O!MtQ$IWO7+%ZO!MyQ$IWO,5>SO!NaQ$IWO,5>SO!NaQ$IWO,5>SO!NoO!LQO'#DwO!NzOSO'#HiOOOO1G/{1G/{O# PQ$IWO1G/{O# XQ%GlO7+(^O# xQ$I[O1G2PP#!cQ$IWO'#FyOOQ$IS,5<h,5<hOOQ$IS-E9z-E9zOOQ$IS7+&q7+&qOOQ$IS1G3T1G3TOOQ$IS,5<T,5<TOOQ$IS-E9g-E9gOOQ$IS7+$q7+$qO#!pQ$IWO,5=WO##ZQ$IWO,5=WO##lQ$I[O,5<WO#$PQ$IWO1G3ZOOQ$IS-E9j-E9jOOQ$IS7+&P7+&PO#$aQ$IWO7+&POOQ$IS7+&R7+&RO#$oQ$IWO'#HvO0PQ$IWO'#HuO#%TQ$IWO7+&ROOQ$IS,5<k,5<kO#%`Q$IWO1G3}OOQ$IS-E9}-E9}OOQ$IS,5<g,5<gO#%nQ$IWO1G3yOOQ$IS-E9y-E9yO#&UQ$IZO7+&]O!DsQ$IWO'#GSO3XQ$IWO7+&]O3XQ$IWO7+&`O#)gQ$I[O,5<oO'UQ$IWO,5<oO#)qQ$IWO1G4POOQ$IS-E:R-E:RO#){Q$IWO1G4PO3XQ$IWO7+&bO/jQ$IWO7+&bOOQ$IV7+&g7+&gO!ExQ%1`O7+&iO#*TQ$IXO1G0rOOQ$IV-E:S-E:SO3XQ$IWO7+&cO3XQ$IWO7+&cOOQ$IV,5<p,5<pO#+yQ$IWO,5<pOOQ$IV7+&c7+&cO#,UQ$IZO7+&cO#/dQ$IWO,5<qO#/oQ$IWO1G4QOOQ$IS-E:T-E:TO#/|Q$IWO1G4QO#0UQ$IWO'#H|O#0dQ$IWO'#H|O0PQ$IWO'#H|OOQ$IS'#H|'#H|O#0oQ$IWO'#H{OOQ$IS,5;e,5;eO#0wQ$IWO,5;eO/jQ$IWO'#E{OOQ$IV7+&i7+&iO3XQ$IWO7+&iOOQ$IV7+&n7+&nO#0|Q$IYO,5;oOOQ$IV7+&s7+&sOOQ$IS1G3a1G3aOOQ$IS,5<Y,5<YO#1RQ$IWO1G3`OOQ$IS-E9l-E9lO#1fQ$IWO,5<ZO#1qQ$IWO,5<ZO#2UQ$IWO1G3cOOQ$IS-E9m-E9mO#2fQ$IWO1G3cO#2nQ$IWO1G3cO#3OQ$IWO1G3cO#2fQ$IWO1G3cOOQ$IS<<HY<<HYO#3ZQ$I[O1G1qOOQ$IS<<Hi<<HiP#3hQ$IWO'#FkO7WQ$IWO1G3YO#3uQ$IWO1G3YO#3zQ$IWO<<HiOOQ$IS<<Hj<<HjO#4[Q$IWO7+(xOOQ$IS<<Hq<<HqO#4lQ$I[O1G1pP#5]Q$IWO'#FjO#5jQ$IWO7+(yO#5zQ$IWO7+(yO#6SQ$IWO<<HuO#6XQ$IWO7+(sOOQ$IS<<Hw<<HwO#7OQ$IWO,5<XO'UQ$IWO,5<XOOQ$IS-E9k-E9kOOQ$IS<<Hu<<HuOOQ$IS,5<_,5<_O/jQ$IWO,5<_O#7TQ$IWO1G3nOOQ$IS-E9q-E9qO#7kQ$IWO1G3nOOOO'#Ft'#FtO#7yO!LQO,5:cOOOO,5>T,5>TOOOO7+%g7+%gO#8UQ$IWO1G2rO#8oQ$IWO1G2rP'UQ$IWO'#FlO/jQ$IWO<<IkO#9QQ$IWO,5>bO#9cQ$IWO,5>bO0PQ$IWO,5>bO#9tQ$IWO,5>aOOQ$IS<<Im<<ImP0PQ$IWO'#GPP/jQ$IWO'#F{OOQ$IV-E:Q-E:QO3XQ$IWO<<IwOOQ$IV,5<n,5<nO3XQ$IWO,5<nOOQ$IV<<Iw<<IwOOQ$IV<<Iz<<IzO#9yQ$I[O1G2ZP#:TQ$IWO'#GTO#:[Q$IWO7+)kO#:fQ$IZO<<I|O3XQ$IWO<<I|OOQ$IV<<JT<<JTO3XQ$IWO<<JTOOQ$IV'#GR'#GRO#=tQ$IZO7+&^OOQ$IV<<I}<<I}O#?pQ$IZO<<I}OOQ$IV1G2[1G2[O0PQ$IWO1G2[O3XQ$IWO<<I}O0PQ$IWO1G2]P/jQ$IWO'#GVO#COQ$IWO7+)lO#C]Q$IWO7+)lOOQ$IS'#Ez'#EzO/jQ$IWO,5>hO#CeQ$IWO,5>hOOQ$IS,5>h,5>hO#CpQ$IWO,5>gO#DRQ$IWO,5>gOOQ$IS1G1P1G1POOQ$IS,5;g,5;gO#DZQ$IWO1G1ZP#D`Q$IWO'#FnO#DpQ$IWO1G1uO#ETQ$IWO1G1uO#EeQ$IWO1G1uP#EpQ$IWO'#FoO#E}Q$IWO7+(}O#F_Q$IWO7+(}O#F_Q$IWO7+(}O#FgQ$IWO7+(}O#FwQ$IWO7+(tO7WQ$IWO7+(tOOQ$ISAN>TAN>TO#GbQ$IWO<<LeOOQ$ISAN>aAN>aO/jQ$IWO1G1sO#GrQ$I[O1G1sP#G|Q$IWO'#FmOOQ$IS1G1y1G1yP#HZQ$IWO'#FsO#HhQ$IWO7+)YOOOO-E9r-E9rO#IOQ$IWO7+(^OOQ$ISAN?VAN?VO#IiQ$IWO,5<jO#I}Q$IWO1G3|OOQ$IS-E9|-E9|O#J`Q$IWO1G3|OOQ$IS1G3{1G3{OOQ$IVAN?cAN?cOOQ$IV1G2Y1G2YO3XQ$IWOAN?hO#JqQ$IZOAN?hOOQ$IVAN?oAN?oOOQ$IV-E:P-E:POOQ$IV<<Ix<<IxO3XQ$IWOAN?iO3XQ$IWO7+'vOOQ$IVAN?iAN?iOOQ$IS7+'w7+'wO#NPQ$IWO<<MWOOQ$IS1G4S1G4SO/jQ$IWO1G4SOOQ$IS,5<r,5<rO#N^Q$IWO1G4ROOQ$IS-E:U-E:UOOQ$IU'#GY'#GYO#NoQ$IYO7+&uO#NzQ$IWO'#FUO$ rQ$IWO7+'aO$!SQ$IWO7+'aOOQ$IS7+'a7+'aO$!_Q$IWO<<LiO$!oQ$IWO<<LiO$!oQ$IWO<<LiO$!wQ$IWO'#HUOOQ$IS<<L`<<L`O$#RQ$IWO<<L`OOQ$IS7+'_7+'_O0PQ$IWO1G2UP0PQ$IWO'#GOO$#lQ$IWO7+)hO$#}Q$IWO7+)hOOQ$IVG25SG25SO3XQ$IWOG25SOOQ$IVG25TG25TOOQ$IV<<Kb<<KbOOQ$IS7+)n7+)nP$$`Q$IWO'#GWOOQ$IU-E:W-E:WOOQ$IV<<Ja<<JaO$%SQ$I[O'#FWOOQ$IS'#FY'#FYO$%dQ$IWO'#FXO$&UQ$IWO'#FXOOQ$IS'#FX'#FXO$&ZQ$IWO'#IOO#NzQ$IWO'#F`O#NzQ$IWO'#F`O$&rQ$IWO'#FaO#NzQ$IWO'#FbO$&yQ$IWO'#IPOOQ$IS'#IP'#IPO$'hQ$IWO,5;pOOQ$IS<<J{<<J{O$'pQ$IWO<<J{O$(QQ$IWOANBTO$(bQ$IWOANBTO$(jQ$IWO'#HVOOQ$IS'#HV'#HVO0kQ$IWO'#DaO$)TQ$IWO,5=pOOQ$ISANAzANAzOOQ$IS7+'p7+'pO$)lQ$IWO<<MSOOQ$IVLD*nLD*nO4VQ%1`O'#G[O$)}Q$I[O,5;yO#NzQ$IWO'#FdOOQ$IS,5;},5;}OOQ$IS'#FZ'#FZO$*oQ$IWO,5;sO$*tQ$IWO,5;sOOQ$IS'#F^'#F^O#NzQ$IWO'#GZO$+fQ$IWO,5;wO$,QQ$IWO,5>jO$,bQ$IWO,5>jO0PQ$IWO,5;vO$,sQ$IWO,5;zO$,xQ$IWO,5;zO#NzQ$IWO'#IQO$,}Q$IWO'#IQO$-SQ$IWO,5;{OOQ$IS,5;|,5;|O'UQ$IWO'#FgOOQ$IU1G1[1G1[O3XQ$IWO1G1[OOQ$ISAN@gAN@gO$-XQ$IWOG27oO$-iQ$IWO,59{OOQ$IS1G3[1G3[OOQ$IS,5<v,5<vOOQ$IS-E:Y-E:YO$-nQ$I[O'#FWO$-uQ$IWO'#IRO$.TQ$IWO'#IRO$.]Q$IWO,5<OOOQ$IS1G1_1G1_O$.bQ$IWO1G1_O$.gQ$IWO,5<uOOQ$IS-E:X-E:XO$/RQ$IWO,5<yO$/jQ$IWO1G4UOOQ$IS-E:]-E:]OOQ$IS1G1b1G1bOOQ$IS1G1f1G1fO$/zQ$IWO,5>lO#NzQ$IWO,5>lOOQ$IS1G1g1G1gO$0YQ$I[O,5<ROOQ$IU7+&v7+&vO$!wQ$IWO1G/gO#NzQ$IWO,5<PO$0aQ$IWO,5>mO$0hQ$IWO,5>mOOQ$IS1G1j1G1jOOQ$IS7+&y7+&yP#NzQ$IWO'#G_O$0pQ$IWO1G4WO$0zQ$IWO1G4WO$1SQ$IWO1G4WOOQ$IS7+%R7+%RO$1bQ$IWO1G1kO$1pQ$I[O'#FWO$1wQ$IWO,5<xOOQ$IS,5<x,5<xO$2VQ$IWO1G4XOOQ$IS-E:[-E:[O#NzQ$IWO,5<wO$2^Q$IWO,5<wO$2cQ$IWO7+)rOOQ$IS-E:Z-E:ZO$2mQ$IWO7+)rO#NzQ$IWO,5<QP#NzQ$IWO'#G^O$2uQ$IWO1G2cO#NzQ$IWO1G2cP$3TQ$IWO'#G]O$3[Q$IWO<<M^O$3fQ$IWO1G1lO$3tQ$IWO7+'}O7WQ$IWO'#C{O7WQ$IWO,59`O7WQ$IWO,59`O7WQ$IWO,59`O$4SQ$I[O,5=WO7WQ$IWO1G.zO/jQ$IWO1G/VO/jQ$IWO7+$nP$4gQ$IWO'#FyO'UQ$IWO'#GlO$4tQ$IWO,59`O$4yQ$IWO,59`O$5QQ$IWO,59kO$5VQ$IWO1G/SO0kQ$IWO'#DPO7WQ$IWO,59h",
  stateData: "$5m~O%[OS%XOS%WOSQOS~OPhOTeOdsOfXOmtOq!SOtuO}vO!O!PO!R!VO!S!UO!VYO!ZZO!fdO!mdO!ndO!odO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#c!TO#f!WO#j!XO#l!YO#q!ZO#tlO#v![O%VqO%gQO%hQO%lRO%mVO&R[O&S]O&V^O&Y_O&``O&caO&ebO~OT!bO]!bO_!cOf!jO!V!lO!d!nO%b!]O%c!^O%d!_O%e!`O%f!`O%g!aO%h!aO%i!bO%j!bO%k!bO~Oi%pXj%pXk%pXl%pXm%pXn%pXq%pXx%pXy%pX!s%pX#^%pX%V%pX%Y%pX%r%pXe%pX!R%pX!S%pX%s%pX!U%pX!Y%pX!O%pX#V%pXr%pX!j%pX~P$bOdsOfXO!VYO!ZZO!fdO!mdO!ndO!odO%gQO%hQO%lRO%mVO&R[O&S]O&V^O&Y_O&``O&caO&ebO~Ox%oXy%oX#^%oX%V%oX%Y%oX%r%oX~Oi!qOj!rOk!pOl!pOm!sOn!tOq!uO!s%oX~P(cOT!{Om/iOt/wO}vO~P'UOT#OOm/iOt/wO!U#PO~P'UOT#SO_#TOm/iOt/wO!Y#UO~P'UO&T#XO&U#ZO~O&W#[O&X#ZO~O!Z#^O&Z#_O&_#aO~O!Z#^O&a#bO&b#aO~O!Z#^O&U#aO&d#dO~O!Z#^O&X#aO&f#fO~OT%aX]%aX_%aXf%aXi%aXj%aXk%aXl%aXm%aXn%aXq%aXx%aX!V%aX!d%aX%b%aX%c%aX%d%aX%e%aX%f%aX%g%aX%h%aX%i%aX%j%aX%k%aXe%aX!R%aX!S%aX~O&R[O&S]O&V^O&Y_O&``O&caO&ebOy%aX!s%aX#^%aX%V%aX%Y%aX%r%aX%s%aX!U%aX!Y%aX!O%aX#V%aXr%aX!j%aX~P+xOx#kOy%`X!s%`X#^%`X%V%`X%Y%`X%r%`X~Om/iOt/wO~P'UO#^#nO%V#pO%Y#pO~O%mVO~O!R#uO#l!YO#q!ZO#tlO~OmtO~P'UOT#zO_#{O%mVOyuP~OT$POm/iOt/wO!O$QO~P'UOy$SO!s$XO%r$TO#^!tX%V!tX%Y!tX~OT$POm/iOt/wO#^!}X%V!}X%Y!}X~P'UOm/iOt/wO#^#RX%V#RX%Y#RX~P'UO!d$_O!m$_O%mVO~OT$iO~P'UO!S$kO#j$lO#l$mO~Oy$nO~OT$uO~P'UOT%OO_%OOe%QOm/iOt/wO~P'UOm/iOt/wOy%TO~P'UO&Q%VO~O_!cOf!jO!V!lO!d!nOT`a]`ai`aj`ak`al`am`an`aq`ax`ay`a!s`a#^`a%V`a%Y`a%b`a%c`a%d`a%e`a%f`a%g`a%h`a%i`a%j`a%k`a%r`ae`a!R`a!S`a%s`a!U`a!Y`a!O`a#V`ar`a!j`a~Ol%[O~Om%[O~P'UOm/iO~P'UOi/kOj/lOk/jOl/jOm/sOn/tOq/xOe%oX!R%oX!S%oX%s%oX!U%oX!Y%oX!O%oX#V%oX!j%oX~P(cO%s%^Oe%nXx%nX!R%nX!S%nX!U%nXy%nX~Oe%`Ox%aO!R%eO!S%dO~Oe%`O~Ox%hO!R%eO!S%dO!U%zX~O!U%lO~Ox%mOy%oO!R%eO!S%dO!Y%uX~O!Y%sO~O!Y%tO~O&T#XO&U%vO~O&W#[O&X%vO~OT%yOm/iOt/wO}vO~P'UO!Z#^O&Z#_O&_%|O~O!Z#^O&a#bO&b%|O~O!Z#^O&U%|O&d#dO~O!Z#^O&X%|O&f#fO~OT!la]!la_!laf!lai!laj!lak!lal!lam!lan!laq!lax!lay!la!V!la!d!la!s!la#^!la%V!la%Y!la%b!la%c!la%d!la%e!la%f!la%g!la%h!la%i!la%j!la%k!la%r!lae!la!R!la!S!la%s!la!U!la!Y!la!O!la#V!lar!la!j!la~P#yOx&ROy%`a!s%`a#^%`a%V%`a%Y%`a%r%`a~P$bOT&TOmtOtuOy%`a!s%`a#^%`a%V%`a%Y%`a%r%`a~P'UOx&ROy%`a!s%`a#^%`a%V%`a%Y%`a%r%`a~OPhOTeOmtOtuO}vO!O!PO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#^$tX%V$tX%Y$tX~P'UO#^#nO%V&YO%Y&YO~O!d&ZOf&hX%V&hX#V&hX#^&hX%Y&hX#U&hX~Of!jO%V&]O~Oicajcakcalcamcancaqcaxcayca!sca#^ca%Vca%Yca%rcaeca!Rca!Sca%sca!Uca!Yca!Oca#Vcarca!jca~P$bOqoaxoayoa#^oa%Voa%Yoa%roa~Oi!qOj!rOk!pOl!pOm!sOn!tO!soa~PD_O%r&_Ox%qXy%qX~O%mVOx%qXy%qX~Ox&bOyuX~Oy&dO~Ox%mO#^%uX%V%uX%Y%uXe%uXy%uX!Y%uX!j%uX%r%uX~OT/rOm/iOt/wO}vO~P'UO%r$TO#^Sa%VSa%YSa~Ox&mO#^%wX%V%wX%Y%wXl%wX~P$bOx&pO!O&oO#^#Ra%V#Ra%Y#Ra~O#V&qO#^#Ta%V#Ta%Y#Ta~O!d$_O!m$_O#U&sO%mVO~O#U&sO~Ox&uO#^&kX%V&kX%Y&kX~Ox&wO#^&gX%V&gX%Y&gXy&gX~Ox&{Ol&mX~P$bOl'OO~OPhOTeOmtOtuO}vO!O!PO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO%V'TO~P'UOr'XO#g'VO#h'WOP#eaT#ead#eaf#eam#eaq#eat#ea}#ea!O#ea!R#ea!S#ea!V#ea!Z#ea!f#ea!m#ea!n#ea!o#ea!v#ea!x#ea!z#ea!|#ea#O#ea#S#ea#U#ea#X#ea#Y#ea#[#ea#c#ea#f#ea#j#ea#l#ea#q#ea#t#ea#v#ea%S#ea%V#ea%g#ea%h#ea%l#ea%m#ea&R#ea&S#ea&V#ea&Y#ea&`#ea&c#ea&e#ea%U#ea%Y#ea~Ox'YO#V'[Oy&nX~Of'^O~Of!jOy$nO~Oy'bO~P$bOT!bO]!bO_!cOf!jO!V!lO!d!nO%d!_O%e!`O%f!`O%g!aO%h!aO%i!bO%j!bO%k!bOiUijUikUilUimUinUiqUixUiyUi!sUi#^Ui%VUi%YUi%bUi%rUieUi!RUi!SUi%sUi!UUi!YUi!OUi#VUirUi!jUi~O%c!^O~P! YO%cUi~P! YOT!bO]!bO_!cOf!jO!V!lO!d!nO%g!aO%h!aO%i!bO%j!bO%k!bOiUijUikUilUimUinUiqUixUiyUi!sUi#^Ui%VUi%YUi%bUi%cUi%dUi%rUieUi!RUi!SUi%sUi!UUi!YUi!OUi#VUirUi!jUi~O%e!`O%f!`O~P!$TO%eUi%fUi~P!$TO_!cOf!jO!V!lO!d!nOiUijUikUilUimUinUiqUixUiyUi!sUi#^Ui%VUi%YUi%bUi%cUi%dUi%eUi%fUi%gUi%hUi%rUieUi!RUi!SUi%sUi!UUi!YUi!OUi#VUirUi!jUi~OT!bO]!bO%i!bO%j!bO%k!bO~P!'ROTUi]Ui%iUi%jUi%kUi~P!'RO!R%eO!S%dOe%}Xx%}X~O%r'fO%s'fO~P+xOx'hOe%|X~Oe'jO~Ox'kOy'mO!U&PX~Om/iOt/wOx'kOy'nO!U&PX~P'UO!U'pO~Ok!pOl!pOm!sOn!tOihiqhixhiyhi!shi#^hi%Vhi%Yhi%rhi~Oj!rO~P!+tOjhi~P!+tOi/kOj/lOk/jOl/jOm/sOn/tO~Or'rO~P!,}OT'wOe'xOm/iOt/wO~P'UOe'xOx'yO~Oe'{O~O!S'}O~Oe(OOx'yO!R%eO!S%dO~P$bOi/kOj/lOk/jOl/jOm/sOn/tOeoa!Roa!Soa%soa!Uoa!Yoa!Ooa#Voaroa!joa~PD_OT'wOm/iOt/wO!U%za~P'UOx(RO!U%za~O!U(SO~Ox(RO!R%eO!S%dO!U%za~P$bOT(WOm/iOt/wO!Y%ua#^%ua%V%ua%Y%uae%uay%ua!j%ua%r%ua~P'UOx(XO!Y%ua#^%ua%V%ua%Y%uae%uay%ua!j%ua%r%ua~O!Y([O~Ox(XO!R%eO!S%dO!Y%ua~P$bOx(_O!R%eO!S%dO!Y%{a~P$bOx(bOy&[X!Y&[X!j&[X~Oy(eO!Y(gO!j(hO~OT&TOmtOtuOy%`i!s%`i#^%`i%V%`i%Y%`i%r%`i~P'UOx(iOy%`i!s%`i#^%`i%V%`i%Y%`i%r%`i~O!d&ZOf&ha%V&ha#V&ha#^&ha%Y&ha#U&ha~O%V(nO~OT#zO_#{O%mVO~Ox&bOyua~OmtOtuO~P'UOx(XO#^%ua%V%ua%Y%uae%uay%ua!Y%ua!j%ua%r%ua~P$bOx(sO#^%`X%V%`X%Y%`X%r%`X~O%r$TO#^Si%VSi%YSi~O#^%wa%V%wa%Y%wal%wa~P'UOx(vO#^%wa%V%wa%Y%wal%wa~OT(zOf(|O%mVO~O#U(}O~O%mVO#^&ka%V&ka%Y&ka~Ox)PO#^&ka%V&ka%Y&ka~Om/iOt/wO#^&ga%V&ga%Y&gay&ga~P'UOx)SO#^&ga%V&ga%Y&gay&ga~Or)WO#a)VOP#_iT#_id#_if#_im#_iq#_it#_i}#_i!O#_i!R#_i!S#_i!V#_i!Z#_i!f#_i!m#_i!n#_i!o#_i!v#_i!x#_i!z#_i!|#_i#O#_i#S#_i#U#_i#X#_i#Y#_i#[#_i#c#_i#f#_i#j#_i#l#_i#q#_i#t#_i#v#_i%S#_i%V#_i%g#_i%h#_i%l#_i%m#_i&R#_i&S#_i&V#_i&Y#_i&`#_i&c#_i&e#_i%U#_i%Y#_i~Or)XOP#biT#bid#bif#bim#biq#bit#bi}#bi!O#bi!R#bi!S#bi!V#bi!Z#bi!f#bi!m#bi!n#bi!o#bi!v#bi!x#bi!z#bi!|#bi#O#bi#S#bi#U#bi#X#bi#Y#bi#[#bi#c#bi#f#bi#j#bi#l#bi#q#bi#t#bi#v#bi%S#bi%V#bi%g#bi%h#bi%l#bi%m#bi&R#bi&S#bi&V#bi&Y#bi&`#bi&c#bi&e#bi%U#bi%Y#bi~OT)ZOl&ma~P'UOx)[Ol&ma~Ox)[Ol&ma~P$bOl)`O~O%T)cO~Or)fO#g'VO#h)eOP#eiT#eid#eif#eim#eiq#eit#ei}#ei!O#ei!R#ei!S#ei!V#ei!Z#ei!f#ei!m#ei!n#ei!o#ei!v#ei!x#ei!z#ei!|#ei#O#ei#S#ei#U#ei#X#ei#Y#ei#[#ei#c#ei#f#ei#j#ei#l#ei#q#ei#t#ei#v#ei%S#ei%V#ei%g#ei%h#ei%l#ei%m#ei&R#ei&S#ei&V#ei&Y#ei&`#ei&c#ei&e#ei%U#ei%Y#ei~Om/iOt/wOy$nO~P'UOm/iOt/wOy&na~P'UOx)lOy&na~OT)pO_)qOe)tO%i)rO%mVO~Oy$nO&q)vO~O%V)zO~OT%OO_%OOm/iOt/wOe%|a~P'UOx*OOe%|a~Om/iOt/wOy*RO!U&Pa~P'UOx*SO!U&Pa~Om/iOt/wOx*SOy*VO!U&Pa~P'UOm/iOt/wOx*SO!U&Pa~P'UOx*SOy*VO!U&Pa~Ok/jOl/jOm/sOn/tOehiihiqhixhi!Rhi!Shi%shi!Uhiyhi!Yhi#^hi%Vhi%Yhi!Ohi#Vhirhi!jhi%rhi~Oj/lO~P!H[Ojhi~P!H[OT'wOe*[Om/iOt/wO~P'UOl*^O~Oe*[Ox*`O~Oe*aO~OT'wOm/iOt/wO!U%zi~P'UOx*bO!U%zi~O!U*cO~OT(WOm/iOt/wO!Y%ui#^%ui%V%ui%Y%uie%uiy%ui!j%ui%r%ui~P'UOx*fO!R%eO!S%dO!Y%{i~Ox*iO!Y%ui#^%ui%V%ui%Y%uie%uiy%ui!j%ui%r%ui~O!Y*jO~O_*lOm/iOt/wO!Y%{i~P'UOx*fO!Y%{i~O!Y*nO~OT*pOm/iOt/wOy&[a!Y&[a!j&[a~P'UOx*qOy&[a!Y&[a!j&[a~O!Z#^O&^*tO!Y!kX~O!Y*vO~Oy(eO!Y*wO~OT&TOmtOtuOy%`q!s%`q#^%`q%V%`q%Y%`q%r%`q~P'UOx$miy$mi!s$mi#^$mi%V$mi%Y$mi%r$mi~P$bOT&TOmtOtuO~P'UOT&TOm/iOt/wO#^%`a%V%`a%Y%`a%r%`a~P'UOx*xO#^%`a%V%`a%Y%`a%r%`a~Ox$`a#^$`a%V$`a%Y$`al$`a~P$bO#^%wi%V%wi%Y%wil%wi~P'UOx*{O#^#Rq%V#Rq%Y#Rq~Ox*|O#V+OO#^&jX%V&jX%Y&jXe&jX~OT+QOf(|O%mVO~O%mVO#^&ki%V&ki%Y&ki~Om/iOt/wO#^&gi%V&gi%Y&giy&gi~P'UOr+UO#a)VOP#_qT#_qd#_qf#_qm#_qq#_qt#_q}#_q!O#_q!R#_q!S#_q!V#_q!Z#_q!f#_q!m#_q!n#_q!o#_q!v#_q!x#_q!z#_q!|#_q#O#_q#S#_q#U#_q#X#_q#Y#_q#[#_q#c#_q#f#_q#j#_q#l#_q#q#_q#t#_q#v#_q%S#_q%V#_q%g#_q%h#_q%l#_q%m#_q&R#_q&S#_q&V#_q&Y#_q&`#_q&c#_q&e#_q%U#_q%Y#_q~Ol$wax$wa~P$bOT)ZOl&mi~P'UOx+]Ol&mi~OPhOTeOmtOq!SOtuO}vO!O!PO!R!VO!S!UO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#c!TO#f!WO#j!XO#l!YO#q!ZO#tlO#v![O~P'UOx+gOy$nO#V+gO~O#h+hOP#eqT#eqd#eqf#eqm#eqq#eqt#eq}#eq!O#eq!R#eq!S#eq!V#eq!Z#eq!f#eq!m#eq!n#eq!o#eq!v#eq!x#eq!z#eq!|#eq#O#eq#S#eq#U#eq#X#eq#Y#eq#[#eq#c#eq#f#eq#j#eq#l#eq#q#eq#t#eq#v#eq%S#eq%V#eq%g#eq%h#eq%l#eq%m#eq&R#eq&S#eq&V#eq&Y#eq&`#eq&c#eq&e#eq%U#eq%Y#eq~O#V+iOx$yay$ya~Om/iOt/wOy&ni~P'UOx+kOy&ni~Oy$SO%r+mOe&pXx&pX~O%mVOe&pXx&pX~Ox+qOe&oX~Oe+sO~O%T+uO~OT%OO_%OOm/iOt/wOe%|i~P'UOy+wOx$ca!U$ca~Om/iOt/wOy+xOx$ca!U$ca~P'UOm/iOt/wOy*RO!U&Pi~P'UOx+{O!U&Pi~Om/iOt/wOx+{O!U&Pi~P'UOx+{Oy,OO!U&Pi~Oe$_ix$_i!U$_i~P$bOT'wOm/iOt/wO~P'UOl,QO~OT'wOe,ROm/iOt/wO~P'UOT'wOm/iOt/wO!U%zq~P'UOx$^i!Y$^i#^$^i%V$^i%Y$^ie$^iy$^i!j$^i%r$^i~P$bOT(WOm/iOt/wO~P'UO_*lOm/iOt/wO!Y%{q~P'UOx,SO!Y%{q~O!Y,TO~OT(WOm/iOt/wO!Y%uq#^%uq%V%uq%Y%uqe%uqy%uq!j%uq%r%uq~P'UOy,UO~OT*pOm/iOt/wOy&[i!Y&[i!j&[i~P'UOx,ZOy&[i!Y&[i!j&[i~O!Z#^O&^*tO!Y!ka~OT&TOm/iOt/wO#^%`i%V%`i%Y%`i%r%`i~P'UOx,]O#^%`i%V%`i%Y%`i%r%`i~O%mVO#^&ja%V&ja%Y&jae&ja~Ox,`O#^&ja%V&ja%Y&jae&ja~Oe,cO~Ol$wix$wi~P$bOT)ZO~P'UOT)ZOl&mq~P'UOr,fOP#dyT#dyd#dyf#dym#dyq#dyt#dy}#dy!O#dy!R#dy!S#dy!V#dy!Z#dy!f#dy!m#dy!n#dy!o#dy!v#dy!x#dy!z#dy!|#dy#O#dy#S#dy#U#dy#X#dy#Y#dy#[#dy#c#dy#f#dy#j#dy#l#dy#q#dy#t#dy#v#dy%S#dy%V#dy%g#dy%h#dy%l#dy%m#dy&R#dy&S#dy&V#dy&Y#dy&`#dy&c#dy&e#dy%U#dy%Y#dy~OPhOTeOmtOq!SOtuO}vO!O!PO!R!VO!S!UO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#c!TO#f!WO#j!XO#l!YO#q!ZO#tlO#v![O%U,jO%Y,jO~P'UO#h,kOP#eyT#eyd#eyf#eym#eyq#eyt#ey}#ey!O#ey!R#ey!S#ey!V#ey!Z#ey!f#ey!m#ey!n#ey!o#ey!v#ey!x#ey!z#ey!|#ey#O#ey#S#ey#U#ey#X#ey#Y#ey#[#ey#c#ey#f#ey#j#ey#l#ey#q#ey#t#ey#v#ey%S#ey%V#ey%g#ey%h#ey%l#ey%m#ey&R#ey&S#ey&V#ey&Y#ey&`#ey&c#ey&e#ey%U#ey%Y#ey~Om/iOt/wOy&nq~P'UOx,oOy&nq~O%r+mOe&pax&pa~OT)pO_)qO%i)rO%mVOe&oa~Ox,sOe&oa~O#y,wO~OT%OO_%OOm/iOt/wO~P'UOm/iOt/wOy,xOx$ci!U$ci~P'UOm/iOt/wOx$ci!U$ci~P'UOy,xOx$ci!U$ci~Om/iOt/wOy*RO~P'UOm/iOt/wOy*RO!U&Pq~P'UOx,{O!U&Pq~Om/iOt/wOx,{O!U&Pq~P'UOq-OO!R%eO!S%dOe%vq!U%vq!Y%vqx%vq~P!,}O_*lOm/iOt/wO!Y%{y~P'UOx$ai!Y$ai~P$bO_*lOm/iOt/wO~P'UOT*pOm/iOt/wO~P'UOT*pOm/iOt/wOy&[q!Y&[q!j&[q~P'UOT&TOm/iOt/wO#^%`q%V%`q%Y%`q%r%`q~P'UO#V-SOx$ra#^$ra%V$ra%Y$rae$ra~O%mVO#^&ji%V&ji%Y&jie&ji~Ox-UO#^&ji%V&ji%Y&jie&ji~Or-XOP#d!RT#d!Rd#d!Rf#d!Rm#d!Rq#d!Rt#d!R}#d!R!O#d!R!R#d!R!S#d!R!V#d!R!Z#d!R!f#d!R!m#d!R!n#d!R!o#d!R!v#d!R!x#d!R!z#d!R!|#d!R#O#d!R#S#d!R#U#d!R#X#d!R#Y#d!R#[#d!R#c#d!R#f#d!R#j#d!R#l#d!R#q#d!R#t#d!R#v#d!R%S#d!R%V#d!R%g#d!R%h#d!R%l#d!R%m#d!R&R#d!R&S#d!R&V#d!R&Y#d!R&`#d!R&c#d!R&e#d!R%U#d!R%Y#d!R~Om/iOt/wOy&ny~P'UOT)pO_)qO%i)rO%mVOe&oi~O#y,wO%U-_O%Y-_O~OT-iOf-gO!V-fO!Z-hO!f-bO!n-dO!o-dO%h-aO%mVO&R[O&S]O&V^O~Om/iOt/wOx$cq!U$cq~P'UOy-nOx$cq!U$cq~Om/iOt/wOy*RO!U&Py~P'UOx-oO!U&Py~Om/iOt-sO~P'UOq-OO!R%eO!S%dOe%vy!U%vy!Y%vyx%vy~P!,}O%mVO#^&jq%V&jq%Y&jqe&jq~Ox-wO#^&jq%V&jq%Y&jqe&jq~OT)pO_)qO%i)rO%mVO~Of-{O!d-yOx#zX#V#zX%b#zXe#zX~Oq#zXy#zX!U#zX!Y#zX~P$$nO%g-}O%h-}Oq#{Xx#{Xy#{X#V#{X%b#{X!U#{Xe#{X!Y#{X~O!f.PO~Ox.TO#V.VO%b.QOq&rXy&rX!U&rXe&rX~O_.YO~P$ WOf-{Oq&sXx&sXy&sX#V&sX%b&sX!U&sXe&sX!Y&sX~Oq.^Oy$nO~Om/iOt/wOx$cy!U$cy~P'UOm/iOt/wOy*RO!U&P!R~P'UOx.bO!U&P!R~Oe%yXq%yX!R%yX!S%yX!U%yX!Y%yXx%yX~P!,}Oq-OO!R%eO!S%dOe%xa!U%xa!Y%xax%xa~O%mVO#^&jy%V&jy%Y&jye&jy~O!d-yOf$Raq$Rax$Ray$Ra#V$Ra%b$Ra!U$Rae$Ra!Y$Ra~O!f.kO~O%g-}O%h-}Oq#{ax#{ay#{a#V#{a%b#{a!U#{ae#{a!Y#{a~O%b.QOq$Pax$Pay$Pa#V$Pa!U$Pae$Pa!Y$Pa~Oq&ray&ra!U&rae&ra~P#NzOx.pOq&ray&ra!U&rae&ra~O!U.sO~Oe.sO~Oy.uO~O!Y.vO~Om/iOt/wOy*RO!U&P!Z~P'UOy.yO~O%r.zO~P$$nOx.{O#V.VO%b.QOe&uX~Ox.{Oe&uX~Oe.}O~O!f/OO~O#V.VOq$}ax$}ay$}a%b$}a!U$}ae$}a!Y$}a~O#V.VO%b.QOq%Rax%Ray%Ra!U%Rae%Ra~Oq&riy&ri!U&rie&ri~P#NzOx/QO#V.VO%b.QO!Y&ta~Oy$Za~P$bOe&ua~P#NzOx/YOe&ua~O_/[O!Y&ti~P$ WOx/^O!Y&ti~Ox/^O#V.VO%b.QO!Y&ti~O#V.VO%b.QOe$Xix$Xi~O%r/aO~P$$nO#V.VO%b.QOe%Qax%Qa~Oe&ui~P#NzOy/dO~O_/[O!Y&tq~P$ WOx/fO!Y&tq~O#V.VO%b.QOx%Pi!Y%Pi~O_/[O~P$ WO_/[O!Y&ty~P$ WO#V.VO%b.QOe$Yix$Yi~O#V.VO%b.QOx%Pq!Y%Pq~Ox*xO#^%`a%V%`a%Y%`a%r%`a~P$bOT&TOm/iOt/wO~P'UOl/nO~Om/nO~P'UOy/oO~Or/pO~P!,}O&S&V&c&e&R!Z&Z&a&d&f&Y&`&Y%m~",
  goto: "!9p&vPPPP&wP'P*e*}+h,S,o-]P-zP'P.k.k'PPPP'P2PPPPPPP2P4oPP4oP6{7U=QPP=T=c=fPP'P'PPP=rPP'P'PPP'P'P'P'P'P=v>m'PP>pP>vByFcPFw'PPPPF{GR&wP&w&wP&wP&wP&wP&wP&w&w&wP&wPP&wPP&wPGXPG`GfPG`PG`G`PPPG`PIePInItIzIePG`JQPG`PJXJ_PJcJwKfLPJcJcLVLdJcJcJcJcLxMOMRMWMZMaMgMsNVN]NgNm! Z! a! g! m! w! }!!T!!Z!!a!!g!!y!#T!#Z!#a!#g!#q!#w!#}!$T!$Z!$e!$k!$u!${!%U!%[!%k!%s!%}!&UPPPPPPPPP!&[!&d!&m!&w!'SPPPPPPPPPPPP!+r!,[!0j!3vPP!4O!4^!4g!5]!5S!5f!5l!5o!5r!5u!5}!6nPPPPPPPPPP!6q!6tPPPPPPPPP!6z!7W!7d!7j!7s!7v!7|!8S!8Y!8]P!8e!8n!9j!9m]iOr#n$n)c+c'udOSXYZehrstvx|}!R!S!T!U!X![!d!e!f!g!h!i!j!l!p!q!r!t!u!{#O#S#T#^#k#n$P$Q$S$U$X$i$k$l$n$u%O%T%[%_%a%d%h%m%o%y&R&T&`&d&m&o&p&w&{'O'V'Y'g'h'k'm'n'r'w'y'}(R(W(X(_(b(i(k(s(v)S)V)Z)[)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*l*p*q*x*z*{+S+[+]+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.^.b.y/i/j/k/l/n/o/p/q/r/t/x}!dP#j#w$Y$h$t%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!P!eP#j#w$Y$h$t$v%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!R!fP#j#w$Y$h$t$v$w%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!T!gP#j#w$Y$h$t$v$w$x%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!V!hP#j#w$Y$h$t$v$w$x$y%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!X!iP#j#w$Y$h$t$v$w$x$y$z%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!]!iP!o#j#w$Y$h$t$v$w$x$y$z${%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m'uSOSXYZehrstvx|}!R!S!T!U!X![!d!e!f!g!h!i!j!l!p!q!r!t!u!{#O#S#T#^#k#n$P$Q$S$U$X$i$k$l$n$u%O%T%[%_%a%d%h%m%o%y&R&T&`&d&m&o&p&w&{'O'V'Y'g'h'k'm'n'r'w'y'}(R(W(X(_(b(i(k(s(v)S)V)Z)[)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*l*p*q*x*z*{+S+[+]+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.^.b.y/i/j/k/l/n/o/p/q/r/t/x&ZUOXYZhrtv|}!R!S!T!X!j!l!p!q!r!t!u#^#k#n$Q$S$U$X$l$n%O%T%[%_%a%h%m%o%y&R&`&d&o&p&w'O'V'Y'g'h'k'm'n'r'y(R(X(_(b(i(k(s)S)V)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*p*q*x*{+S+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.b.y/i/j/k/l/n/o/p/q/t/x%eWOXYZhrv|}!R!S!T!X!j!l#^#k#n$Q$S$U$X$l$n%O%T%_%a%h%m%o%y&R&`&d&o&p&w'O'V'Y'g'h'k'm'n'r'y(R(X(_(b(i(k(s)S)V)`)c)l)v*O*R*S*V*]*`*b*e*f*i*p*q*x*{+S+c+j+k+n+v+w+x+z+{,O,S,U,W,Y,Z,],o,q,x,{-n-o.b/o/p/qQ#}uQ.c-sR/u/w'ldOSXYZehrstvx|}!R!S!T!U!X![!d!e!f!g!h!i!l!p!q!r!t!u!{#O#S#T#^#k#n$P$Q$S$U$X$i$k$l$n$u%O%T%[%_%a%d%h%m%o%y&R&T&`&d&m&o&p&w&{'O'V'Y'g'k'm'n'r'w'y'}(R(W(X(_(b(i(k(s(v)S)V)Z)[)`)c)l)v*R*S*V*]*^*`*b*e*f*i*l*p*q*x*z*{+S+[+]+c+j+k+n+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.^.b.y/i/j/k/l/n/o/p/q/r/t/xW#ql!O!P$`W#yu&b-s/wQ$b!QQ$r!YQ$s!ZW$}!j'h*O+vS&a#z#{Q'R$mQ(l&ZQ(z&qU({&s(|(}U)O&u)P+RQ)n'[W)o'^+q,s-]S+p)p)qY,_*|,`-T-U-wQ,b+OQ,l+gQ,n+il-`,w-f-g-i.R.T.Y.p.u.z/P/[/a/dQ-v-SQ.Z-hQ.g-{Q.r.VU/V.{/Y/bX/]/Q/^/e/fR&`#yi!xXY!S!T%a%h'y(R)V*]*`*bR%_!wQ!|XQ%z#^Q&i$UR&l$XT-r-O.y![!kP!o#j#w$Y$h$t$v$w$x$y$z${%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/mQ&^#rR'a$sR'g$}Q%W!nR.e-y'tcOSXYZehrstvx|}!R!S!T!U!X![!d!e!f!g!h!i!j!l!p!q!r!t!u!{#O#S#T#^#k#n$P$Q$S$U$X$i$k$l$n$u%O%T%[%_%a%d%h%m%o%y&R&T&`&d&m&o&p&w&{'O'V'Y'g'h'k'm'n'r'w'y'}(R(W(X(_(b(i(k(s(v)S)V)Z)[)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*l*p*q*x*z*{+S+[+]+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.^.b.y/i/j/k/l/n/o/p/q/r/t/xS#hc#i!P-d,w-f-g-h-i-{.R.T.Y.p.u.z.{/P/Q/Y/[/^/a/b/d/e/f'tcOSXYZehrstvx|}!R!S!T!U!X![!d!e!f!g!h!i!j!l!p!q!r!t!u!{#O#S#T#^#k#n$P$Q$S$U$X$i$k$l$n$u%O%T%[%_%a%d%h%m%o%y&R&T&`&d&m&o&p&w&{'O'V'Y'g'h'k'm'n'r'w'y'}(R(W(X(_(b(i(k(s(v)S)V)Z)[)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*l*p*q*x*z*{+S+[+]+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.^.b.y/i/j/k/l/n/o/p/q/r/t/xT#hc#iS#__#`S#b`#cS#da#eS#fb#gT*t(e*uT(f%z(hQ$WwR+o)oX$Uw$V$W&kZkOr$n)c+cXoOr)c+cQ$o!WQ&y$fQ&z$gQ']$qQ'`$sQ)a'QQ)g'VQ)i'WQ)j'XQ)w'_Q)y'aQ+V)VQ+X)WQ+Y)XQ+^)_S+`)b)xQ+d)eQ+e)fQ+f)hQ,d+UQ,e+WQ,g+_Q,h+aQ,m+hQ-W,fQ-Y,kQ-Z,lQ-x-XQ._-lR.x.`WoOr)c+cR#tnQ'_$rR)b'RQ+n)oR,q+oQ)x'_R+a)bZmOnr)c+cQ'c$tR){'dT,u+u,vu-k,w-f-g-i-{.R.T.Y.p.u.z.{/P/Y/[/a/b/dt-k,w-f-g-i-{.R.T.Y.p.u.z.{/P/Y/[/a/b/dQ.Z-hX/]/Q/^/e/f!P-c,w-f-g-h-i-{.R.T.Y.p.u.z.{/P/Q/Y/[/^/a/b/d/e/fQ.O-bR.l.Pg.R-e.S.h.o.t/S/U/W/c/g/hu-j,w-f-g-i-{.R.T.Y.p.u.z.{/P/Y/[/a/b/dX-|-`-j.g/VR.i-{V/X.{/Y/bR.`-lQrOR#vrQ&c#|R(q&cS%n#R$OS(Y%n(]T(]%q&eQ%b!zQ%i!}W'z%b%i(P(TQ(P%fR(T%kQ&n$YR(w&nQ(`%rQ*g(ZT*m(`*gQ'i%PR*P'iS'l%S%TY*T'l*U+|,|-pU*U'm'n'oU+|*V*W*XS,|+},OR-p,}Q#Y]R%u#YQ#]^R%w#]Q#`_R%{#`Q(c%xS*r(c*sR*s(dQ*u(eR,[*uQ#c`R%}#cQ#eaR&O#eQ#gbR&P#gQ#icR&Q#iQ#lfQ&S#jW&V#l&S(t*yQ(t&hR*y/mQ$VwS&j$V&kR&k$WQ&x$dR)T&xQ&[#qR(m&[Q$`!PR&r$`Q*}({S,a*}-VR-V,bQ&v$bR)Q&vQ#ojR&X#oQ+c)cR,i+cQ)U&yR+T)UQ&|$hS)]&|)^R)^&}Q'U$oR)d'UQ'Z$pS)m'Z+lR+l)nQ+r)sR,t+rWnOr)c+cR#snQ,v+uR-^,vd.S-e.h.o.t/S/U/W/c/g/hR.n.SU-z-`.g/VR.f-zQ/R.tS/_/R/`R/`/SS.|.h.iR/Z.|Q.U-eR.q.USqOrT+b)c+cWpOr)c+cR'S$nYjOr$n)c+cR&W#n[wOr#n$n)c+cR&i$U&YPOXYZhrtv|}!R!S!T!X!j!l!p!q!r!t!u#^#k#n$Q$S$U$X$l$n%O%T%[%_%a%h%m%o%y&R&`&d&o&p&w'O'V'Y'g'h'k'm'n'r'y(R(X(_(b(i(k(s)S)V)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*p*q*x*{+S+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.b.y/i/j/k/l/n/o/p/q/t/xQ!oSQ#jeQ#wsU$Yx%d'}S$h!U$kQ$t![Q$v!dQ$w!eQ$x!fQ$y!gQ$z!hQ${!iQ%f!{Q%k#OQ%q#SQ%r#TQ&e$PQ&}$iQ'd$uQ(j&TU(u&m(v*zW)Y&{)[+[+]Q*Z'wQ*d(WQ+Z)ZQ,V*lQ.w.^R/m/rQ!zXQ!}YQ$f!SQ$g!T^'v%a%h'y(R*]*`*bR+W)V[fOr#n$n)c+ch!wXY!S!T%a%h'y(R)V*]*`*bQ#RZQ#mhS$Ov|Q$]}W$d!R$X'O)`S$p!X$lW$|!j'h*O+vQ%S!lQ%x#^`&U#k&R(i(k(s*x,]/qQ&f$QQ&g$SQ&h$UQ'e%OQ'o%TQ'u%_W(V%m(X*e*iQ(Z%oQ(d%yQ(o&`S(r&d/oQ(x&oQ(y&pU)R&w)S+SQ)h'VY)k'Y)l+j+k,oQ)|'g^*Q'k*S+z+{,{-o.bQ*W'mQ*X'nS*Y'r/pW*k(_*f,S,WW*o(b*q,Y,ZQ+t)vQ+y*RQ+}*VQ,X*pQ,^*{Q,p+nQ,y+wQ,z+xQ,},OQ-R,UQ-[,qQ-m,xR.a-nhTOr#k#n$n&R&d'r(i(k)c+c$z!vXYZhv|}!R!S!T!X!j!l#^$Q$S$U$X$l%O%T%_%a%h%m%o%y&`&o&p&w'O'V'Y'g'h'k'm'n'y(R(X(_(b(s)S)V)`)l)v*O*R*S*V*]*`*b*e*f*i*p*q*x*{+S+j+k+n+v+w+x+z+{,O,S,U,W,Y,Z,],o,q,x,{-n-o.b/o/p/qQ#xtW%X!p!t/j/tQ%Y!qQ%Z!rQ%]!uQ%g/iS'q%[/nQ's/kQ't/lQ,P*^Q-Q,QS-q-O.yR/v/xU#|u-s/wR(p&b[gOr#n$n)c+cX!yX#^$U$XQ#WZQ$RvR$[|Q%c!zQ%j!}Q%p#RQ'e$|Q(Q%fQ(U%kQ(^%qQ(a%rQ*h(ZQ-P,PQ-u-QR.d-tQ$ZxQ'|%dR*_'}Q-t-OR/T.yR#QYR#VZR%R!jQ%P!jV)}'h*O+v!]!mP!o#j#w$Y$h$t$v$w$x$y$z${%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/mR%U!lR%z#^Q(g%zR*w(hQ$e!RQ&l$XQ)_'OR+_)`Q#rlQ$^!OQ$a!PR&t$`Q(z&sR+Q(}Q(z&sQ+P(|R+Q(}R$c!QXpOr)c+cQ$j!UR'P$kQ$q!XR'Q$lR)u'^Q)s'^V,r+q,s-]Q-l,wQ.W-fR.X-gU-e,w-f-gQ.]-iQ.h-{Q.m.RU.o.T.p/PQ.t.YQ/S.uQ/U.zU/W.{/Y/bQ/c/[Q/g/aR/h/dR.[-hR.j-{",
  nodeNames: "⚠ print Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatConversion FormatSpec ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard",
  maxTerm: 267,
  context: Tq,
  nodeProps: [
    ["group", -14, 4, 80, 82, 83, 85, 87, 89, 91, 93, 94, 95, 97, 100, 103, "Statement Statement", -22, 6, 16, 19, 23, 38, 47, 48, 54, 55, 58, 59, 60, 61, 62, 65, 68, 69, 70, 74, 75, 76, 77, "Expression", -10, 105, 107, 110, 112, 113, 117, 119, 124, 126, 129, "Statement", -9, 134, 135, 138, 139, 141, 142, 143, 144, 145, "Pattern"],
    ["openedBy", 21, "(", 52, "[", 56, "{"],
    ["closedBy", 22, ")", 53, "]", 57, "}"]
  ],
  propSources: [_q],
  skippedNodes: [0, 2],
  repeatNodeCount: 38,
  tokenData: ")'WMgR!`OX%TXY!EQY[%T[]!EQ]p%Tpq!EQqr!Gkrs!Ktst#J]tu%Tuv&'{vw&*kwx&+}xy'*fyz'+rz{'-O{|'/z|}'1^}!O'2j!O!P'5]!P!Q'Ae!Q!R'Da!R!['Ho![!](&g!]!^()V!^!_(*c!_!`(-_!`!a(.q!a!b%T!b!c(1j!c!d(3O!d!e(4|!e!h(3O!h!i(?z!i!t(3O!t!u(J[!u!w(3O!w!x(>S!x!}(3O!}#O(Ll#O#P!Fp#P#Q(Mx#Q#R) U#R#S(3O#S#T%T#T#U(3O#U#V(4|#V#Y(3O#Y#Z(?z#Z#f(3O#f#g(J[#g#i(3O#i#j(>S#j#o(3O#o#p)!h#p#q)#d#q#r)$v#r#s)%z#s$g%T$g;'S(3O;'S;=`(4v<%lO(3O<r%f]&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<Q&j]&^7[&TS&Z`&d!bOr'crs!,gsw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'c<Q'r]&^7[&TS&WW&Z`&d!b&f#tOr'crs&_sw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'c;p(t]&^7[&WW&f#tOr)mrs*ssw)mwxKmx#O)m#O#P7}#P#o)m#o#pDs#p#q)m#q#r8l#r;'S)m;'S;=`Kg<%lO)m;p)z]&^7[&TS&WW&d!b&f#tOr)mrs*ssw)mwx(kx#O)m#O#P7}#P#o)m#o#pDs#p#q)m#q#r8l#r;'S)m;'S;=`Kg<%lO)m;p*|]&^7[&TS&d!bOr)mrs+usw)mwx(kx#O)m#O#P7}#P#o)m#o#pDs#p#q)m#q#r8l#r;'S)m;'S;=`Kg<%lO)m;p,O]&^7[&TS&d!bOr)mrs,wsw)mwx(kx#O)m#O#P7}#P#o)m#o#pDs#p#q)m#q#r8l#r;'S)m;'S;=`Kg<%lO)m8r-QZ&^7[&TS&d!bOw,wwx-sx#O,w#O#P/}#P#o,w#o#p3n#p#q,w#q#r0l#r;'S,w;'S;=`7w<%lO,w8r-xZ&^7[Ow,wwx.kx#O,w#O#P/}#P#o,w#o#p3n#p#q,w#q#r0l#r;'S,w;'S;=`7w<%lO,w8r.pZ&^7[Ow,wwx/cx#O,w#O#P/}#P#o,w#o#p3n#p#q,w#q#r0l#r;'S,w;'S;=`7w<%lO,w7[/hT&^7[O#o/c#p#q/c#r;'S/c;'S;=`/w<%lO/c7[/zP;=`<%l/c8r0SW&^7[O#o,w#o#p0l#p#q,w#q#r0l#r;'S,w;'S;=`7Q;=`<%l0l<%lO,w!f0sX&TS&d!bOw0lwx1`x#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z<%lO0l!f1cXOw0lwx2Ox#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z<%lO0l!f2RWOw0lx#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z<%lO0l!f2nRO;'S0l;'S;=`2w;=`O0l!f3OY&TS&d!bOw0lwx1`x#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z;=`<%l0l<%lO0l!f3sX&TSOw4`wx4zx#O4`#O#P5y#P#o4`#o#p0l#p;'S4`;'S;=`6t<%lO4`S4eV&TSOw4`wx4zx#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`S4}VOw4`wx5dx#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`S5gUOw4`x#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`S5|RO;'S4`;'S;=`6V;=`O4`S6[W&TSOw4`wx4zx#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l4`<%lO4`S6wP;=`<%l4`!f6}P;=`<%l0l8r7XY&TS&d!bOw0lwx1`x#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z;=`<%l,w<%lO0l8r7zP;=`<%l,w;p8SW&^7[O#o)m#o#p8l#p#q)m#q#r8l#r;'S)m;'S;=`Jf;=`<%l8l<%lO)m%d8wZ&TS&WW&d!b&f#tOr8lrs9jsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`<%lO8l%d9qZ&TS&d!bOr8lrs:dsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`<%lO8l%d:kZ&TS&d!bOr8lrs0lsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`<%lO8l%d;eZ&WW&f#tOr8lrs9jsw8lwx<Wx#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`<%lO8l%d<_Z&WW&f#tOr8lrs9jsw8lwx=Qx#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`<%lO8l#|=XX&WW&f#tOr=Qrs=ts#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`<%lO=Q#|=wXOr=Qrs>ds#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`<%lO=Q#|>gWOr=Qs#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`<%lO=Q#|?SRO;'S=Q;'S;=`?];=`O=Q#|?dY&WW&f#tOr=Qrs=ts#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`;=`<%l=Q<%lO=Q#|@XX&WWOr@trsA`s#O@t#O#PB_#P#o@t#o#p=Q#p;'S@t;'S;=`CY<%lO@tW@yV&WWOr@trsA`s#O@t#O#PB_#P;'S@t;'S;=`CY<%lO@tWAcVOr@trsAxs#O@t#O#PB_#P;'S@t;'S;=`CY<%lO@tWA{UOr@ts#O@t#O#PB_#P;'S@t;'S;=`CY<%lO@tWBbRO;'S@t;'S;=`Bk;=`O@tWBpW&WWOr@trsA`s#O@t#O#PB_#P;'S@t;'S;=`CY;=`<%l@t<%lO@tWC]P;=`<%l@t#|CcP;=`<%l=Q%dCiRO;'S8l;'S;=`Cr;=`O8l%dC}[&TS&WW&d!b&f#tOr8lrs9jsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`;=`<%l8l<%lO8l%dDzZ&TS&WWOrEmrsFaswEmwxGsx#OEm#O#PIV#P#oEm#o#p8l#p;'SEm;'S;=`JY<%lOEm[EtX&TS&WWOrEmrsFaswEmwxGsx#OEm#O#PIV#P;'SEm;'S;=`JY<%lOEm[FfX&TSOrEmrsGRswEmwxGsx#OEm#O#PIV#P;'SEm;'S;=`JY<%lOEm[GWX&TSOrEmrs4`swEmwxGsx#OEm#O#PIV#P;'SEm;'S;=`JY<%lOEm[GxX&WWOrEmrsFaswEmwxHex#OEm#O#PIV#P;'SEm;'S;=`JY<%lOEm[HjX&WWOrEmrsFaswEmwx@tx#OEm#O#PIV#P;'SEm;'S;=`JY<%lOEm[IYRO;'SEm;'S;=`Ic;=`OEm[IjY&TS&WWOrEmrsFaswEmwxGsx#OEm#O#PIV#P;'SEm;'S;=`JY;=`<%lEm<%lOEm[J]P;=`<%lEm%dJcP;=`<%l8l;pJq[&TS&WW&d!b&f#tOr8lrs9jsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`;=`<%l)m<%lO8l;pKjP;=`<%l)m;pKv]&^7[&WW&f#tOr)mrs*ssw)mwxLox#O)m#O#P7}#P#o)m#o#pDs#p#q)m#q#r8l#r;'S)m;'S;=`Kg<%lO)m:YLxZ&^7[&WW&f#tOrLorsMks#OLo#O#P! Z#P#oLo#o#p@S#p#qLo#q#r=Q#r;'SLo;'S;=`!!o<%lOLo:YMpZ&^7[OrLorsNcs#OLo#O#P! Z#P#oLo#o#p@S#p#qLo#q#r=Q#r;'SLo;'S;=`!!o<%lOLo:YNhZ&^7[OrLors/cs#OLo#O#P! Z#P#oLo#o#p@S#p#qLo#q#r=Q#r;'SLo;'S;=`!!o<%lOLo:Y! `W&^7[O#oLo#o#p=Q#p#qLo#q#r=Q#r;'SLo;'S;=`! x;=`<%l=Q<%lOLo:Y!!PY&WW&f#tOr=Qrs=ts#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`;=`<%lLo<%lO=Q:Y!!rP;=`<%lLo<Q!!zW&^7[O#o'c#o#p!#d#p#q'c#q#r!#d#r;'S'c;'S;=`!+^;=`<%l!#d<%lO'c%t!#qZ&TS&WW&Z`&d!b&f#tOr!#drs!$dsw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W<%lO!#d%t!$mZ&TS&Z`&d!bOr!#drs!%`sw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W<%lO!#d%t!%iZ&TS&Z`&d!bOr!#drs!&[sw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W<%lO!#d!v!&eX&TS&Z`&d!bOw!&[wx1`x#O!&[#O#P!'Q#P#o!&[#o#p!(V#p;'S!&[;'S;=`!(w<%lO!&[!v!'TRO;'S!&[;'S;=`!'^;=`O!&[!v!'gY&TS&Z`&d!bOw!&[wx1`x#O!&[#O#P!'Q#P#o!&[#o#p!(V#p;'S!&[;'S;=`!(w;=`<%l!&[<%lO!&[!v!([X&TSOw4`wx4zx#O4`#O#P5y#P#o4`#o#p!&[#p;'S4`;'S;=`6t<%lO4`!v!(zP;=`<%l!&[%t!)QRO;'S!#d;'S;=`!)Z;=`O!#d%t!)h[&TS&WW&Z`&d!b&f#tOr!#drs!$dsw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W;=`<%l!#d<%lO!#d%t!*eZ&TS&WWOrEmrsFaswEmwxGsx#OEm#O#PIV#P#oEm#o#p!#d#p;'SEm;'S;=`JY<%lOEm%t!+ZP;=`<%l!#d<Q!+k[&TS&WW&Z`&d!b&f#tOr!#drs!$dsw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W;=`<%l'c<%lO!#d<Q!,dP;=`<%l'c<Q!,r]&^7[&TS&Z`&d!bOr'crs!-ksw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'c9S!-vZ&^7[&TS&Z`&d!bOw!-kwx-sx#O!-k#O#P!.i#P#o!-k#o#p!(V#p#q!-k#q#r!&[#r;'S!-k;'S;=`!0P<%lO!-k9S!.nW&^7[O#o!-k#o#p!&[#p#q!-k#q#r!&[#r;'S!-k;'S;=`!/W;=`<%l!&[<%lO!-k9S!/aY&TS&Z`&d!bOw!&[wx1`x#O!&[#O#P!'Q#P#o!&[#o#p!(V#p;'S!&[;'S;=`!(w;=`<%l!-k<%lO!&[9S!0SP;=`<%l!-k<b!0b]&^7[&WW&ap&f#tOr!1Zrs*ssw!1Zwx!<Tx#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1Z<b!1j]&^7[&TS&WW&ap&d!b&f#tOr!1Zrs*ssw!1Zwx!0Vx#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1Z<b!2hW&^7[O#o!1Z#o#p!3Q#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!:z;=`<%l!3Q<%lO!1Z&U!3_Z&TS&WW&ap&d!b&f#tOr!3Qrs9jsw!3Qwx!4Qx#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t<%lO!3Q&U!4ZZ&WW&ap&f#tOr!3Qrs9jsw!3Qwx!4|x#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t<%lO!3Q&U!5VZ&WW&ap&f#tOr!3Qrs9jsw!3Qwx!5xx#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t<%lO!3Q$n!6RX&WW&ap&f#tOr!5xrs=ts#O!5x#O#P!6n#P#o!5x#o#p!7s#p;'S!5x;'S;=`!8e<%lO!5x$n!6qRO;'S!5x;'S;=`!6z;=`O!5x$n!7TY&WW&ap&f#tOr!5xrs=ts#O!5x#O#P!6n#P#o!5x#o#p!7s#p;'S!5x;'S;=`!8e;=`<%l!5x<%lO!5x$n!7xX&WWOr@trsA`s#O@t#O#PB_#P#o@t#o#p!5x#p;'S@t;'S;=`CY<%lO@t$n!8hP;=`<%l!5x&U!8nRO;'S!3Q;'S;=`!8w;=`O!3Q&U!9U[&TS&WW&ap&d!b&f#tOr!3Qrs9jsw!3Qwx!4Qx#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t;=`<%l!3Q<%lO!3Q&U!:RZ&TS&WWOrEmrsFaswEmwxGsx#OEm#O#PIV#P#oEm#o#p!3Q#p;'SEm;'S;=`JY<%lOEm&U!:wP;=`<%l!3Q<b!;X[&TS&WW&ap&d!b&f#tOr!3Qrs9jsw!3Qwx!4Qx#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t;=`<%l!1Z<%lO!3Q<b!<QP;=`<%l!1Z<b!<`]&^7[&WW&ap&f#tOr!1Zrs*ssw!1Zwx!=Xx#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1Z:z!=dZ&^7[&WW&ap&f#tOr!=XrsMks#O!=X#O#P!>V#P#o!=X#o#p!7s#p#q!=X#q#r!5x#r;'S!=X;'S;=`!?m<%lO!=X:z!>[W&^7[O#o!=X#o#p!5x#p#q!=X#q#r!5x#r;'S!=X;'S;=`!>t;=`<%l!5x<%lO!=X:z!>}Y&WW&ap&f#tOr!5xrs=ts#O!5x#O#P!6n#P#o!5x#o#p!7s#p;'S!5x;'S;=`!8e;=`<%l!=X<%lO!5x:z!?pP;=`<%l!=X<r!?xW&^7[O#o%T#o#p!@b#p#q%T#q#r!@b#r;'S%T;'S;=`!Cu;=`<%l!@b<%lO%T&f!@qZ&TS&WW&Z`&ap&d!b&f#tOr!@brs!$dsw!@bwx!4Qx#O!@b#O#P!Ad#P#o!@b#o#p!Bu#p;'S!@b;'S;=`!Co<%lO!@b&f!AgRO;'S!@b;'S;=`!Ap;=`O!@b&f!BP[&TS&WW&Z`&ap&d!b&f#tOr!@brs!$dsw!@bwx!4Qx#O!@b#O#P!Ad#P#o!@b#o#p!Bu#p;'S!@b;'S;=`!Co;=`<%l!@b<%lO!@b&f!B|Z&TS&WWOrEmrsFaswEmwxGsx#OEm#O#PIV#P#oEm#o#p!@b#p;'SEm;'S;=`JY<%lOEm&f!CrP;=`<%l!@b<r!DU[&TS&WW&Z`&ap&d!b&f#tOr!@brs!$dsw!@bwx!4Qx#O!@b#O#P!Ad#P#o!@b#o#p!Bu#p;'S!@b;'S;=`!Co;=`<%l%T<%lO!@b<r!D}P;=`<%l%TMg!Eec&^7[&TS&WW%[1s&Z`&ap&d!b&f#tOX%TXY!EQY[%T[]!EQ]p%Tpq!EQqr%Trs&_sw%Twx!0Vx#O%T#O#P!Fp#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TMg!Fu[&^7[OY%TYZ!EQZ]%T]^!EQ^#o%T#o#p!@b#p#q%T#q#r!@b#r;'S%T;'S;=`!Cu;=`<%l!@b<%lO%T<u!G|d&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`!I[!`#O%T#O#P!?s#P#T%T#T#U!Jh#U#f%T#f#g!Jh#g#h!Jh#h#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<u!Io]kR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<u!J{]!jR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{!LTa&bp&^7[&TS&R,X&Z`&d!bOY!MYYZ'cZ]!MY]^'c^r!MYrs#HTsw!MYwx# vx#O!MY#O#P#@t#P#o!MY#o#p#E^#p#q!MY#q#r#Ac#r;'S!MY;'S;=`#G}<%lO!MYGZ!Mka&^7[&TS&WW&R,X&Z`&d!b&f#tOY!MYYZ'cZ]!MY]^'c^r!MYrs!Npsw!MYwx# vx#O!MY#O#P#@t#P#o!MY#o#p#E^#p#q!MY#q#r#Ac#r;'S!MY;'S;=`#G}<%lO!MYGZ!N}]&^7[&TS&R,X&Z`&d!bOr'crs!,gsw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'cFy#!Ra&^7[&WW&R,X&f#tOY##WYZ)mZ]##W]^)m^r##Wrs#$lsw##Wwx#;fx#O##W#O#P#%p#P#o##W#o#p#3d#p#q##W#q#r#&_#r;'S##W;'S;=`#;`<%lO##WFy##ga&^7[&TS&WW&R,X&d!b&f#tOY##WYZ)mZ]##W]^)m^r##Wrs#$lsw##Wwx# vx#O##W#O#P#%p#P#o##W#o#p#3d#p#q##W#q#r#&_#r;'S##W;'S;=`#;`<%lO##WFy#$w]&^7[&TS&R,X&d!bOr)mrs+usw)mwx(kx#O)m#O#P7}#P#o)m#o#pDs#p#q)m#q#r8l#r;'S)m;'S;=`Kg<%lO)mFy#%uW&^7[O#o##W#o#p#&_#p#q##W#q#r#&_#r;'S##W;'S;=`#:P;=`<%l#&_<%lO##W0m#&l_&TS&WW&R,X&d!b&f#tOY#&_YZ8lZ]#&_]^8l^r#&_rs#'ksw#&_wx#(gx#O#&_#O#P#1w#P#o#&_#o#p#3d#p;'S#&_;'S;=`#9y<%lO#&_0m#'tZ&TS&R,X&d!bOr8lrs:dsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`<%lO8l0m#(p_&WW&R,X&f#tOY#&_YZ8lZ]#&_]^8l^r#&_rs#'ksw#&_wx#)ox#O#&_#O#P#1w#P#o#&_#o#p#3d#p;'S#&_;'S;=`#9y<%lO#&_0m#)x_&WW&R,X&f#tOY#&_YZ8lZ]#&_]^8l^r#&_rs#'ksw#&_wx#*wx#O#&_#O#P#1w#P#o#&_#o#p#3d#p;'S#&_;'S;=`#9y<%lO#&_/V#+Q]&WW&R,X&f#tOY#*wYZ=QZ]#*w]^=Q^r#*wrs#+ys#O#*w#O#P#,k#P#o#*w#o#p#-|#p;'S#*w;'S;=`#1q<%lO#*w/V#,OX&R,XOr=Qrs>ds#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`<%lO=Q/V#,nRO;'S#*w;'S;=`#,w;=`O#*w/V#-Q^&WW&R,X&f#tOY#*wYZ=QZ]#*w]^=Q^r#*wrs#+ys#O#*w#O#P#,k#P#o#*w#o#p#-|#p;'S#*w;'S;=`#1q;=`<%l#*w<%lO#*w/V#.T]&WW&R,XOY#.|YZ@tZ]#.|]^@t^r#.|rs#/vs#O#.|#O#P#0b#P#o#.|#o#p#*w#p;'S#.|;'S;=`#1k<%lO#.|,a#/TZ&WW&R,XOY#.|YZ@tZ]#.|]^@t^r#.|rs#/vs#O#.|#O#P#0b#P;'S#.|;'S;=`#1k<%lO#.|,a#/{V&R,XOr@trsAxs#O@t#O#PB_#P;'S@t;'S;=`CY<%lO@t,a#0eRO;'S#.|;'S;=`#0n;=`O#.|,a#0u[&WW&R,XOY#.|YZ@tZ]#.|]^@t^r#.|rs#/vs#O#.|#O#P#0b#P;'S#.|;'S;=`#1k;=`<%l#.|<%lO#.|,a#1nP;=`<%l#.|/V#1tP;=`<%l#*w0m#1zRO;'S#&_;'S;=`#2T;=`O#&_0m#2b`&TS&WW&R,X&d!b&f#tOY#&_YZ8lZ]#&_]^8l^r#&_rs#'ksw#&_wx#(gx#O#&_#O#P#1w#P#o#&_#o#p#3d#p;'S#&_;'S;=`#9y;=`<%l#&_<%lO#&_0m#3m_&TS&WW&R,XOY#4lYZEmZ]#4l]^Em^r#4lrs#5nsw#4lwx#6bx#O#4l#O#P#8b#P#o#4l#o#p#&_#p;'S#4l;'S;=`#9s<%lO#4l,e#4u]&TS&WW&R,XOY#4lYZEmZ]#4l]^Em^r#4lrs#5nsw#4lwx#6bx#O#4l#O#P#8b#P;'S#4l;'S;=`#9s<%lO#4l,e#5uX&TS&R,XOrEmrsGRswEmwxGsx#OEm#O#PIV#P;'SEm;'S;=`JY<%lOEm,e#6i]&WW&R,XOY#4lYZEmZ]#4l]^Em^r#4lrs#5nsw#4lwx#7bx#O#4l#O#P#8b#P;'S#4l;'S;=`#9s<%lO#4l,e#7i]&WW&R,XOY#4lYZEmZ]#4l]^Em^r#4lrs#5nsw#4lwx#.|x#O#4l#O#P#8b#P;'S#4l;'S;=`#9s<%lO#4l,e#8eRO;'S#4l;'S;=`#8n;=`O#4l,e#8w^&TS&WW&R,XOY#4lYZEmZ]#4l]^Em^r#4lrs#5nsw#4lwx#6bx#O#4l#O#P#8b#P;'S#4l;'S;=`#9s;=`<%l#4l<%lO#4l,e#9vP;=`<%l#4l0m#9|P;=`<%l#&_Fy#:^`&TS&WW&R,X&d!b&f#tOY#&_YZ8lZ]#&_]^8l^r#&_rs#'ksw#&_wx#(gx#O#&_#O#P#1w#P#o#&_#o#p#3d#p;'S#&_;'S;=`#9y;=`<%l##W<%lO#&_Fy#;cP;=`<%l##WFy#;qa&^7[&WW&R,X&f#tOY##WYZ)mZ]##W]^)m^r##Wrs#$lsw##Wwx#<vx#O##W#O#P#%p#P#o##W#o#p#3d#p#q##W#q#r#&_#r;'S##W;'S;=`#;`<%lO##WEc#=R_&^7[&WW&R,X&f#tOY#<vYZLoZ]#<v]^Lo^r#<vrs#>Qs#O#<v#O#P#>z#P#o#<v#o#p#-|#p#q#<v#q#r#*w#r;'S#<v;'S;=`#@n<%lO#<vEc#>XZ&^7[&R,XOrLorsNcs#OLo#O#P! Z#P#oLo#o#p@S#p#qLo#q#r=Q#r;'SLo;'S;=`!!o<%lOLoEc#?PW&^7[O#o#<v#o#p#*w#p#q#<v#q#r#*w#r;'S#<v;'S;=`#?i;=`<%l#*w<%lO#<vEc#?r^&WW&R,X&f#tOY#*wYZ=QZ]#*w]^=Q^r#*wrs#+ys#O#*w#O#P#,k#P#o#*w#o#p#-|#p;'S#*w;'S;=`#1q;=`<%l#<v<%lO#*wEc#@qP;=`<%l#<vGZ#@yW&^7[O#o!MY#o#p#Ac#p#q!MY#q#r#Ac#r;'S!MY;'S;=`#Fl;=`<%l#Ac<%lO!MY0}#Ar_&TS&WW&R,X&Z`&d!b&f#tOY#AcYZ!#dZ]#Ac]^!#d^r#Acrs#Bqsw#Acwx#(gx#O#Ac#O#P#Co#P#o#Ac#o#p#E^#p;'S#Ac;'S;=`#Ff<%lO#Ac0}#B|Z&TS&R,X&Z`&d!bOr!#drs!%`sw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W<%lO!#d0}#CrRO;'S#Ac;'S;=`#C{;=`O#Ac0}#D[`&TS&WW&R,X&Z`&d!b&f#tOY#AcYZ!#dZ]#Ac]^!#d^r#Acrs#Bqsw#Acwx#(gx#O#Ac#O#P#Co#P#o#Ac#o#p#E^#p;'S#Ac;'S;=`#Ff;=`<%l#Ac<%lO#Ac0}#Eg_&TS&WW&R,XOY#4lYZEmZ]#4l]^Em^r#4lrs#5nsw#4lwx#6bx#O#4l#O#P#8b#P#o#4l#o#p#Ac#p;'S#4l;'S;=`#9s<%lO#4l0}#FiP;=`<%l#AcGZ#F{`&TS&WW&R,X&Z`&d!b&f#tOY#AcYZ!#dZ]#Ac]^!#d^r#Acrs#Bqsw#Acwx#(gx#O#Ac#O#P#Co#P#o#Ac#o#p#E^#p;'S#Ac;'S;=`#Ff;=`<%l!MY<%lO#AcGZ#HQP;=`<%l!MYGZ#Hb]&^7[&TS&R,X&Z`&d!bOr'crs#IZsw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'cGZ#IjZ&X#|&^7[&TS&V,X&Z`&d!bOw!-kwx-sx#O!-k#O#P!.i#P#o!-k#o#p!(V#p#q!-k#q#r!&[#r;'S!-k;'S;=`!0P<%lO!-kMg#JpaQ1s&^7[&TS&WW&Z`&ap&d!b&f#tOY#J]YZ%TZ]#J]]^%T^r#J]rs#Kusw#J]wx%;ax#O#J]#O#P& a#P#o#J]#o#p&%b#p#q#J]#q#r&!^#r;'S#J];'S;=`&'u<%lO#J]Lu#LSaQ1s&^7[&TS&Z`&d!bOY#MXYZ'cZ]#MX]^'c^r#MXrs%6usw#MXwx#Nox#O#MX#O#P%*Z#P#o#MX#o#p%4^#p#q#MX#q#r%+W#r;'S#MX;'S;=`%6o<%lO#MXLu#MjaQ1s&^7[&TS&WW&Z`&d!b&f#tOY#MXYZ'cZ]#MX]^'c^r#MXrs#Kusw#MXwx#Nox#O#MX#O#P%*Z#P#o#MX#o#p%4^#p#q#MX#q#r%+W#r;'S#MX;'S;=`%6o<%lO#MXLe#NzaQ1s&^7[&WW&f#tOY$!PYZ)mZ]$!P]^)m^r$!Prs$#esw$!Pwx%#ix#O$!P#O#P$6g#P#o$!P#o#p$Hf#p#q$!P#q#r$7d#r;'S$!P;'S;=`%#c<%lO$!PLe$!`aQ1s&^7[&TS&WW&d!b&f#tOY$!PYZ)mZ]$!P]^)m^r$!Prs$#esw$!Pwx#Nox#O$!P#O#P$6g#P#o$!P#o#p$Hf#p#q$!P#q#r$7d#r;'S$!P;'S;=`%#c<%lO$!PLe$#paQ1s&^7[&TS&d!bOY$!PYZ)mZ]$!P]^)m^r$!Prs$$usw$!Pwx#Nox#O$!P#O#P$6g#P#o$!P#o#p$Hf#p#q$!P#q#r$7d#r;'S$!P;'S;=`%#c<%lO$!PLe$%QaQ1s&^7[&TS&d!bOY$!PYZ)mZ]$!P]^)m^r$!Prs$&Vsw$!Pwx#Nox#O$!P#O#P$6g#P#o$!P#o#p$Hf#p#q$!P#q#r$7d#r;'S$!P;'S;=`%#c<%lO$!PIg$&b_Q1s&^7[&TS&d!bOY$&VYZ,wZ]$&V]^,w^w$&Vwx$'ax#O$&V#O#P$+X#P#o$&V#o#p$0h#p#q$&V#q#r$,U#r;'S$&V;'S;=`$6a<%lO$&VIg$'h_Q1s&^7[OY$&VYZ,wZ]$&V]^,w^w$&Vwx$(gx#O$&V#O#P$+X#P#o$&V#o#p$0h#p#q$&V#q#r$,U#r;'S$&V;'S;=`$6a<%lO$&VIg$(n_Q1s&^7[OY$&VYZ,wZ]$&V]^,w^w$&Vwx$)mx#O$&V#O#P$+X#P#o$&V#o#p$0h#p#q$&V#q#r$,U#r;'S$&V;'S;=`$6a<%lO$&VHP$)tZQ1s&^7[OY$)mYZ/cZ]$)m]^/c^#o$)m#o#p$*g#p#q$)m#q#r$*g#r;'S$)m;'S;=`$+R<%lO$)m1s$*lTQ1sOY$*gZ]$*g^;'S$*g;'S;=`$*{<%lO$*g1s$+OP;=`<%l$*gHP$+UP;=`<%l$)mIg$+`[Q1s&^7[OY$&VYZ,wZ]$&V]^,w^#o$&V#o#p$,U#p#q$&V#q#r$,U#r;'S$&V;'S;=`$5j;=`<%l0l<%lO$&V3Z$,_]Q1s&TS&d!bOY$,UYZ0lZ]$,U]^0l^w$,Uwx$-Wx#O$,U#O#P$/S#P#o$,U#o#p$0h#p;'S$,U;'S;=`$5d<%lO$,U3Z$-]]Q1sOY$,UYZ0lZ]$,U]^0l^w$,Uwx$.Ux#O$,U#O#P$/S#P#o$,U#o#p$0h#p;'S$,U;'S;=`$5d<%lO$,U3Z$.Z]Q1sOY$,UYZ0lZ]$,U]^0l^w$,Uwx$*gx#O$,U#O#P$/S#P#o$,U#o#p$0h#p;'S$,U;'S;=`$5d<%lO$,U3Z$/XWQ1sOY$,UYZ0lZ]$,U]^0l^;'S$,U;'S;=`$/q;=`<%l0l<%lO$,U3Z$/xY&TS&d!bOw0lwx1`x#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z;=`<%l$,U<%lO0l3Z$0o]Q1s&TSOY$1hYZ4`Z]$1h]^4`^w$1hwx$2bx#O$1h#O#P$4Q#P#o$1h#o#p$,U#p;'S$1h;'S;=`$5^<%lO$1h1w$1oZQ1s&TSOY$1hYZ4`Z]$1h]^4`^w$1hwx$2bx#O$1h#O#P$4Q#P;'S$1h;'S;=`$5^<%lO$1h1w$2gZQ1sOY$1hYZ4`Z]$1h]^4`^w$1hwx$3Yx#O$1h#O#P$4Q#P;'S$1h;'S;=`$5^<%lO$1h1w$3_ZQ1sOY$1hYZ4`Z]$1h]^4`^w$1hwx$*gx#O$1h#O#P$4Q#P;'S$1h;'S;=`$5^<%lO$1h1w$4VWQ1sOY$1hYZ4`Z]$1h]^4`^;'S$1h;'S;=`$4o;=`<%l4`<%lO$1h1w$4tW&TSOw4`wx4zx#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l$1h<%lO4`1w$5aP;=`<%l$1h3Z$5gP;=`<%l$,UIg$5qY&TS&d!bOw0lwx1`x#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z;=`<%l$&V<%lO0lIg$6dP;=`<%l$&VLe$6n[Q1s&^7[OY$!PYZ)mZ]$!P]^)m^#o$!P#o#p$7d#p#q$!P#q#r$7d#r;'S$!P;'S;=`%!b;=`<%l8l<%lO$!P6X$7q_Q1s&TS&WW&d!b&f#tOY$7dYZ8lZ]$7d]^8l^r$7drs$8psw$7dwx$;Qx#O$7d#O#P$Fv#P#o$7d#o#p$Hf#p;'S$7d;'S;=`%![<%lO$7d6X$8y_Q1s&TS&d!bOY$7dYZ8lZ]$7d]^8l^r$7drs$9xsw$7dwx$;Qx#O$7d#O#P$Fv#P#o$7d#o#p$Hf#p;'S$7d;'S;=`%![<%lO$7d6X$:R_Q1s&TS&d!bOY$7dYZ8lZ]$7d]^8l^r$7drs$,Usw$7dwx$;Qx#O$7d#O#P$Fv#P#o$7d#o#p$Hf#p;'S$7d;'S;=`%![<%lO$7d6X$;Z_Q1s&WW&f#tOY$7dYZ8lZ]$7d]^8l^r$7drs$8psw$7dwx$<Yx#O$7d#O#P$Fv#P#o$7d#o#p$Hf#p;'S$7d;'S;=`%![<%lO$7d6X$<c_Q1s&WW&f#tOY$7dYZ8lZ]$7d]^8l^r$7drs$8psw$7dwx$=bx#O$7d#O#P$Fv#P#o$7d#o#p$Hf#p;'S$7d;'S;=`%![<%lO$7d4q$=k]Q1s&WW&f#tOY$=bYZ=QZ]$=b]^=Q^r$=brs$>ds#O$=b#O#P$@`#P#o$=b#o#p$At#p;'S$=b;'S;=`$Fp<%lO$=b4q$>i]Q1sOY$=bYZ=QZ]$=b]^=Q^r$=brs$?bs#O$=b#O#P$@`#P#o$=b#o#p$At#p;'S$=b;'S;=`$Fp<%lO$=b4q$?g]Q1sOY$=bYZ=QZ]$=b]^=Q^r$=brs$*gs#O$=b#O#P$@`#P#o$=b#o#p$At#p;'S$=b;'S;=`$Fp<%lO$=b4q$@eWQ1sOY$=bYZ=QZ]$=b]^=Q^;'S$=b;'S;=`$@};=`<%l=Q<%lO$=b4q$AUY&WW&f#tOr=Qrs=ts#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`;=`<%l$=b<%lO=Q4q$A{]Q1s&WWOY$BtYZ@tZ]$Bt]^@t^r$Btrs$Cns#O$Bt#O#P$E^#P#o$Bt#o#p$=b#p;'S$Bt;'S;=`$Fj<%lO$Bt1{$B{ZQ1s&WWOY$BtYZ@tZ]$Bt]^@t^r$Btrs$Cns#O$Bt#O#P$E^#P;'S$Bt;'S;=`$Fj<%lO$Bt1{$CsZQ1sOY$BtYZ@tZ]$Bt]^@t^r$Btrs$Dfs#O$Bt#O#P$E^#P;'S$Bt;'S;=`$Fj<%lO$Bt1{$DkZQ1sOY$BtYZ@tZ]$Bt]^@t^r$Btrs$*gs#O$Bt#O#P$E^#P;'S$Bt;'S;=`$Fj<%lO$Bt1{$EcWQ1sOY$BtYZ@tZ]$Bt]^@t^;'S$Bt;'S;=`$E{;=`<%l@t<%lO$Bt1{$FQW&WWOr@trsA`s#O@t#O#PB_#P;'S@t;'S;=`CY;=`<%l$Bt<%lO@t1{$FmP;=`<%l$Bt4q$FsP;=`<%l$=b6X$F{WQ1sOY$7dYZ8lZ]$7d]^8l^;'S$7d;'S;=`$Ge;=`<%l8l<%lO$7d6X$Gp[&TS&WW&d!b&f#tOr8lrs9jsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`;=`<%l$7d<%lO8l6X$Ho_Q1s&TS&WWOY$InYZEmZ]$In]^Em^r$Inrs$Jpsw$Inwx$Lpx#O$In#O#P$Np#P#o$In#o#p$7d#p;'S$In;'S;=`%!U<%lO$In2P$Iw]Q1s&TS&WWOY$InYZEmZ]$In]^Em^r$Inrs$Jpsw$Inwx$Lpx#O$In#O#P$Np#P;'S$In;'S;=`%!U<%lO$In2P$Jw]Q1s&TSOY$InYZEmZ]$In]^Em^r$Inrs$Kpsw$Inwx$Lpx#O$In#O#P$Np#P;'S$In;'S;=`%!U<%lO$In2P$Kw]Q1s&TSOY$InYZEmZ]$In]^Em^r$Inrs$1hsw$Inwx$Lpx#O$In#O#P$Np#P;'S$In;'S;=`%!U<%lO$In2P$Lw]Q1s&WWOY$InYZEmZ]$In]^Em^r$Inrs$Jpsw$Inwx$Mpx#O$In#O#P$Np#P;'S$In;'S;=`%!U<%lO$In2P$Mw]Q1s&WWOY$InYZEmZ]$In]^Em^r$Inrs$Jpsw$Inwx$Btx#O$In#O#P$Np#P;'S$In;'S;=`%!U<%lO$In2P$NuWQ1sOY$InYZEmZ]$In]^Em^;'S$In;'S;=`% _;=`<%lEm<%lO$In2P% fY&TS&WWOrEmrsFaswEmwxGsx#OEm#O#PIV#P;'SEm;'S;=`JY;=`<%l$In<%lOEm2P%!XP;=`<%l$In6X%!_P;=`<%l$7dLe%!m[&TS&WW&d!b&f#tOr8lrs9jsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`;=`<%l$!P<%lO8lLe%#fP;=`<%l$!PLe%#taQ1s&^7[&WW&f#tOY$!PYZ)mZ]$!P]^)m^r$!Prs$#esw$!Pwx%$yx#O$!P#O#P$6g#P#o$!P#o#p$Hf#p#q$!P#q#r$7d#r;'S$!P;'S;=`%#c<%lO$!PJ}%%U_Q1s&^7[&WW&f#tOY%$yYZLoZ]%$y]^Lo^r%$yrs%&Ts#O%$y#O#P%(a#P#o%$y#o#p$At#p#q%$y#q#r$=b#r;'S%$y;'S;=`%*T<%lO%$yJ}%&[_Q1s&^7[OY%$yYZLoZ]%$y]^Lo^r%$yrs%'Zs#O%$y#O#P%(a#P#o%$y#o#p$At#p#q%$y#q#r$=b#r;'S%$y;'S;=`%*T<%lO%$yJ}%'b_Q1s&^7[OY%$yYZLoZ]%$y]^Lo^r%$yrs$)ms#O%$y#O#P%(a#P#o%$y#o#p$At#p#q%$y#q#r$=b#r;'S%$y;'S;=`%*T<%lO%$yJ}%(h[Q1s&^7[OY%$yYZLoZ]%$y]^Lo^#o%$y#o#p$=b#p#q%$y#q#r$=b#r;'S%$y;'S;=`%)^;=`<%l=Q<%lO%$yJ}%)eY&WW&f#tOr=Qrs=ts#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`;=`<%l%$y<%lO=QJ}%*WP;=`<%l%$yLu%*b[Q1s&^7[OY#MXYZ'cZ]#MX]^'c^#o#MX#o#p%+W#p#q#MX#q#r%+W#r;'S#MX;'S;=`%5l;=`<%l!#d<%lO#MX6i%+g_Q1s&TS&WW&Z`&d!b&f#tOY%+WYZ!#dZ]%+W]^!#d^r%+Wrs%,fsw%+Wwx$;Qx#O%+W#O#P%2l#P#o%+W#o#p%4^#p;'S%+W;'S;=`%5f<%lO%+W6i%,q_Q1s&TS&Z`&d!bOY%+WYZ!#dZ]%+W]^!#d^r%+Wrs%-psw%+Wwx$;Qx#O%+W#O#P%2l#P#o%+W#o#p%4^#p;'S%+W;'S;=`%5f<%lO%+W6i%-{_Q1s&TS&Z`&d!bOY%+WYZ!#dZ]%+W]^!#d^r%+Wrs%.zsw%+Wwx$;Qx#O%+W#O#P%2l#P#o%+W#o#p%4^#p;'S%+W;'S;=`%5f<%lO%+W3k%/V]Q1s&TS&Z`&d!bOY%.zYZ!&[Z]%.z]^!&[^w%.zwx$-Wx#O%.z#O#P%0O#P#o%.z#o#p%1f#p;'S%.z;'S;=`%2f<%lO%.z3k%0TWQ1sOY%.zYZ!&[Z]%.z]^!&[^;'S%.z;'S;=`%0m;=`<%l!&[<%lO%.z3k%0vY&TS&Z`&d!bOw!&[wx1`x#O!&[#O#P!'Q#P#o!&[#o#p!(V#p;'S!&[;'S;=`!(w;=`<%l%.z<%lO!&[3k%1m]Q1s&TSOY$1hYZ4`Z]$1h]^4`^w$1hwx$2bx#O$1h#O#P$4Q#P#o$1h#o#p%.z#p;'S$1h;'S;=`$5^<%lO$1h3k%2iP;=`<%l%.z6i%2qWQ1sOY%+WYZ!#dZ]%+W]^!#d^;'S%+W;'S;=`%3Z;=`<%l!#d<%lO%+W6i%3h[&TS&WW&Z`&d!b&f#tOr!#drs!$dsw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W;=`<%l%+W<%lO!#d6i%4g_Q1s&TS&WWOY$InYZEmZ]$In]^Em^r$Inrs$Jpsw$Inwx$Lpx#O$In#O#P$Np#P#o$In#o#p%+W#p;'S$In;'S;=`%!U<%lO$In6i%5iP;=`<%l%+WLu%5y[&TS&WW&Z`&d!b&f#tOr!#drs!$dsw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W;=`<%l#MX<%lO!#dLu%6rP;=`<%l#MXLu%7SaQ1s&^7[&TS&Z`&d!bOY#MXYZ'cZ]#MX]^'c^r#MXrs%8Xsw#MXwx#Nox#O#MX#O#P%*Z#P#o#MX#o#p%4^#p#q#MX#q#r%+W#r;'S#MX;'S;=`%6o<%lO#MXIw%8f_Q1s&^7[&TS&Z`&d!bOY%8XYZ!-kZ]%8X]^!-k^w%8Xwx$'ax#O%8X#O#P%9e#P#o%8X#o#p%1f#p#q%8X#q#r%.z#r;'S%8X;'S;=`%;Z<%lO%8XIw%9l[Q1s&^7[OY%8XYZ!-kZ]%8X]^!-k^#o%8X#o#p%.z#p#q%8X#q#r%.z#r;'S%8X;'S;=`%:b;=`<%l!&[<%lO%8XIw%:kY&TS&Z`&d!bOw!&[wx1`x#O!&[#O#P!'Q#P#o!&[#o#p!(V#p;'S!&[;'S;=`!(w;=`<%l%8X<%lO!&[Iw%;^P;=`<%l%8XMV%;naQ1s&^7[&WW&ap&f#tOY%<sYZ!1ZZ]%<s]^!1Z^r%<srs$#esw%<swx%Jux#O%<s#O#P%>Z#P#o%<s#o#p%H^#p#q%<s#q#r%?W#r;'S%<s;'S;=`%Jo<%lO%<sMV%=UaQ1s&^7[&TS&WW&ap&d!b&f#tOY%<sYZ!1ZZ]%<s]^!1Z^r%<srs$#esw%<swx%;ax#O%<s#O#P%>Z#P#o%<s#o#p%H^#p#q%<s#q#r%?W#r;'S%<s;'S;=`%Jo<%lO%<sMV%>b[Q1s&^7[OY%<sYZ!1ZZ]%<s]^!1Z^#o%<s#o#p%?W#p#q%<s#q#r%?W#r;'S%<s;'S;=`%Il;=`<%l!3Q<%lO%<s6y%?g_Q1s&TS&WW&ap&d!b&f#tOY%?WYZ!3QZ]%?W]^!3Q^r%?Wrs$8psw%?Wwx%@fx#O%?W#O#P%Fl#P#o%?W#o#p%H^#p;'S%?W;'S;=`%If<%lO%?W6y%@q_Q1s&WW&ap&f#tOY%?WYZ!3QZ]%?W]^!3Q^r%?Wrs$8psw%?Wwx%Apx#O%?W#O#P%Fl#P#o%?W#o#p%H^#p;'S%?W;'S;=`%If<%lO%?W6y%A{_Q1s&WW&ap&f#tOY%?WYZ!3QZ]%?W]^!3Q^r%?Wrs$8psw%?Wwx%Bzx#O%?W#O#P%Fl#P#o%?W#o#p%H^#p;'S%?W;'S;=`%If<%lO%?W5c%CV]Q1s&WW&ap&f#tOY%BzYZ!5xZ]%Bz]^!5x^r%Bzrs$>ds#O%Bz#O#P%DO#P#o%Bz#o#p%Ef#p;'S%Bz;'S;=`%Ff<%lO%Bz5c%DTWQ1sOY%BzYZ!5xZ]%Bz]^!5x^;'S%Bz;'S;=`%Dm;=`<%l!5x<%lO%Bz5c%DvY&WW&ap&f#tOr!5xrs=ts#O!5x#O#P!6n#P#o!5x#o#p!7s#p;'S!5x;'S;=`!8e;=`<%l%Bz<%lO!5x5c%Em]Q1s&WWOY$BtYZ@tZ]$Bt]^@t^r$Btrs$Cns#O$Bt#O#P$E^#P#o$Bt#o#p%Bz#p;'S$Bt;'S;=`$Fj<%lO$Bt5c%FiP;=`<%l%Bz6y%FqWQ1sOY%?WYZ!3QZ]%?W]^!3Q^;'S%?W;'S;=`%GZ;=`<%l!3Q<%lO%?W6y%Gh[&TS&WW&ap&d!b&f#tOr!3Qrs9jsw!3Qwx!4Qx#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t;=`<%l%?W<%lO!3Q6y%Hg_Q1s&TS&WWOY$InYZEmZ]$In]^Em^r$Inrs$Jpsw$Inwx$Lpx#O$In#O#P$Np#P#o$In#o#p%?W#p;'S$In;'S;=`%!U<%lO$In6y%IiP;=`<%l%?WMV%Iy[&TS&WW&ap&d!b&f#tOr!3Qrs9jsw!3Qwx!4Qx#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t;=`<%l%<s<%lO!3QMV%JrP;=`<%l%<sMV%KSaQ1s&^7[&WW&ap&f#tOY%<sYZ!1ZZ]%<s]^!1Z^r%<srs$#esw%<swx%LXx#O%<s#O#P%>Z#P#o%<s#o#p%H^#p#q%<s#q#r%?W#r;'S%<s;'S;=`%Jo<%lO%<sKo%Lf_Q1s&^7[&WW&ap&f#tOY%LXYZ!=XZ]%LX]^!=X^r%LXrs%&Ts#O%LX#O#P%Me#P#o%LX#o#p%Ef#p#q%LX#q#r%Bz#r;'S%LX;'S;=`& Z<%lO%LXKo%Ml[Q1s&^7[OY%LXYZ!=XZ]%LX]^!=X^#o%LX#o#p%Bz#p#q%LX#q#r%Bz#r;'S%LX;'S;=`%Nb;=`<%l!5x<%lO%LXKo%NkY&WW&ap&f#tOr!5xrs=ts#O!5x#O#P!6n#P#o!5x#o#p!7s#p;'S!5x;'S;=`!8e;=`<%l%LX<%lO!5xKo& ^P;=`<%l%LXMg& h[Q1s&^7[OY#J]YZ%TZ]#J]]^%T^#o#J]#o#p&!^#p#q#J]#q#r&!^#r;'S#J];'S;=`&&p;=`<%l!@b<%lO#J]7Z&!o_Q1s&TS&WW&Z`&ap&d!b&f#tOY&!^YZ!@bZ]&!^]^!@b^r&!^rs%,fsw&!^wx%@fx#O&!^#O#P&#n#P#o&!^#o#p&%b#p;'S&!^;'S;=`&&j<%lO&!^7Z&#sWQ1sOY&!^YZ!@bZ]&!^]^!@b^;'S&!^;'S;=`&$];=`<%l!@b<%lO&!^7Z&$l[&TS&WW&Z`&ap&d!b&f#tOr!@brs!$dsw!@bwx!4Qx#O!@b#O#P!Ad#P#o!@b#o#p!Bu#p;'S!@b;'S;=`!Co;=`<%l&!^<%lO!@b7Z&%k_Q1s&TS&WWOY$InYZEmZ]$In]^Em^r$Inrs$Jpsw$Inwx$Lpx#O$In#O#P$Np#P#o$In#o#p&!^#p;'S$In;'S;=`%!U<%lO$In7Z&&mP;=`<%l&!^Mg&'P[&TS&WW&Z`&ap&d!b&f#tOr!@brs!$dsw!@bwx!4Qx#O!@b#O#P!Ad#P#o!@b#o#p!Bu#p;'S!@b;'S;=`!Co;=`<%l#J]<%lO!@bMg&'xP;=`<%l#J]Gz&(`_%jQ&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGz&)r]!s,W&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGz&+O_%dQ&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{&,^a&_`&^7[&WW&R,X&ap&f#tOY&-cYZ!1ZZ]&-c]^!1Z^r&-crs&.ysw&-cwx'(^x#O&-c#O#P&N}#P#o&-c#o#p'%g#p#q&-c#q#r' l#r;'S&-c;'S;=`'(W<%lO&-cGk&-ta&^7[&TS&WW&R,X&ap&d!b&f#tOY&-cYZ!1ZZ]&-c]^!1Z^r&-crs&.ysw&-cwx&Mwx#O&-c#O#P&N}#P#o&-c#o#p'%g#p#q&-c#q#r' l#r;'S&-c;'S;=`'(W<%lO&-cFy&/Ua&^7[&TS&R,X&d!bOY&0ZYZ)mZ]&0Z]^)m^r&0Zrs&Hisw&0Zwx&1ox#O&0Z#O#P&2s#P#o&0Z#o#p&@g#p#q&0Z#q#r&3b#r;'S&0Z;'S;=`&Hc<%lO&0ZFy&0ja&^7[&TS&WW&R,X&d!b&f#tOY&0ZYZ)mZ]&0Z]^)m^r&0Zrs&.ysw&0Zwx&1ox#O&0Z#O#P&2s#P#o&0Z#o#p&@g#p#q&0Z#q#r&3b#r;'S&0Z;'S;=`&Hc<%lO&0ZFy&1z]&^7[&WW&R,X&f#tOr)mrs*ssw)mwxKmx#O)m#O#P7}#P#o)m#o#pDs#p#q)m#q#r8l#r;'S)m;'S;=`Kg<%lO)mFy&2xW&^7[O#o&0Z#o#p&3b#p#q&0Z#q#r&3b#r;'S&0Z;'S;=`&GS;=`<%l&3b<%lO&0Z0m&3o_&TS&WW&R,X&d!b&f#tOY&3bYZ8lZ]&3b]^8l^r&3brs&4nsw&3bwx&>Ox#O&3b#O#P&>z#P#o&3b#o#p&@g#p;'S&3b;'S;=`&F|<%lO&3b0m&4w_&TS&R,X&d!bOY&3bYZ8lZ]&3b]^8l^r&3brs&5vsw&3bwx&>Ox#O&3b#O#P&>z#P#o&3b#o#p&@g#p;'S&3b;'S;=`&F|<%lO&3b0m&6P_&TS&R,X&d!bOY&3bYZ8lZ]&3b]^8l^r&3brs&7Osw&3bwx&>Ox#O&3b#O#P&>z#P#o&3b#o#p&@g#p;'S&3b;'S;=`&F|<%lO&3b-o&7X]&TS&R,X&d!bOY&7OYZ0lZ]&7O]^0l^w&7Owx&8Qx#O&7O#O#P&8r#P#o&7O#o#p&:T#p;'S&7O;'S;=`&=x<%lO&7O-o&8VX&R,XOw0lwx2Ox#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z<%lO0l-o&8uRO;'S&7O;'S;=`&9O;=`O&7O-o&9X^&TS&R,X&d!bOY&7OYZ0lZ]&7O]^0l^w&7Owx&8Qx#O&7O#O#P&8r#P#o&7O#o#p&:T#p;'S&7O;'S;=`&=x;=`<%l&7O<%lO&7O-o&:[]&TS&R,XOY&;TYZ4`Z]&;T]^4`^w&;Twx&;}x#O&;T#O#P&<i#P#o&;T#o#p&7O#p;'S&;T;'S;=`&=r<%lO&;T,]&;[Z&TS&R,XOY&;TYZ4`Z]&;T]^4`^w&;Twx&;}x#O&;T#O#P&<i#P;'S&;T;'S;=`&=r<%lO&;T,]&<SV&R,XOw4`wx5dx#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`,]&<lRO;'S&;T;'S;=`&<u;=`O&;T,]&<|[&TS&R,XOY&;TYZ4`Z]&;T]^4`^w&;Twx&;}x#O&;T#O#P&<i#P;'S&;T;'S;=`&=r;=`<%l&;T<%lO&;T,]&=uP;=`<%l&;T-o&={P;=`<%l&7O0m&>XZ&WW&R,X&f#tOr8lrs9jsw8lwx<Wx#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`<%lO8l0m&>}RO;'S&3b;'S;=`&?W;=`O&3b0m&?e`&TS&WW&R,X&d!b&f#tOY&3bYZ8lZ]&3b]^8l^r&3brs&4nsw&3bwx&>Ox#O&3b#O#P&>z#P#o&3b#o#p&@g#p;'S&3b;'S;=`&F|;=`<%l&3b<%lO&3b0m&@p_&TS&WW&R,XOY&AoYZEmZ]&Ao]^Em^r&Aors&Bqsw&Aowx&Dqx#O&Ao#O#P&Ee#P#o&Ao#o#p&3b#p;'S&Ao;'S;=`&Fv<%lO&Ao,e&Ax]&TS&WW&R,XOY&AoYZEmZ]&Ao]^Em^r&Aors&Bqsw&Aowx&Dqx#O&Ao#O#P&Ee#P;'S&Ao;'S;=`&Fv<%lO&Ao,e&Bx]&TS&R,XOY&AoYZEmZ]&Ao]^Em^r&Aors&Cqsw&Aowx&Dqx#O&Ao#O#P&Ee#P;'S&Ao;'S;=`&Fv<%lO&Ao,e&Cx]&TS&R,XOY&AoYZEmZ]&Ao]^Em^r&Aors&;Tsw&Aowx&Dqx#O&Ao#O#P&Ee#P;'S&Ao;'S;=`&Fv<%lO&Ao,e&DxX&WW&R,XOrEmrsFaswEmwxHex#OEm#O#PIV#P;'SEm;'S;=`JY<%lOEm,e&EhRO;'S&Ao;'S;=`&Eq;=`O&Ao,e&Ez^&TS&WW&R,XOY&AoYZEmZ]&Ao]^Em^r&Aors&Bqsw&Aowx&Dqx#O&Ao#O#P&Ee#P;'S&Ao;'S;=`&Fv;=`<%l&Ao<%lO&Ao,e&FyP;=`<%l&Ao0m&GPP;=`<%l&3bFy&Ga`&TS&WW&R,X&d!b&f#tOY&3bYZ8lZ]&3b]^8l^r&3brs&4nsw&3bwx&>Ox#O&3b#O#P&>z#P#o&3b#o#p&@g#p;'S&3b;'S;=`&F|;=`<%l&0Z<%lO&3bFy&HfP;=`<%l&0ZFy&Hta&^7[&TS&R,X&d!bOY&0ZYZ)mZ]&0Z]^)m^r&0Zrs&Iysw&0Zwx&1ox#O&0Z#O#P&2s#P#o&0Z#o#p&@g#p#q&0Z#q#r&3b#r;'S&0Z;'S;=`&Hc<%lO&0ZC{&JU_&^7[&TS&R,X&d!bOY&IyYZ,wZ]&Iy]^,w^w&Iywx&KTx#O&Iy#O#P&K}#P#o&Iy#o#p&:T#p#q&Iy#q#r&7O#r;'S&Iy;'S;=`&Mq<%lO&IyC{&K[Z&^7[&R,XOw,wwx.kx#O,w#O#P/}#P#o,w#o#p3n#p#q,w#q#r0l#r;'S,w;'S;=`7w<%lO,wC{&LSW&^7[O#o&Iy#o#p&7O#p#q&Iy#q#r&7O#r;'S&Iy;'S;=`&Ll;=`<%l&7O<%lO&IyC{&Lu^&TS&R,X&d!bOY&7OYZ0lZ]&7O]^0l^w&7Owx&8Qx#O&7O#O#P&8r#P#o&7O#o#p&:T#p;'S&7O;'S;=`&=x;=`<%l&Iy<%lO&7OC{&MtP;=`<%l&IyGk&NU]&^7[&WW&R,X&ap&f#tOr!1Zrs*ssw!1Zwx!<Tx#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1ZGk' SW&^7[O#o&-c#o#p' l#p#q&-c#q#r' l#r;'S&-c;'S;=`'&u;=`<%l' l<%lO&-c1_' {_&TS&WW&R,X&ap&d!b&f#tOY' lYZ!3QZ]' l]^!3Q^r' lrs&4nsw' lwx'!zx#O' l#O#P'#x#P#o' l#o#p'%g#p;'S' l;'S;=`'&o<%lO' l1_'#VZ&WW&R,X&ap&f#tOr!3Qrs9jsw!3Qwx!4|x#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t<%lO!3Q1_'#{RO;'S' l;'S;=`'$U;=`O' l1_'$e`&TS&WW&R,X&ap&d!b&f#tOY' lYZ!3QZ]' l]^!3Q^r' lrs&4nsw' lwx'!zx#O' l#O#P'#x#P#o' l#o#p'%g#p;'S' l;'S;=`'&o;=`<%l' l<%lO' l1_'%p_&TS&WW&R,XOY&AoYZEmZ]&Ao]^Em^r&Aors&Bqsw&Aowx&Dqx#O&Ao#O#P&Ee#P#o&Ao#o#p' l#p;'S&Ao;'S;=`&Fv<%lO&Ao1_'&rP;=`<%l' lGk''U`&TS&WW&R,X&ap&d!b&f#tOY' lYZ!3QZ]' l]^!3Q^r' lrs&4nsw' lwx'!zx#O' l#O#P'#x#P#o' l#o#p'%g#p;'S' l;'S;=`'&o;=`<%l&-c<%lO' lGk'(ZP;=`<%l&-cGk'(k]&^7[&WW&R,X&ap&f#tOr!1Zrs*ssw!1Zwx')dx#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1ZGk')sZ&U!f&^7[&WW&S,X&ap&f#tOr!=XrsMks#O!=X#O#P!>V#P#o!=X#o#p!7s#p#q!=X#q#r!5x#r;'S!=X;'S;=`!?m<%lO!=XG{'*y]f,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<u',V]eR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{'-caT,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vxz%Tz{'.h{!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{'.{__R&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{'0__%g,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<u'1q]xR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TMg'2}`%h,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`!a'4P!a#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TB^'4d]&q&j&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{'5pa!dQ&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!O%T!O!P'6u!P!Q%T!Q!['9c![#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{'7W_&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!O%T!O!P'8V!P#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{'8j]!m,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'9vi!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!['9c![!g%T!g!h';e!h!l%T!l!m'@X!m#O%T#O#P!?s#P#R%T#R#S'9c#S#X%T#X#Y';e#Y#^%T#^#_'@X#_#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy';vc&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx{%T{|'=R|}%T}!O'=R!O!Q%T!Q!['>c![#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'=d_&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!['>c![#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'>ve!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!['>c![!l%T!l!m'@X!m#O%T#O#P!?s#P#R%T#R#S'>c#S#^%T#^#_'@X#_#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'@l]!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{'Axa%iR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!P%T!P!Q'B}!Q!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGz'Cb_%kQ&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'Dtw!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!O%T!O!P'G_!P!Q%T!Q!['Ho![!d%T!d!e'Jw!e!g%T!g!h';e!h!l%T!l!m'@X!m!q%T!q!r'M}!r!z%T!z!{(!}!{#O%T#O#P!?s#P#R%T#R#S'Ho#S#U%T#U#V'Jw#V#X%T#X#Y';e#Y#^%T#^#_'@X#_#c%T#c#d'M}#d#l%T#l#m(!}#m#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'Gp_&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!['9c![#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'ISk!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!O%T!O!P'G_!P!Q%T!Q!['Ho![!g%T!g!h';e!h!l%T!l!m'@X!m#O%T#O#P!?s#P#R%T#R#S'Ho#S#X%T#X#Y';e#Y#^%T#^#_'@X#_#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'KYb&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!R'Lb!R!S'Lb!S#O%T#O#P!?s#P#R%T#R#S'Lb#S#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'Lub!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!R'Lb!R!S'Lb!S#O%T#O#P!?s#P#R%T#R#S'Lb#S#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'N`a&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!Y( e!Y#O%T#O#P!?s#P#R%T#R#S( e#S#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy( xa!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!Y( e!Y#O%T#O#P!?s#P#R%T#R#S( e#S#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy(#`e&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q![($q![!c%T!c!i($q!i#O%T#O#P!?s#P#R%T#R#S($q#S#T%T#T#Z($q#Z#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy(%Ue!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q![($q![!c%T!c!i($q!i#O%T#O#P!?s#P#R%T#R#S($q#S#T%T#T#Z($q#Z#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TMg(&z_y1s&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`('y!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<u((^]%sR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{()j]#^,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{(*vakR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!^%T!^!_(+{!_!`!I[!`!a!I[!a#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGz(,`_%eQ&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{(-r_%r,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`!I[!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{(/U`kR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`!I[!`!a(0W!a#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGz(0k_%fQ&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{(2P_]Q#tP&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TMg(3ee&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr%Trs&_sw%Twx!0Vx!Q%T!Q![(3O![!c%T!c!}(3O!}#O%T#O#P!?s#P#R%T#R#S(3O#S#T%T#T#o(3O#o#p!Bu#p#q%T#q#r!@b#r$g%T$g;'S(3O;'S;=`(4v<%lO(3OMg(4yP;=`<%l(3OMg(5ci&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr%Trs(7Qsw%Twx(:jx!Q%T!Q![(3O![!c%T!c!t(3O!t!u(>S!u!}(3O!}#O%T#O#P!?s#P#R%T#R#S(3O#S#T%T#T#f(3O#f#g(>S#g#o(3O#o#p!Bu#p#q%T#q#r!@b#r$g%T$g;'S(3O;'S;=`(4v<%lO(3OGZ(7_a&^7[&TS&R,X&Z`&d!bOY!MYYZ'cZ]!MY]^'c^r!MYrs(8dsw!MYwx# vx#O!MY#O#P#@t#P#o!MY#o#p#E^#p#q!MY#q#r#Ac#r;'S!MY;'S;=`#G}<%lO!MYGZ(8q]&^7[&TS&R,X&Z`&d!bOr'crs(9jsw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'cD](9wZ&^7[&TS&V,X&Z`&d!bOw!-kwx-sx#O!-k#O#P!.i#P#o!-k#o#p!(V#p#q!-k#q#r!&[#r;'S!-k;'S;=`!0P<%lO!-kGk(:wa&^7[&WW&R,X&ap&f#tOY&-cYZ!1ZZ]&-c]^!1Z^r&-crs&.ysw&-cwx(;|x#O&-c#O#P&N}#P#o&-c#o#p'%g#p#q&-c#q#r' l#r;'S&-c;'S;=`'(W<%lO&-cGk(<Z]&^7[&WW&R,X&ap&f#tOr!1Zrs*ssw!1Zwx(=Sx#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1ZFT(=aZ&^7[&WW&S,X&ap&f#tOr!=XrsMks#O!=X#O#P!>V#P#o!=X#o#p!7s#p#q!=X#q#r!5x#r;'S!=X;'S;=`!?m<%lO!=XMg(>ie&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr%Trs(7Qsw%Twx(:jx!Q%T!Q![(3O![!c%T!c!}(3O!}#O%T#O#P!?s#P#R%T#R#S(3O#S#T%T#T#o(3O#o#p!Bu#p#q%T#q#r!@b#r$g%T$g;'S(3O;'S;=`(4v<%lO(3OMg(@ai&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr%Trs(BOsw%Twx(EYx!Q%T!Q![(3O![!c%T!c!t(3O!t!u(Hd!u!}(3O!}#O%T#O#P!?s#P#R%T#R#S(3O#S#T%T#T#f(3O#f#g(Hd#g#o(3O#o#p!Bu#p#q%T#q#r!@b#r$g%T$g;'S(3O;'S;=`(4v<%lO(3OGZ(B]]&^7[&TS&Z`&d!b&`,XOr'crs(CUsw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'cGZ(Ca]&^7[&TS&Z`&d!bOr'crs(DYsw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'cD](DgZ&^7[&TS&e,X&Z`&d!bOw!-kwx-sx#O!-k#O#P!.i#P#o!-k#o#p!(V#p#q!-k#q#r!&[#r;'S!-k;'S;=`!0P<%lO!-kGk(Eg]&^7[&WW&ap&f#t&Y,XOr!1Zrs*ssw!1Zwx(F`x#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1ZGk(Fk]&^7[&WW&ap&f#tOr!1Zrs*ssw!1Zwx(Gdx#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1ZFT(GqZ&^7[&WW&c,X&ap&f#tOr!=XrsMks#O!=X#O#P!>V#P#o!=X#o#p!7s#p#q!=X#q#r!5x#r;'S!=X;'S;=`!?m<%lO!=XMg(Hye&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr%Trs(BOsw%Twx(EYx!Q%T!Q![(3O![!c%T!c!}(3O!}#O%T#O#P!?s#P#R%T#R#S(3O#S#T%T#T#o(3O#o#p!Bu#p#q%T#q#r!@b#r$g%T$g;'S(3O;'S;=`(4v<%lO(3OMg(Jqm&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr%Trs(7Qsw%Twx(:jx!Q%T!Q![(3O![!c%T!c!h(3O!h!i(Hd!i!t(3O!t!u(>S!u!}(3O!}#O%T#O#P!?s#P#R%T#R#S(3O#S#T%T#T#U(3O#U#V(>S#V#Y(3O#Y#Z(Hd#Z#o(3O#o#p!Bu#p#q%T#q#r!@b#r$g%T$g;'S(3O;'S;=`(4v<%lO(3OG{(MP]!V,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<u(N]]!UR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGz) i_%cQ&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy)!qZ&TS&WW!ZGmOrEmrsFaswEmwxGsx#OEm#O#PIV#P#oEm#o#p!@b#p;'SEm;'S;=`JY<%lOEmG{)#w_%bR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<u)%XZ!Y7_&TS&WW&Z`&ap&d!b&f#tOr!@brs!$dsw!@bwx!4Qx#O!@b#O#P!Ad#P#o!@b#o#p!Bu#p;'S!@b;'S;=`!Co<%lO!@bGy)&_]%l,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T",
  tokenizers: [kq, Xq, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, vq],
  topRules: { Script: [0, 3] },
  specialized: [{ term: 213, get: (t) => Wq[t] || -1 }],
  tokenPrec: 7282
});
var OS = new P1();
var TX = /* @__PURE__ */ new Set([
  "Script",
  "Body",
  "FunctionDefinition",
  "ClassDefinition",
  "LambdaExpression",
  "ForStatement",
  "MatchClause"
]);
function Ol(t) {
  return (e, i, n) => {
    if (n)
      return false;
    let O = e.node.getChild("VariableName");
    return O && i(O, t), true;
  };
}
var Rq = {
  FunctionDefinition: Ol("function"),
  ClassDefinition: Ol("class"),
  ForStatement(t, e, i) {
    if (i) {
      for (let n = t.node.firstChild; n; n = n.nextSibling)
        if (n.name == "VariableName")
          e(n, "variable");
        else if (n.name == "in")
          break;
    }
  },
  ImportStatement(t, e) {
    var i, n;
    let { node: O } = t, r = ((i = O.firstChild) === null || i === void 0 ? void 0 : i.name) == "from";
    for (let a = O.getChild("import"); a; a = a.nextSibling)
      a.name == "VariableName" && ((n = a.nextSibling) === null || n === void 0 ? void 0 : n.name) != "as" && e(a, r ? "variable" : "namespace");
  },
  AssignStatement(t, e) {
    for (let i = t.node.firstChild; i; i = i.nextSibling)
      if (i.name == "VariableName")
        e(i, "variable");
      else if (i.name == ":" || i.name == "AssignOp")
        break;
  },
  ParamList(t, e) {
    for (let i = null, n = t.node.firstChild; n; n = n.nextSibling)
      n.name == "VariableName" && (!i || !/\*|AssignOp/.test(i.name)) && e(n, "variable"), i = n;
  },
  CapturePattern: Ol("variable"),
  AsPattern: Ol("variable"),
  __proto__: null
};
function kX(t, e) {
  let i = OS.get(e);
  if (i)
    return i;
  let n = [], O = true;
  function r(a, o) {
    let s = t.sliceString(a.from, a.to);
    n.push({ label: s, type: o });
  }
  return e.cursor(ze.IncludeAnonymous).iterate((a) => {
    if (a.name) {
      let o = Rq[a.name];
      if (o && o(a, r, O) || !O && TX.has(a.name))
        return false;
      O = false;
    } else if (a.to - a.from > 8192) {
      for (let o of kX(t, a.node))
        n.push(o);
      return false;
    }
  }), OS.set(e, n), n;
}
var rS = /^[\w\xa1-\uffff][\w\d\xa1-\uffff]*$/;
var _X = ["String", "FormatString", "Comment", "PropertyName"];
function Zq(t) {
  let e = Ye(t.state).resolveInner(t.pos, -1);
  if (_X.indexOf(e.name) > -1)
    return null;
  let i = e.name == "VariableName" || e.to - e.from < 20 && rS.test(t.state.sliceDoc(e.from, e.to));
  if (!i && !t.explicit)
    return null;
  let n = [];
  for (let O = e; O; O = O.parent)
    TX.has(O.name) && (n = n.concat(kX(t.state.doc, O)));
  return {
    options: n,
    from: i ? e.from : t.pos,
    validFor: rS
  };
}
var Uq = [
  "__annotations__",
  "__builtins__",
  "__debug__",
  "__doc__",
  "__import__",
  "__name__",
  "__loader__",
  "__package__",
  "__spec__",
  "False",
  "None",
  "True"
].map((t) => ({ label: t, type: "constant" })).concat([
  "ArithmeticError",
  "AssertionError",
  "AttributeError",
  "BaseException",
  "BlockingIOError",
  "BrokenPipeError",
  "BufferError",
  "BytesWarning",
  "ChildProcessError",
  "ConnectionAbortedError",
  "ConnectionError",
  "ConnectionRefusedError",
  "ConnectionResetError",
  "DeprecationWarning",
  "EOFError",
  "Ellipsis",
  "EncodingWarning",
  "EnvironmentError",
  "Exception",
  "FileExistsError",
  "FileNotFoundError",
  "FloatingPointError",
  "FutureWarning",
  "GeneratorExit",
  "IOError",
  "ImportError",
  "ImportWarning",
  "IndentationError",
  "IndexError",
  "InterruptedError",
  "IsADirectoryError",
  "KeyError",
  "KeyboardInterrupt",
  "LookupError",
  "MemoryError",
  "ModuleNotFoundError",
  "NameError",
  "NotADirectoryError",
  "NotImplemented",
  "NotImplementedError",
  "OSError",
  "OverflowError",
  "PendingDeprecationWarning",
  "PermissionError",
  "ProcessLookupError",
  "RecursionError",
  "ReferenceError",
  "ResourceWarning",
  "RuntimeError",
  "RuntimeWarning",
  "StopAsyncIteration",
  "StopIteration",
  "SyntaxError",
  "SyntaxWarning",
  "SystemError",
  "SystemExit",
  "TabError",
  "TimeoutError",
  "TypeError",
  "UnboundLocalError",
  "UnicodeDecodeError",
  "UnicodeEncodeError",
  "UnicodeError",
  "UnicodeTranslateError",
  "UnicodeWarning",
  "UserWarning",
  "ValueError",
  "Warning",
  "ZeroDivisionError"
].map((t) => ({ label: t, type: "type" }))).concat([
  "bool",
  "bytearray",
  "bytes",
  "classmethod",
  "complex",
  "float",
  "frozenset",
  "int",
  "list",
  "map",
  "memoryview",
  "object",
  "range",
  "set",
  "staticmethod",
  "str",
  "super",
  "tuple",
  "type"
].map((t) => ({ label: t, type: "class" }))).concat([
  "abs",
  "aiter",
  "all",
  "anext",
  "any",
  "ascii",
  "bin",
  "breakpoint",
  "callable",
  "chr",
  "compile",
  "delattr",
  "dict",
  "dir",
  "divmod",
  "enumerate",
  "eval",
  "exec",
  "exit",
  "filter",
  "format",
  "getattr",
  "globals",
  "hasattr",
  "hash",
  "help",
  "hex",
  "id",
  "input",
  "isinstance",
  "issubclass",
  "iter",
  "len",
  "license",
  "locals",
  "max",
  "min",
  "next",
  "oct",
  "open",
  "ord",
  "pow",
  "print",
  "property",
  "quit",
  "repr",
  "reversed",
  "round",
  "setattr",
  "slice",
  "sorted",
  "sum",
  "vars",
  "zip"
].map((t) => ({ label: t, type: "function" })));
var Vq = [
  rt("def ${name}(${params}):\n	${}", {
    label: "def",
    detail: "function",
    type: "keyword"
  }),
  rt("for ${name} in ${collection}:\n	${}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  rt("while ${}:\n	${}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  rt("try:\n	${}\nexcept ${error}:\n	${}", {
    label: "try",
    detail: "/ except block",
    type: "keyword"
  }),
  rt(`if \${}:
	
`, {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  rt("if ${}:\n	${}\nelse:\n	${}", {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  rt("class ${name}:\n	def __init__(self, ${params}):\n			${}", {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  rt("import ${module}", {
    label: "import",
    detail: "statement",
    type: "keyword"
  }),
  rt("from ${module} import ${names}", {
    label: "from",
    detail: "import",
    type: "keyword"
  })
];
var qq = Jp(_X, au(Uq.concat(Vq)));
function aS(t, e) {
  let i = t.lineIndent(e.from), n = t.lineAt(t.pos, -1), O = n.from + n.text.length;
  return !/\S/.test(n.text) && t.node.to < O + 100 && !/\S/.test(t.state.sliceDoc(O, t.node.to)) && t.lineIndent(t.pos, -1) <= i || /^\s*(else:|elif |except |finally:)/.test(t.textAfter) && t.lineIndent(t.pos, -1) > i ? null : i + t.unit;
}
var bf = Kt.define({
  name: "python",
  parser: Yq.configure({
    props: [
      ci.add({
        Body: (t) => {
          var e;
          return (e = aS(t, t.node)) !== null && e !== void 0 ? e : t.continue();
        },
        IfStatement: (t) => /^\s*(else:|elif )/.test(t.textAfter) ? t.baseIndent : t.continue(),
        TryStatement: (t) => /^\s*(except |finally:|else:)/.test(t.textAfter) ? t.baseIndent : t.continue(),
        "TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression": dO({ closing: ")" }),
        "DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression": dO({ closing: "}" }),
        "ArrayExpression ArrayComprehensionExpression": dO({ closing: "]" }),
        "String FormatString": () => null,
        Script: (t) => {
          if (t.pos + /\s*/.exec(t.textAfter)[0].length >= t.node.to) {
            let e = null;
            for (let i = t.node, n = i.to; i = i.lastChild, !(!i || i.to != n); )
              i.type.name == "Body" && (e = i);
            if (e) {
              let i = aS(t, e);
              if (i != null)
                return i;
            }
          }
          return t.continue();
        }
      }),
      ui.add({
        "ArrayExpression DictionaryExpression SetExpression TupleExpression": Mn,
        Body: (t, e) => ({ from: t.from + 1, to: t.to - (t.to == e.doc.length ? 0 : 1) })
      })
    ]
  }),
  languageData: {
    closeBrackets: {
      brackets: ["(", "[", "{", "'", '"', "'''", '"""'],
      stringPrefixes: [
        "f",
        "fr",
        "rf",
        "r",
        "u",
        "b",
        "br",
        "rb",
        "F",
        "FR",
        "RF",
        "R",
        "U",
        "B",
        "BR",
        "RB"
      ]
    },
    commentTokens: { line: "#" },
    indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:)$/
  }
});
function zq() {
  return new li(bf, [
    bf.data.of({ autocomplete: Zq }),
    bf.data.of({ autocomplete: qq })
  ]);
}
var Cq = 1;
var Eq = 2;
var jq = 3;
var Iq = 4;
var Aq = 5;
var oS = 98;
var Gq = 101;
var Lq = 102;
var sS = 114;
var Dq = 69;
var rl = 48;
var lS = 46;
var Mq = 43;
var Nq = 45;
var cS = 35;
var uS = 34;
var Bq = 124;
var Fq = 60;
var Hq = 62;
function pd(t) {
  return t >= 48 && t <= 57;
}
function al(t) {
  return pd(t) || t == 95;
}
var Kq = new Ie((t, e) => {
  if (pd(t.next)) {
    let i = false;
    do
      t.advance();
    while (al(t.next));
    if (t.next == lS) {
      if (i = true, t.advance(), pd(t.next))
        do
          t.advance();
        while (al(t.next));
      else if (t.next == lS || t.next > 127 || /\w/.test(String.fromCharCode(t.next)))
        return;
    }
    if (t.next == Gq || t.next == Dq) {
      if (i = true, t.advance(), (t.next == Mq || t.next == Nq) && t.advance(), !al(t.next))
        return;
      do
        t.advance();
      while (al(t.next));
    }
    if (t.next == Lq) {
      let n = t.peek(1);
      if (n == rl + 3 && t.peek(2) == rl + 2 || n == rl + 6 && t.peek(2) == rl + 4)
        t.advance(3), i = true;
      else
        return;
    }
    i && t.acceptToken(Aq);
  } else if (t.next == oS || t.next == sS) {
    if (t.next == oS && t.advance(), t.next != sS)
      return;
    t.advance();
    let i = 0;
    for (; t.next == cS; )
      i++, t.advance();
    if (t.next != uS)
      return;
    t.advance();
    e:
      for (; ; ) {
        if (t.next < 0)
          return;
        let n = t.next == uS;
        if (t.advance(), n) {
          for (let O = 0; O < i; O++) {
            if (t.next != cS)
              continue e;
            t.advance();
          }
          t.acceptToken(Iq);
          return;
        }
      }
  }
});
var Jq = new Ie((t) => {
  t.next == Bq && t.acceptToken(Cq, 1);
});
var ez = new Ie((t) => {
  t.next == Fq ? t.acceptToken(Eq, 1) : t.next == Hq && t.acceptToken(jq, 1);
});
var tz = ti({
  "const macro_rules struct union enum type fn impl trait let static": f.definitionKeyword,
  "mod use crate": f.moduleKeyword,
  "pub unsafe async mut extern default move": f.modifier,
  "for if else loop while match continue break return await": f.controlKeyword,
  "as in ref": f.operatorKeyword,
  "where _ crate super dyn": f.keyword,
  self: f.self,
  String: f.string,
  Char: f.character,
  RawString: f.special(f.string),
  Boolean: f.bool,
  Identifier: f.variableName,
  "CallExpression/Identifier": f.function(f.variableName),
  BoundIdentifier: f.definition(f.variableName),
  "FunctionItem/BoundIdentifier": f.function(f.definition(f.variableName)),
  LoopLabel: f.labelName,
  FieldIdentifier: f.propertyName,
  "CallExpression/FieldExpression/FieldIdentifier": f.function(f.propertyName),
  Lifetime: f.special(f.variableName),
  ScopeIdentifier: f.namespace,
  TypeIdentifier: f.typeName,
  "MacroInvocation/Identifier MacroInvocation/ScopedIdentifier/Identifier": f.macroName,
  "MacroInvocation/TypeIdentifier MacroInvocation/ScopedIdentifier/TypeIdentifier": f.macroName,
  '"!"': f.macroName,
  UpdateOp: f.updateOperator,
  LineComment: f.lineComment,
  BlockComment: f.blockComment,
  Integer: f.integer,
  Float: f.float,
  ArithOp: f.arithmeticOperator,
  LogicOp: f.logicOperator,
  BitOp: f.bitwiseOperator,
  CompareOp: f.compareOperator,
  "=": f.definitionOperator,
  ".. ... => ->": f.punctuation,
  "( )": f.paren,
  "[ ]": f.squareBracket,
  "{ }": f.brace,
  ". DerefOp": f.derefOperator,
  "&": f.operator,
  ", ; ::": f.separator,
  "Attribute/...": f.meta
});
var iz = { __proto__: null, self: 28, super: 32, crate: 34, impl: 46, true: 72, false: 72, pub: 88, in: 92, const: 96, unsafe: 104, async: 108, move: 110, if: 114, let: 118, ref: 142, mut: 144, _: 198, else: 200, match: 204, as: 248, return: 252, await: 262, break: 270, continue: 276, while: 312, loop: 316, for: 320, macro_rules: 327, mod: 334, extern: 342, struct: 346, where: 364, union: 379, enum: 382, type: 390, default: 395, fn: 396, trait: 412, use: 420, static: 438, dyn: 476 };
var nz = Jt.deserialize({
  version: 14,
  states: "$2xQ]Q_OOP$wOWOOO&sQWO'#CnO)WQWO'#I`OOQP'#I`'#I`OOQQ'#Ie'#IeO)hO`O'#C}OOQR'#Ih'#IhO)sQWO'#IuOOQO'#Hk'#HkO)xQWO'#DpOOQR'#Iw'#IwO)xQWO'#DpO*ZQWO'#DpOOQO'#Iv'#IvO,SQWO'#J`O,ZQWO'#EiOOQV'#Hp'#HpO,cQYO'#F{OOQV'#El'#ElOOQV'#Em'#EmOOQV'#En'#EnO.YQ_O'#EkO0_Q_O'#EoO2gQWOOO4QQ_O'#FPO7hQWO'#J`OOQV'#FY'#FYO7{Q_O'#F^O:WQ_O'#FaOOQO'#F`'#F`O=sQ_O'#FcO=}Q_O'#FbO@VQWO'#FgOOQO'#J`'#J`OOQV'#Io'#IoOA]Q_O'#InOEPQWO'#InOOQV'#Fw'#FwOF[QWO'#JuOFcQWO'#F|OOQO'#IO'#IOOGrQWO'#GhOOQV'#Im'#ImOOQV'#Il'#IlOOQV'#Hj'#HjQGyQ_OOOKeQ_O'#DUOKlQYO'#CqOOQP'#I_'#I_OOQV'#Hg'#HgQ]Q_OOOLuQWO'#I`ONsQYO'#DXO!!eQWO'#JuO!!lQWO'#JuO!!vQ_O'#DfO!%]Q_O'#E}O!(sQ_O'#FWO!,ZQWO'#FZO!.^QXO'#FbO!.cQ_O'#EeO!!vQ_O'#FmO!0uQWO'#FoO!0zQWO'#FoO!1PQ^O'#FqO!1WQWO'#JuO!1_QWO'#FtO!1dQWO'#FxO!2WQWO'#JjO!2_QWO'#GOO!2_QWO'#G`O!2_QWO'#GbO!2_QWO'#GsOOQO'#Ju'#JuO!2dQWO'#GhO!2lQYO'#GpO!2_QWO'#GqO!3uQ^O'#GtO!3|QWO'#GuO!4hQWO'#HOP!4sOpO'#CcPOOO)CC})CC}OOOO'#Hi'#HiO!5OO`O,59iOOQV,59i,59iO!5ZQYO,5?aOOQO-E;i-E;iOOQO,5:[,5:[OOQP,59Z,59ZO)xQWO,5:[O)xQWO,5:[O!5oQWO,5?kO!5zQYO,5;qO!6PQYO,5;TO!6hQWO,59QO!7kQXO'#CnO!7xQXO'#I`O!9SQWO'#CoO,^QWO'#EiOOQV-E;n-E;nO!9eQWO'#FsOOQV,5<g,5<gO!9SQWO'#CoO!9jQWO'#CoO!9oQWO'#I`O! yQWO'#JuO!9yQWO'#J`O!:aQWO,5;VOOQO'#In'#InO!0zQWO'#DaO!<aQWO'#DcO!<iQWO,5;ZO.YQ_O,5;ZOOQO,5;[,5;[OOQV'#Er'#ErOOQV'#Es'#EsOOQV'#Et'#EtOOQV'#Eu'#EuOOQV'#Ev'#EvOOQV'#Ew'#EwOOQV'#Ex'#ExOOQV'#Ey'#EyO.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;fO!=PQ_O,5;kO!@gQ_O'#FROOQO,5;l,5;lO!BrQWO,5;pO.YQ_O,5;wOKlQYO,5;gO!D_QWO,5;kO!EOQWO,5;xOOQO,5;x,5;xO!E]QWO,5;xO!EbQ_O,5;xO!GmQWO'#CfO!GrQWO,5<QO!G|Q_O,5<QOOQO,5;{,5;{O!JjQXO'#CnO!K{QXO'#I`OOQS'#Dk'#DkOOQP'#Ir'#IrO!LuQ[O'#IrO!L}QXO'#DjO!M{QWO'#DnO!M{QWO'#DnO!N^QWO'#DnOOQP'#It'#ItO!NcQXO'#ItO# ^Q^O'#DoO# hQWO'#DrO# pQ^O'#DzO# zQ^O'#D|O#!RQWO'#EPO#!^QXO'#FdOOQP'#ES'#ESOOQP'#Iq'#IqO#!lQXO'#JfOOQP'#Je'#JeO#!tQXO,5;}O#!yQXO'#I`O!1PQ^O'#DyO!1PQ^O'#FdO##sQWO,5;|OOQO,5;|,5;|OKlQYO,5;|O#$ZQWO'#FhOOQO,5<R,5<ROOQV,5=l,5=lO#&`QYO'#FzOOQV,5<h,5<hO#&gQWO,5<hO#&nQWO,5=SO!1WQWO,59rO!1dQWO,5<dO#&uQWO,5=iO!2_QWO,5<jO!2_QWO,5<zO!2_QWO,5<|O!2_QWO,5=QO#&|QWO,5=]O#'TQWO,5=SO!2_QWO,5=]O!3|QWO,5=aO#']QWO,5=jOOQO-E;|-E;|O#'hQWO'#JjOOQV-E;h-E;hO#(PQWO'#HRO#(WQ_O,59pOOQV,59p,59pO#(_QWO,59pO#(dQ_O,59pO#)SQZO'#CuO#+[QZO'#CvOOQV'#C|'#C|O#-wQWO'#HTO#.OQYO'#IdOOQO'#Hh'#HhO#.WQWO'#CwO#.WQWO'#CwO#.iQWO'#CwOOQR'#Ic'#IcO#.nQZO'#IbO#1TQYO'#HTO#1qQYO'#H[O#2}QYO'#H_OKlQYO'#H`OOQR'#Hb'#HbO#4ZQWO'#HeO#4`QYO,59]OOQR'#Ib'#IbO#5PQZO'#CtO#7[QYO'#HUO#7aQWO'#HTO#7fQYO'#CrO#8VQWO'#H]O#7fQYO'#HcOOQV-E;e-E;eO#8_QWO,59sOOQV,59{,59{O#8mQYO,5=[OOQV,59},59}O!0zQWO,59}O#;aQWO'#IpOOQO'#Ip'#IpO!1PQ^O'#DhO!0zQWO,5:QO#;hQWO,5;iO#<OQWO,5;rO#<fQ_O,5;rOOQO,5;u,5;uO#@PQ_O,5;|O#BXQWO,5;PO!0zQWO,5<XO#B`QWO,5<ZOOQV,5<Z,5<ZO#BkQWO,5<]O!1PQ^O'#EOOOQQ'#D_'#D_O#BsQWO,59rO#BxQWO,5<`O#B}QWO,5<dOOQO,5@U,5@UO#CVQWO,5=iOOQQ'#Cv'#CvO#C[QYO,5<jO#CmQYO,5<zO#CxQYO,5<|O#DTQYO,5=_O#DcQYO,5=SO#E{QYO'#GQO#FYQYO,5=[O#FmQWO,5=[O#F{QYO,5=[O#HUQYO,5=]O#HdQWO,5=`O!1PQ^O,5=`O#HrQWO'#CnO#ITQWO'#I`OOQO'#Jy'#JyO#IfQWO'#IQO#IkQWO'#GwOOQO'#Jz'#JzO#JSQWO'#GzOOQO'#G|'#G|OOQO'#Jx'#JxO#IkQWO'#GwO#JZQWO'#GxO#J`QWO,5=aO#JeQWO,5=jO!1dQWO,5=jO#'`QWO,5=jPOOO'#Hf'#HfP#JjOpO,58}POOO,58},58}OOOO-E;g-E;gOOQV1G/T1G/TO#JuQWO1G4{O#JzQ^O'#CyPOQQ'#Cx'#CxOOQO1G/v1G/vOOQP1G.u1G.uO)xQWO1G/vO#NTQ!fO'#ETO#N[Q!fO'#EaO#NcQ!fO'#EbO$ kQWO1G1yO$!_Q_O1G1yOOQP1G5V1G5VOOQO1G1]1G1]O$&RQWO1G0oO$&WQWO'#CiO!7xQXO'#I`O!6PQYO1G.lO!5oQWO,5<_O!9SQWO,59ZO!9SQWO,59ZO!5oQWO,5?kO$&iQWO1G0uO$(vQWO1G0wO$*nQWO1G0wO$+UQWO1G0wO$-YQWO1G0wO$-aQWO1G0wO$/bQWO1G0wO$/iQWO1G0wO$1jQWO1G0wO$1qQWO1G0wO$3YQWO1G1QO$5ZQWO1G1VO$5zQ_O'#JcO$8SQWO'#JcOOQO'#Jb'#JbO$8^QWO,5;mOOQO'#Dw'#DwOOQO1G1[1G1[OOQO1G1Y1G1YO$8cQWO1G1cOOQO1G1R1G1RO$8jQ_O'#HrO$:xQWO,5@OO.YQ_O1G1dOOQO1G1d1G1dO$;QQWO1G1dO$;_QWO1G1dO$;dQWO1G1eOOQO1G1l1G1lO$;lQWO1G1lOOQP,5?^,5?^O$;vQ^O,5:kO$<aQXO,5:YO!M{QWO,5:YO!M{QWO,5:YO!1PQ^O,5:gO$=bQWO'#IyOOQO'#Ix'#IxO$=pQWO,5:ZO# ^Q^O,5:ZO$=uQWO'#DsOOQP,5:^,5:^O$>WQWO,5:fOOQP,5:h,5:hO!1PQ^O,5:hO!1PQ^O,5:mO$>]QYO,5<OO$>gQ_O'#HsO$>tQXO,5@QOOQV1G1i1G1iOOQP,5:e,5:eO$>|QXO,5<OO$?[QWO1G1hO$?dQWO'#CnO$?oQWO'#FiOOQO'#Fi'#FiO$?wQWO'#FjO.YQ_O'#FkOOQO'#Ji'#JiO$?|QWO'#JhOOQO'#Jg'#JgO$@UQWO,5<SOOQQ'#Hv'#HvO$@ZQYO,5<fOOQV,5<f,5<fO$@bQYO,5<fOOQV1G2S1G2SO$@iQWO1G2nO$@qQWO1G/^O$@vQWO1G2OO#CVQWO1G3TO$AOQYO1G2UO#CmQYO1G2fO#CxQYO1G2hO$AaQYO1G2lO!2_QWO1G2wO#DcQYO1G2nO#HUQYO1G2wO$AiQWO1G2{O$AnQWO1G3UO!1dQWO1G3UO$AsQWO1G3UOOQV1G/[1G/[O$A{QWO1G/[O$BQQ_O1G/[O#7aQWO,5=oO$BXQYO,5?OO$BmQWO,5?OO$BrQZO'#IeOOQO-E;f-E;fOOQR,59c,59cO#.WQWO,59cO#.WQWO,59cOOQR,5=n,5=nO$E_QYO'#HVO$FwQZO,5=oO!5oQWO,5={O$IZQWO,5=oO$IbQZO,5=vO$KqQYO,5=vO$>]QYO,5=vO$LRQWO'#KRO$L^QWO,5=xOOQR,5=y,5=yO$LcQWO,5=zO$>]QYO,5>PO$>]QYO,5>POOQO1G.w1G.wO$>]QYO1G.wO$LnQYO,5=pO$LvQZO,59^OOQR,59^,59^O$>]QYO,5=wO% YQZO,5=}OOQR,5=},5=}O%#lQWO1G/_O!6PQYO1G/_O#FYQYO1G2vO%#qQWO1G2vO%$PQYO1G2vOOQV1G/i1G/iO%%YQWO,5:SO%%bQ_O1G/lO%*kQWO1G1^O%+RQWO1G1hOOQO1G1h1G1hO$>]QYO1G1hO%+iQ^O'#EgOOQV1G0k1G0kOOQV1G1s1G1sO!!vQ_O1G1sO!0zQWO1G1uO!1PQ^O1G1wO!.cQ_O1G1wOOQP,5:j,5:jO$>]QYO1G/^OOQO'#Cn'#CnO%+vQWO1G1zOOQV1G2O1G2OO%,OQWO'#CnO%,WQWO1G3TO%,]QWO1G3TO%,bQYO'#GQO%,sQWO'#G]O%-UQYO'#G_O%.hQYO'#GXOOQV1G2U1G2UO%/wQWO1G2UO%/|QWO1G2UO$ARQWO1G2UOOQV1G2f1G2fO%/wQWO1G2fO#CpQWO1G2fO%0UQWO'#GdOOQV1G2h1G2hO%0gQWO1G2hO#C{QWO1G2hO%0lQYO'#GSO$>]QYO1G2lO$AdQWO1G2lOOQV1G2y1G2yO%1xQWO1G2yO%3hQ^O'#GkO%3rQWO1G2nO#DfQWO1G2nO%4QQYO,5<lO%4[QYO,5<lO%4jQYO,5<lO%5XQYO,5<lOOQQ,5<l,5<lO!1WQWO'#JuO%5dQYO,5<lO%5lQWO1G2vOOQV1G2v1G2vO%5tQWO1G2vO$>]QYO1G2vOOQV1G2w1G2wO%5tQWO1G2wO%5yQWO1G2wO#HXQWO1G2wOOQV1G2z1G2zO.YQ_O1G2zO$>]QYO1G2zO%6RQWO1G2zOOQO,5>l,5>lOOQO-E<O-E<OOOQO,5=c,5=cOOQO,5=e,5=eOOQO,5=g,5=gOOQO,5=h,5=hO%6aQWO'#J|OOQO'#J{'#J{O%6iQWO,5=fO%6nQWO,5=cO!1dQWO,5=dOOQV1G2{1G2{O$>]QYO1G3UPOOO-E;d-E;dPOOO1G.i1G.iOOQO7+*g7+*gO%7VQYO'#IcO%7nQYO'#IfO%7yQYO'#IfO%8RQYO'#IfO%8^QYO,59eOOQO7+%b7+%bOOQP7+$a7+$aO%8cQ!fO'#JTOOQS'#EX'#EXOOQS'#EY'#EYOOQS'#EZ'#EZOOQS'#JT'#JTO%;UQWO'#EWOOQS'#E`'#E`OOQS'#JR'#JROOQS'#Hn'#HnO%;ZQ!fO,5:oOOQV,5:o,5:oOOQV'#JQ'#JQO%;bQ!fO,5:{OOQV,5:{,5:{O%;iQ!fO,5:|OOQV,5:|,5:|OOQV7+'e7+'eOOQV7+&Z7+&ZO%;pQ!fO,59TOOQO,59T,59TO%>YQWO7+$WO%>_QWO1G1yOOQV1G1y1G1yO!9SQWO1G.uO%>dQWO,5?}O%>nQ_O'#HqO%@|QWO,5?}OOQO1G1X1G1XOOQO7+&}7+&}O%AUQWO,5>^OOQO-E;p-E;pO%AcQWO7+'OO.YQ_O7+'OOOQO7+'O7+'OOOQO7+'P7+'PO%AjQWO7+'POOQO7+'W7+'WOOQP1G0V1G0VO%ArQXO1G/tO!M{QWO1G/tO%BsQXO1G0RO%CkQ^O'#HlO%C{QWO,5?eOOQP1G/u1G/uO%DWQWO1G/uO%D]QWO'#D_OOQO'#Dt'#DtO%DhQWO'#DtO%DmQWO'#I{OOQO'#Iz'#IzO%DuQWO,5:_O%DzQWO'#DtO%EPQWO'#DtOOQP1G0Q1G0QOOQP1G0S1G0SOOQP1G0X1G0XO%EXQXO1G1jO%EdQXO'#FeOOQP,5>_,5>_O!1PQ^O'#FeOOQP-E;q-E;qO$>]QYO1G1jOOQO7+'S7+'SOOQO,5<T,5<TO%ErQWO,5<UO.YQ_O,5<UO%EwQWO,5<VO%FRQWO'#HtO%FdQWO,5@SOOQO1G1n1G1nOOQQ-E;t-E;tOOQV1G2Q1G2QO%FlQYO1G2QO#DcQYO7+(YO$>]QYO7+$xOOQV7+'j7+'jO%FsQWO7+(oO%FxQWO7+(oOOQV7+'p7+'pO%/wQWO7+'pO%F}QWO7+'pO%GVQWO7+'pOOQV7+(Q7+(QO%/wQWO7+(QO#CpQWO7+(QOOQV7+(S7+(SO%0gQWO7+(SO#C{QWO7+(SO$>]QYO7+(WO%GeQWO7+(WO#HUQYO7+(cO%GjQWO7+(YO#DfQWO7+(YOOQV7+(c7+(cO%5tQWO7+(cO%5yQWO7+(cO#HXQWO7+(cOOQV7+(g7+(gO$>]QYO7+(pO%GxQWO7+(pO!1dQWO7+(pOOQV7+$v7+$vO%G}QWO7+$vO%HSQZO1G3ZO%JfQWO1G4jOOQO1G4j1G4jOOQR1G.}1G.}O#.WQWO1G.}O%JkQWO'#KQOOQO'#HW'#HWO%J|QWO'#HXO%KXQWO'#KQOOQO'#KP'#KPO%KaQWO,5=qO%KfQYO'#H[O%LrQWO'#GmO%L}QYO'#CtO%MXQWO'#GmO$>]QYO1G3ZOOQR1G3g1G3gO#7aQWO1G3ZO%M^QZO1G3bO$>]QYO1G3bO& mQYO'#IVO& }QWO,5@mOOQR1G3d1G3dOOQR1G3f1G3fO.YQ_O1G3fOOQR1G3k1G3kO&!VQYO7+$cO&!_QYO'#KOOOQQ'#J}'#J}O&!gQYO1G3[O&!lQZO1G3cOOQQ7+$y7+$yO&${QWO7+$yO&%QQWO7+(bOOQV7+(b7+(bO%5tQWO7+(bO$>]QYO7+(bO#FYQYO7+(bO&%YQWO7+(bO!.cQ_O1G/nO&%hQWO7+%WO$?[QWO7+'SO&%pQWO'#EhO&%{Q^O'#EhOOQU'#Ho'#HoO&%{Q^O,5;ROOQV,5;R,5;RO&&VQWO,5;RO&&[Q^O,5;RO!0zQWO7+'_OOQV7+'a7+'aO&&iQWO7+'cO&&qQWO7+'cO&&xQWO7+$xO&'TQ!fO7+'fO&'[Q!fO7+'fOOQV7+(o7+(oO!1dQWO7+(oO&'cQYO,5<lO&'nQYO,5<lO!1dQWO'#GWO&'|QWO'#JpO&([QWO'#G^O!BxQWO'#G^O&(aQWO'#JpOOQO'#Jo'#JoO&(iQWO,5<wOOQO'#DX'#DXO&(nQYO'#JrO&)}QWO'#JrO$>]QYO'#JrOOQO'#Jq'#JqO&*YQWO,5<yO&*_QWO'#GZO#D^QWO'#G[O&*gQWO'#G[O&*oQWO'#JmOOQO'#Jl'#JlO&*zQYO'#GTOOQO,5<s,5<sO&+PQWO7+'pO&+UQWO'#JtO&+dQWO'#GeO#BxQWO'#GeO&+uQWO'#JtOOQO'#Js'#JsO&+}QWO,5=OO$>]QYO'#GUO&,SQYO'#JkOOQQ,5<n,5<nO&,kQWO7+(WOOQV7+(e7+(eO&.TQ^O'#D|O&._QWO'#GlO&.gQ^O'#JwOOQO'#Gn'#GnO&.nQWO'#JwOOQO'#Jv'#JvO&.vQWO,5=VO&.{QWO'#I`O&/]Q^O'#GmO&/dQWO'#IqO&/rQWO'#GmOOQV7+(Y7+(YO&/zQWO7+(YO$>]QYO7+(YO&0SQYO'#HxO&0hQYO1G2WOOQQ1G2W1G2WOOQQ,5<m,5<mO$>]QYO,5<qO&0pQWO,5<rO&0uQWO7+(bO&1QQWO7+(fO&1XQWO7+(fOOQV7+(f7+(fO.YQ_O7+(fO$>]QYO7+(fO&1dQWO'#IRO&1nQWO,5@hOOQO1G3Q1G3QOOQO1G2}1G2}OOQO1G3P1G3POOQO1G3R1G3ROOQO1G3S1G3SOOQO1G3O1G3OO&1vQWO7+(pO$>]QYO,59fO&2RQ^O'#ISO&2xQYO,5?QOOQR1G/P1G/PO&3QQ!bO,5:pO&3VQ!fO,5:rOOQS-E;l-E;lOOQV1G0Z1G0ZOOQV1G0g1G0gOOQV1G0h1G0hO&3^QWO'#JTOOQO1G.o1G.oOOQV<<Gr<<GrO&3iQWO1G5iO$5zQ_O,5>]O&3qQWO,5>]OOQO-E;o-E;oOOQO<<Jj<<JjO&3{QWO<<JjOOQO<<Jk<<JkO&4SQXO7+%`O&5TQWO,5>WOOQO-E;j-E;jOOQP7+%a7+%aO!1PQ^O,5:`O&5cQWO'#HmO&5wQWO,5?gOOQP1G/y1G/yOOQO,5:`,5:`O&6PQWO,5:`O%DzQWO,5:`O$>]QYO,5<PO&6UQXO,5<PO&6dQXO7+'UO.YQ_O1G1pO&6oQWO1G1pOOQO,5>`,5>`OOQO-E;r-E;rOOQV7+'l7+'lO&6yQWO<<KtO#DfQWO<<KtO&7XQWO<<HdOOQV<<LZ<<LZO!1dQWO<<LZOOQV<<K[<<K[O&7dQWO<<K[O%/wQWO<<K[O&7iQWO<<K[OOQV<<Kl<<KlO%/wQWO<<KlOOQV<<Kn<<KnO%0gQWO<<KnO&7qQWO<<KrO$>]QYO<<KrOOQV<<K}<<K}O%5tQWO<<K}O%5yQWO<<K}O#HXQWO<<K}OOQV<<Kt<<KtO&7yQWO<<KtO$>]QYO<<KtO&8RQWO<<L[O$>]QYO<<L[O&8^QWO<<L[OOQV<<Hb<<HbO$>]QYO7+(uOOQO7+*U7+*UOOQR7+$i7+$iO&8cQWO,5@lOOQO'#Gm'#GmO&8kQWO'#GmO&8vQYO'#IUO&8cQWO,5@lOOQR1G3]1G3]O&:cQYO,5=vO&;rQYO,5=XO&;|QWO,5=XOOQO,5=X,5=XOOQR7+(u7+(uO&<RQZO7+(uO&>eQZO7+(|O&@tQWO,5>qOOQO-E<T-E<TO&APQWO7+)QOOQO<<G}<<G}O&AWQYO'#ITO&AcQYO,5@jOOQQ7+(v7+(vOOQQ<<He<<HeO$>]QYO<<K|OOQV<<K|<<K|O&0uQWO<<K|O&AkQWO<<K|O%5tQWO<<K|O&AsQWO7+%YOOQV<<Hr<<HrOOQO<<Jn<<JnO.YQ_O,5;SO&AzQWO,5;SO.YQ_O'#EjO&BPQWO,5;SOOQU-E;m-E;mO&B[QWO1G0mOOQV1G0m1G0mO&%{Q^O1G0mOOQV<<Jy<<JyO!.cQ_O<<J}OOQV<<J}<<J}OOQV<<Hd<<HdO.YQ_O<<HdO&BaQWO'#FvO&BfQWO<<KQO&BnQ!fO<<KQO&BuQWO<<KQO&BzQWO<<KQO&CSQ!fO<<KQOOQV<<KQ<<KQO&CZQWO<<LZO&C`QWO,5@[O$>]QYO,5<xO&ChQWO,5<xO&CmQWO'#H{O&C`QWO,5@[OOQV1G2c1G2cO&DRQWO,5@^O$>]QYO,5@^O&D^QYO'#H|O&EsQWO,5@^OOQO1G2e1G2eO%,nQWO,5<uOOQO,5<v,5<vO&E{QYO'#HzO&G_QWO,5@XO%,bQYO,5=pO$>]QYO,5<oO&GjQWO,5@`O.YQ_O,5=PO&GrQWO,5=PO&G}QWO,5=PO&H`QWO'#H}O&GjQWO,5@`OOQV1G2j1G2jO&HtQYO,5<pO%0lQYO,5>PO&I]QYO,5@VOOQV<<Kr<<KrO&ItQWO,5=XO&KfQ^O,5:hO&KmQWO,5=XO$>]QYO,5=WO&KuQWO,5@cO&K}QWO,5@cO&MvQ^O'#IPO&KuQWO,5@cOOQO1G2q1G2qO&NTQWO,5=WO&N]QWO<<KtO&NkQYO,5>oO&NvQYO,5>dO' UQYO,5>dOOQQ,5>d,5>dOOQQ-E;v-E;vOOQQ7+'r7+'rO' aQYO1G2]O$>]QYO1G2^OOQV<<LQ<<LQO.YQ_O<<LQO' lQWO<<LQO' sQWO<<LQOOQO,5>m,5>mOOQO-E<P-E<POOQV<<L[<<L[O.YQ_O<<L[O'!OQYO1G/QO'!ZQYO,5>nOOQQ,5>n,5>nO'!fQYO,5>nOOQQ-E<Q-E<QOOQS1G0[1G0[O'$tQ!fO1G0^O'%RQ!fO1G0^O'%YQWO1G3wOOQOAN@UAN@UO'%dQWO1G/zOOQO,5>X,5>XOOQO-E;k-E;kO!1PQ^O1G/zOOQO1G/z1G/zO'%oQWO1G/zO'%tQXO1G1kO$>]QYO1G1kO'&PQWO7+'[OOQVANA`ANA`O'&ZQWOANA`O$>]QYOANA`O'&cQWOANA`OOQVAN>OAN>OO.YQ_OAN>OO'&qQWOANAuOOQVAN@vAN@vO'&vQWOAN@vOOQVANAWANAWOOQVANAYANAYOOQVANA^ANA^O'&{QWOANA^OOQVANAiANAiO%5tQWOANAiO%5yQWOANAiO''TQWOANA`OOQVANAvANAvO.YQ_OANAvO''cQWOANAvO$>]QYOANAvOOQR<<La<<LaO''nQWO1G6WO%JkQWO,5>pOOQO'#HY'#HYO''vQWO'#HZOOQO,5>p,5>pOOQO-E<S-E<SO'(RQYO1G2sO'(]QWO1G2sOOQO1G2s1G2sO$>]QYO<<LaOOQR<<Ll<<LlOOQQ,5>o,5>oOOQQ-E<R-E<RO&0uQWOANAhOOQVANAhANAhO%5tQWOANAhO$>]QYOANAhO'(bQWO1G1rO')UQ^O1G0nO.YQ_O1G0nO'*zQWO,5;UO'+RQWO1G0nP'+WQWO'#ERP&%{Q^O'#HpOOQV7+&X7+&XO'+cQWO7+&XO&&qQWOAN@iO'+hQWOAN>OO!5oQWO,5<bOOQS,5>a,5>aO'+oQWOAN@lO'+tQWOAN@lOOQS-E;s-E;sOOQVAN@lAN@lO'+|QWOAN@lOOQVANAuANAuO',UQWO1G5vO',^QWO1G2dO$>]QYO1G2dO&'|QWO,5>gOOQO,5>g,5>gOOQO-E;y-E;yO',iQWO1G5xO',qQWO1G5xO&(nQYO,5>hO',|QWO,5>hO$>]QYO,5>hOOQO-E;z-E;zO'-XQWO'#JnOOQO1G2a1G2aOOQO,5>f,5>fOOQO-E;x-E;xO&'cQYO,5<lO'-gQYO1G2ZO'.RQWO1G5zO'.ZQWO1G2kO.YQ_O1G2kO'.eQWO1G2kO&+UQWO,5>iOOQO,5>i,5>iOOQO-E;{-E;{OOQQ,5>c,5>cOOQQ-E;u-E;uO'.pQWO1G2sO'/QQWO1G2rO'/]QWO1G5}O'/eQ^O,5>kOOQO'#Go'#GoOOQO,5>k,5>kO'/lQWO,5>kOOQO-E;}-E;}O$>]QYO1G2rO'/zQYO7+'xO'0VQWOANAlOOQVANAlANAlO.YQ_OANAlO'0^QWOANAvOOQS7+%x7+%xO'0eQWO7+%xO'0pQ!fO7+%xO'0}QWO7+%fO!1PQ^O7+%fO'1YQXO7+'VOOQVG26zG26zO'1eQWOG26zO'1sQWOG26zO$>]QYOG26zO'1{QWOG23jOOQVG27aG27aOOQVG26bG26bOOQVG26xG26xOOQVG27TG27TO%5tQWOG27TO'2SQWOG27bOOQVG27bG27bO.YQ_OG27bO'2ZQWOG27bOOQO1G4[1G4[OOQO7+(_7+(_OOQRANA{ANA{OOQVG27SG27SO%5tQWOG27SO&0uQWOG27SO'2fQ^O7+&YO'4PQWO7+'^O'4sQ^O7+&YO.YQ_O7+&YP.YQ_O,5;SP'6PQWO,5;SP'6UQWO,5;SOOQV<<Is<<IsOOQVG26TG26TOOQVG23jG23jOOQO1G1|1G1|OOQVG26WG26WO'6aQWOG26WP&B}QWO'#HuO'6fQWO7+(OOOQO1G4R1G4RO'6qQWO7++dO'6yQWO1G4SO$>]QYO1G4SO%,nQWO'#HyO'7UQWO,5@YO'7dQWO7+(VO.YQ_O7+(VOOQO1G4T1G4TOOQO1G4V1G4VO'7nQWO1G4VO'7|QWO7+(^OOQVG27WG27WO'8XQWOG27WOOQS<<Id<<IdO'8`QWO<<IdO'8kQWO<<IQOOQVLD,fLD,fO'8vQWOLD,fO'9OQWOLD,fOOQVLD)ULD)UOOQVLD,oLD,oOOQVLD,|LD,|O'9^QWOLD,|O.YQ_OLD,|OOQVLD,nLD,nO%5tQWOLD,nO'9eQ^O<<ItO';OQWO<<JxO';rQ^O<<ItP'=OQWO1G0nP'=oQ^O1G0nP.YQ_O1G0nP'?bQWO1G0nOOQVLD+rLD+rO'?gQWO7+)nOOQO,5>e,5>eOOQO-E;w-E;wO'?rQWO<<KqOOQVLD,rLD,rOOQSAN?OAN?OOOQV!$(!Q!$(!QO'?|QWO!$(!QOOQV!$(!h!$(!hO'@UQWO!$(!hOOQV!$(!Y!$(!YO'@]Q^OAN?`POQU7+&Y7+&YP'AvQWO7+&YP'BgQ^O7+&YP.YQ_O7+&YOOQV!)9El!)9ElOOQV!)9FS!)9FSPOQU<<It<<ItP'DYQWO<<ItP'DyQ^O<<ItPOQUAN?`AN?`O'FlQWO'#CnO'FsQXO'#CnO'GlQWO'#I`O'IRQXO'#I`O'IxQWO'#DpO'IxQWO'#DpO!.cQ_O'#EkO'JZQ_O'#EoO'JbQ_O'#FPO'MfQ_O'#FbO'MmQXO'#I`O'NdQ_O'#E}O( gQ_O'#FWO'IxQWO,5:[O'IxQWO,5:[O!.cQ_O,5;ZO!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;fO(!jQ_O,5;kO(%nQWO,5;kO(&OQWO,5;|O(&VQYO'#CuO(&bQYO'#CvO(&mQWO'#CwO(&mQWO'#CwO('OQYO'#CtO('ZQWO,5;iO('bQWO,5;rO('iQ_O,5;rO((oQ_O,5;|O'IxQWO1G/vO((vQWO1G0uO(*eQWO1G0wO(*oQWO1G0wO(,dQWO1G0wO(,kQWO1G0wO(.]QWO1G0wO(.dQWO1G0wO(0UQWO1G0wO(0]QWO1G0wO(0dQWO1G1QO(0tQWO1G1VO(1UQYO'#IeO(&mQWO,59cO(&mQWO,59cO(1aQWO1G1^O(1hQWO1G1hO(&mQWO1G.}O(1oQWO'#DpO!.^QXO'#FbO(1tQWO,5;ZO(1{QWO'#Cw",
  stateData: "(2_~O&|OSUOS&}PQ~OPoOQ!QOSVOTVOZeO[lO^RO_RO`ROa!UOd[Og!nOsVOtVOuVOw!POyvO|!VO}mO!Q!dO!U!WO!W!XO!X!^O!Z!YO!]!pO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'Q`O'TQO'ZkO'^UO'gcO'qiO(QdO~O&}!sO~OZbX[bXdbXdlXobXwjX}bX!lbX!qbX!tbX#ObX#PbX#pbX'gbX'qbX'rbX'xbX'ybX'zbX'{bX'|bX'}bX(ObX(PbX(QbX(RbX(TbX~OybXXbX!ebX!PbXvbX#RbX~P$|OZ'SX['SXd'SXd'XXo'SXw'kXy'SX}'SX!l'SX!q'SX!t'SX#O'SX#P'SX#p'SX'g'SX'q'SX'r'SX'x'SX'y'SX'z'SX'{'SX'|'SX'}'SX(O'SX(P'SX(Q'SX(R'SX(T'SXv'SX~OX'SX!e'SX!P'SX#R'SX~P'ZOr!uO']!wO'_!uO~Od!xO~O^RO_RO`ROaRO'TQO~Od!}O~Od#PO[(SXo(SXy(SX}(SX!l(SX!q(SX!t(SX#O(SX#P(SX#p(SX'g(SX'q(SX'r(SX'x(SX'y(SX'z(SX'{(SX'|(SX'}(SX(O(SX(P(SX(Q(SX(R(SX(T(SXv(SX~OZ#OO~P*`OZ#RO[#QO~OQ!QO^#TO_#TO`#TOa#]Od#ZOg!nOyvO|!VO!Q!dO!U#^O!W!lO!]!pO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'Q#VO'T#SO~OPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdO~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!j#eO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdO~P)xO[#}Oo#xO}#zO!l#yO!q#jO!t#yO#O#xO#P#uO#p$OO'g#gO'q#yO'r#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO~OPoOQ!QOSVOTVOZeOd[OsVOtVOuVOw!PO!U#bO!W#cO!X!^O!Z!YO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO[#sXo#sXy#sX}#sX!l#sX!q#sX!t#sX#O#sX#P#sX#p#sX'g#sX'q#sX'r#sX'x#sX'y#sX'z#sX'{#sX'|#sX'}#sX(O#sX(P#sX(Q#sX(R#sX(T#sXX#sX!e#sX!P#sXv#sX#R#sX~P)xOX(SX!e(SX!P(SXw(SX#R(SX~P*`OPoOQ!QOSVOTVOX$ROZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q$UO'ZkO'^UO'gcO'qiO(QdO~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!P$XO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q$UO'ZkO'^UO'gcO'qiO(QdO~P)xOQ!QOSVOTVO[$gO^$pO_$ZO`9yOa9yOd$aOsVOtVOuVO}$eO!i$qO!l$lO!q$hO#V$lO'T$YO'^UO'g$[O~O!j$rOP(XP~P<cOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Q$uO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdO~P)xOw$vO~Oo'bX#O'bX#P'bX#p'bX'r'bX'x'bX'y'bX'z'bX'{'bX'|'bX'}'bX(O'bX(P'bX(R'bX(T'bX~OP%tXQ%tXS%tXT%tXZ%tX[%tX^%tX_%tX`%tXa%tXd%tXg%tXs%tXt%tXu%tXw%tXy%tX|%tX}%tX!Q%tX!U%tX!W%tX!X%tX!Z%tX!]%tX!l%tX!q%tX!t%tX#Y%tX#r%tX#{%tX$O%tX$b%tX$d%tX$f%tX$i%tX$m%tX$q%tX$s%tX%T%tX%V%tX%Z%tX%]%tX%^%tX%f%tX%j%tX%s%tX&z%tX'Q%tX'T%tX'Z%tX'^%tX'g%tX'q%tX(Q%tXv%tX~P@[Oy$xO['bX}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bXv'bX~P@[Ow$yO!Q(iX!U(iX!W(iX$q(iX%](iX%^(iX~Oy$zO~PEsO!Q$}O!U%UO!W!lO$m%OO$q%PO$s%QO%T%RO%V%SO%Z%TO%]!lO%^%VO%f%WO%j%XO%s%YO~O!Q!lO!U!lO!W!lO$q%[O%]!lO~O%^%VO~PGaOPoOQ!QOSVOTVOZeO[lO^RO_RO`ROa!UOd[Og!nOsVOtVOuVOw!POyvO|!VO}mO!Q!dO!U!WO!W!XO!X!^O!Z!YO!]!pO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'Q#VO'TQO'ZkO'^UO'gcO'qiO(QdO~Ov%`O~P]OQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaO!Q{X!U{X!W{X$m{X$q{X$s{X%T{X%V{X%Z{X%]{X%^{X%f{X%j{X%s{X~P'ZO!Q{X!U{X!W{X$m{X$q{X$s{X%T{X%V{X%Z{X%]{X%^{X%f{X%j{X%s{X~O}%}O'T{XQ{XZ{X[{X^{X_{X`{Xa{Xd{Xg{X!q{X$f{X&W{X'Z{X(Q{X~PMuOg&PO%f%WO!Q(iX!U(iX!W(iX$q(iX%](iX%^(iX~Ow!PO~P! yOw!PO!X&RO~PEvOPoOQ!QOSVOTVOZeO[lO^9qO_9qO`9qOa9qOd9tOsVOtVOuVOw!PO}mO!U#bO!W#cO!X:zO!Z!YO!]&UO!l9wO!q9vO!t9wO#Y!_O#r9zO#{9{O$O!]O$b!`O$d!bO$f!cO'T9oO'ZkO'^UO'gcO'q9wO(QdO~OPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdOo#qXy#qX#O#qX#P#qX#p#qX'r#qX'x#qX'y#qX'z#qX'{#qX'|#qX'}#qX(O#qX(P#qX(R#qX(T#qXX#qX!e#qX!P#qXv#qX#R#qX~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdOo#zXy#zX#O#zX#P#zX#p#zX'r#zX'x#zX'y#zX'z#zX'{#zX'|#zX'}#zX(O#zX(P#zX(R#zX(T#zXX#zX!e#zX!P#zXv#zX#R#zX~P)xO'ZkO[#}Xo#}Xy#}X}#}X!l#}X!q#}X!t#}X#O#}X#P#}X#p#}X'g#}X'q#}X'r#}X'x#}X'y#}X'z#}X'{#}X'|#}X'}#}X(O#}X(P#}X(Q#}X(R#}X(T#}XX#}X!e#}X!P#}Xv#}Xw#}X#R#}X~OPoO~OPoOQ!QOSVOTVOZeO[lO^9qO_9qO`9qOa9qOd9tOsVOtVOuVOw!PO}mO!U#bO!W#cO!X:zO!Z!YO!l9wO!q9vO!t9wO#Y!_O#r9zO#{9{O$O!]O$b!`O$d!bO$f!cO'T9oO'ZkO'^UO'gcO'q9wO(QdO~O!S&_O~Ow!PO~O!j&bO~P<cO'T&cO~PEvOZ&eO~O'T&cO~O'^UOw(^Xy(^X!Q(^X!U(^X!W(^X$q(^X%](^X%^(^X~Oa&hO~P!1iO'T&iO~O_&nO'T&cO~OQ&oOZ&pO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaO!j&uO~P<cO^&wO_&wO`&wOa&wOd'POw&|O'T&vO(Q&}O~O!i'UO!j'TO'T&cO~O&}!sO'O'VO'P'XO~Or!uO']'ZO'_!uO~OQ']O^'ia_'ia`'iaa'ia'T'ia~O['cOw'dO}'bO~OQ']O~OQ!QO^#TO_#TO`#TOa'kOd#ZO'T#SO~O['lO~OZbXdlXXbXobXPbX!SbX!ebX'rbX!PbX!ObXybX!ZbX#RbXvbX~O[bXwbX}bX~P!6mOZ'SXd'XXX'SX['SXo'SXw'SX}'SX#p'SXP'SX!S'SX!e'SX'r'SX!P'SX!O'SXy'SX!Z'SX#R'SXv'SX~O^#TO_#TO`#TOa'kO'T#SO~OZ'mO~Od'oO~OZ'SXd'XX~PMuOZ'pOX(SX!e(SX!P(SXw(SX#R(SX~P*`O[#}O}#zO(O#|O(R#fOo#_ay#_a!l#_a!q#_a!t#_a#O#_a#P#_a#p#_a'g#_a'q#_a'r#_a'x#_a'y#_a'z#_a'{#_a'|#_a'}#_a(P#_a(Q#_a(T#_aX#_a!e#_a!P#_av#_aw#_a#R#_a~Ow!PO!X&RO~Oy#caX#ca!e#ca!P#cav#ca#R#ca~P2gOPoOQ!QOSVOTVOZeOd[OsVOtVOuVOw!PO!U#bO!W#cO!X!^O!Z!YO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO[#sao#say#sa}#sa!l#sa!q#sa!t#sa#O#sa#P#sa#p#sa'g#sa'q#sa'r#sa'x#sa'y#sa'z#sa'{#sa'|#sa'}#sa(O#sa(P#sa(Q#sa(R#sa(T#saX#sa!e#sa!P#sav#sa#R#sa~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q#VO'ZkO'^UO'gcO'qiO(QdO!P(UP~P)xOu(SO#w(TO'T(RO~O[#}O}#zO!q#jO'g#gO'r#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO!l#sa!t#sa#p#sa'q#sa~Oo#xO#O#xO#P#uOy#saX#sa!e#sa!P#sav#sa#R#sa~P!B}Oy(YO!e(WOX(WX~P2gOX(ZO~OPoOQ!QOSVOTVOX(ZOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q$UO'ZkO'^UO'gcO'qiO(QdO~P)xOZ#RO~O!P(_O!e(WO~P2gOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q$UO'ZkO'^UO'gcO'qiO(QdO~P)xOZbXdlXwjX}jX!tbX'qbX~OP!RX!S!RX!e!RX'p!RX'r!RX!O!RXo!RXy!RX!P!RXX!RX!Z!RX#R!RXv!RX~P!JUOZ'SXd'XXw'kX}'kX!t'SX'q'SX~OP!`X!S!`X!e!`X'r!`X!O!`Xo!`Xy!`X!P!`XX!`X!Z!`X#R!`Xv!`X~P!KgOT(aOu(aO~O!t(bO'q(bOP!^X!S!^X!e!^X'r!^X!O!^Xo!^Xy!^X!P!^XX!^X!Z!^X#R!^Xv!^X~O^9rO_9rO`9yOa9yO'T9pO~Od(eO~O'p(fOP'hX!S'hX!e'hX'r'hX!O'hXo'hXy'hX!P'hXX'hX!Z'hX#R'hXv'hX~O!j&bO!P'lP~P<cOw(kO}(jO~O!j&bOX'lP~P<cO!j(oO~P<cOZ'pO!t(bO'q(bO~O!S(qO'r(pOP$WX!e$WX~O!e(rOP(YX~OP(tO~OP!aX!S!aX!e!aX'r!aX!O!aXo!aXy!aX!P!aXX!aX!Z!aX#R!aXv!aX~P!KgOy$UaX$Ua!e$Ua!P$Uav$Ua#R$Ua~P2gO!l(|O'Q#VO'T(xOv(ZP~OQ!QO^#TO_#TO`#TOa#]Od#ZOg!nOyvO|!VO!Q!dO!U#^O!W!lO!]!pO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'Q`O'T#SO~Ov)TO~P#$iOy)VO~PEsO%^)WO~PGaOa)ZO~P!1iO%f)`O~PEvO_)aO'T&cO~O!i)fO!j)eO'T&cO~O'^UO!Q(^X!U(^X!W(^X$q(^X%](^X%^(^X~Ov%uX~P2gOv)gO~PGyOv)gO~Ov)gO~P]OQiXQ'XXZiXd'XX}iX#piX(PiX~ORiXwiX$fiX$|iX[iXoiXyiX!liX!qiX!tiX#OiX#PiX'giX'qiX'riX'xiX'yiX'ziX'{iX'|iX'}iX(OiX(QiX(RiX(TiX!PiX!eiXXiXPiXviX!SiX#RiX~P#(kOQjXQlXRjXZjXdlX}jX#pjX(PjXwjX$fjX$|jX[jXojXyjX!ljX!qjX!tjX#OjX#PjX'gjX'qjX'rjX'xjX'yjX'zjX'{jX'|jX'}jX(OjX(QjX(RjX(TjX!PjX!ejXXjX!SjXPjXvjX#RjX~O%^)jO~PGaOQ']Od)kO~O^)mO_)mO`)mOa)mO'T%dO~Od)qO~OQ']OZ)uO})sOR'UX#p'UX(P'UXw'UX$f'UX$|'UX['UXo'UXy'UX!l'UX!q'UX!t'UX#O'UX#P'UX'g'UX'q'UX'r'UX'x'UX'y'UX'z'UX'{'UX'|'UX'}'UX(O'UX(Q'UX(R'UX(T'UX!P'UX!e'UXX'UXP'UXv'UX!S'UX#R'UX~OQ!QO^:bO_:^O`TOaTOd:aO%^)jO'T:_O~PGaOQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!j)yO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaOQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!P)|O!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaO(P*OO~OR*QO#p*RO(P*PO~OQhXQ'XXZhXd'XX}hX(PhX~ORhX#phXwhX$fhX$|hX[hXohXyhX!lhX!qhX!thX#OhX#PhX'ghX'qhX'rhX'xhX'yhX'zhX'{hX'|hX'}hX(OhX(QhX(RhX(ThX!PhX!ehXXhXPhXvhX!ShX#RhX~P#4kOQ*SO~O})sO~OQ!QO^%vO_%cO`TOaTOd%jO$f%wO%^%xO'T%dO~PGaO!Q*VO!j*VO~O^*YO`*YOa*YO!O*ZO~OQ&oOZ*[O[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaO[#}Oo:YO}#zO!l:ZO!q#jO!t:ZO#O:YO#P:VO#p$OO'g#gO'q:ZO'r#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO~Ow'dX~P#9vOy#qaX#qa!e#qa!P#qav#qa#R#qa~P2gOy#zaX#za!e#za!P#zav#za#R#za~P2gOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!S&_O!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdOo#zay#za#O#za#P#za#p#za'r#za'x#za'y#za'z#za'{#za'|#za'}#za(O#za(P#za(R#za(T#zaX#za!e#za!P#zav#za#R#za~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Q*eO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdO~P)xOw*fO~P#9vO$b*iO$d*jO$f*kO~O!O*lO'r(pO~O!S*nO~O'T*oO~Ow$yOy*qO~O'T*rO~OQ*uOw*vOy*yO}*wO$|*xO~OQ*uOw*vO$|*xO~OQ*uOw+QO$|*xO~OQ*uOo+VOy+XO!S+UO~OQ*uO}+ZO~OQ!QOZ%rO[%qO^%vO`TOaTOd%jOg%yO}%pO!U!lO!W!lO!q%oO$f%wO$q%[O%]!lO%^%xO&W%{O'T%dO'Z%eO(Q%zO~OR+bO_+^O!Q+cO~P#DkO_%cO!Q!lOw&UX$|&UX(P&UX~P#DkOw$yO$f+hO$|*xO(P*PO~OQ!QOZ*[O[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaOQ*uOw$yO!S+UO$|*xO~Oo+nOy+mO!S+oO'r(pO~OdlXy!RX#pbXv!RX!e!RX~Od'XXy(mX#p'SXv(mX!e(mX~Od+qO~O^#TO_#TO`#TOa'kOw&|O'T&vO(Q+vO~Ov(oP~P!3|O#p+{O~Oy+|O~O!S+}O~O&}!sO'O'VO'P,PO~Od,QO~OSVOTVO_%cOsVOtVOuVOw!PO!Q!lO'^UO~P#DkOS,^OT,^OZ,^O['cO_,YOd,^Oo,^Os,^Ou,^Ow'dOy,^O}'bO!S,^O!e,^O!l,^O!q,[O!t,^O!y,^O#O,^O#P,^O#Q,^O#R,^O'Q,^O'Z%eO'^UO'g,ZO'r,[O'v,_O'x,ZO'y,[O'z,[O'{,[O'|,]O'},]O(O,^O(P,`O(Q,`O(R,aO~O!P,dO~P#KkOX,gO~P#KkOv,iO~P#KkOo'tX#O'tX#P'tX#p'tX'r'tX'x'tX'y'tX'z'tX'{'tX'|'tX'}'tX(O'tX(P'tX(R'tX(T'tX~Oy,jO['tX}'tX!l'tX!q'tX!t'tX'g'tX'q'tX(Q'tXv'tX~P#NjOP$giQ$giS$giT$giZ$gi[$gi^$gi_$gi`$gia$gid$gig$gis$git$giu$giw$giy$gi|$gi}$gi!Q$gi!U$gi!W$gi!X$gi!Z$gi!]$gi!l$gi!q$gi!t$gi#Y$gi#r$gi#{$gi$O$gi$b$gi$d$gi$f$gi$i$gi$m$gi$q$gi$s$gi%T$gi%V$gi%Z$gi%]$gi%^$gi%f$gi%j$gi%s$gi&z$gi'Q$gi'T$gi'Z$gi'^$gi'g$gi'q$gi(Q$giv$gi~P#NjOX,kO~O['cOo,lOw'dO}'bOX]X~Oy#ciX#ci!e#ci!P#civ#ci#R#ci~P2gO[#}O}#zO'x#hO(O#|O(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!q#ei!t#ei#O#ei#P#ei#p#ei'q#ei'r#ei'y#ei'z#ei'{#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#R#ei~O'g#ei(P#ei~P$'PO[#}O}#zO(O#|O(R#fOo#eiy#ei!l#ei!q#ei!t#ei#O#ei#P#ei#p#ei'q#ei'r#ei'y#ei'z#ei'{#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#R#ei~O'g#ei'x#ei(P#ei(Q#ei(T#eiw#ei~P$)QO'g#gO(P#gO~P$'PO[#}O}#zO'g#gO'x#hO'y#iO'z#iO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!t#ei#O#ei#P#ei#p#ei'q#ei'r#ei'{#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#R#ei~O!q#ei~P$+`O!q#jO~P$+`O[#}O}#zO!q#jO'g#gO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!t#ei#O#ei#P#ei#p#ei'q#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#R#ei~O'r#ei~P$-hO'r#lO~P$-hO[#}O}#zO!q#jO#P#uO'g#gO'r#lO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!t#ei#O#ei#p#ei'q#ei'|#eiX#ei!e#ei!P#eiv#ei#R#ei~O'}#ei~P$/pO'}#mO~P$/pO[#}O}#zO!q#jO'g#gO'r#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO!l#ni!t#ni#p#ni'q#ni~Oo#xO#O#xO#P#uOy#niX#ni!e#ni!P#niv#ni#R#ni~P$1xO[#}O}#zO!q#jO'g#gO'r#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO!l#si!t#si#p#si'q#si~Oo#xO#O#xO#P#uOy#siX#si!e#si!P#siv#si#R#si~P$3yOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q#VO'ZkO'^UO'gcO'qiO(QdO~P)xO!e,sO!P(VX~P2gO!P,uO~OX,vO~P2gOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdOX&fX!e&fX!P&fX~P)xO!e(WOX(Wa~Oy,zO!e(WOX(WX~P2gOX,{O~O!P,|O!e(WO~O!P-OO!e(WO~P2gOSVOTVOsVOtVOuVO'^UO'g$[O~P!6POP!baZca!S!ba!e!ba!tca'qca'r!ba!O!bao!bay!ba!P!baX!ba!Z!ba#R!bav!ba~O!e-TO'r(pO!P'mXX'mX~O!P-VO~O!i-`O!j-_O!l-[O'T-XOv'nP~OX-aO~O_%cO!Q!lO~P#DkO!j-gOP&gX!e&gX~P<cO!e(rOP(Ya~O!S-iO'r(pOP$Wa!e$Wa~Ow!PO(P*PO~OvbX!S!kX!ebX~O'Q#VO'T(xO~O!S-mO~O!e-oOv([X~Ov-qO~Ov-sO~P,cOv-sO~P#$iO_-uO'T&cO~O!S-vO~Ow$yOy-wO~OQ*uOw*vOy-zO}*wO$|*xO~OQ*uOo.UO~Oy._O~O!S.`O~O!j.bO'T&cO~Ov.cO~Ov.cO~PGyOQ']O^'Wa_'Wa`'Waa'Wa'T'Wa~Od.gO~OQ'XXQ'kXR'kXZ'kXd'XX}'kX#p'kX(P'kXw'kX$f'kX$|'kX['kXo'kXy'kX!l'kX!q'kX!t'kX#O'kX#P'kX'g'kX'q'kX'r'kX'x'kX'y'kX'z'kX'{'kX'|'kX'}'kX(O'kX(Q'kX(R'kX(T'kX!P'kX!e'kXX'kXP'kXv'kX!S'kX#R'kX~OQ!QOZ%rO[%qO^.rO_%cO`TOaTOd%jOg%yO}%pO!j.sO!q.pO!t.kO#V.mO$f%wO%^%xO&W%{O'Q#VO'T%dO'Z%eO(Q%zO!P(sP~PGaO#Q.tOR%wa#p%wa(P%waw%wa$f%wa$|%wa[%wao%way%wa}%wa!l%wa!q%wa!t%wa#O%wa#P%wa'g%wa'q%wa'r%wa'x%wa'y%wa'z%wa'{%wa'|%wa'}%wa(O%wa(Q%wa(R%wa(T%wa!P%wa!e%waX%waP%wav%wa!S%wa#R%wa~O%^.vO~PGaO(P*POR&Oa#p&Oaw&Oa$f&Oa$|&Oa[&Oao&Oay&Oa}&Oa!l&Oa!q&Oa!t&Oa#O&Oa#P&Oa'g&Oa'q&Oa'r&Oa'x&Oa'y&Oa'z&Oa'{&Oa'|&Oa'}&Oa(O&Oa(Q&Oa(R&Oa(T&Oa!P&Oa!e&OaX&OaP&Oav&Oa!S&Oa#R&Oa~O_%cO!Q!lO!j.xO(P*OO~P#DkO!e.yO(P*PO!P(uX~O!P.{O~OX.|Oy.}O(P*PO~O'Z%eOR(qP~OQ']O})sORfa#pfa(Pfawfa$ffa$|fa[faofayfa!lfa!qfa!tfa#Ofa#Pfa'gfa'qfa'rfa'xfa'yfa'zfa'{fa'|fa'}fa(Ofa(Qfa(Rfa(Tfa!Pfa!efaXfaPfavfa!Sfa#Rfa~OQ']O})sOR&Va#p&Va(P&Vaw&Va$f&Va$|&Va[&Vao&Vay&Va!l&Va!q&Va!t&Va#O&Va#P&Va'g&Va'q&Va'r&Va'x&Va'y&Va'z&Va'{&Va'|&Va'}&Va(O&Va(Q&Va(R&Va(T&Va!P&Va!e&VaX&VaP&Vav&Va!S&Va#R&Va~O!P/UO~Ow$yO$f/ZO$|*xO(P*PO~OQ!QOZ/[O[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaOo/^O'r(pO~O#W/_OP!YiQ!YiS!YiT!YiZ!Yi[!Yi^!Yi_!Yi`!Yia!Yid!Yig!Yio!Yis!Yit!Yiu!Yiw!Yiy!Yi|!Yi}!Yi!Q!Yi!U!Yi!W!Yi!X!Yi!Z!Yi!]!Yi!l!Yi!q!Yi!t!Yi#O!Yi#P!Yi#Y!Yi#p!Yi#r!Yi#{!Yi$O!Yi$b!Yi$d!Yi$f!Yi$i!Yi$m!Yi$q!Yi$s!Yi%T!Yi%V!Yi%Z!Yi%]!Yi%^!Yi%f!Yi%j!Yi%s!Yi&z!Yi'Q!Yi'T!Yi'Z!Yi'^!Yi'g!Yi'q!Yi'r!Yi'x!Yi'y!Yi'z!Yi'{!Yi'|!Yi'}!Yi(O!Yi(P!Yi(Q!Yi(R!Yi(T!YiX!Yi!e!Yi!P!Yiv!Yi!i!Yi!j!Yi#V!Yi#R!Yi~Oy#ziX#zi!e#zi!P#ziv#zi#R#zi~P2gOy$UiX$Ui!e$Ui!P$Uiv$Ui#R$Ui~P2gOv/eO!j&bO'Q`O~P<cOw/nO}/mO~Oy!RX#pbX~Oy/oO~O#p/pO~OR+bO_+dO!Q/sO'T&iO'Z%eO~Oa/zO|!VO'Q#VO'T(ROv(cP~OQ!QOZ%rO[%qO^%vO_%cO`TOa/zOd%jOg%yO|!VO}%pO!q%oO$f%wO%^%xO&W%{O'Q#VO'T%dO'Z%eO(Q%zO!P(eP~PGaOQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f0VO%^%xO&W%{O'T%dO'Z%eO(Q%zOw(`Py(`P~PGaOw*vO~Oy-zO$|*xO~Oa/zO|!VO'Q#VO'T*oOv(gP~Ow+QO~OQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f0VO%^%xO&W%{O'T%dO'Z%eO(Q%zO(R0`O~PGaOy0dO~OQ!QOSVOTVO[$gO^0lO_$ZO`9yOa9yOd$aOsVOtVOuVO}$eO!i$qO!j0mO!l$lO!q0eO!t0hO'Q#VO'T$YO'Z%eO'^UO'g$[O~O#V0nO!P(jP~P%1}Ow!POy0pO#Q0rO$|*xO~OR0uO!e0sO~P#(kOR0uO!S+UO!e0sO(P*OO~OR0uOo0wO!S+UO!e0sOQ'VXZ'VX}'VX#p'VX(P'VX~OR0uOo0wO!e0sO~OR0uO!e0sO~O$f/ZO(P*PO~Ow$yO~Ow$yO$|*xO~Oo0}Oy0|O!S1OO'r(pO~O!e1POv(pX~Ov1RO~O^#TO_#TO`#TOa'kOw&|O'T&vO(Q1VO~Oo1YOQ'VXR'VXZ'VX}'VX!e'VX(P'VX~O!e1ZO(P*POR'YX~O!e1ZOR'YX~O!e1ZO(P*OOR'YX~OR1]O~O!S1^OS'wXT'wXZ'wX['wX_'wXd'wXo'wXs'wXu'wXw'wXy'wX}'wX!P'wX!e'wX!l'wX!q'wX!t'wX!y'wX#O'wX#P'wX#Q'wX#R'wX'Q'wX'Z'wX'^'wX'g'wX'r'wX'v'wX'x'wX'y'wX'z'wX'{'wX'|'wX'}'wX(O'wX(P'wX(Q'wX(R'wXX'wXv'wX~O}1_O~O!P1aO~P#KkOX1bO~P#KkOv1cO~P#KkOS,^OT,^OZ,^O['cO_1dOd,^Oo,^Os,^Ou,^Ow'dOy,^O}'bO!S,^O!e,^O!l,^O!q,[O!t,^O!y,^O#O,^O#P,^O#Q,^O#R,^O'Q,^O'Z%eO'^UO'g,ZO'r,[O'v,_O'x,ZO'y,[O'z,[O'{,[O'|,]O'},]O(O,^O(P,`O(Q,`O(R,aO~OX1fO~Oy,jO~O!e,sO!P(Va~P2gOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q#VO'ZkO'^UO'gcO'qiO(QdO!P&eX!e&eX~P)xO!e,sO!P(Va~OX&fa!e&fa!P&fa~P2gOX1kO~P2gO!P1mO!e(WO~OP!biZci!S!bi!e!bi!tci'qci'r!bi!O!bio!biy!bi!P!biX!bi!Z!bi#R!biv!bi~O'r(pOP!oi!S!oi!e!oi!O!oio!oiy!oi!P!oiX!oi!Z!oi#R!oiv!oi~O!j&bO!P&`X!e&`XX&`X~P<cO!e-TO!P'maX'ma~O!P1qO~Ov!RX!S!kX!e!RX~O!S1rO~O!e1sOv'oX~Ov1uO~O'T-XO~O!j1xO'T-XO~O(P*POP$Wi!e$Wi~O!S1yO'r(pOP$XX!e$XX~O!S1|O~Ov$_a!e$_a~P2gO!l(|O'Q#VO'T(xOv&hX!e&hX~O!e-oOv([a~Ov2QO~P,cOy2UO~O#p2VO~Oy2WO$|*xO~Ow*vOy2WO}*wO$|*xO~Oo2aO~Ow!POy2fO#Q2hO$|*xO~O!S2jO~Ov2lO~O#Q2mOR%wi#p%wi(P%wiw%wi$f%wi$|%wi[%wio%wiy%wi}%wi!l%wi!q%wi!t%wi#O%wi#P%wi'g%wi'q%wi'r%wi'x%wi'y%wi'z%wi'{%wi'|%wi'}%wi(O%wi(Q%wi(R%wi(T%wi!P%wi!e%wiX%wiP%wiv%wi!S%wi#R%wi~Od2nO~O^2qO!j.sO!q2rO'Q#VO'Z%eO~O(P*PO!P%{X!e%{X~O!e2sO!P(tX~O!P2uO~OQ!QOZ%rO[%qO^2wO_%cO`TOaTOd%jOg%yO}%pO!j2xO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaO^2yO!j2xO(P*OO~O!P%aX!e%aX~P#4kO^2yO~O(P*POR&Oi#p&Oiw&Oi$f&Oi$|&Oi[&Oio&Oiy&Oi}&Oi!l&Oi!q&Oi!t&Oi#O&Oi#P&Oi'g&Oi'q&Oi'r&Oi'x&Oi'y&Oi'z&Oi'{&Oi'|&Oi'}&Oi(O&Oi(Q&Oi(R&Oi(T&Oi!P&Oi!e&OiX&OiP&Oiv&Oi!S&Oi#R&Oi~O_%cO!Q!lO!P&yX!e&yX~P#DkO!e.yO!P(ua~OR3QO(P*PO~O!e3ROR(rX~OR3TO~O(P*POR&Pi#p&Piw&Pi$f&Pi$|&Pi[&Pio&Piy&Pi}&Pi!l&Pi!q&Pi!t&Pi#O&Pi#P&Pi'g&Pi'q&Pi'r&Pi'x&Pi'y&Pi'z&Pi'{&Pi'|&Pi'}&Pi(O&Pi(Q&Pi(R&Pi(T&Pi!P&Pi!e&PiX&PiP&Piv&Pi!S&Pi#R&Pi~O!P3UO~O$f3VO(P*PO~Ow$yO$f3VO$|*xO(P*PO~Ow!PO!Z!YO~O!Z3aO#R3_O'r(pO~O!j&bO'Q#VO~P<cOv3eO~Ov3eO!j&bO'Q`O~P<cO!O3hO'r(pO~Ow!PO~P#9vOo3kOy3jO(P*PO~O!P3oO~P%;pOv3rO~P%;pOR0uO!S+UO!e0sO~OR0uOo0wO!S+UO!e0sO~Oa/zO|!VO'Q#VO'T(RO~O!S3uO~O!e3wOv(dX~Ov3yO~OQ!QOZ%rO[%qO^%vO_%cO`TOa/zOd%jOg%yO|!VO}%pO!q%oO$f%wO%^%xO&W%{O'Q#VO'T%dO'Z%eO(Q%zO~PGaO!e3|O(P*PO!P(fX~O!P4OO~O!S4PO(P*OO~O!S+UO(P*PO~O!e4ROw(aXy(aX~OQ4TO~Oy2WO~Oa/zO|!VO'Q#VO'T*oO~Oo4WOw*vO}*wOv%XX!e%XX~O!e4ZOv(hX~Ov4]O~O(P4_Oy(_Xw(_X$|(_XR(_Xo(_X!e(_X~Oy4aO(P*PO~OQ!QOSVOTVO[$gO^4bO_$ZO`9yOa9yOd$aOsVOtVOuVO}$eO!i$qO!l$lO!q$hO#V$lO'T$YO'^UO'g$[O~O!j4cO'Z%eO~P&,sO!S4eO'r(pO~O#V4gO~P%1}O!e4hO!P(kX~O!P4jO~O!P%aX!S!aX!e%aX'r!aX~P!KgO!j&bO~P&,sO!e4hO!P(kX!S'eX'r'eX~O^2yO!j2xO~Ow!POy2fO~O_4pO!Q/sO'T&iO'Z%eOR&lX!e&lX~OR4rO!e0sO~O!S4tO~Ow$yO$|*xO(P*PO~Oy4uO~P2gOo4vOy4uO(P*PO~Ov&uX!e&uX~P!3|O!e1POv(pa~Oo4|Oy4{O(P*PO~OSVOTVO_%cOsVOtVOuVOw!PO!Q!lO'^UOR&vX!e&vX~P#DkO!e1ZOR'Ya~O!y5SO~O!P5TO~P#KkO!S1^OX'wX#R'wX~O!e,sO!P(Vi~O!P&ea!e&ea~P2gOX5WO~P2gOP!bqZcq!S!bq!e!bq!tcq'qcq'r!bq!O!bqo!bqy!bq!P!bqX!bq!Z!bq#R!bqv!bq~O'r(pO!P&`a!e&`aX&`a~O!i-`O!j-_O!l5YO'T-XOv&aX!e&aX~O!e1sOv'oa~O!S5[O~O!S5`O'r(pOP$Xa!e$Xa~O(P*POP$Wq!e$Wq~Ov$^i!e$^i~P2gOw!POy5bO#Q5dO$|*xO~Oo5gOy5fO(P*PO~Oy5iO~Oy5iO$|*xO~Oy5mO(P*PO~Ow!POy5bO~Oo5tOy5sO(P*PO~O!S5vO~O!e2sO!P(ta~O^2yO!j2xO'Z%eO~OQ!QOZ%rO[%qO^.rO_%cO`TOaTOd%jOg%yO}%pO!j.sO!q.pO!t5zO#V5|O$f%wO%^%xO&W%{O'Q#VO'T%dO'Z%eO(Q%zO!P&xX!e&xX~PGaOQ!QOZ%rO[%qO^6OO_%cO`TOaTOd%jOg%yO}%pO!j6PO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(P*OO(Q%zO~PGaO!P%aa!e%aa~P#4kO^6QO~O#Q6ROR%wq#p%wq(P%wqw%wq$f%wq$|%wq[%wqo%wqy%wq}%wq!l%wq!q%wq!t%wq#O%wq#P%wq'g%wq'q%wq'r%wq'x%wq'y%wq'z%wq'{%wq'|%wq'}%wq(O%wq(Q%wq(R%wq(T%wq!P%wq!e%wqX%wqP%wqv%wq!S%wq#R%wq~O(P*POR&Oq#p&Oqw&Oq$f&Oq$|&Oq[&Oqo&Oqy&Oq}&Oq!l&Oq!q&Oq!t&Oq#O&Oq#P&Oq'g&Oq'q&Oq'r&Oq'x&Oq'y&Oq'z&Oq'{&Oq'|&Oq'}&Oq(O&Oq(Q&Oq(R&Oq(T&Oq!P&Oq!e&OqX&OqP&Oqv&Oq!S&Oq#R&Oq~O(P*PO!P&ya!e&ya~OX6SO~P2gO'Z%eOR&wX!e&wX~O!e3ROR(ra~O$f6YO(P*PO~Ow![q~P#9vO#R6]O~O!Z3aO#R6]O'r(pO~Ov6bO~O#R6fO~Oy6gO!P6hO~O!P6hO~P%;pOy6kO~Ov6kOy6gO~Ov6kO~P%;pOy6mO~O!e3wOv(da~O!S6pO~Oa/zO|!VO'Q#VO'T(ROv&oX!e&oX~O!e3|O(P*PO!P(fa~OQ!QOZ%rO[%qO^%vO_%cO`TOa/zOd%jOg%yO|!VO}%pO!q%oO$f%wO%^%xO&W%{O'Q#VO'T%dO'Z%eO(Q%zO!P&pX!e&pX~PGaO!e3|O!P(fa~OQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f0VO%^%xO&W%{O'T%dO'Z%eO(Q%zOw&nX!e&nXy&nX~PGaO!e4ROw(aay(aa~O!e4ZOv(ha~Oo7SOv%Xa!e%Xa~Oo7SOw*vO}*wOv%Xa!e%Xa~Oa/zO|!VO'Q#VO'T*oOv&qX!e&qX~O(P*POy$xaw$xa$|$xaR$xao$xa!e$xa~O(P4_Oy(_aw(_a$|(_aR(_ao(_a!e(_a~O!P%aa!S!aX!e%aa'r!aX~P!KgOQ!QOSVOTVO[$gO_$ZO`9yOa9yOd$aOsVOtVOuVO}$eO!i$qO!j&bO!l$lO!q$hO#V$lO'T$YO'^UO'g$[O~O^7ZO~P&JUO^6QO!j6PO~O!e4hO!P(ka~O!e4hO!P(ka!S'eX'r'eX~OQ!QOSVOTVO[$gO^0lO_$ZO`9yOa9yOd$aOsVOtVOuVO}$eO!i$qO!j0mO!l$lO!q0eO!t7_O'Q#VO'T$YO'Z%eO'^UO'g$[O~O#V7aO!P&sX!e&sX~P&L]O!S7cO'r(pO~Ow!POy5bO$|*xO(P*PO~O!S+UOR&la!e&la~Oo0wO!S+UOR&la!e&la~Oo0wOR&la!e&la~O(P*POR$yi!e$yi~Oy7fO~P2gOo7gOy7fO(P*PO~O(P*PORni!eni~O(P*POR&va!e&va~O(P*OOR&va!e&va~OS,^OT,^OZ,^O_,^Od,^Oo,^Os,^Ou,^Oy,^O!S,^O!e,^O!l,^O!q,[O!t,^O!y,^O#O,^O#P,^O#Q,^O#R,^O'Q,^O'Z%eO'^UO'g,ZO'r,[O'x,ZO'y,[O'z,[O'{,[O'|,]O'},]O(O,^O~O(P7iO(Q7iO(R7iO~P'!qO!P7kO~P#KkO!P&ei!e&ei~P2gO'r(pOv!hi!e!hi~O!S7mO~O(P*POP$Xi!e$Xi~Ov$^q!e$^q~P2gOw!POy7oO~Ow!POy7oO#Q7rO$|*xO~Oy7tO~Oy7uO~Oy7vO(P*PO~Ow!POy7oO$|*xO(P*PO~Oo7{Oy7zO(P*PO~O!e2sO!P(ti~O(P*PO!P%}X!e%}X~O!P%ai!e%ai~P#4kO^8OO~O!e8TO['bXv$`i}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[OQ#[iS#[iT#[i[#[i^#[i_#[i`#[ia#[id#[is#[it#[iu#[iv$`i}#[i!i#[i!j#[i!l#[i!q#[i!t'bX#V#[i'Q#[i'T#[i'^#[i'g#[i'q'bX(Q'bX~P@[O#R#^a~P2gO#R8WO~O!Z3aO#R8XO'r(pO~Ov8[O~Oy8^O~P2gOy8`O~Oy6gO!P8aO~Ov8`Oy6gO~O!e3wOv(di~O(P*POv%Qi!e%Qi~O!e3|O!P(fi~O!e3|O(P*PO!P(fi~O(P*PO!P&pa!e&pa~O(P8hOw(bX!e(bXy(bX~O(P*PO!S$wiy$wiw$wi$|$wiR$wio$wi!e$wi~O!e4ZOv(hi~Ov%Xi!e%Xi~P2gOo8kOv%Xi!e%Xi~O!P%ai!S!aX!e%ai'r!aX~P!KgO(P*PO!P%`i!e%`i~O!e4hO!P(ki~O#V8nO~P&L]O!P&sa!S'eX!e&sa'r'eX~O(P*POR$zq!e$zq~Oy8pO~P2gOy7zO~P2gO(P8rO(Q8rO(R8rO~O(P8rO(Q8rO(R8rO~P'!qO'r(pOv!hq!e!hq~O(P*POP$Xq!e$Xq~Ow!POy8uO$|*xO(P*PO~Ow!POy8uO~Oy8xO~P2gOy8zO~P2gOo8|Oy8zO(P*PO~OQ#[qS#[qT#[q[#[q^#[q_#[q`#[qa#[qd#[qs#[qt#[qu#[qv$`q}#[q!i#[q!j#[q!l#[q!q#[q#V#[q'Q#[q'T#[q'^#[q'g#[q~O!e9PO['bXv$`q}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[Oo'bX!t'bX#O'bX#P'bX#p'bX'q'bX'r'bX'x'bX'y'bX'z'bX'{'bX'|'bX'}'bX(O'bX(P'bX(Q'bX(R'bX(T'bX~P'2fO#R9UO~O!Z3aO#R9UO'r(pO~Oy9WO~O(P*POv%Qq!e%Qq~O!e3|O!P(fq~O(P*PO!P&pi!e&pi~O(P8hOw(ba!e(bay(ba~Ov%Xq!e%Xq~P2gO!P&si!S'eX!e&si'r'eX~O(P*PO!P%`q!e%`q~Oy9]O~P2gO(P9^O(Q9^O(R9^O~O'r(pOv!hy!e!hy~Ow!POy9_O~Ow!POy9_O$|*xO(P*PO~Oy9aO~P2gOQ#[yS#[yT#[y[#[y^#[y_#[y`#[ya#[yd#[ys#[yt#[yu#[yv$`y}#[y!i#[y!j#[y!l#[y!q#[y#V#[y'Q#[y'T#[y'^#[y'g#[y~O!e9dO['bXv$`y}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[Oo'bX!t'bX#O'bX#P'bX#p'bX'q'bX'r'bX'x'bX'y'bX'z'bX'{'bX'|'bX'}'bX(O'bX(P'bX(Q'bX(R'bX(T'bX~P'9eO!e9eO['bX}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[OQ#[iS#[iT#[i[#[i^#[i_#[i`#[ia#[id#[is#[it#[iu#[i}#[i!i#[i!j#[i!l#[i!q#[i!t'bX#V#[i'Q#[i'T#[i'^#[i'g#[i'q'bX(Q'bX~P@[O#R9hO~O(P*PO!P&pq!e&pq~Ov%Xy!e%Xy~P2gOw!POy9iO~Oy9jO~P2gOQ#[!RS#[!RT#[!R[#[!R^#[!R_#[!R`#[!Ra#[!Rd#[!Rs#[!Rt#[!Ru#[!Rv$`!R}#[!R!i#[!R!j#[!R!l#[!R!q#[!R#V#[!R'Q#[!R'T#[!R'^#[!R'g#[!R~O!e9kO['bX}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[OQ#[qS#[qT#[q[#[q^#[q_#[q`#[qa#[qd#[qs#[qt#[qu#[q}#[q!i#[q!j#[q!l#[q!q#[q!t'bX#V#[q'Q#[q'T#[q'^#[q'g#[q'q'bX(Q'bX~P@[O!e9nO['bX}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[OQ#[yS#[yT#[y[#[y^#[y_#[y`#[ya#[yd#[ys#[yt#[yu#[y}#[y!i#[y!j#[y!l#[y!q#[y!t'bX#V#[y'Q#[y'T#[y'^#[y'g#[y'q'bX(Q'bX~P@[OwbX~P$|OwjX}jX!tbX'qbX~P!6mOZ'SXd'XXo'SXw'kX!t'SX'q'SX'r'SX~O['SXd'SXw'SX}'SX!l'SX!q'SX#O'SX#P'SX#p'SX'g'SX'x'SX'y'SX'z'SX'{'SX'|'SX'}'SX(O'SX(P'SX(Q'SX(R'SX(T'SX~P'GTOP'SX}'kX!S'SX!e'SX!O'SXy'SX!P'SXX'SX!Z'SX#R'SXv'SX~P'GTO^9qO_9qO`9qOa9qO'T9oO~O!j:OO~P!.cOPoOQ!QOSVOTVOZeOd9tOsVOtVOuVO!U#bO!W#cO!X:zO!Z!YO#Y!_O#r9zO#{9{O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO[#sXo#sXw#sX}#sX!l#sX!q#sX!t#sX#O#sX#P#sX#p#sX'g#sX'q#sX'r#sX'x#sX'y#sX'z#sX'{#sX'|#sX'}#sX(O#sX(P#sX(Q#sX(R#sX(T#sX~P'IxO#Q$uO~P!.cO}'kXP'SX!S'SX!e'SX!O'SXy'SX!P'SXX'SX!Z'SX#R'SXv'SX~P'GTOo#qX#O#qX#P#qX#p#qX'r#qX'x#qX'y#qX'z#qX'{#qX'|#qX'}#qX(O#qX(P#qX(R#qX(T#qX~P!.cOo#zX#O#zX#P#zX#p#zX'r#zX'x#zX'y#zX'z#zX'{#zX'|#zX'}#zX(O#zX(P#zX(R#zX(T#zX~P!.cOPoOQ!QOSVOTVOZeOd9tOsVOtVOuVO!U#bO!W#cO!X:zO!Z!YO#Y!_O#r9zO#{9{O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO[#sao#saw#sa}#sa!l#sa!q#sa!t#sa#O#sa#P#sa#p#sa'g#sa'q#sa'r#sa'x#sa'y#sa'z#sa'{#sa'|#sa'}#sa(O#sa(P#sa(Q#sa(R#sa(T#sa~P'IxOo:YO#O:YO#P:VOw#sa~P!B}Ow$Ua~P#9vOQ'XXd'XX}iX~OQlXdlX}jX~O^:sO_:sO`:sOa:sO'T:_O~OQ'XXd'XX}hX~Ow#qa~P#9vOw#za~P#9vO!S&_Oo#za#O#za#P#za#p#za'r#za'x#za'y#za'z#za'{#za'|#za'}#za(O#za(P#za(R#za(T#za~P!.cO#Q*eO~P!.cOw#ci~P#9vO[#}O}#zO'x#hO(O#|O(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!q#ei!t#ei#O#ei#P#ei#p#ei'q#ei'r#ei'y#ei'z#ei'{#ei'|#ei'}#ei~O'g#ei(P#ei~P((}O'g#gO(P#gO~P((}O[#}O}#zO'g#gO'x#hO'y#iO'z#iO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!t#ei#O#ei#P#ei#p#ei'q#ei'r#ei'{#ei'|#ei'}#ei~O!q#ei~P(*yO!q#jO~P(*yO[#}O}#zO!q#jO'g#gO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!t#ei#O#ei#P#ei#p#ei'q#ei'|#ei'}#ei~O'r#ei~P(,rO'r#lO~P(,rO[#}O}#zO!q#jO#P:VO'g#gO'r#lO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!t#ei#O#ei#p#ei'q#ei'|#ei~O'}#ei~P(.kO'}#mO~P(.kOo:YO#O:YO#P:VOw#ni~P$1xOo:YO#O:YO#P:VOw#si~P$3yOQ'XXd'XX}'kX~Ow#zi~P#9vOw$Ui~P#9vOd9}O~Ow#ca~P#9vOd:uO~OU'x_'v'P'O'^s!y'^'T'Z~",
  goto: "$Ku(vPPPPPPP(wPP)OPP)^PPPP)d-hP0f5aP7R7R8v7R>wD_DpPDvHQPPPPPPK`P! P! _PPPPP!!VP!$oP!$oPP!&oP!(rP!(w!)n!*f!*f!*f!(w!+]P!(w!.Q!.TPP!.ZP!(w!(w!(w!(wP!(w!(wP!(w!(w!.y!/dP!/dJ}J}J}PPPP!/d!.y!/sPP!$oP!0^!0a!0g!1h!1t!3t!3t!5r!7t!1t!1t!9p!;_!=O!>k!@U!Am!CS!De!1t!1tP!1tP!1t!1t!Et!1tP!Ge!1t!1tP!Ie!1tP!1t!7t!7t!1t!7t!1t!Kl!Mt!Mw!7t!1t!Mz!M}!M}!M}!NR!$oP!$oP!$oP! P! PP!N]! P! PP!Ni# }! PP! PP#!^##c##k#$Z#$_#$e#$e#$mP#&s#&s#&y#'o#'{! PP! PP#(]#(l! PP! PPP#(x#)W#)d#)|#)^! P! PP! P! P! PP#*S#*S#*Y#*`#*S#*S! P! PP#*m#*v#+Q#+Q#,x#.l#.x#.x#.{#.{5a5a5a5a5a5a5a5aP5a#/O#/U#/p#1{#2R#2b#6^#6d#6j#6|#7W#8w#9R#9b#9h#9n#9x#:S#:Y#:g#:m#:s#:}#;]#;g#=u#>R#>`#>f#>n#>u#?PPPPPPPP#?V#BaP#F^#Jx#Ls#Nr$&^P$&aPPP$)_$)h$)z$/U$1d$1m$3fP!(w$4`$7r$:i$>T$>^$>c$>fPPP$>i$A`$A|P$BaPPPPPPPPPP$BvP$EU$EX$E[$Eb$Ee$Eh$Ek$En$Et$HO$HR$HU$HX$H[$H_$Hb$He$Hh$Hk$Hn$Jt$Jw$Jz#*S$KW$K^$Ka$Kd$Kh$Kl$Ko$KrQ!tPT'V!s'Wi!SOlm!P!T$T$W$y%b)U*f/gQ'i#QR,n'l(OSOY[bfgilmop!O!P!T!Y!Z![!_!`!c!p!q!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r$y%X%_%b&U&Y&[&b&u&z&|'P'a'l'n'o'}(W(Y(b(d(e(f(j(o(p(r(|)S)U)i*Z*f*i*k*l+Z+n+z,q,s,z-R-T-g-m-t.}/^/b/d/g0e0g0m0}1P1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9s9t9u9v9w9x9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f:gS(z$v-oQ*p&eQ*t&hQ-k(yQ-y)ZW0Z+Q0Y4Z7UR4Y0[&w!RObfgilmop!O!P!T!Y!Z![!_!`!c!p#Q#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r$y%_%b&U&Y&[&b&u'l'}(W(Y(b(f(j(o(p(r(|)S)U)i*Z*f*i*k*l+Z+n,s,z-T-g-m-t.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f#r]Ofgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i+n,s,z-m.}0}1h1|3_3a3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9hb#[b#Q$y'l(b)S)U*Z-t!h$bo!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7m$b%k!Q!n$O$u%o%p%q%y%{&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g!W:y!Y!_!`*i*l/^3h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fR:|%n$_%u!Q!n$O$u%o%p%q&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g$e%l!Q!n$O$u%n%o%p%q%y%{&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g'hZOY[fgilmop!O!P!T!Y!Z![!_!`!c!p!|!}#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r%_%b%i%j&U&Y&[&b&u'a'}(W(Y(d(e(f(j(o(p(r(|)i)p)q*f*i*k*l+Z+n,s,z-R-T-g-m.i.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9s9t9u9v9w9x9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:`:a:e:f:g:t:u:x$^%l!Q!n$O$u%n%o%p%q%y%{&P&p&r(q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gQ&j!hQ&k!iQ&l!jQ&m!kQ&s!oQ)[%QQ)]%RQ)^%SQ)_%TQ)b%WQ+`&oS,R']1ZQ.W)`S/r*u4TR4n0s+yTOY[bfgilmop!O!P!Q!T!Y!Z![!_!`!c!n!p!q!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$O$T$W$`$a$e$g$h$q$r$u$y%X%_%b%i%j%n%o%p%q%y%{&P&U&Y&[&b&o&p&r&u&z&|'P']'a'l'n'o'}(W(Y(b(d(e(f(j(o(p(q(r(|)S)U)i)p)q)s)x)y*O*P*R*V*Z*[*^*e*f*i*k*l*n*w*x+U+V+Z+h+n+o+z+},q,s,z-R-T-g-i-m-t-v.U.`.i.p.t.x.y.}/Z/[/^/b/d/g/{/}0`0e0g0m0r0w0}1O1P1Y1Z1h1r1y1|2a2h2j2m2s2v3V3_3a3f3h3k3u3{3|4R4U4W4_4c4e4h4t4v4|5[5`5d5g5t5v6R6Y6]6a6p6v6x7S7^7c7g7m7r7{8W8X8g8k8|9U9h9s9t9u9v9w9x9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:`:a:e:f:g:t:u:xQ'[!xQ'h#PQ)l%gU)r%m*T*WR.f)kQ,T']R5P1Z#t%s!Q!n$O$u%p%q&P&p&r(q)x)y*O*R*V*[*^*e*n*w+V+h+o+}-i-v.U.`.t.x.y/Z/[/{/}0`0r0w1O1Y1y2a2h2j2m2v3V3u3{3|4U4e4t5`5d5v6R6Y6p6v6x7c7r8gQ)x%oQ+_&oQ,U']n,^'b'c'd,c,f,h,l/m/n1_3n3q5T5U7kS.q)s2sQ/O*PQ/Q*SQ/q*uS0Q*x4RQ0a+U[0o+Z.j0g4h5y7^Q2v.pS4d0e2rQ4m0sQ5Q1ZQ6T3RQ6z4PQ7O4TQ7X4_R9Y8h&jVOfgilmop!O!P!T!Y!Z![!_!`!c!p#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r%_%b&U&Y&[&b&u']'}(W(Y(b(f(j(o(p(r(|)i*f*i*k*l+Z+n,s,z-T-g-m.}/^/b/d/g0e0g0m0}1Z1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fU&g!g%P%[o,^'b'c'd,c,f,h,l/m/n1_3n3q5T5U7k$nsOfgilm!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y'}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9z9{:O:P:Q:R:S:T:U:V:W:X:Y:eS$tp9xS&O!W#bS&Q!X#cQ&`!bQ*_&RQ*a&VS*d&[:fQ*h&^Q,T']Q-j(wQ/i*jQ0p+[S2f.X0qQ3]/_Q3^/`Q3g/hQ3i/kQ5P1ZU5b2R2g4lU7o5c5e5rQ8]6dS8u7p7qS9_8v8wR9i9`i{Ob!O!P!T$y%_%b)S)U)i-thxOb!O!P!T$y%_%b)S)U)i-tW/v*v/t3w6qQ/}*wW0[+Q0Y4Z7UQ3{/{Q6x3|R8g6v!h$do!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mQ&d!dQ&f!fQ&n!mW&x!q%X&|1PQ'S!rQ)X$}Q)Y%OQ)a%VU)d%Y'T'UQ*s&hS+s&z'PS-Y(k1sQ-u)WQ-x)ZS.a)e)fS0x+c/sQ1S+zQ1W+{S1v-_-`Q2k.bQ3s/pQ5]1xR5h2V${sOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f$zsOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fR3]/_V&T!Y!`*i!i$lo!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7m!k$^o!c!p$e$g$h$q$r&U&b&u(b(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7m!i$co!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7m&e^Ofgilmop!O!P!T!Y!Z![!_!`!c!p#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r%_%b&U&Y&[&b&u'}(W(Y(f(j(o(p(r(|)i*f*i*k*l+Z+n,s,z-T-g-m.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fR(l$fQ-[(kR5Y1sQ(S#|S({$v-oS-Z(k1sQ-l(yW/u*v/t3w6qS1w-_-`Q3v/vR5^1xQ'e#Or,e'b'c'd'j'p)u,c,f,h,l/m/n1_3n3q5U6fR,o'mk,a'b'c'd,c,f,h,l/m/n1_3n3q5UQ'f#Or,e'b'c'd'j'p)u,c,f,h,l/m/n1_3n3q5U6fR,p'mR*g&]X/c*f/d/g3f!}aOb!O!P!T#z$v$y%_%b'}(y)S)U)i)s*f*v*w+Q+Z,s-o-t.j/b/d/g/t/{0Y0g1h2s3f3w3|4Z4h5y6a6q6v7U7^Q3`/aQ6_3bQ8Y6`R9V8Z${rOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f#nfOfglmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#z#}$T$W%_%b&Y&['}(W(Y(|)i+n,s,z-m.}0}1h1|3_3a3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h!T9u!Y!_!`*i*l/^3h9u9v9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:e:f#rfOfgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i+n,s,z-m.}0}1h1|3_3a3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h!X9u!Y!_!`*i*l/^3h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f$srOfglmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:e:f#U#oh#d$P$Q$V$s%^&W&X'q't'u'v'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9b}:P&S&]/k3[6d:[:]:c:d:h:j:k:l:m:n:o:p:q:r:v:w:{#W#ph#d$P$Q$V$s%^&W&X'q'r't'u'v'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9b!P:Q&S&]/k3[6d:[:]:c:d:h:i:j:k:l:m:n:o:p:q:r:v:w:{#S#qh#d$P$Q$V$s%^&W&X'q'u'v'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9b{:R&S&]/k3[6d:[:]:c:d:h:k:l:m:n:o:p:q:r:v:w:{#Q#rh#d$P$Q$V$s%^&W&X'q'v'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9by:S&S&]/k3[6d:[:]:c:d:h:l:m:n:o:p:q:r:v:w:{#O#sh#d$P$Q$V$s%^&W&X'q'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9bw:T&S&]/k3[6d:[:]:c:d:h:m:n:o:p:q:r:v:w:{!|#th#d$P$Q$V$s%^&W&X'q'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9bu:U&S&]/k3[6d:[:]:c:d:h:n:o:p:q:r:v:w:{!x#vh#d$P$Q$V$s%^&W&X'q'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9bq:W&S&]/k3[6d:[:]:c:d:h:p:q:r:v:w:{!v#wh#d$P$Q$V$s%^&W&X'q'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9bo:X&S&]/k3[6d:[:]:c:d:h:q:r:v:w:{$]#{h#`#d$P$Q$V$s%^&S&W&X&]'q'r's't'u'v'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n/k0z1i1l1}3P3[4w5V5a6^6d6e7R7e7h7s7y8j8q8{9[9b:[:]:c:d:h:i:j:k:l:m:n:o:p:q:r:v:w:{${jOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f$v!aOfgilmp!O!P!T!Y!Z!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fQ&Y![Q&Z!]R:e9{#rpOfgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i+n,s,z-m.}0}1h1|3_3a3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9hQ&[!^!W9x!Y!_!`*i*l/^3h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fR:f:zR$moR-f(rR$wqT(}$v-oQ/f*fS3d/d/gR6c3fQ3m/mQ3p/nQ6i3nR6l3qQ$zwQ)V${Q*q&fQ+f&qQ+i&sQ-w)YW.Z)b+j+k+lS/X*]+gW2b.W.[.].^U3W/Y/]0yU5o2c2d2eS6W3X3ZS7w5p5qS8Q6V6XQ8y7xS8}8R8SR9c9O^|O!O!P!T%_%b)iX)R$y)S)U-tQ&r!nQ*^&PQ*|&jQ+P&kQ+T&lQ+W&mQ+]&nQ+l&sQ-})[Q.Q)]Q.T)^Q.V)_Q.Y)aQ.^)bQ2S-uQ2e.WR4U0VU+a&o*u4TR4o0sQ+Y&mQ+k&sS.])b+l^0v+_+`/q/r4m4n7OS2d.W.^S4Q0R0SR5q2eS0R*x4RQ0a+UR7X4_U+d&o*u4TR4p0sQ*z&jQ+O&kQ+S&lQ+g&qQ+j&sS-{)[*|S.P)]+PS.S)^+TU.[)b+k+lQ/Y*]Q0X*{Q0q+[Q2X-|Q2Y-}Q2].QQ2_.TU2c.W.].^Q2g.XS3Z/]0yS5c2R4lQ5j2ZS5p2d2eQ6X3XS7q5e5rQ7x5qQ8R6VQ8v7pQ9O8SR9`8wQ0T*xR6|4RQ*y&jQ*}&kU-z)[*z*|U.O)]+O+PS2W-{-}S2[.P.QQ4X0ZQ5i2YQ5k2]R7T4YQ/w*vQ3t/tQ6r3wR8d6qQ*{&jS-|)[*|Q2Z-}Q4X0ZR7T4YQ+R&lU.R)^+S+TS2^.S.TR5l2_Q0]+QQ4V0YQ7V4ZR8l7UQ+[&nS.X)a+]S2R-u.YR5e2SQ0i+ZQ4f0gQ7`4hR8m7^Q.m)sQ0i+ZQ2p.jQ4f0gQ5|2sQ7`4hQ7}5yR8m7^Q0i+ZR4f0gX'O!q%X&|1PX&{!q%X&|1PW'O!q%X&|1PS+u&z'PR1U+z_|O!O!P!T%_%b)iQ%a!PS)h%_%bR.d)i$^%u!Q!n$O$u%o%p%q&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gQ*U%yR*X%{$c%n!Q!n$O$u%o%p%q%y%{&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gW)t%m%x*T*WQ.e)jR2{.vR.m)sR5|2sQ'W!sR,O'WQ!TOQ$TlQ$WmQ%b!P[%|!T$T$W%b)U/gQ)U$yR/g*f$b%i!Q!n$O$u%o%p%q%y%{&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g[)n%i)p.i:`:t:xQ)p%jQ.i)qQ:`%nQ:t:aR:x:uQ!vUR'Y!vS!OO!TU%]!O%_)iQ%_!PR)i%b#rYOfgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i+n,s,z-m.}0}1h1|3_3a3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9hh!yY!|#U$`'a'n(d,q-R9s9|:gQ!|[b#Ub#Q$y'l(b)S)U*Z-t!h$`o!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mQ'a!}Q'n#ZQ(d$aQ,q'oQ-R(e!W9s!Y!_!`*i*l/^3h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fQ9|9tR:g9}Q-U(gR1p-UQ1t-[R5Z1tQ,c'bQ,f'cQ,h'dW1`,c,f,h5UR5U1_Q/d*fS3c/d3fR3f/gfbO!O!P!T$y%_%b)S)U)i-tp#Wb'}(y.j/b/t/{0Y0g1h5y6a6q6v7U7^Q'}#zS(y$v-oQ.j)sW/b*f/d/g3fQ/t*vQ/{*wQ0Y+QQ0g+ZQ1h,sQ5y2sQ6q3wQ6v3|Q7U4ZR7^4hQ,t(OQ1g,rT1j,t1gS(X$Q([Q(^$VU,x(X(^,}R,}(`Q(s$mR-h(sQ-p)OR2P-pQ3n/mQ3q/nT6j3n3qQ)S$yS-r)S-tR-t)UQ4`0aR7Y4``0t+^+_+`+a+d/q/r7OR4q0tQ8i6zR9Z8iQ4S0TR6}4SQ3x/wQ6n3tT6s3x6nQ3}/|Q6t3zU6y3}6t8eR8e6uQ4[0]Q7Q4VT7W4[7QhzOb!O!P!T$y%_%b)S)U)i-tQ$|xW%Zz$|%f)v$b%f!Q!n$O$u%o%p%q%y%{&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gR)v%nS4i0i0nS7]4f4gT7b4i7]W&z!q%X&|1PS+r&z+zR+z'PQ1Q+wR4z1QU1[,S,T,UR5R1[S3S/Q7OR6U3SQ2t.mQ5x2pT5}2t5xQ.z)zR3O.z^_O!O!P!T%_%b)iY#Xb$y)S)U-t$l#_fgilmp!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W&Y&['}(W(Y(|*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f!h$io!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mS'j#Q'lQ-P(bR/V*Z&v!RObfgilmop!O!P!T!Y!Z![!_!`!c!p#Q#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r$y%_%b&U&Y&[&b&u'l'}(W(Y(b(f(j(o(p(r(|)S)U)i*Z*f*i*k*l+Z+n,s,z-T-g-m-t.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f[!{Y[#U#Z9s9tW&{!q%X&|1P['`!|!}'n'o9|9}S(c$`$aS+t&z'PU,X'a,q:gS-Q(d(eQ1T+zR1n-RS%t!Q&oQ&q!nQ(V$OQ(w$uS)w%o.pQ)z%pQ)}%qS*]&P&rQ+e&pQ,S']Q-d(qQ.l)sU.w)x)y2vS/O*O*PQ/P*RQ/T*VQ/W*[Q/]*^Q/`*eQ/l*nQ/|*wS0S*x4RQ0a+UQ0c+VQ0y+hQ0{+oQ1X+}Q1{-iQ2T-vQ2`.UQ2i.`Q2z.tQ2|.xQ2}.yQ3X/ZQ3Y/[S3z/{/}Q4^0`Q4l0rQ4s0wQ4x1OQ4}1YQ5O1ZQ5_1yQ5n2aQ5r2hQ5u2jQ5w2mQ5{2sQ6V3VQ6o3uQ6u3{Q6w3|Q7P4UQ7X4_Q7[4eQ7d4tQ7n5`Q7p5dQ7|5vQ8P6RQ8S6YQ8c6pS8f6v6xQ8o7cQ8w7rR9X8g$^%m!Q!n$O$u%o%p%q&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gQ)j%nQ*T%yR*W%{$y%h!Q!n$O$u%i%j%n%o%p%q%y%{&P&o&p&r'](q)p)q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.i.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g:`:a:t:u:x'pWOY[bfgilmop!O!P!T!Y!Z![!_!`!c!p!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r$y%_%b&U&Y&[&b&u'a'l'n'o'}(W(Y(b(d(e(f(j(o(p(r(|)S)U)i*Z*f*i*k*l+Z+n,q,s,z-R-T-g-m-t.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9s9t9u9v9w9x9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f:g$x%g!Q!n$O$u%i%j%n%o%p%q%y%{&P&o&p&r'](q)p)q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.i.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g:`:a:t:u:x_&y!q%X&z&|'P+z1PR,V']$zrOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f!j$]o!c!p$e$g$h$q$r&U&b&u(b(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mQ,T']R5P1Z_}O!O!P!T%_%b)i^|O!O!P!T%_%b)iQ#YbX)R$y)S)U-tbhO!O!T3_6]8W8X9U9hS#`f9uQ#dgQ$PiQ$QlQ$VmQ$spW%^!P%_%b)iU&S!Y!`*iQ&W!ZQ&X![Q&]!_Q'q#eQ'r#oS's#p:QQ't#qQ'u#rQ'v#sQ'w#tQ'x#uQ'y#vQ'z#wQ'{#xQ'|#yQ(O#zQ(U#}Q([$TQ(`$WQ*b&YQ*c&[Q,r'}Q,w(WQ,y(YQ-n(|Q/k*lQ0z+nQ1i,sQ1l,zQ1}-mQ3P.}Q3[/^Q4w0}Q5V1hQ5a1|Q6^3aQ6d3hQ6e3kQ7R4WQ7e4vQ7h4|Q7s5gQ7y5tQ8j7SQ8q7gQ8{7{Q9[8kQ9b8|Q:[9wQ:]9xQ:c9zQ:d9{Q:h:OQ:i:PQ:j:RQ:k:SQ:l:TQ:m:UQ:n:VQ:o:WQ:p:XQ:q:YQ:r:ZQ:v:eQ:w:fR:{9v^tO!O!P!T%_%b)i$`#afgilmp!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W&Y&['}(W(Y(|*i*l+n,s,z-m.}/^0}1h1|3a3h3k4W4v4|5g5t7S7g7{8k8|9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fQ6[3_Q8V6]Q9R8WQ9T8XQ9g9UR9m9hQ&V!YQ&^!`R/h*iQ$joQ&a!cQ&t!pU(g$e$g(jS(n$h0eQ(u$qQ(v$rQ*`&UQ*m&bQ+p&uQ-S(fS-b(o4cQ-c(pQ-e(rW/a*f/d/g3fQ/j*kW0f+Z0g4h7^Q1o-TQ1z-gQ3b/bQ4k0mQ5X1rQ7l5[Q8Z6aR8t7m!h$_o!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mR-P(b'qXOY[bfgilmop!O!P!T!Y!Z![!_!`!c!p!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r$y%_%b&U&Y&[&b&u'a'l'n'o'}(W(Y(b(d(e(f(j(o(p(r(|)S)U)i*Z*f*i*k*l+Z+n,q,s,z-R-T-g-m-t.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9s9t9u9v9w9x9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f:g$zqOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f!i$fo!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7m&d^Ofgilmop!O!P!T!Y!Z![!_!`!c!p#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r%_%b&U&Y&[&b&u'}(W(Y(f(j(o(p(r(|)i*f*i*k*l+Z+n,s,z-T-g-m.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f[!zY[$`$a9s9t['_!|!}(d(e9|9}W)o%i%j:`:aU,W'a-R:gW.h)p)q:t:uT2o.i:xQ(i$eQ(m$gR-W(jV(h$e$g(jR-^(kR-](k$znOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f!i$ko!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mS'g#O'pj,a'b'c'd,c,f,h,l/m/n1_3n3q5UQ,m'jQ.u)uR8_6f`,b'b'c'd,c,f,h1_5UQ1e,lX3l/m/n3n3qj,a'b'c'd,c,f,h,l/m/n1_3n3q5UQ7j5TR8s7k^uO!O!P!T%_%b)i$`#afgilmp!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W&Y&['}(W(Y(|*i*l+n,s,z-m.}/^0}1h1|3a3h3k4W4v4|5g5t7S7g7{8k8|9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fQ6Z3_Q8U6]Q9Q8WQ9S8XQ9f9UR9l9hR(Q#zR(P#zQ$SlR(]$TR$ooR$noR)Q$vR)P$vQ)O$vR2O-ohwOb!O!P!T$y%_%b)S)U)i-t$l!lz!Q!n$O$u$|%f%n%o%p%q%y%{&P&o&p&r'](q)s)v)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gR${xR0b+UR0W*xR0U*xR6{4PR/y*vR/x*vR0P*wR0O*wR0_+QR0^+Q%XyObxz!O!P!Q!T!n$O$u$y$|%_%b%f%n%o%p%q%y%{&P&o&p&r'](q)S)U)i)s)v)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-t-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gR0k+ZR0j+ZQ'R!qQ)c%XQ+w&|R4y1PX'Q!q%X&|1PR+y&|R+x&|T/S*S4TT/R*S4TR.o)sR.n)sR){%p",
  nodeNames: "⚠ | < > RawString Float LineComment BlockComment SourceFile ] InnerAttribute ! [ MetaItem self Metavariable super crate Identifier ScopedIdentifier :: QualifiedScope AbstractType impl SelfType MetaType TypeIdentifier ScopedTypeIdentifier ScopeIdentifier TypeArgList TypeBinding = Lifetime String Escape Char Boolean Integer } { Block ; ConstItem Vis pub ( in ) const BoundIdentifier : UnsafeBlock unsafe AsyncBlock async move IfExpression if LetDeclaration let LiteralPattern ArithOp MetaPattern SelfPattern ScopedIdentifier TuplePattern ScopedTypeIdentifier , StructPattern FieldPatternList FieldPattern ref mut FieldIdentifier .. RefPattern SlicePattern CapturedPattern ReferencePattern & MutPattern RangePattern ... OrPattern MacroPattern ParenthesizedTokens TokenBinding Identifier TokenRepetition ArithOp BitOp LogicOp UpdateOp CompareOp -> => ArithOp BracketedTokens BracedTokens _ else MatchExpression match MatchBlock MatchArm Attribute Guard UnaryExpression ArithOp DerefOp LogicOp ReferenceExpression TryExpression BinaryExpression ArithOp ArithOp BitOp BitOp BitOp BitOp LogicOp LogicOp AssignmentExpression TypeCastExpression as ReturnExpression return RangeExpression CallExpression ArgList AwaitExpression await FieldExpression GenericFunction BreakExpression break LoopLabel ContinueExpression continue IndexExpression ArrayExpression TupleExpression MacroInvocation UnitExpression ClosureExpression ParamList Parameter Parameter ParenthesizedExpression StructExpression FieldInitializerList ShorthandFieldInitializer FieldInitializer BaseFieldInitializer MatchArm WhileExpression while LoopExpression loop ForExpression for MacroInvocation MacroDefinition macro_rules MacroRule EmptyStatement ModItem mod DeclarationList AttributeItem ForeignModItem extern StructItem struct TypeParamList ConstrainedTypeParameter TraitBounds HigherRankedTraitBound RemovedTraitBound OptionalTypeParameter ConstParameter WhereClause where LifetimeClause TypeBoundClause FieldDeclarationList FieldDeclaration OrderedFieldDeclarationList UnionItem union EnumItem enum EnumVariantList EnumVariant TypeItem type FunctionItem default fn ParamList Parameter SelfParameter VariadicParameter VariadicParameter ImplItem TraitItem trait AssociatedType LetDeclaration UseDeclaration use ScopedIdentifier UseAsClause ScopedIdentifier UseList ScopedUseList UseWildcard ExternCrateDeclaration StaticItem static ExpressionStatement ExpressionStatement GenericType FunctionType ForLifetimes ParamList VariadicParameter Parameter VariadicParameter Parameter ReferenceType PointerType TupleType UnitType ArrayType MacroInvocation EmptyType DynamicType dyn BoundedType",
  maxTerm: 359,
  nodeProps: [
    ["group", -42, 4, 5, 14, 15, 16, 17, 18, 19, 33, 35, 36, 37, 40, 51, 53, 56, 101, 107, 111, 112, 113, 122, 123, 125, 127, 128, 130, 132, 133, 134, 137, 139, 140, 141, 142, 143, 144, 148, 149, 155, 157, 159, "Expression", -16, 22, 24, 25, 26, 27, 222, 223, 230, 231, 232, 233, 234, 235, 236, 237, 239, "Type", -20, 42, 161, 162, 165, 166, 169, 170, 172, 188, 190, 194, 196, 204, 205, 207, 208, 209, 217, 218, 220, "Statement", -17, 49, 60, 62, 63, 64, 65, 68, 74, 75, 76, 77, 78, 80, 81, 83, 84, 99, "Pattern"],
    ["openedBy", 9, "[", 38, "{", 47, "("],
    ["closedBy", 12, "]", 39, "}", 45, ")"]
  ],
  propSources: [tz],
  skippedNodes: [0, 6, 7, 240],
  repeatNodeCount: 32,
  tokenData: "#?|_R!VOX$hXY1_YZ2ZZ]$h]^1_^p$hpq1_qr2srs4qst5Ztu6Vuv9lvw;jwx=nxy!!ayz!#]z{!$X{|!&R|}!'T}!O!(P!O!P!*Q!P!Q!-|!Q!R!6X!R![!7|![!]!Jw!]!^!Lu!^!_!Mq!_!`# x!`!a##y!a!b#&Q!b!c#&|!c!}#'x!}#O#)o#O#P#*k#P#Q#1b#Q#R#2^#R#S#'x#S#T$h#T#U#'x#U#V#3`#V#f#'x#f#g#6s#g#o#'x#o#p#<Q#p#q#<|#q#r#?Q#r${$h${$|#'x$|4w$h4w5b#'x5b5i$h5i6S#'x6S~$hU$oZ'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hU%iT'_Q'OSOz%xz{&^{!P%x!P!Q'S!Q~%xS%}T'OSOz%xz{&^{!P%x!P!Q'S!Q~%xS&aTOz&pz{&^{!P&p!P!Q({!Q~&pS&sTOz%xz{&^{!P%x!P!Q'S!Q~%xS'VSOz&p{!P&p!P!Q'c!Q~&pS'fSOz'r{!P'r!P!Q'c!Q~'rS'uTOz(Uz{(l{!P(U!P!Q'c!Q~(US(]T'PS'OSOz(Uz{(l{!P(U!P!Q'c!Q~(US(oSOz'rz{(l{!P'r!Q~'rS)QO'PSU)VZ'_QOY)xYZ+hZr)xrs&psz)xz{)Q{!P)x!P!Q0w!Q#O)x#O#P&p#P~)xU)}Z'_QOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hU*uZ'_QOY)xYZ+hZr)xrs&psz)xz{+|{!P)x!P!Q,g!Q#O)x#O#P&p#P~)xU+mT'_QOz%xz{&^{!P%x!P!Q'S!Q~%xQ,RT'_QOY+|YZ,bZr+|s#O+|#P~+|Q,gO'_QU,lZ'_QOY-_YZ0cZr-_rs'rsz-_z{+|{!P-_!P!Q,g!Q#O-_#O#P'r#P~-_U-dZ'_QOY.VYZ/RZr.Vrs(Usz.Vz{/k{!P.V!P!Q,g!Q#O.V#O#P(U#P~.VU.`Z'_Q'PS'OSOY.VYZ/RZr.Vrs(Usz.Vz{/k{!P.V!P!Q,g!Q#O.V#O#P(U#P~.VU/[T'_Q'PS'OSOz(Uz{(l{!P(U!P!Q'c!Q~(UU/pZ'_QOY-_YZ0cZr-_rs'rsz-_z{/k{!P-_!P!Q+|!Q#O-_#O#P'r#P~-_U0hT'_QOz(Uz{(l{!P(U!P!Q'c!Q~(UU1OT'_Q'PSOY+|YZ,bZr+|s#O+|#P~+|_1hZ'_Q&|X'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_2dT'_Q&|X'OSOz%xz{&^{!P%x!P!Q'S!Q~%x_2|]ZX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`3u!`#O$h#O#P%x#P~$h_4OZ#PX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_4zT']Q'OS'^XOz%xz{&^{!P%x!P!Q'S!Q~%x_5dZ'QX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_6`g'_Q'vW'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!c$h!c!}7w!}#O$h#O#P%x#P#R$h#R#S7w#S#T$h#T#o7w#o${$h${$|7w$|4w$h4w5b7w5b5i$h5i6S7w6S~$h_8Qh'_Q_X'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![7w![!c$h!c!}7w!}#O$h#O#P%x#P#R$h#R#S7w#S#T$h#T#o7w#o${$h${$|7w$|4w$h4w5b7w5b5i$h5i6S7w6S~$h_9u](TP'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_:wZ#OX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_;s_!qX'_Q'OSOY$hYZ%bZr$hrs%xsv$hvw<rwz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_<{Z'}X'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_=ui'_Q'OSOY?dYZA`Zr?drsBdsw?dwx@dxz?dz{CO{!P?d!P!QDv!Q!c?d!c!}Et!}#O?d#O#PId#P#R?d#R#SEt#S#T?d#T#oEt#o${?d${$|Et$|4w?d4w5bEt5b5i?d5i6SEt6S~?d_?k]'_Q'OSOY$hYZ%bZr$hrs%xsw$hwx@dxz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_@mZ'_Q'OSsXOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_AgV'_Q'OSOw%xwxA|xz%xz{&^{!P%x!P!Q'S!Q~%x]BTT'OSsXOz%xz{&^{!P%x!P!Q'S!Q~%x]BiV'OSOw%xwxA|xz%xz{&^{!P%x!P!Q'S!Q~%x_CT]'_QOY)xYZ+hZr)xrs&psw)xwxC|xz)xz{)Q{!P)x!P!Q0w!Q#O)x#O#P&p#P~)x_DTZ'_QsXOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_D{]'_QOY)xYZ+hZr)xrs&psw)xwxC|xz)xz{+|{!P)x!P!Q,g!Q#O)x#O#P&p#P~)x_E}j'_Q'OS'ZXOY$hYZ%bZr$hrs%xsw$hwx@dxz$hz{)Q{!P$h!P!Q*p!Q![Go![!c$h!c!}Go!}#O$h#O#P%x#P#R$h#R#SGo#S#T$h#T#oGo#o${$h${$|Go$|4w$h4w5bGo5b5i$h5i6SGo6S~$h_Gxh'_Q'OS'ZXOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![Go![!c$h!c!}Go!}#O$h#O#P%x#P#R$h#R#SGo#S#T$h#T#oGo#o${$h${$|Go$|4w$h4w5bGo5b5i$h5i6SGo6S~$h]IiX'OSOzBdz{JU{!PBd!P!QKS!Q#iBd#i#jKi#j#lBd#l#mMX#m~Bd]JXVOw&pwxJnxz&pz{&^{!P&p!P!Q({!Q~&p]JsTsXOz%xz{&^{!P%x!P!Q'S!Q~%x]KVUOw&pwxJnxz&p{!P&p!P!Q'c!Q~&p]Kn['OSOz%xz{&^{!P%x!P!Q'S!Q![Ld![!c%x!c!iLd!i#T%x#T#ZLd#Z#o%x#o#pNq#p~%x]LiY'OSOz%xz{&^{!P%x!P!Q'S!Q![MX![!c%x!c!iMX!i#T%x#T#ZMX#Z~%x]M^Y'OSOz%xz{&^{!P%x!P!Q'S!Q![M|![!c%x!c!iM|!i#T%x#T#ZM|#Z~%x]NRY'OSOz%xz{&^{!P%x!P!Q'S!Q![Bd![!c%x!c!iBd!i#T%x#T#ZBd#Z~%x]NvY'OSOz%xz{&^{!P%x!P!Q'S!Q![! f![!c%x!c!i! f!i#T%x#T#Z! f#Z~%x]! k['OSOz%xz{&^{!P%x!P!Q'S!Q![! f![!c%x!c!i! f!i#T%x#T#Z! f#Z#q%x#q#rBd#r~%x_!!jZ}X'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!#fZ!PX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!$`](QX'_QOY)xYZ+hZr)xrs&psz)xz{)Q{!P)x!P!Q0w!Q!_)x!_!`!%X!`#O)x#O#P&p#P~)x_!%`Z#OX'_QOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!&[](PX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_!'^Z!eX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!(Y^'gX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`!a!)U!a#O$h#O#P%x#P~$h_!)_Z#QX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!*Z[(OX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!O$h!O!P!+P!P!Q*p!Q#O$h#O#P%x#P~$h_!+Y^!lX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!O$h!O!P!,U!P!Q*p!Q!_$h!_!`!-Q!`#O$h#O#P%x#P~$h_!,_Z!tX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hV!-ZZ'qP'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!.T]'_Q'xXOY)xYZ+hZr)xrs&psz)xz{!.|{!P)x!P!Q!/d!Q!_)x!_!`!%X!`#O)x#O#P&p#P~)x_!/TT&}]'_QOY+|YZ,bZr+|s#O+|#P~+|_!/kZ'_QUXOY!0^YZ0cZr!0^rs!3`sz!0^z{!5k{!P!0^!P!Q!/d!Q#O!0^#O#P!3`#P~!0^_!0eZ'_QUXOY!1WYZ/RZr!1Wrs!2Usz!1Wz{!4q{!P!1W!P!Q!/d!Q#O!1W#O#P!2U#P~!1W_!1cZ'_QUX'PS'OSOY!1WYZ/RZr!1Wrs!2Usz!1Wz{!4q{!P!1W!P!Q!/d!Q#O!1W#O#P!2U#P~!1W]!2_VUX'PS'OSOY!2UYZ(UZz!2Uz{!2t{!P!2U!P!Q!3z!Q~!2U]!2yVUXOY!3`YZ'rZz!3`z{!2t{!P!3`!P!Q!4f!Q~!3`]!3eVUXOY!2UYZ(UZz!2Uz{!2t{!P!2U!P!Q!3z!Q~!2U]!4PVUXOY!3`YZ'rZz!3`z{!4f{!P!3`!P!Q!3z!Q~!3`X!4kQUXOY!4fZ~!4f_!4xZ'_QUXOY!0^YZ0cZr!0^rs!3`sz!0^z{!4q{!P!0^!P!Q!5k!Q#O!0^#O#P!3`#P~!0^Z!5rV'_QUXOY!5kYZ,bZr!5krs!4fs#O!5k#O#P!4f#P~!5k_!6bhuX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![!7|![#O$h#O#P%x#P#R$h#R#S!7|#S#U$h#U#V!By#V#]$h#]#^!9_#^#c$h#c#d!Ee#d#i$h#i#j!9_#j#l$h#l#m!Gy#m~$h_!8VbuX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![!7|![#O$h#O#P%x#P#R$h#R#S!7|#S#]$h#]#^!9_#^#i$h#i#j!9_#j~$h_!9fe'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!R$h!R!S!:w!S!T$h!T!U!=y!U!W$h!W!X!>y!X!Y$h!Y!Z!<}!Z#O$h#O#P%x#P#g$h#g#h!?y#h~$h_!;O_'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!S$h!S!T!;}!T!W$h!W!X!<}!X#O$h#O#P%x#P~$h_!<U]'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!Y$h!Y!Z!<}!Z#O$h#O#P%x#P~$h_!=WZuX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!>Q]'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!S$h!S!T!<}!T#O$h#O#P%x#P~$h_!?Q]'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!U$h!U!V!<}!V#O$h#O#P%x#P~$h_!@Q]'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P#]$h#]#^!@y#^~$h_!AQ]'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P#n$h#n#o!Ay#o~$h_!BQ]'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P#X$h#X#Y!<}#Y~$h_!CQ_'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!R!DP!R!S!DP!S#O$h#O#P%x#P#R$h#R#S!DP#S~$h_!DYcuX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!R!DP!R!S!DP!S#O$h#O#P%x#P#R$h#R#S!DP#S#]$h#]#^!9_#^#i$h#i#j!9_#j~$h_!El^'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!Y!Fh!Y#O$h#O#P%x#P#R$h#R#S!Fh#S~$h_!FqbuX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!Y!Fh!Y#O$h#O#P%x#P#R$h#R#S!Fh#S#]$h#]#^!9_#^#i$h#i#j!9_#j~$h_!HQb'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![!IY![!c$h!c!i!IY!i#O$h#O#P%x#P#R$h#R#S!IY#S#T$h#T#Z!IY#Z~$h_!IcfuX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![!IY![!c$h!c!i!IY!i#O$h#O#P%x#P#R$h#R#S!IY#S#T$h#T#Z!IY#Z#]$h#]#^!9_#^#i$h#i#j!9_#j~$h_!KQ]!SX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![$h![!]!Ky!]#O$h#O#P%x#P~$h_!LSZdX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!MOZyX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!Mz^#PX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!^$h!^!_!Nv!_!`3u!`#O$h#O#P%x#P~$h_# P]'yX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_#!R^oX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`3u!`!a#!}!a#O$h#O#P%x#P~$h_##WZ#RX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#$S^#PX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`3u!`!a#%O!a#O$h#O#P%x#P~$h_#%X]'zX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_#&ZZ(RX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hV#'VZ'pP'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#(Th'_Q'OS!yW'TPOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![#'x![!c$h!c!}#'x!}#O$h#O#P%x#P#R$h#R#S#'x#S#T$h#T#o#'x#o${$h${$|#'x$|4w$h4w5b#'x5b5i$h5i6S#'x6S~$h_#)xZ[X'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hU#*pX'OSOz#+]z{#+s{!P#+]!P!Q#,X!Q#i#+]#i#j#,j#j#l#+]#l#m#.Y#m~#+]U#+dTrQ'OSOz%xz{&^{!P%x!P!Q'S!Q~%xU#+xTrQOz&pz{&^{!P&p!P!Q({!Q~&pU#,^SrQOz&p{!P&p!P!Q'c!Q~&pU#,o['OSOz%xz{&^{!P%x!P!Q'S!Q![#-e![!c%x!c!i#-e!i#T%x#T#Z#-e#Z#o%x#o#p#/r#p~%xU#-jY'OSOz%xz{&^{!P%x!P!Q'S!Q![#.Y![!c%x!c!i#.Y!i#T%x#T#Z#.Y#Z~%xU#._Y'OSOz%xz{&^{!P%x!P!Q'S!Q![#.}![!c%x!c!i#.}!i#T%x#T#Z#.}#Z~%xU#/SY'OSOz%xz{&^{!P%x!P!Q'S!Q![#+]![!c%x!c!i#+]!i#T%x#T#Z#+]#Z~%xU#/wY'OSOz%xz{&^{!P%x!P!Q'S!Q![#0g![!c%x!c!i#0g!i#T%x#T#Z#0g#Z~%xU#0l['OSOz%xz{&^{!P%x!P!Q'S!Q![#0g![!c%x!c!i#0g!i#T%x#T#Z#0g#Z#q%x#q#r#+]#r~%x_#1kZXX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#2g]'{X'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_#3kj'_Q'OS!yW'TPOY$hYZ%bZr$hrs#5]sw$hwx#5sxz$hz{)Q{!P$h!P!Q*p!Q![#'x![!c$h!c!}#'x!}#O$h#O#P%x#P#R$h#R#S#'x#S#T$h#T#o#'x#o${$h${$|#'x$|4w$h4w5b#'x5b5i$h5i6S#'x6S~$h]#5dT'OS'^XOz%xz{&^{!P%x!P!Q'S!Q~%x_#5z]'_Q'OSOY?dYZA`Zr?drsBdsw?dwx@dxz?dz{CO{!P?d!P!QDv!Q#O?d#O#PId#P~?d_#7Oi'_Q'OS!yW'TPOY$hYZ%bZr$hrs%xst#8mtz$hz{)Q{!P$h!P!Q*p!Q![#'x![!c$h!c!}#'x!}#O$h#O#P%x#P#R$h#R#S#'x#S#T$h#T#o#'x#o${$h${$|#'x$|4w$h4w5b#'x5b5i$h5i6S#'x6S~$hV#8tg'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!c$h!c!}#:]!}#O$h#O#P%x#P#R$h#R#S#:]#S#T$h#T#o#:]#o${$h${$|#:]$|4w$h4w5b#:]5b5i$h5i6S#:]6S~$hV#:fh'_Q'OS'TPOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![#:]![!c$h!c!}#:]!}#O$h#O#P%x#P#R$h#R#S#:]#S#T$h#T#o#:]#o${$h${$|#:]$|4w$h4w5b#:]5b5i$h5i6S#:]6S~$h_#<ZZwX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#=V_'rX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P#p$h#p#q#>U#q~$h_#>_Z'|X'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#?ZZvX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h",
  tokenizers: [Jq, ez, Kq, 0, 1, 2, 3],
  topRules: { SourceFile: [0, 8] },
  specialized: [{ term: 281, get: (t) => iz[t] || -1 }],
  tokenPrec: 15596
});
var Oz = Kt.define({
  name: "rust",
  parser: nz.configure({
    props: [
      ci.add({
        IfExpression: gt({ except: /^\s*({|else\b)/ }),
        "String BlockComment": () => null,
        AttributeItem: (t) => t.continue(),
        "Statement MatchArm": gt()
      }),
      ui.add((t) => {
        if (/(Block|edTokens|List)$/.test(t.name))
          return Mn;
        if (t.name == "BlockComment")
          return (e) => ({ from: e.from + 2, to: e.to - 2 });
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:\{|\})$/,
    closeBrackets: { stringPrefixes: ["b", "r", "br"] }
  }
});
function rz() {
  return new li(Oz);
}
var fS = 1;
var az = 2;
var oz = 3;
var sz = 82;
var lz = 76;
var cz = 117;
var uz = 85;
var fz = 97;
var hz = 122;
var dz = 65;
var pz = 90;
var $z = 95;
var $d = 48;
var hS = 34;
var Qz = 40;
var dS = 41;
var gz = 32;
var pS = 62;
var mz = new Ie((t) => {
  if (t.next == lz || t.next == uz ? t.advance() : t.next == cz && (t.advance(), t.next == $d + 8 && t.advance()), t.next != sz || (t.advance(), t.next != hS))
    return;
  t.advance();
  let e = "";
  for (; t.next != Qz; ) {
    if (t.next == gz || t.next <= 13 || t.next == dS)
      return;
    e += String.fromCharCode(t.next), t.advance();
  }
  for (t.advance(); ; ) {
    if (t.next < 0)
      return t.acceptToken(fS);
    if (t.next == dS) {
      let i = true;
      for (let n = 0; i && n < e.length; n++)
        t.peek(n + 1) != e.charCodeAt(n) && (i = false);
      if (i && t.peek(e.length + 1) == hS)
        return t.acceptToken(fS, 2 + e.length);
    }
    t.advance();
  }
});
var Sz = new Ie((t) => {
  if (t.next == pS)
    t.peek(1) == pS && t.acceptToken(az, 1);
  else {
    let e = false, i = 0;
    for (; ; i++) {
      if (t.next >= dz && t.next <= pz)
        e = true;
      else {
        if (t.next >= fz && t.next <= hz)
          return;
        if (t.next != $z && !(t.next >= $d && t.next <= $d + 9))
          break;
      }
      t.advance();
    }
    e && i > 1 && t.acceptToken(oz);
  }
}, { extend: true });
var Pz = ti({
  "typedef struct union enum class typename decltype auto template operator friend noexcept namespace using requires concept import export module __attribute__ __declspec __based": f.definitionKeyword,
  "extern MsCallModifier MsPointerModifier extern static register thread_local inline const volatile restrict _Atomic mutable constexpr constinit consteval virtual explicit VirtualSpecifier Access": f.modifier,
  "if else switch for while do case default return break continue goto throw try catch": f.controlKeyword,
  "co_return co_yield co_await": f.controlKeyword,
  "new sizeof delete static_assert": f.operatorKeyword,
  "NULL nullptr": f.null,
  this: f.self,
  "True False": f.bool,
  "TypeSize PrimitiveType": f.standard(f.typeName),
  TypeIdentifier: f.typeName,
  FieldIdentifier: f.propertyName,
  "CallExpression/FieldExpression/FieldIdentifier": f.function(f.propertyName),
  "ModuleName/Identifier": f.namespace,
  PartitionName: f.labelName,
  StatementIdentifier: f.labelName,
  "Identifier DestructorName": f.variableName,
  "CallExpression/Identifier": f.function(f.variableName),
  "CallExpression/ScopedIdentifier/Identifier": f.function(f.variableName),
  "FunctionDeclarator/Identifier FunctionDeclarator/DestructorName": f.function(f.definition(f.variableName)),
  NamespaceIdentifier: f.namespace,
  OperatorName: f.operator,
  ArithOp: f.arithmeticOperator,
  LogicOp: f.logicOperator,
  BitOp: f.bitwiseOperator,
  CompareOp: f.compareOperator,
  AssignOp: f.definitionOperator,
  UpdateOp: f.updateOperator,
  LineComment: f.lineComment,
  BlockComment: f.blockComment,
  Number: f.number,
  String: f.string,
  "RawString SystemLibString": f.special(f.string),
  CharLiteral: f.character,
  EscapeSequence: f.escape,
  "UserDefinedLiteral/Identifier": f.literal,
  PreProcArg: f.meta,
  "PreprocDirectiveName #include #ifdef #ifndef #if #define #else #endif #elif": f.processingInstruction,
  MacroName: f.special(f.name),
  "( )": f.paren,
  "[ ]": f.squareBracket,
  "{ }": f.brace,
  "< >": f.angleBracket,
  ". ->": f.derefOperator,
  ", ;": f.separator
});
var yz = { __proto__: null, bool: 34, char: 34, int: 34, float: 34, double: 34, void: 34, size_t: 34, ssize_t: 34, intptr_t: 34, uintptr_t: 34, charptr_t: 34, int8_t: 34, int16_t: 34, int32_t: 34, int64_t: 34, uint8_t: 34, uint16_t: 34, uint32_t: 34, uint64_t: 34, char8_t: 34, char16_t: 34, char32_t: 34, char64_t: 34, const: 68, volatile: 70, restrict: 72, _Atomic: 74, mutable: 76, constexpr: 78, constinit: 80, consteval: 82, struct: 86, __declspec: 90, final: 148, override: 148, public: 152, private: 152, protected: 152, virtual: 154, extern: 160, static: 162, register: 164, inline: 166, thread_local: 168, __attribute__: 172, __based: 178, __restrict: 180, __uptr: 180, __sptr: 180, _unaligned: 180, __unaligned: 180, noexcept: 194, requires: 198, TRUE: 786, true: 786, FALSE: 788, false: 788, typename: 218, class: 220, template: 234, throw: 248, __cdecl: 256, __clrcall: 256, __stdcall: 256, __fastcall: 256, __thiscall: 256, __vectorcall: 256, try: 260, catch: 264, export: 284, import: 288, case: 298, default: 300, if: 310, else: 316, switch: 320, do: 324, while: 326, for: 332, return: 336, break: 340, continue: 344, goto: 348, co_return: 352, co_yield: 356, using: 364, typedef: 368, namespace: 382, new: 400, delete: 402, co_await: 404, concept: 408, enum: 412, static_assert: 416, friend: 424, union: 426, explicit: 432, operator: 446, module: 458, signed: 520, unsigned: 520, long: 520, short: 520, decltype: 530, auto: 532, sizeof: 568, NULL: 574, nullptr: 588, this: 590 };
var bz = { __proto__: null, "<": 131 };
var vz = { __proto__: null, ">": 135 };
var Xz = { __proto__: null, operator: 390, new: 578, delete: 584 };
var xz = Jt.deserialize({
  version: 14,
  states: "$;fQ!QQVOOP'gOUOOO(XOWO'#CdO,RQUO'#CgO,]QUO'#FkO-sQbO'#CwO.UQUO'#CwO0TQUO'#K[O0[QUO'#CvO0gOpO'#DvO0oQ!dO'#D]OOQR'#JP'#JPO5XQVO'#GVO5fQUO'#JWOOQQ'#JW'#JWO8zQUO'#KnO<eQUO'#KnO>{QVO'#E^O?]QUO'#E^OOQQ'#Ed'#EdOOQQ'#Ee'#EeO?bQVO'#EfO@XQVO'#EiOBUQUO'#FPOBvQUO'#FiOOQR'#Fk'#FkOB{QUO'#FkOOQR'#LR'#LROOQR'#LQ'#LQOETQVO'#KROFxQUO'#LWOGVQUO'#KrOGkQUO'#LWOH]QUO'#LYOOQR'#HV'#HVOOQR'#HW'#HWOOQR'#HX'#HXOOQR'#K}'#K}OOQR'#J`'#J`Q!QQVOOOHkQVO'#F^OIWQUO'#EhOI_QUOOOKZQVO'#HhOKkQUO'#HhONVQUO'#KrONaQUO'#KrOOQQ'#Kr'#KrO!!_QUO'#KrOOQQ'#Jr'#JrO!!lQUO'#HyOOQQ'#K['#K[O!&^QUO'#K[O!&zQUO'#KRO!(zQVO'#I^O!(zQVO'#IaOCQQUO'#KROOQQ'#Iq'#IqOOQQ'#KR'#KRO!,}QUO'#K[OOQR'#KZ'#KZO!-UQUO'#DYO!/mQUO'#KoOOQQ'#Ko'#KoO!/tQUO'#KoO!/{QUO'#ETO!0QQUO'#EWO!0VQUO'#FRO8zQUO'#FPO!QQVO'#F_O!0[Q#vO'#FaO!0gQUO'#FlO!0oQUO'#FqO!0tQVO'#FsO!0oQUO'#FvO!3sQUO'#FwO!3xQVO'#FyO!4SQUO'#F{O!4XQUO'#F}O!4^QUO'#GPO!4cQVO'#GRO!(zQVO'#GTO!4jQUO'#GqO!4xQUO'#GZO!(zQVO'#FfO!6VQUO'#FfO!6[QVO'#GaO!6cQUO'#GbO!6nQUO'#GoO!6sQUO'#GsO!6xQUO'#G{O!7jQ&lO'#HjO!:mQUO'#GvO!:}QUO'#HYO!;YQUO'#H[O!;bQUO'#DWO!;bQUO'#HvO!;bQUO'#HwO!;yQUO'#HxO!<[QUO'#H}O!=PQUO'#IOO!>uQVO'#IcO!(zQVO'#IeO!?PQUO'#IhO!?WQVO'#IkP!@}{,UO'#CbP!6n{,UO'#CbP!AY{7[O'#CbP!6n{,UO'#CbP!A_{,UO'#CbP!AjOSO'#I{POOO)CEo)CEoOOOO'#I}'#I}O!AtOWO,59OOOQR,59O,59OO!(zQVO,59UOOQQ,59W,59WO!(zQVO,5;ROOQR,5<V,5<VO!BPQUO,59YO!(zQVO,5>rOOQR'#IY'#IYOOQR'#IZ'#IZOOQR'#I['#I[OOQR'#I]'#I]O!(zQVO,5>sO!(zQVO,5>sO!(zQVO,5>sO!(zQVO,5>sO!(zQVO,5>sO!(zQVO,5>sO!(zQVO,5>sO!(zQVO,5>sO!(zQVO,5>sO!(zQVO,5>sO!DOQVO,5>{OOQQ,5?X,5?XO!EqQVO'#ChO!IjQUO'#CyOOQQ,59c,59cOOQQ,59b,59bOOQQ,5=O,5=OO!IwQ&lO,5=nO!?PQUO,5?SO!LkQVO,5?VO!LrQbO,59cO!L}QVO'#FYOOQQ,5?Q,5?QO!M_QVO,59VO!MfO`O,5:bO!MkQbO'#D^O!M|QbO'#K_O!N[QbO,59wO!NdQbO'#CwO!NuQUO'#CwO!NzQUO'#K[O# UQUO'#CvOOQR-E<}-E<}O# aQUO,5ApO# hQVO'#EfO@XQVO'#EiOBUQUO,5;kOOQR,5<q,5<qO#$aQUO'#KRO#$hQUO'#KRO!(zQVO'#IVO8zQUO,5;kO#${Q&lO'#HjO#(SQUO'#CsO#*wQbO'#CwO#*|QUO'#CvO#.jQUO'#K[OOQQ-E=U-E=UO#0}QUO,5AYO#1XQUO'#K[O#1cQUO,5AYOOQR,5Ap,5ApOOQQ,5>m,5>mO#3gQUO'#CgO#4]QUO,5>qO#6OQUO'#IfOOQR'#JO'#JOO#6WQUO,5:xO#6tQUO,5:xO#7eQUO,5:xO#8YQUO'#CtO!0QQUO'#ClOOQQ'#JX'#JXO#6tQUO,5:xO#8bQUO,5;QO!4xQUO'#C}O#9kQUO,5;QO#9pQUO,5>RO#:|QUO'#C}O#;dQUO,5>|O#;iQUO'#KxO#<rQUO,5;TO#<zQVO,5;TO#=UQUO,5;TOOQQ,5;T,5;TO#>}QUO'#L]O#?UQUO,5>VO#?ZQbO'#CwO#?fQUO'#GdO#?kQUO'#E^O#@[QUO,5;kO#@sQUO'#LOO#@{QUO,5;rOKkQUO'#HgOBUQUO'#HhO#AQQUO'#KrO!6nQUO'#HkO#AxQUO'#CtO!0tQVO,5<TOOQQ'#Cg'#CgOOQR'#Ji'#JiO#A}QVO,5=aOOQQ,5?[,5?[O#DWQbO'#CwO#DcQUO'#GdOOQQ'#Jj'#JjOOQQ-E=h-E=hOGVQUO,5ArOGkQUO,5ArO#DhQUO,5AtO#DsQUO'#G}OOQR,5Ar,5ArO#DhQUO,5ArO#EOQUO'#HPO#EWQUO,5AtOOQR,5At,5AtOOQR,5Au,5AuO#EfQVO,5AuOOQR-E=^-E=^O#G`QVO,5;xOOQR,5;j,5;jO#IaQUO'#EjO#JfQUO'#EwO#K]QVO'#ExO#MoQUO'#EvO#MwQUO'#EyO#NvQUO'#EzOOQQ'#K{'#K{O$ mQUO,5;SO$!sQUO'#EvOOQQ,5;S,5;SO$#pQUO,5;SO$%cQUO,5:yO$'|QVO,5>QO$(WQUO'#E[O$(eQUO,5>SOOQQ,5>T,5>TO$,RQVO'#C{OOQQ-E=p-E=pOOQQ,5>e,5>eOOQQ,59`,59`O$,]QUO,5>xO$.]QUO,5>{O!6nQUO,59tO$.pQUO,5;qO$.}QUO,5<|O!0QQUO,5:oOOQQ,5:r,5:rO$/YQUO,5;mO$/_QUO'#KnOBUQUO,5;kOOQR,5;y,5;yO$0OQUO'#FcO$0^QUO'#FcO$0cQUO,5;{O$3|QVO'#FnO!0tQVO,5<WO!0oQUO,5<WO!0VQUO,5<]O$4TQVO'#GVO$7PQUO,5<_O!0tQVO,5<bO$:gQVO,5<cO$:tQUO,5<eOOQR,5<e,5<eO$;}QUO,5<eOOQR,5<g,5<gOOQR,5<i,5<iOOQQ'#Fj'#FjO$<SQUO,5<kO$<XQUO,5<mOOQR,5<m,5<mO$=_QUO,5<oO$>eQUO,5<sO$>pQUO,5=]O$>uQUO,5=]O!4xQUO,5<uO$>}QUO,5<uO$?cQUO,5<QO$@iQVO,5<QO$BzQUO,5<{OOQR,5<{,5<{O$DQQVO'#F^OOQR,5<|,5<|O$>uQUO,5<|O$DXQUO,5<|O$DdQUO,5=ZO!(zQVO,5=_O!(zQVO,5=gO#NeQUO,5=nOOQQ,5>U,5>UO$FiQUO,5>UO$FsQUO,5>UO$FxQUO,5>UO$F}QUO,5>UO!6nQUO,5>UO$H{QUO'#K[O$ISQUO,5=pO$I_QUO,5=bOKkQUO,5=pO$JXQUO,5=tOOQR,5=t,5=tO$JaQUO,5=tO$LlQVO'#H]OOQQ,5=v,5=vO!;]QUO,5=vO%#gQUO'#KkO%#nQUO'#K]O%$SQUO'#KkO%$^QUO'#DyO%$oQUO'#D|O%'lQUO'#K]OOQQ'#K]'#K]O%)_QUO'#K]O%#nQUO'#K]O%)dQUO'#K]OOQQ,59r,59rOOQQ,5>b,5>bOOQQ,5>c,5>cO%)lQUO'#H{O%)tQUO,5>dOOQQ,5>d,5>dO%-`QUO,5>dO%-kQUO,5>iO%1VQVO,5>jO%1^QUO,5>}O# hQVO'#EfO%4dQUO,5>}OOQQ,5>},5>}O%5TQUO,5?PO%7XQUO,5?SO!<[QUO,5?SO%9TQUO,5?VO%<pQVO,5?VP!A_{,UO,58|P%<w{,UO,58|P%=V{7[O,58|P%=]{,UO,58|PO{O'#Jv'#JvP%=b{,UO'#LdPOOO'#Ld'#LdP%=h{,UO'#LdPOOO,58|,58|POOO,5?g,5?gP%=mOSO,5?gOOOO-E<{-E<{OOQR1G.j1G.jO%=tQUO1G.pO%>zQUO1G0mOOQQ1G0m1G0mO%@WQUO'#CoO%BgQbO'#CwO%BrQUO'#CrO%BwQUO'#CrO%B|QUO1G.tO#AxQUO'#CqOOQQ1G.t1G.tO%EPQUO1G4^O%FVQUO1G4_O%GxQUO1G4_O%IkQUO1G4_O%K^QUO1G4_O%MPQUO1G4_O%NrQUO1G4_O&!eQUO1G4_O&$WQUO1G4_O&%yQUO1G4_O&'lQUO1G4_O&)_QUO1G4_O&+QQUO'#KQO&,ZQUO'#KQO&,cQUO,59SOOQQ,5=Q,5=QO&.kQUO,5=QO&.uQUO,5=QO&.zQUO,5=QO&/PQUO,5=QO!6nQUO,5=QO#NeQUO1G3YO&/ZQUO1G4nO!<[QUO1G4nO&1VQUO1G4qO&2xQVO1G4qOOQQ1G.}1G.}OOQQ1G.|1G.|OOQQ1G2j1G2jO!IwQ&lO1G3YO&3PQUO'#LPO@XQVO'#EiO&4YQUO'#F]OOQQ'#Jb'#JbO&4_QUO'#FZO&4jQUO'#LPO&4rQUO,5;tO&4wQUO1G.qOOQQ1G.q1G.qOOQR1G/|1G/|O&6jQ!dO'#JQO&6oQbO,59xO&9QQ!eO'#D`O&9XQ!dO'#JSO&9^QbO,5@yO&9^QbO,5@yOOQR1G/c1G/cO&9iQbO1G/cO&9nQ&lO'#GfO&:lQbO,59cOOQR1G7[1G7[O#@[QUO1G1VO&:wQUO1G1^OBUQUO1G1VO&=YQUO'#CyO#*wQbO,59cO&@{QUO1G6tOOQR-E<|-E<|O&B_QUO1G0dO#6WQUO1G0dOOQQ-E=V-E=VO#6tQUO1G0dOOQQ1G0l1G0lO&CSQUO,59iOOQQ1G3m1G3mO&CjQUO,59iO&DQQUO,59iO!M_QVO1G4hO!(zQVO'#JZO&DlQUO,5AdOOQQ1G0o1G0oO!(zQVO1G0oO!6nQUO'#JoO&DtQUO,5AwOOQQ1G3q1G3qOOQR1G1V1G1VO&J]QVO'#FOO!M_QVO,5;sOOQQ,5;s,5;sOBUQUO'#JdO&JmQUO,5AjO&JuQVO'#E[OOQR1G1^1G1^O&MdQUO'#L]OOQR1G1o1G1oOOQR-E=g-E=gOOQR1G7^1G7^O#DhQUO1G7^OGVQUO1G7^O#DhQUO1G7`OOQR1G7`1G7`O&MlQUO'#HOO&MtQUO'#LXOOQQ,5=i,5=iO&NSQUO,5=kO&NXQUO,5=lOOQR1G7a1G7aO#EfQVO1G7aO&N^QUO1G7aO' dQVO,5=lOOQR1G1U1G1UO$.vQUO'#E]O'!YQUO'#E]OOQQ'#Kz'#KzO'!sQUO'#KyO'#OQUO,5;UO'#WQUO'#ElO'#kQUO'#ElO'$OQUO'#EtOOQQ'#J]'#J]O'$TQUO,5;cO'$zQUO,5;cO'%uQUO,5;dO'&{QVO,5;dOOQQ,5;d,5;dO''VQVO,5;dO'&{QVO,5;dO''^QUO,5;bO'(ZQUO,5;eO'(fQUO'#KqO'(nQUO,5:vO'(sQUO,5;fOOQQ1G0n1G0nOOQQ'#J^'#J^O''^QUO,5;bO!4xQUO'#E}OOQQ,5;b,5;bO')nQUO'#E`O'+hQUO'#E{OHrQUO1G0nO'+mQUO'#EbOOQQ'#JY'#JYO'-VQUO'#KsOOQQ'#Ks'#KsO'.PQUO1G0eO'.wQUO1G3lO'/}QVO1G3lOOQQ1G3l1G3lO'0XQVO1G3lO'0`QUO'#L`O'1lQUO'#KYO'1zQUO'#KXO'2VQUO,59gO'2_QUO1G/`O'2dQUO'#FPOOQR1G1]1G1]OOQR1G2h1G2hO$>uQUO1G2hO'2nQUO1G2hO'2yQUO1G0ZOOQR'#Ja'#JaO'3OQVO1G1XO'8wQUO'#FTO'8|QUO1G1VO!6nQUO'#JeO'9[QUO,5;}O$0^QUO,5;}OOQQ'#Fd'#FdOOQQ,5;},5;}O'9jQUO1G1gOOQR1G1g1G1gO'9rQUO,5<YO$.vQUO'#FWOBUQUO'#FWO'9yQUO,5<YO!(zQVO,5<YO':RQUO,5<YO':WQVO1G1rO!0tQVO1G1rOOQR1G1w1G1wO'?vQUO1G1yOOQR1G1|1G1|O'?{QUO1G1}OBUQUO1G2^O'AUQVO1G1}O'CjQUO1G1}O'CoQUO'#GXO8zQUO1G2^OOQR1G2P1G2POOQR1G2V1G2VOOQR1G2X1G2XOOQR1G2Z1G2ZO'CtQUO1G2_O!4xQUO1G2_OOQR1G2w1G2wO'C|QUO1G2wO$>}QUO1G2aOOQQ'#Cu'#CuO'DRQUO'#G]O'D|QUO'#G]O'ERQUO'#LSO'EaQUO'#G`OOQQ'#LT'#LTO'EoQUO1G2aO'EtQVO1G1lO'HVQVO'#GVOBUQUO'#FWOOQR'#Jf'#JfO'EtQVO1G1lO'HaQUO'#FwOOQR1G2g1G2gOOQR,5;x,5;xO'HfQVO,5;xO'HmQUO1G2hO'HrQUO'#JhO'2nQUO1G2hO!(zQVO1G2uO'HzQUO1G2yO'JTQUO1G3RO'KZQUO1G3YOOQQ1G3p1G3pO'KoQUO1G3pOOQR1G3[1G3[O'KtQUO'#K[O'2dQUO'#LUOGkQUO'#LWOOQR'#Gz'#GzO#DhQUO'#LYOOQR'#HR'#HRO'LOQUO'#GwO'$OQUO'#GvOOQR1G2|1G2|O'L{QUO1G2|O'MrQUO1G3[O'M}QUO1G3`O'NSQUO1G3`OOQR1G3`1G3`O'N[QUO'#H^OOQR'#H^'#H^O( eQUO'#H^O!(zQVO'#HaO!(zQVO'#H`OOQR'#L['#L[O( jQUO'#L[OOQR'#Jl'#JlO( oQVO,5=wOOQQ,5=w,5=wO( vQUO'#H_O(!OQUO'#H[OOQQ1G3b1G3bO(!YQUO,5@wOOQQ,5@w,5@wO%)_QUO,5@wO%)dQUO,5@wO%$^QUO,5:eO(%wQUO'#KlO(&VQUO'#KlOOQQ,5:e,5:eOOQQ'#JT'#JTO(&bQUO'#D}O(&lQUO'#KrOGkQUO'#LWO('hQUO'#D}OOQQ'#Hq'#HqOOQQ'#Hs'#HsOOQQ'#Ht'#HtOOQQ'#Km'#KmOOQQ'#JV'#JVO('rQUO,5:hOOQQ,5:h,5:hO((oQUO'#LWO((|QUO'#HuO()dQUO,5@wO()kQUO'#H|O()vQUO'#L_O(*OQUO,5>gO(*TQUO'#L^OOQQ1G4O1G4OO(-zQUO1G4OO(.RQUO1G4OO(.YQUO1G4UO(/`QUO1G4UO(/eQUO,5A}O!6nQUO1G4iO!(zQVO'#IjOOQQ1G4n1G4nO(/jQUO1G4nO(1mQVO1G4qPOOO1G.h1G.hP!A_{,UO1G.hP(3mQUO'#LfP(3x{,UO1G.hP(3}{7[O1G.hPO{O-E=t-E=tPOOO,5BO,5BOP(4V{,UO,5BOPOOO1G5R1G5RO!(zQVO7+$[O(4[QUO'#CyOOQQ,59^,59^O(4gQbO,59cO(4rQbO,59^OOQQ,59],59]OOQQ7+)x7+)xO!M_QVO'#JuO(4}QUO,5@lOOQQ1G.n1G.nOOQQ1G2l1G2lO(5VQUO1G2lO(5[QUO7+(tOOQQ7+*Y7+*YO(7pQUO7+*YO(7wQUO7+*YO(1mQVO7+*]O#NeQUO7+(tO(8UQVO'#JcO(8iQUO,5AkO(8qQUO,5;vOOQQ'#Co'#CoOOQQ,5;w,5;wO!(zQVO'#F[OOQQ-E=`-E=`O!M_QVO,5;uOOQQ1G1`1G1`OOQQ,5?l,5?lOOQQ-E=O-E=OOOQR'#Dg'#DgOOQR'#Di'#DiOOQR'#Dl'#DlO(9zQ!eO'#K`O(:RQMkO'#K`O(:YQ!eO'#K`OOQR'#K`'#K`OOQR'#JR'#JRO(:aQ!eO,59zOOQQ,59z,59zO(:hQbO,5?nOOQQ-E=Q-E=QO(:vQbO1G6eOOQR7+$}7+$}OOQR7+&q7+&qOOQR7+&x7+&xO'8|QUO7+&qO(;RQUO7+&OO#6WQUO7+&OO(;vQUO1G/TO(<^QUO1G/TO(<xQUO7+*SOOQQ7+*W7+*WO(>kQUO,5?uOOQQ-E=X-E=XO(?tQUO7+&ZOOQQ,5@Z,5@ZOOQQ-E=m-E=mO(?yQUO'#LPO@XQVO'#EiO(AVQUO1G1_OOQQ1G1_1G1_O(B`QUO,5@OOOQQ,5@O,5@OOOQQ-E=b-E=bO(BtQUO'#KqOOQR7+,x7+,xO#DhQUO7+,xOOQR7+,z7+,zO(CRQUO,5=jO#DsQUO'#JkO(CdQUO,5AsOOQR1G3V1G3VOOQR1G3W1G3WO(CrQUO7+,{OOQR7+,{7+,{O(EjQUO,5:wO(GXQUO'#EwO!(zQVO,5;VO(GzQUO,5:wO(HUQUO'#EpO(HgQUO'#EzOOQQ,5;Z,5;ZO#K]QVO'#ExO(H}QUO,5:wO(IUQUO'#EyO#GgQUO'#J[O(JnQUO,5AeOOQQ1G0p1G0pO(JyQUO,5;WO!<[QUO,5;^O(KdQUO,5;_O(KrQUO,5;WO(NUQUO,5;`OOQQ-E=Z-E=ZO(N^QUO1G0}OOQQ1G1O1G1OO) XQUO1G1OO)!_QVO1G1OO)!fQVO1G1OO)!pQUO1G0|OOQQ1G0|1G0|OOQQ1G1P1G1PO)#mQUO'#JpO)#wQUO,5A]OOQQ1G0b1G0bOOQQ-E=[-E=[O)$PQUO,5;iO!<[QUO,5;iO)$|QVO,5:zO)%TQUO,5;gO$ mQUO7+&YOOQQ7+&Y7+&YO!(zQVO'#EfO)%[QUO,5:|OOQQ'#Kt'#KtOOQQ-E=W-E=WOOQQ,5A_,5A_OOQQ'#Jm'#JmO))PQUO7+&PPOQQ7+&P7+&POOQQ7+)W7+)WO))wQUO7+)WO)*}QVO7+)WOOQQ,5>n,5>nO$)YQVO'#JtO)+UQUO,5@sOOQQ1G/R1G/ROOQQ7+$z7+$zO)+aQUO7+(SO)+fQUO7+(SOOQR7+(S7+(SO$>uQUO7+(SOOQQ7+%u7+%uOOQR-E=_-E=_O!0VQUO,5;oOOQQ,5@P,5@POOQQ-E=c-E=cO$0^QUO1G1iOOQQ1G1i1G1iOOQR7+'R7+'ROOQR1G1t1G1tOBUQUO,5;rO),SQUO,5<ZO),ZQUO1G1tO)-dQUO1G1tO!0tQVO7+'^O)-iQVO7+'^O)3XQUO7+'eO)3^QVO7+'iO)5rQUO7+'xO)5|QUO7+'iO)7SQVO7+'iOKkQUO7+'xO$>hQUO,5<sO!4xQUO7+'yO)7ZQUO7+'yOOQR7+(c7+(cO)7`QUO7+'{O)7eQUO,5<wO'DRQUO,5<wO)8]QUO,5<wO'DRQUO,5<wOOQQ,5<x,5<xO)8nQVO,5<yO'EaQUO'#JgO)8xQUO,5AnO)9QQUO,5<zOOQR7+'{7+'{O)9]QVO7+'WO)5uQUO'#LOOOQR-E=d-E=dO);nQVO,5<cOOQR1G1d1G1dOOQQ,5@S,5@SO!6nQUO,5@SOOQQ-E=f-E=fO)>VQUO7+(aO)?]QUO7+(eO)?bQVO7+(eOOQQ7+(m7+(mOOQQ7+)[7+)[O)?jQUO'#KkO)?tQUO'#KkOOQR,5=c,5=cO)@RQUO,5=cO!;bQUO,5=cO!;bQUO,5=cO!;bQUO,5=cOOQR7+(h7+(hOOQR7+(v7+(vOOQR7+(z7+(zOOQR,5=x,5=xO)@WQUO,5={O)A^QUO,5=zOOQR,5Av,5AvOOQR-E=j-E=jOOQQ1G3c1G3cO)BdQUO,5=yO)BiQVO'#EfOOQQ1G6c1G6cO%)_QUO1G6cO%)dQUO1G6cOOQQ1G0P1G0POOQQ-E=R-E=RO)EQQUO,5AWO(%wQUO'#JUO)E]QUO,5AWO)E]QUO,5AWO)EeQUO,5:iO8zQUO,5:iOOQQ,5>^,5>^O)EoQUO,5ArO)EvQUO'#EVO)GQQUO'#EVO)GkQUO,5:iO)GuQUO'#HmO)GuQUO'#HnOOQQ'#Kp'#KpO)HdQUO'#KpO!(zQVO'#HoOOQQ,5:i,5:iO)IUQUO,5:iO!M_QVO,5:iOOQQ-E=T-E=TOOQQ1G0S1G0SOOQQ,5>a,5>aO)IZQUO1G6cO!(zQVO,5>hO)LxQUO'#JsO)MTQUO,5AyOOQQ1G4R1G4RO)M]QUO,5AxOOQQ,5Ax,5AxOOQQ7+)j7+)jO*!zQUO7+)jOOQQ7+)p7+)pO*'yQVO1G7iO*){QUO7+*TO**QQUO,5?UO*+WQUO7+*]POOO7+$S7+$SP*,yQUO'#LgP*-RQUO,5BQP*-W{,UO7+$SPOOO1G7j1G7jO*-]QUO<<GvOOQQ1G.x1G.xOOQQ'#IU'#IUO*/OQUO,5@aOOQQ,5@a,5@aOOQQ-E=s-E=sOOQQ7+(W7+(WOOQQ<<Mt<<MtO*0XQUO<<MtO*2[QUO<<MwO*3}QUO<<L`O*4cQUO,5?}OOQQ,5?},5?}OOQQ-E=a-E=aOOQQ1G1b1G1bO*5lQUO,5;vO*6rQUO1G1aOOQQ1G1a1G1aOOQR,5@z,5@zO*7{Q!eO,5@zO*8SQMkO,5@zO*8ZQ!eO,5@zOOQR-E=P-E=POOQQ1G/f1G/fO*8bQ!eO'#DwOOQQ1G5Y1G5YOOQR<<J]<<J]O*8iQUO<<IjO*9^QUO7+$oOOQQ<<Iu<<IuO(8UQVO,5;ROOQR<=!d<=!dOOQQ1G3U1G3UOOQQ,5@V,5@VOOQQ-E=i-E=iOOQR<=!g<=!gO*:ZQUO1G0cO*:bQUO'#EzO*:rQUO1G0cO*:yQUO'#JOO*<aQUO1G0qO!(zQVO1G0qOOQQ,5;[,5;[OOQQ,5;],5;]OOQQ,5?v,5?vOOQQ-E=Y-E=YO!<[QUO1G0xO*=pQUO1G0xOOQQ1G0y1G0yO*>RQUO'#ElOOQQ1G0z1G0zOOQQ7+&j7+&jO*>gQUO7+&jO*?mQVO7+&jOOQQ7+&h7+&hOOQQ,5@[,5@[OOQQ-E=n-E=nO*@iQUO1G1TO*@sQUO1G1TO*A^QUO1G0fOOQQ1G0f1G0fO*BdQUO'#K|O*BlQUO1G1ROOQQ<<It<<ItOOQQ'#Hc'#HcO'+mQUO,5=|OOQQ'#He'#HeO'+mQUO,5>OOOQQ-E=k-E=kPOQQ<<Ik<<IkPOQQ-E=l-E=lOOQQ<<Lr<<LrO*BqQUO'#LbO*C}QUO'#LaOOQQ,5@`,5@`OOQQ-E=r-E=rOOQR<<Kn<<KnO$>uQUO<<KnO*D]QUO<<KnOOQR1G1Z1G1ZOOQQ7+'T7+'TO!M_QVO1G1uO*DbQUO1G1uOOQR7+'`7+'`OOQR<<Jx<<JxO!0tQVO<<JxOOQR<<KP<<KPO*DmQUO<<KTO*EsQVO<<KTOKkQUO<<KdO!M_QVO<<KdO*EzQUO<<KTO!0tQVO<<KTO*GTQUO<<KTO*GYQUO<<KdO*GeQUO<<KeOOQR<<Ke<<KeOOQR<<Kg<<KgO*GjQUO1G2cO)7eQUO1G2cO'DRQUO1G2cO*G{QUO1G2eO*IRQVO1G2eOOQQ1G2e1G2eO*I]QVO1G2eO*IdQUO,5@ROOQQ-E=e-E=eOOQQ1G2f1G2fO*IrQUO1G1}O*J{QVO1G1}O*KSQUO1G1}OOQQ1G5n1G5nOOQR<<K{<<K{OOQR<<LP<<LPO*KXQVO<<LPO*KdQUO<<LPOOQR1G2}1G2}O*KiQUO1G2}O*KpQUO1G3fOOQR1G3e1G3eOOQQ7++}7++}O%)_QUO7++}O*K{QUO1G6rO*K{QUO1G6rO(%wQUO,5?pO*LTQUO,5?pOOQQ-E=S-E=SO*L`QUO1G0TOOQQ1G0T1G0TO*LjQUO1G0TO!M_QVO1G0TO*LoQUO1G0TOOQQ1G3x1G3xO*LyQUO,5:qO)EvQUO,5:qO*MgQUO,5:qO)EvQUO,5:qO$#uQUO,5:uO*NUQVO,5>WO)GuQUO'#JqO*N`QUO1G0TO*NqQVO1G0TOOQQ1G3v1G3vO*NxQUO,5>XO+ TQUO,5>YO+ rQUO,5>ZO+!xQUO1G0TO%)dQUO7++}O+$OQUO1G4SOOQQ,5@_,5@_OOQQ-E=q-E=qOOQQ<<MU<<MUOOQQ<<Mo<<MoO+%XQUO1G4pP+'[QUO'#JwP+'dQUO,5BRPO{O1G7l1G7lPOOO<<Gn<<GnOOQQANC`ANC`OOQR1G6f1G6fO+'lQ!eO,5:cOOQQ,5:c,5:cO+'sQUO1G0mO+)PQUO7+&]O+*`QUO7+&dO+*qQUO,5;WOOQQ<<JU<<JUO++PQUO7+&oOOQQ7+&Q7+&QO!4xQUO'#J_O++zQUO,5AhOOQQ7+&m7+&mOOQQ1G3h1G3hO+,SQUO1G3jOOQQ,5>o,5>oO+/wQUOANAYOOQRANAYANAYO+/|QUO7+'aOOQRAN@dAN@dO+1YQVOAN@oO+1aQUOAN@oO!0tQVOAN@oO+2jQUOAN@oO+2oQUOANAOO+2zQUOANAOO+4QQUOANAOOOQRAN@oAN@oO!M_QVOANAOOOQRANAPANAPO+4VQUO7+'}O)7eQUO7+'}OOQQ7+(P7+(PO+4hQUO7+(PO+5nQVO7+(PO+5uQVO7+'iO+5|QUOANAkOOQR7+(i7+(iOOQR7+)Q7+)QO+6RQUO7+)QO+6WQUO7+)QOOQQ<= i<= iO+6`QUO7+,^O+6hQUO1G5[OOQQ1G5[1G5[O+6sQUO7+%oOOQQ7+%o7+%oO+7UQUO7+%oO*NqQVO7+%oOOQQ7+)b7+)bO+7ZQUO7+%oO+8aQUO7+%oO!M_QVO7+%oO+8kQUO1G0]O*LyQUO1G0]O)EvQUO1G0]OOQQ1G0a1G0aO+9YQUO1G3rO+:`QVO1G3rOOQQ1G3r1G3rO+:jQVO1G3rO+:qQUO,5@]OOQQ-E=o-E=oOOQQ1G3s1G3sO%)_QUO<= iOOQQ7+*[7+*[POQQ,5@c,5@cPOQQ-E=u-E=uOOQQ1G/}1G/}OOQQ,5?y,5?yOOQQ-E=]-E=]OOQRG26tG26tO+;YQUOG26ZO!0tQVOG26ZO+<cQUOG26ZOOQRG26ZG26ZO!M_QVOG26jO!0tQVOG26jO+<hQUOG26jO+=nQUOG26jO+=sQUO<<KiOOQQ<<Kk<<KkOOQRG27VG27VOOQR<<Ll<<LlO+>UQUO<<LlOOQQ7+*v7+*vOOQQ<<IZ<<IZO+>ZQUO<<IZO!M_QVO<<IZO+>`QUO<<IZO+?fQUO<<IZO*NqQVO<<IZOOQQ<<L|<<L|O+?wQUO7+%wO*LyQUO7+%wOOQQ7+)^7+)^O+@fQUO7+)^O+AlQVO7+)^OOQQANETANETO!0tQVOLD+uOOQRLD+uLD+uO+AsQUOLD,UO+ByQUOLD,UOOQRLD,ULD,UO!0tQVOLD,UOOQRANBWANBWOOQQAN>uAN>uO+COQUOAN>uO+DUQUOAN>uO!M_QVOAN>uO+DZQUO<<IcOOQQ<<Lx<<LxOOQR!$( a!$( aO!0tQVO!$( pOOQR!$( p!$( pOOQQG24aG24aO+DxQUOG24aO+FOQUOG24aOOQR!)9E[!)9E[OOQQLD){LD){O+FTQUO'#CgO(dQUO'#CgO+JQQUO'#CyO+LqQUO'#CyO!E{QUO'#CyO+MjQUO'#CyO+M}QUO'#CyO,#pQUO'#CyO,$QQUO'#CyO,$_QUO'#CyO,$jQbO,59cO,$uQbO,59cO,%QQbO,59cO,%]QbO'#CwO,%nQbO'#CwO,&PQbO'#CwO,&bQUO'#CgO,(uQUO'#CgO,)SQUO'#CgO,+wQUO'#CgO,.zQUO'#CgO,/[QUO'#CgO,3TQUO'#CgO,3[QUO'#CgO,4[QUO'#CgO,6eQUO,5:xO#?kQUO,5:xO#?kQUO,5:xO#=ZQUO'#L]O,7RQbO'#CwO,7^QbO'#CwO,7iQbO'#CwO,7tQbO'#CwO#6tQUO'#E^O,8PQUO'#E^O,9^QUO'#HhO,:OQbO'#CwO,:ZQbO'#CwO,:fQUO'#CvO,:kQUO'#CvO,:pQUO'#CoO,;OQbO,59cO,;ZQbO,59cO,;fQbO,59cO,;qQbO,59cO,;|QbO,59cO,<XQbO,59cO,<dQbO,59cO,6eQUO1G0dO,<oQUO1G0dO#?kQUO1G0dO,8PQUO1G0dO,>|QUO'#K[O,?^QUO'#CyO,?lQbO,59cO,6eQUO7+&OO,<oQUO7+&OO,?wQUO'#EwO,@jQUO'#EzO,AZQUO'#E^O,A`QUO'#GdO,AeQUO'#CvO,AjQUO'#CwO,AoQUO'#CwO,AtQUO'#CvO,AyQUO'#GdO,BOQUO'#K[O,BlQUO'#K[O,BvQUO'#CvO,CRQUO'#CvO,C^QUO'#CvO,<oQUO,5:xO,8PQUO,5:xO,8PQUO,5:xO,CiQUO'#K[O,C|QbO'#CwO,DXQUO'#CrO,D^QUO'#E^",
  stateData: ",ES~O(oOSSOSTOSRPQVPQ'fPQ'hPQ'iPQ'jPQ'kPQ'lPQ'mPQ'nPQ~O*[OS~OPmO]eOa!]Od!POlTOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!TxO!VfO!X!XO!Y!WO!i!YO!opO!r!`O!s!aO!t!aO!u!bO!v!aO!x!cO!{!dO#V#QO#a#VO#b#TO#i#OO#p!xO#t!fO#v!eO$S!gO$U!hO$Z!vO$[!wO$a!iO$f!jO$h!kO$i!lO$l!mO$n!nO$p!oO$r!pO$t!qO$v!rO$x!sO$|!tO%O!uO%V!yO%`#ZO%a#[O%b#YO%d!zO%f#UO%h!{O%m#SO%p!|O%w!}O%}#PO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(sRO)QYO)TaO)V|O)W{O)XiO)Y!ZO)ZXO)icO)jdO~OR#bOV#]O'f#^O'h#_O'i#`O'j#`O'k#aO'l#aO'm#_O'n#_O~OX#dO(q#dO(r#fO~O]ZX]iXdiXlgXpZXpiXriXsiXtiXuiXviXwiXxiXyiX}iX!TiX!VZX!ViX!XZX!YZX![ZX!^ZX!_ZX!aZX!bZX!cZX!eZX!fZX!gZX!hZX!riX!siX!tiX!uiX!viX!xiX!{iX%wiX&siX&tiX(siX(vZX(w$^X(xZX(yZX)TZX)TiX)UZX)VZX)ViX)WZX)WiX)XZX)YZX)kZX~O)XiX!UZX~P(dO]#}O!V#lO!X#{O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO(x#kO(y#kO)T#mO)U#oO)V#nO)W#pO)X#jO)Y#|O~Od$RO%Z$SO']$TO'`$UO(z$OO~Ol$VO~O!T$WO])OXd)OXr)OXs)OXt)OXu)OXv)OXw)OXx)OXy)OX})OX!V)OX!r)OX!s)OX!t)OX!u)OX!v)OX!x)OX!{)OX%w)OX&s)OX&t)OX(s)OX)T)OX)V)OX)W)OX)X)OX~Ol$VO~P.ZOl$VO!g$YO)k$YO~OX$ZO)[$ZO~O!R$[O)Y)RP)^)RP~OPmO]$eOa!]Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!TxO!V$fO!X!XO!Y!WO!i!YO!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO#V#QO#a#VO#b#TO#v!eO$Z!vO$[!wO$a!iO$f!jO$h!kO$i!lO$l!mO$n!nO$p!oO$r!pO$t!qO$v!rO$x!sO%`#ZO%a#[O%b#YO%f#UO%m#SO%w$mO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO)QYO)T$kO)W$kO)XiO)Y!ZO)ZXO)icO)jdO~Ol$_O#t$lO(sRO~P0zO](^Xa'zXd(^Xl'zXl(^Xr'zXr(^Xs'zXs(^Xt'zXt(^Xu'zXu(^Xv'zXv(^Xw'zXw(^Xx'zXx(^Xy'zXy(^X{'zX}'zX!V(^X!o(^X!r'zX!r(^X!s'zX!s(^X!t'zX!t(^X!u'zX!u(^X!v'zX!v(^X!x'zX!x(^X!{(^X#a'zX#b'zX%f'zX%m'zX%p(^X%w(^X&n'zX&s'zX&t'zX(s'zX(s(^X)T(^X)V(^X)W(^X~Oa!TOl$oOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO#a#VO#b#TO%f#UO%m#SO&n!RO&s#WO&t!TO(s$nO~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O}!_O!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO&s#WO&t$wO])bXd)bXl)bX!V)bX!{)bX%w)bX(s)bX)T)bX)V)bX)W)bX~O)X$vO~P:nOPmO]eOd!POr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!VfO!X!XO!Y!WO!i!YO!{!dO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO)TaO)V|O)W{O)Y!ZO)ZXO)icO)jdO~Oa%QOl;OO!|%RO(s$xO~P<lO)T%SO~Oa!]Ol$_O{#RO#a#VO#b#TO%f#UO%m#SO&n!RO&s#WO&t!TO(s;RO~P<lOPmO]$eOa%QOl;OO!V$fO!W%_O!X!XO!Y!WO!i!YO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)T$kO)W%]O)Y!ZO)ZXO)icO)jdO)k%[O~O]%hOd!POl%bO!V%kO!{!dO%w$mO(s;SO)T%dO)V%iO)W%iO~O(w%mO~O)X#jO~O(s%nO](uX!V(uX!X(uX!Y(uX![(uX!^(uX!_(uX!a(uX!b(uX!c(uX!e(uX!f(uX!h(uX(v(uX(x(uX(y(uX)T(uX)U(uX)V(uX)W(uX)X(uX)Y(uX!g(uX)k(uX!O(uX!W(uX(w(uX!U(uXQ(uX!d(uX~OP%oO(pQO~PCQO]%hOd!POr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!V%kO!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO!{!dO%p!|O%w!}O)T;dO)V|O)W|O~Ol%rO!o%wO(s$xO~PE_O!TxO#v!eO(w%yO)k%|O])fX!V)fX~O]%hOd!POl%rO!V%kO!{!dO%w!}O(s$xO)T;dO)V|O)W|O~O!TxO#v!eO)X&PO)k&QO~O!U&TO~P!QO]&YO!TxO!V&WO)T&VO)V&ZO)W&ZO~Op&UO~PHrO]&cO!V&bO~OPmO]eOd!PO!VfO!X!XO!Y!WO!i!YO!{!dO#V#QO%`#ZO%a#[O%b#YO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO)TaO)V|O)W{O)Y!ZO)ZXO)icO)jdO~Oa%QOl;OO%w$mO(s$xO~PIgO]%hOd!POl;`O!V%kO!{!dO%w$mO(s$xO)T;dO)V|O)W|O~Op&fO](uX])fX!V(uX!V)fX!X(uX!Y(uX![(uX!^(uX!_(uX!a(uX!b(uX!c(uX!e(uX!f(uX!h(uX(v(uX(x(uX(y(uX)T(uX)U(uX)V(uX)W(uX)X(uX)Y(uX!O(uX!O)fX!U(uX~O!g$YO)k$YO~PL]O!g(uX)k(uX~PL]O](uX!V(uX!X(uX!Y(uX![(uX!^(uX!_(uX!a(uX!b(uX!c(uX!e(uX!f(uX!h(uX(v(uX(x(uX(y(uX)T(uX)U(uX)V(uX)W(uX)X(uX)Y(uX!g(uX)k(uX!O(uX!U(uX~O])fX!V)fX!O)fX~PNkOa&hO&n!RO]&mXd&mXl&mXr&mXs&mXt&mXu&mXv&mXw&mXx&mXy&mX}&mX!V&mX!r&mX!s&mX!t&mX!u&mX!v&mX!x&mX!{&mX%w&mX&s&mX&t&mX(s&mX)T&mX)V&mX)W&mX)X&mX!O&mX!T&mX!X&mX!Y&mX![&mX!^&mX!_&mX!a&mX!b&mX!c&mX!e&mX!f&mX!h&mX(v&mX(x&mX(y&mX)U&mX)Y&mX!g&mX)k&mX!W&mXQ&mX!d&mX(w&mX!U&mX#v&mX~Op&fOl)OX!O)OXQ)OX!d)OX!h)OX)Y)OX)k)OX~P.ZO!g$YO)k$YO](uX!V(uX!X(uX!Y(uX![(uX!^(uX!_(uX!a(uX!b(uX!c(uX!e(uX!f(uX!h(uX(v(uX(x(uX(y(uX)T(uX)U(uX)V(uX)W(uX)X(uX)Y(uX!O(uX!W(uX(w(uX!U(uXQ(uX!d(uX~OPmO]$eOa%QOl;OO!V$fO!X!XO!Y!WO!i!YO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)T$kO)W$kO)Y!ZO)ZXO)icO)jdO~O])OXd)OXl)OXr)OXs)OXt)OXu)OXv)OXw)OXx)OXy)OX})OX!V)OX!r)OX!s)OX!t)OX!u)OX!v)OX!x)OX!{)OX%w)OX&s)OX&t)OX(s)OX)T)OX)V)OX)W)OX)X)OX!O)OXQ)OX!d)OX!h)OX)Y)OX)k)OX~O]#}O~P!*qO]&lO~O])cXa)cXd)cXl)cXr)cXs)cXt)cXu)cXv)cXw)cXx)cXy)cX{)cX})cX!V)cX!o)cX!r)cX!s)cX!t)cX!u)cX!v)cX!x)cX!{)cX#a)cX#b)cX%f)cX%m)cX%p)cX%w)cX&n)cX&s)cX&t)cX(s)cX)T)cX)V)cX)W)cX~O(pQO~P!-ZO%V&nO~P!-ZO]&oO~O]#}O~O!TxO~O$X&wO(s%nO(w&vO~O]&xOw&zO~O]&xO~OPmO]$eOa%QOl;OO!TxO!V$fO!X!XO!Y!WO!i!YO#V#QO#p!xO#v!eO$Z!vO$[!wO$a!iO$f!jO$h!kO$i!lO$l!mO$n!nO$p!oO$r!pO$t!qO$v!rO$x!sO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s:qO)QYO)T$kO)W$kO)XiO)Y!ZO)ZXO)icO)jdO~O]'PO~O!T$WO)X'RO~P!(zO)X'TO~O)X'UO~O(s'VO~O)X'YO~P!(zOl;bO%V'^O%f'^O(s;TO~Oa!TOl$oOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO#a#VO#b#TO%f#UO%m#SO&n!RO&s#WO&t!TO(s$nO~O(w'bO~O)X'dO~P!(zO!T'eO(s%nO)k'gO~O(s%nO~O]'jO~O]'kOd%oXl%oX!V%oX!{%oX%w%oX(s%oX)T%oX)V%oX)W%oX~O]'oO!V'pO!X'mO!g'mO%['mO%]'mO%^'mO%_'mO%`'qO%a'qO%b'mO(y'nO)k'mO)y'rO~P8zO]%hOa!TOd!POr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!V%kO!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO!{!dO#a#VO#b#TO%f#UO%m#SO&n!RO&s#WO&t!TO)T;dO)V|O)W|O~Ol;cOp&UO%w$mO(s;UO~P!8jO(s%nO(w'wO)X'xO~O]&cO!T'zO~Ol$oO}!_O!T(RO!l(WO(s$nO(w(QO)QYO~Ol$oO{(_O!T([O#b(_O(s$nO~Oa!TOl$oO{#RO#a#VO#b#TO%f#UO%m#SO&n!RO&s#WO&t!TO(s$nO~O](aO~OPmOa%QOl;OO!V$fO!X!XO!Y!WO!i!YO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)T$kO)W$kO)ZXO)icO)jdO~O](cO)Y(dO~P!=UO]#}O~P!<[OPmO]$eOa%QOl;OO!V(jO!X!XO!Y!WO!i!YO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)T$kO)W$kO)Y!ZO)ZXO)icO)jdO~OY(kO(pQO(s%nO~O'g(nO~OS(rOT(oO*X(qO~O]#}O(o(uO~Q'oXX#dO(q#dO(r(wO~Od)ROl(|O&s#WO(s({O~O!Y'Ta!['Ta!^'Ta!_'Ta!a'Ta!b'Ta!c'Ta!e'Ta!f'Ta!h'Ta(v'Ta)T'Ta)U'Ta)V'Ta)W'Ta)X'Ta)Y'Ta!g'Ta)k'Ta!O'Ta!W'Ta(w'Ta!U'TaQ'Ta!d'Ta~OPmOa%QOl;OO!i!YO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)ZXO)icO)jdO]'Ta!V'Ta!X'Ta(x'Ta(y'Ta~P!B_O!T$WO!O(tP~P!(zO]nX]%XXdnXlmXpnXp%XXrnXsnXtnXunXvnXwnXxnXynX}nX!TnX!VnX!V%XX!X%XX!Y%XX![%XX!^%XX!_%XX!a%XX!b%XX!c%XX!e%XX!f%XX!gmX!h%XX!rnX!snX!tnX!unX!vnX!xnX!{nX%wnX&snX&tnX(snX(v%XX(x%XX(y%XX)TnX)T%XX)U%XX)VnX)V%XX)WnX)W%XX)X%XX)Y%XX)kmX!O%XX~O)XnX!OnX!U%XX~P!E{O])eO!V)fO!X)cO!g)cO%[)cO%])cO%^)cO%_)cO%`)gO%a)gO%b)cO(y)dO)k)cO)y)hO~P8zOPmO]$eOa%QOl;OO!X!XO!Y!WO!i!YO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)T$kO)W$kO)Y!ZO)ZXO)icO)jdO~O!V)mO~P!JwOd)pO%Z)qO(z$OO~O!T$WO!V)sO(x)tO!U)sP~P!JwO!T$WO~P!(zO)]){O~Ol)|O]!QX!h!QX)Y!QX)^!QX~O]*OO!h*PO)Y)RX)^)RX~O)Y*TO)^*SO~Od$RO%Z*UO']$TO'`$UO(z$OO~Ol*VO~Ol*VO!O)OX~P.ZOl*VO!g$YO)k$YO~O)X*WO~P:nOPmO]$eOa!]Ol$_Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO!V$fO!X!XO!Y!WO!i!YO#V#QO#a#VO#b#TO%`#ZO%a#[O%b#YO%f#UO%m#SO%w$mO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s;RO)T$kO)W$kO)Y!ZO)ZXO)icO)jdO~Op&fO~P!&zOp&fO!W(uX(w(uXQ(uX!d(uX~PNkO]'oO!V'pO!X'mO!g'mO%['mO%]'mO%^'mO%_'mO%`'qO%a'qO%b'mO(y'nO)k'mO)y'rO~O]iXdiXlgXpiXriXsiXtiXuiXviXwiXxiXyiX}iX!ViX!riX!siX!tiX!uiX!viX!xiX!{iX%wiX&siX&tiX(siX)TiX)ViX)WiX!TiX!hiX)YiX)kiX!OiX~O!liX(wiX)XiX!XiX!YiX![iX!^iX!_iX!aiX!biX!ciX!eiX!fiX(viX(xiX(yiX)UiX!giX!WiXQiX!diX!UiX#viX#TiX#ViX#piXaiX{iX!oiX#aiX#biX#iiX#tiX$|iX%diX%fiX%liX%miX%piX&niX)QiX~P#%yO(z*[O~Ol*]O~O])OXd)OXr)OXs)OXt)OXu)OXv)OXw)OXx)OXy)OX})OX!V)OX!r)OX!s)OX!t)OX!u)OX!v)OX!x)OX!{)OX%w)OX&s)OX&t)OX(s)OX)T)OX)V)OX)W)OX)X)OX!T)OX!X)OX!Y)OX![)OX!^)OX!_)OX!a)OX!b)OX!c)OX!e)OX!f)OX!h)OX(v)OX(x)OX(y)OX)U)OX)Y)OX!g)OX)k)OX!O)OX!W)OXQ)OX!d)OX(w)OX!U)OX#v)OX~Ol*]O~P#+ROr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O}!_O!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO])bad)bal)ba!V)ba!{)ba%w)ba(s)ba)T)ba)V)ba)W)baQ)ba!d)ba!h)ba)Y)ba)k)ba!O)ba!T)ba(w)ba)X)ba~O&s#WO&t$wO~P#.qOp&fOl)OX~P#+RO&s)ba~P#.qO]ZXlgXpZXpiX!TiX!VZX!XZX!YZX![ZX!^ZX!_ZX!aZX!bZX!cZX!eZX!fZX!gZX!hZX(vZX(xZX(yZX)TZX)UZX)VZX)WZX)XZX)YZX)kZX!OZX~O!WZX(wZX!UZXQZX!dZX~P#1jO]#}O!V#lO!X#{O(x#kO(y#kO~O!Y&ya![&ya!^&ya!_&ya!a&ya!b&ya!c&ya!e&ya!f&ya!g&ya!h&ya(v&ya)T&ya)U&ya)V&ya)W&ya)X&ya)Y&ya)k&ya!O&ya!W&ya(w&ya!U&yaQ&ya!d&ya~P#3zOl;lO!T$WO~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O~PKkOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!|%RO~PKkO]&cO!V&bO!O#Qa!T#Qa!h#Qa#v#Qa)X#Qa)k#QaQ#Qa!d#Qa(w#Qa~Op&fO!T$WO~O!O*dO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!O*dO~O]&cO!O*fO!V&bO~O]&YOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!V&WO&s#WO&t$wO)T&VO)V&ZO)W&ZO~O!OqXQqX!dqX!hqX)YqX)XqX~P#9{O!O*iO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h*jO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!W)lX~P#3zO!W*lO!h*mO~O!W*lO!h*mO~P!(zO!W*lO~Op&fO!g$YO!h*nO)k$YO](uX!V(uX!W(uX!W*PX!X(uX!Y(uX![(uX!^(uX!_(uX!a(uX!b(uX!c(uX!e(uX!f(uX(v(uX(x(uX(y(uX)T(uX)U(uX)V(uX)W(uX)Y(uX~O!h(uX~P#=ZO!W*pO~Od$RO%Z*UO(z:vO~Ol;oO~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!|%RO~PBUO]*wO!T*rO!V&bO!h*uO#v!eO)k*sO)X)rX~O!h*uO)X)rX~O)X*xO~Op&fO])fX!T)fX!V)fX!h)fX#v)fX)X)fX)k)fX!O)fXQ)fX!d)fX(w)fX~Op&fO~OP%oO(pQO]%ia!V%ia!X%ia!Y%ia![%ia!^%ia!_%ia!a%ia!b%ia!c%ia!e%ia!f%ia!h%ia(s%ia(v%ia(x%ia(y%ia)T%ia)U%ia)V%ia)W%ia)X%ia)Y%ia!g%ia)k%ia!O%ia!W%ia(w%ia!U%iaQ%ia!d%ia~Od$RO%Z$SO(z:sO~Ol:{O~O!TxO#v!eO)k%|O~Ol<`O&s#WO(s;kO~O$[+UO%a+VO~O!TxO#v!eO)X+WO)k+XO~OPmO]$eOa%QOl;OO!V$fO!X!XO!Y!WO!i!YO#V#QO$[+UO%`#ZO%a+ZO%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)T$kO)W$kO)Y!ZO)ZXO)icO)jdO~O!U+[O~P!QOa!TOl$oOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO#a+bO#b+cO#i+dO%f#UO%m#SO&n!RO&s#WO&t!TO(s$nO)QYO~OQ)mP!d)mP~P#GgO]&YOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!V&WO)T&VO)V&ZO)W&ZO~O!O#kX!T#kX#v#kX)X#kX)k#kXQ#kX!d#kX!h#kX)Y#kX!x#kX(w#kX~P#IkOPmO]$eOa%QOl;OOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!V$fO!W+jO!X!XO!Y!WO!i!YO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)T+kO)W$kO)Y!ZO)ZXO)icO)jdO~O]&cO!V+lO~O]&YO!V&WO)QYO)T&VO)V&ZO)W&ZO)Y+oO!O)eP~P8zO]&YO!V&WO)T&VO)V&ZO)W&ZO~O!O#nX!T#nX#v#nX)X#nX)k#nXQ#nX!d#nX!h#nX)Y#nX!x#nX(w#nX~P#NeO!TxO])oX!V)oX~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O#T+wO#p+xO(y+uO)V+sO)W+sO~O]#jX!T#jX!V#jX!O#jX#v#jX)X#jX)k#jXQ#jX!d#jX!h#jX)Y#jX!x#jX(w#jX~P$ xO#V+zO~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!l+{O#T+wO#V+zO#p+xO(y+uO)V+{O)W+{O])gP!T)gP!V)gP#v)gP(w)gP)k)gP!O)gP!h)gP)X)gP~O!x)gPQ)gP!d)gP~P$#uOPmO]$eOa%QOl;OOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!V$fO!X!XO!Y!WO!i!YO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)W$kO)Y!ZO)ZXO)icO)jdO~O!W,RO)T,SO~P$%pO)QYO)Y+oO!O)eP~P8zO]&cO!V&bO!O&[a!T&[a!h&[a#v&[a)X&[a)k&[aQ&[a!d&[a(w&[a~OPmO]$eOa!]Ol;QOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO!V$fO!X!XO!Y!WO!i!YO#V#QO#a#VO#b#TO%`#ZO%a#[O%b#YO%f#UO%m#SO%w$mO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s;VO)T$kO)W$kO)Y!ZO)ZXO)icO)jdO~OQ({P!d({P~P$)YO]#}O!V#lO(x#kO(y#kO!X'Qa!Y'Qa!['Qa!^'Qa!_'Qa!a'Qa!b'Qa!c'Qa!e'Qa!f'Qa!h'Qa(v'Qa)T'Qa)U'Qa)V'Qa)W'Qa)X'Qa)Y'Qa!g'Qa)k'Qa!O'Qa!W'Qa(w'Qa!U'QaQ'Qa!d'Qa~O]#}O!V#lO!X#{O(x#kO(y#kO~P!B_O!T'eO#t!fO)QYO~P8zO!T'eO(s%nO)k,]O~O#x,bO~OQ)bX!d)bX!h)bX)Y)bX)k)bX!O)bX!T)bX(w)bX)X)bX~P:nO(w,fO(x,dO)Q$VX)X$VX~O(s,gO~O)QYO)X,jO~OPmO]$eOa!]Ol;POr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!V$fO!X!XO!Y!WO!i!YO!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO#V#QO#a#VO#b#TO%`#ZO%a#[O%b#YO%f#UO%m#SO%w$mO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO)QYO)T$kO)W$kO)XiO)Y!ZO)ZXO)icO)jdO~O(s;WO~P$0kOPmO]$eOa%QOl;OO!TxO!V$fO!X!XO!Y!WO!i!YO#V#QO#v!eO$Z!vO$[!wO$a!iO$f!jO$h!kO$i!lO$l!mO$n!nO$p!oO$r!pO$t!qO$v!rO$x!sO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s:qO)QYO)T$kO)W$kO)XiO)Y!ZO)ZXO)icO)jdO~O$i,tO~OPmO]$eOa!]Ol;POr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!V$fO!X!XO!Y!WO!i!YO!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO#V#QO#a#VO#b#TO%O!uO%`#ZO%a#[O%b#YO%f#UO%m#SO%w$mO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO)QYO)T$kO)W$kO)Y!ZO)ZXO)icO)jdO~O$|,zO(s;RO)X,xO~P$7UO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO)T#mO)U#oO)V#nO)W#pO)X,|O)Y#|O~P#3zO)X,|O~O)X,}O~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X-OO)Y#|O~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X-PO)Y#|O~P#3zOp&fO)QYO)k-RO~O)X-SO~Ol;bO(s;TO~O]-ZO!{!dO&s#WO&t$wO(s-VO)T-WO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO(w-^O)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!TxO$a!iO$f!jO$h!kO$i!lO$l-cO$n!nO$p!oO$r!pO$t!qO$v!rO$x!sO%O!uO(s:rOd$Ya!o$Ya!{$Ya#i$Ya#p$Ya#t$Ya#v$Ya$S$Ya$U$Ya$Z$Ya$[$Ya$|$Ya%V$Ya%d$Ya%h$Ya%p$Ya%}$Ya(l$Ya)V$Ya!U$Ya$d$Ya~P$0kO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X-dO)Y#|O~P#3zO!U-eO~P!QOl-hO!T'eO)k,]O~O)k-jO~O]&^a!X&^a!Y&^a![&^a!^&^a!_&^a!a&^a!b&^a!c&^a!e&^a!f&^a!h&^a(v&^a(x&^a(y&^a)U&^a)V&^a)W&^a)X&^a)Y&^a!g&^a)k&^a!O&^a!W&^a!T&^a#v&^a(w&^a!U&^aQ&^a!d&^a~O)T-nO!V&^a~P$DiO!O-nO~O!W-nO~O!V-oO)T&^a~P$DiO])OXd)OXr)OXs)OXt)OXu)OXv)OXw)OXx)OXy)OX})OX!V)OX!r)OX!s)OX!t)OX!u)OX!v)OX!x)OX!{)OX%w)OX&s)OX&t)OX(s)OX)T)OX)V)OX)W)OX~Ol;qO~P$GXO]&cO!V&bO)X-pO~Ol;gO!o-sO#V+zO#i-xO#t!fO$|,zO%d!zO%l-wO%p!|O%w!}O(s;XO)QYO~P!8jO!n-|O(s,gO~O)QYO)X.OO~OPmO]$eOa%QOl;OO!T.TO!V$fO!X!XO!Y!WO!i!YO#V.[O#a.ZO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO(y.SO)T$kO)W$kO)X.QO)Y!ZO)ZXO)icO)jdO~O!U.YO~P$JiO])_Xd)_Xr)_Xs)_Xt)_Xu)_Xv)_Xw)_Xx)_Xy)_X})_X!T)_X!V)_X!l)_X!r)_X!s)_X!t)_X!u)_X!v)_X!x)_X!{)_X%w)_X&s)_X&t)_X(s)_X(w)_X)T)_X)V)_X)W)_X)X)_X!O)_X!h)_X)Y)_X!X)_X!Y)_X![)_X!^)_X!_)_X!a)_X!b)_X!c)_X!e)_X!f)_X(v)_X(x)_X(y)_X)U)_X!g)_X)k)_X!W)_XQ)_X!d)_X#T)_X#V)_X#p)_X#v)_Xa)_X{)_X!o)_X#a)_X#b)_X#i)_X#t)_X$|)_X%d)_X%f)_X%l)_X%m)_X%p)_X&n)_X)Q)_X!U)_X~Ol*]O~P$LsOl$oO!T(RO!l.aO(s$nO(w(QO)QYO~Op&fOl)_X~P$LsOl$oO!n.fO!o.fO(s$nO)QYO~Ol;hO!U.qO!n.sO!o.rO#i-xO$|!tO%O!uO%h!{O%l-wO%p!|O%w!}O(s;ZO)QYO~P!8jO!T(RO!l.aO(w(QO])PXd)PXl)PXr)PXs)PXt)PXu)PXv)PXw)PXx)PXy)PX})PX!V)PX!r)PX!s)PX!t)PX!u)PX!v)PX!x)PX!{)PX%w)PX&s)PX&t)PX(s)PX)T)PX)V)PX)W)PX~O)X)PX!O)PX!X)PX!Y)PX![)PX!^)PX!_)PX!a)PX!b)PX!c)PX!e)PX!f)PX!h)PX(v)PX(x)PX(y)PX)U)PX)Y)PX!g)PX)k)PX!W)PXQ)PX!d)PX!U)PX#v)PX~P%%lO!T(RO~O!T(RO(w(QO~O(s%nO!U*RP~O!T([O(w.xO]&lad&lal&lar&las&lat&lau&lav&law&lax&lay&la}&la!V&la!r&la!s&la!t&la!u&la!v&la!x&la!{&la%w&la&s&la&t&la(s&la)T&la)V&la)W&la)X&la!O&la!X&la!Y&la![&la!^&la!_&la!a&la!b&la!c&la!e&la!f&la!h&la(v&la(x&la(y&la)U&la)Y&la!g&la)k&la!W&laQ&la!d&la!U&la#v&la~Ol$oO!T([O(s$nO~O&s#WO&t$wO]&qad&qal&qar&qas&qat&qau&qav&qaw&qax&qay&qa}&qa!V&qa!r&qa!s&qa!t&qa!u&qa!v&qa!x&qa!{&qa%w&qa(s&qa)T&qa)V&qa)W&qa)X&qa!O&qa!T&qa!X&qa!Y&qa![&qa!^&qa!_&qa!a&qa!b&qa!c&qa!e&qa!f&qa!h&qa(v&qa(x&qa(y&qa)U&qa)Y&qa!g&qa)k&qa!W&qaQ&qa!d&qa(w&qa!U&qa#v&qa~O&t.}O~P!(zO!Y#qO![#rO!f#zO)T#mO!^'Va!_'Va!a'Va!b'Va!c'Va!e'Va!h'Va(v'Va)U'Va)V'Va)W'Va)X'Va)Y'Va!g'Va)k'Va!O'Va!W'Va(w'Va!U'VaQ'Va!d'Va~P#3zO!V'eX!X'eX!Y'eX!['eX!^'eX!_'eX!a'eX!b'eX!c'eX!e'eX!f'eX!h'eX(v'eX(x'eX(y'eX)T'eX)U'eX)V'eX)W'eX)Y'eX!O'eX~O]/PO)X'eX!g'eX)k'eX!W'eX(w'eX!U'eXQ'eX!d'eX~P%3PO!Y#qO![#rO!f#zO)T#mO!^'Xa!_'Xa!a'Xa!b'Xa!c'Xa!e'Xa!h'Xa(v'Xa)U'Xa)V'Xa)W'Xa)X'Xa)Y'Xa!g'Xa)k'Xa!O'Xa!W'Xa(w'Xa!U'XaQ'Xa!d'Xa~P#3zO]#}O!T$WO!V/QO&s#WO&t$wO~O!X'[a!Y'[a!['[a!^'[a!_'[a!a'[a!b'[a!c'[a!e'[a!f'[a!h'[a(v'[a(x'[a(y'[a)T'[a)U'[a)V'[a)W'[a)X'[a)Y'[a!g'[a)k'[a!O'[a!W'[a(w'[a!U'[aQ'[a!d'[a~P%6vO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!h'_a)X'_a!g'_a)k'_a!O'_a!W'_a(w'_a!U'_aQ'_a!d'_a~P#3zOPmO]$eOa%QOl;OO!V$fO!X!XO!Y!WO!i!YO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)T$kO)W%]O)Y!ZO)ZXO)icO)jdO)k%[O~O!W/TO~P%:vOS(rOT(oO]#}O*X(qO~O]/WO'g/XO*X/UO~OS/]OT(oO*X/[O~O]#}O~Q'oa!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO(w/_O)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O)X#Zi!O#Zi~P#3zO]cXlgXpcXpiX!VcX!XcX!YcX![cX!^cX!_cX!acX!bcX!ccX!ecX!fcX!gcX!hcX(vcX(xcX(ycX)TcX)UcX)VcX)WcX)XcX)YcX)kcX!OcX!WcX(wcX!TcX#vcX!UcXQcX!dcX~Od/aO%Z*UO(z/`O~Ol/bO~Ol/cO~Op&fO]bi!Vbi!Xbi!Ybi![bi!^bi!_bi!abi!bbi!cbi!ebi!fbi!gbi!hbi(vbi(xbi(ybi)Tbi)Ubi)Vbi)Wbi)Xbi)Ybi)kbi!Obi!Wbi(wbi!UbiQbi!dbi~O!W/eO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO![#rO)T#mO!Y&{i!^&{i!_&{i!a&{i!b&{i!c&{i!e&{i!f&{i!h&{i(v&{i)U&{i)V&{i)W&{i)X&{i)Y&{i!g&{i)k&{i!O&{i!W&{i(w&{i!U&{iQ&{i!d&{i~P#3zO!Y&{i![&{i!^&{i!_&{i!a&{i!b&{i!c&{i!e&{i!f&{i!h&{i(v&{i)T&{i)U&{i)V&{i)W&{i)X&{i)Y&{i!g&{i)k&{i!O&{i!W&{i(w&{i!U&{iQ&{i!d&{i~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO)T#mO)W#pO!h&{i(v&{i)U&{i)V&{i)X&{i)Y&{i!g&{i)k&{i!O&{i!W&{i(w&{i!U&{iQ&{i!d&{i~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO)T#mO)V#nO)W#pO!h&{i(v&{i)U&{i)X&{i)Y&{i!g&{i)k&{i!O&{i!W&{i(w&{i!U&{iQ&{i!d&{i~P#3zO!Y#qO![#rO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO)T#mO)W#pO!^&{i!h&{i(v&{i)U&{i)V&{i)X&{i)Y&{i!g&{i)k&{i!O&{i!W&{i(w&{i!U&{iQ&{i!d&{i~P#3zO!Y#qO![#rO!a#xO!b#yO!c#yO!e#yO!f#zO)T#mO)W#pO!^&{i!_&{i!h&{i(v&{i)U&{i)V&{i)X&{i)Y&{i!g&{i)k&{i!O&{i!W&{i(w&{i!U&{iQ&{i!d&{i~P#3zO!Y#qO![#rO!a#xO!b#yO!c#yO!e#yO!f#zO)T#mO!^&{i!_&{i!h&{i(v&{i)U&{i)V&{i)W&{i)X&{i)Y&{i!g&{i)k&{i!O&{i!W&{i(w&{i!U&{iQ&{i!d&{i~P#3zO!Y#qO![#rO!b#yO!c#yO!e#yO!f#zO)T#mO!^&{i!_&{i!a&{i!h&{i(v&{i)U&{i)V&{i)W&{i)X&{i)Y&{i!g&{i)k&{i!O&{i!W&{i(w&{i!U&{iQ&{i!d&{i~P#3zO!Y#qO![#rO!f#zO)T#mO!^&{i!_&{i!a&{i!b&{i!c&{i!e&{i!h&{i(v&{i)U&{i)V&{i)W&{i)X&{i)Y&{i!g&{i)k&{i!O&{i!W&{i(w&{i!U&{iQ&{i!d&{i~P#3zO!Y#qO![#rO)T#mO!^&{i!_&{i!a&{i!b&{i!c&{i!e&{i!f&{i!h&{i(v&{i)U&{i)V&{i)W&{i)X&{i)Y&{i!g&{i)k&{i!O&{i!W&{i(w&{i!U&{iQ&{i!d&{i~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO)T#mO)U#oO)V#nO)W#pO!h&{i(v&{i)X&{i)Y&{i!g&{i)k&{i!O&{i!W&{i(w&{i!U&{iQ&{i!d&{i~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h/fO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!O(tX~P#3zO!h/fO!O(tX~O!O/hO~O]%Yap%Ya!X%Ya!Y%Ya![%Ya!^%Ya!_%Ya!a%Ya!b%Ya!c%Ya!e%Ya!f%Ya!h%Ya(v%Ya(x%Ya(y%Ya)U%Ya)V%Ya)W%Ya)X%Ya)Y%Ya!g%Ya)k%Ya!O%Ya!W%Ya!T%Ya#v%Ya(w%Ya!U%YaQ%Ya!d%Ya~O)T/iO!V%Ya~P&,hO!O/iO~O!W/iO~O!V/jO)T%Ya~P&,hO!X'[i!Y'[i!['[i!^'[i!_'[i!a'[i!b'[i!c'[i!e'[i!f'[i!h'[i(v'[i(x'[i(y'[i)T'[i)U'[i)V'[i)W'[i)X'[i)Y'[i!g'[i)k'[i!O'[i!W'[i(w'[i!U'[iQ'[i!d'[i~P%6vO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!h'_i)X'_i!g'_i)k'_i!O'_i!W'_i(w'_i!U'_iQ'_i!d'_i~P#3zO!W/oO~P%:vO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h/qO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!U)sX~P#3zO(s/tO~O!V/vO(x)tO)k/xO~O!h/qO!U)sX~O!U/yO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO)T#mO)U#oO)V#nO)W#pO)Y#|O!h_i(v_i)X_i!g_i)k_i!O_i!W_i(w_i!U_iQ_i!d_i~P#3zO!R/zO~Ol)|O]!Qa!h!Qa)Y!Qa)^!Qa~OP0SO]0ROl0SO!R0SO!T0PO!V0QO!X0SO!Y0SO![0SO!^0SO!_0SO!a0SO!b0SO!c0SO!e0SO!f0SO!g0SO!h0SO!i0SO(pQO(w0SO(x0SO(y0SO)T/|O)U/}O)V/}O)W0OO)X0SO)Y0SO)ZXO~O!O0VO~P&7QO!R$[O~O!h*PO)Y)Ra)^)Ra~O)^0ZO~O])eO!V)fO!X)cO!g)cO%[)cO%])cO%^)cO%_)cO%`)gO%a)gO%b)cO(y)dO)k)cO)y)hO~Od)pO%Z*UO(z$OO~O)X0]O~O]nXdnXlmXpnXrnXsnXtnXunXvnXwnXxnXynX}nX!VnX!rnX!snX!tnX!unX!vnX!xnX!{nX%wnX&snX&tnX(snX)TnX)VnX)WnX!TnX!hnX)YnX!OnXQnX!dnX~O!lnX(wnX)XnX!XnX!YnX![nX!^nX!_nX!anX!bnX!cnX!enX!fnX(vnX(xnX(ynX)UnX!gnX)knX!WnX!UnX#vnX#TnX#VnX#pnXanX{nX!onX#anX#bnX#inX#tnX$|nX%dnX%fnX%lnX%mnX%pnX&nnX)QnX~P&:|Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O}!_O!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO~O])bid)bil)bi!V)bi!{)bi%w)bi(s)bi)T)bi)V)bi)W)biQ)bi!d)bi!h)bi)Y)bi)k)bi!O)bi!T)bi&s)bi(w)bi)X)bi~P&?zO]&cO!V&bO!O#Qi!T#Qi!h#Qi#v#Qi)X#Qi)k#QiQ#Qi!d#Qi(w#Qi~O!OqaQqa!dqa!hqa)Yqa)Xqa~P#9{O!OqaQqa!dqa!hqa)Yqa)Xqa~P#IkO]&cO!V+lO!OqaQqa!dqa!hqa)Yqa)Xqa~O!h*jO!W)la~O!h*nO!W*Pa~OPmO]eOa!]Od!POlTOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!X!XO!Y!WO!i!YO!opO!r!`O!s!aO!t!aO!u!bO!v!aO!x!cO!{!dO#V#QO#a#VO#b#TO#i#OO#p!xO#t!fO#v!eO$S!gO$U!hO$Z!vO$[!wO$a!iO$f!jO$h!kO$i!lO$l!mO$n!nO$p!oO$r!pO$t!qO$v!rO$x!sO$|!tO%O!uO%V!yO%`#ZO%a#[O%b#YO%d!zO%f#UO%h!{O%m#SO%p!|O%w!}O%}#PO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(sRO)QYO)TaO)V|O)W{O)XiO)Y!ZO)ZXO)icO)jdO~O!T*rO!U&TO!V0kO(x)tO~P&D|O!h*uO)X)ra~OPmO]$eOa!]Ol;QO{#RO!T$WO!V$fO!X!XO!Y!WO!i!YO#V#QO#a#VO#b#TO%`#ZO%a#[O%b#YO%f#UO%m#SO%w$mO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s;YO)QYO)T$kO)W$kO)Y0qO)ZXO)icO)jdO!O(tP!O)eP~P&?zO!h*nO!W*PX~O]#}O!T$WO~O!h0vO!T){X#v){X)k){X~O)X0xO~O)X0yO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X0{O)Y#|O~P#3zO)X0yO~P!?WO]1VOd!POl%bO!V1TO!{!dO%w$mO(s$xO)T0}O)Y1QO~O)V1RO)W1RO)k1OOQ#PX!d#PX!h#PX!O#PX~P' kO!h1WOQ)mX!d)mX~OQ1YO!d1YO~O)Y1]O)k1[OQ#`X!d#`X!h#`X~P!<[O)Y1]O)k1[OQ#`X!d#`X!h#`X~P!;bOp&UO~O!O#ka!T#ka#v#ka)X#ka)k#kaQ#ka!d#ka!h#ka)Y#ka!x#ka(w#ka~P#IkO]&cO!V+lO!O#ka!T#ka#v#ka)X#ka)k#kaQ#ka!d#ka!h#ka)Y#ka!x#ka(w#ka~O!W1bO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!W1bO)T1dO~P$%pO!W1bO~P!(zO]#ja!T#ja!V#ja!O#ja#v#ja)X#ja)k#jaQ#ja!d#ja!h#ja)Y#ja!x#ja(w#ja~P$ xO]&cO!O1hO!V+lO~O!h1iO!O)eX~O!O1kO~O]&cO!V+lO!O#na!T#na#v#na)X#na)k#naQ#na!d#na!h#na)Y#na!x#na(w#na~O]1oOr#SXs#SXt#SXu#SXv#SXw#SXx#SXy#SX!T#SX!V#SX#T#SX#p#SX(y#SX)V#SX)W#SX!l#SX!x#SX#V#SX#v#SX(w#SX)k#SX!O#SX!h#SX)X#SXQ#SX!d#SX)Y#SX~O]1pO~O]1sOl$oO!V$fO#V#QO(s$nO)icO)jdO~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!l+{O#T+wO#V+zO#p+xO(y+uO)V+{O)W+{O~O])gX!T)gX!V)gX!x)gX#v)gX(w)gX)k)gX!O)gX!h)gX)X)gXQ)gX!d)gX~P',UO!x!cO]#Ri!T#Ri!V#Ri#v#Ri(w#Ri)k#Ri!O#Ri!h#Ri)X#RiQ#Ri!d#Ri~O!W1{O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!W1{O)T1}O~P$%pO!W1{O~P!(zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|OQ*SX!d*SX!h*SX~P#3zO)Y2OOQ(|X!d(|X!h(|X~O!h2POQ({X!d({X~OQ2RO!d2RO~O!O2SO~O#t$lO)QYO~P8zOl-hO!T'eO)k2WO~O!O2XO~O#x,bOP#ui]#uia#uid#uil#uir#uis#uit#uiu#uiv#uiw#uix#uiy#ui{#ui}#ui!T#ui!V#ui!X#ui!Y#ui!i#ui!o#ui!r#ui!s#ui!t#ui!u#ui!v#ui!x#ui!{#ui#V#ui#a#ui#b#ui#i#ui#p#ui#t#ui#v#ui$S#ui$U#ui$Z#ui$[#ui$a#ui$f#ui$h#ui$i#ui$l#ui$n#ui$p#ui$r#ui$t#ui$v#ui$x#ui$|#ui%O#ui%V#ui%`#ui%a#ui%b#ui%d#ui%f#ui%h#ui%m#ui%p#ui%w#ui%}#ui&n#ui&s#ui&t#ui'R#ui'S#ui'W#ui'Z#ui'b#ui'c#ui(l#ui(p#ui(s#ui)Q#ui)T#ui)V#ui)W#ui)X#ui)Y#ui)Z#ui)i#ui)j#ui!U#ui$d#ui!n#ui%l#ui~O]&cO~O]&cO!TxO!V&bO#v!eO~O(w2^O(x,dO)Q$Va)X$Va~O)QYO)X2`O~O!O2aO~P,]O!O2aO)X#jO~O!O2aO~O$d2fOP$`i]$`ia$`id$`il$`ir$`is$`it$`iu$`iv$`iw$`ix$`iy$`i{$`i}$`i!T$`i!V$`i!X$`i!Y$`i!i$`i!o$`i!r$`i!s$`i!t$`i!u$`i!v$`i!x$`i!{$`i#V$`i#a$`i#b$`i#i$`i#p$`i#t$`i#v$`i$S$`i$U$`i$Z$`i$[$`i$a$`i$f$`i$h$`i$i$`i$l$`i$n$`i$p$`i$r$`i$t$`i$v$`i$x$`i$|$`i%O$`i%V$`i%`$`i%a$`i%b$`i%d$`i%f$`i%h$`i%m$`i%p$`i%w$`i%}$`i&n$`i&s$`i&t$`i'R$`i'S$`i'W$`i'Z$`i'b$`i'c$`i(l$`i(p$`i(s$`i)Q$`i)T$`i)V$`i)W$`i)X$`i)Y$`i)Z$`i)i$`i)j$`i!U$`i~O]1sO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO)T#mO)U#oO)V#nO)W#pO)X2iO)Y#|O~P#3zOPmO]$eOa!]Ol;PO{#RO!V$fO!X!XO!Y!WO!i!YO#V#QO#a#VO#b#TO%`#ZO%a#[O%b#YO%f#UO%m#SO%w$mO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s;RO)T$kO)W$kO)X2lO)Y!ZO)ZXO)icO)jdO~P&?zO)X2iO~O(s-VO~O)QYO)k2oO~O)X2qO~O]-ZOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!{!dO!|%RO(s-VO)T-WO~O)T2vO~O]&cO!V2xO!h2yO)X)vX~O]-ZO!{!dO(s-VO)T-WO~O)X2|O~O!TxO$a!iO$f!jO$h!kO$i!lO$l-cO$n!nO$p!oO$r!pO$t!qO$v!rO$x!sO%O!uO(s:rOd$Yi!o$Yi!{$Yi#i$Yi#p$Yi#t$Yi#v$Yi$S$Yi$U$Yi$Z$Yi$[$Yi$|$Yi%V$Yi%d$Yi%h$Yi%p$Yi%}$Yi(l$Yi)V$Yi!U$Yi$d$Yi~P$0kOl;PO(s:rO~P0zO]3QO~O!U3RO~P!QO)X2VO~O!u3TO(s%nO~O!O3WO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h3XO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!O3YO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO]&cO!V+lO!T%vi#v%vi)X%vi)k%vi~O!W3ZO~Ol:}O)X)OX~P$GXOa!TOl$oO{3aO#a#VO#b3`O#t!fO%f#UO%m3bO&n!RO&s#WO&t!TO(s$nO)QYO~P&?zOl;gO!o-sO#i-xO#t!fO$|,zO%d!zO%l-wO%p!|O%w!}O(s;XO)QYO~P!8jO]&cO!V&bO)X3dO~O)X3eO~O)QYO)X3eO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO)T#mO)U#oO)V#nO)W#pO)X3fO)Y#|O~P#3zO)X3fO~O)X3iO~O!U3kO~P$JiOl$oO(s$nO~O]3mO!T'zO~P'+pO!T(RO!l3pO(w(QO])Pad)Pal)Par)Pas)Pat)Pau)Pav)Paw)Pax)Pay)Pa})Pa!V)Pa!r)Pa!s)Pa!t)Pa!u)Pa!v)Pa!x)Pa!{)Pa%w)Pa&s)Pa&t)Pa(s)Pa)T)Pa)V)Pa)W)Pa)X)Pa!O)Pa!X)Pa!Y)Pa![)Pa!^)Pa!_)Pa!a)Pa!b)Pa!c)Pa!e)Pa!f)Pa!h)Pa(v)Pa(x)Pa(y)Pa)U)Pa)Y)Pa!g)Pa)k)Pa!W)PaQ)Pa!d)Pa!U)Pa#v)Pa~Ol$oO!n.fO!o.fO(s$nO~O!h3tO)Y3vO!T)`X~O!o3xO)QYO~P8zO)X3yO~PGVO]4OOl(|O!T$WO!{!dO%w$mO&s#WO(s({O(w4SO)T3{O)V4PO)W4PO~O)X4TO)k4VO~P(&sOl;hO!U4XO!n.sO!o.rO#i-xO$|!tO%O!uO%h!{O%l-wO%p!|O%w!}O(s;ZO)QYO~P!8jOl;hO%w!}O(s;ZO~P!8jO(w4YO~Ol$oO!T(RO(s$nO(w(QO)QYO~O!l3pO~P()RO)k4[O!U&pX!h&pX~O!h4]O!U*RX~O!U4_O~Oa4aOl$oO&n!RO(s$nO~O!T([O]&lid&lil&lir&lis&lit&liu&liv&liw&lix&liy&li}&li!V&li!r&li!s&li!t&li!u&li!v&li!x&li!{&li%w&li&s&li&t&li(s&li)T&li)V&li)W&li)X&li!O&li!X&li!Y&li![&li!^&li!_&li!a&li!b&li!c&li!e&li!f&li!h&li(v&li(x&li(y&li)U&li)Y&li!g&li)k&li!W&liQ&li!d&li!U&li#v&li~O(w&li~P(*cO(w.xO~P(*cO!O4dO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!O4dO~O!O4eO~O]#}O!T$WO!V'[i!X'[i!Y'[i!['[i!^'[i!_'[i!a'[i!b'[i!c'[i!e'[i!f'[i!h'[i(v'[i(x'[i(y'[i)T'[i)U'[i)V'[i)W'[i)X'[i)Y'[i!g'[i)k'[i!O'[i!W'[i(w'[i!U'[iQ'[i!d'[i~OPmOa%QOl;OO!X!XO!Y!WO!i!YO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)Y!ZO)ZXO)icO)jdO]#]ap#]a!T#]a!V#]a)T#]a)V#]a)W#]a~O(s%nO)Y4jO!O*ZP~O*X4iO~O'g4lO*X4iO~O*X4mO~OlmXpnXp&xX~Od4oO%Z*UO(z/`O~Od4oO%Z*UO(z4pO~O!h/fO!O(ta~O!W4tO~O]&cO!V+lO!T%vq#v%vq)X%vq)k%vq~O]#}O!T$WO!X'[q!Y'[q!['[q!^'[q!_'[q!a'[q!b'[q!c'[q!e'[q!f'[q!h'[q(v'[q(x'[q(y'[q)T'[q)U'[q)V'[q)W'[q)X'[q)Y'[q!g'[q)k'[q!O'[q!W'[q(w'[q!U'[qQ'[q!d'[q~O!V'[q~P(5pO!V/QO&s#WO&t$wO~P(5pO!T$WO!V)sO(x)tO!U(VX!h(VX~P!JwO!h/qO!U)sa~O!W4|O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h*jO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!U5QO~P&7QO!W5QO~P&7QO!O5QO~P&7QO!O5VO~P&7QO]5WO!h'va)Y'va)^'va~O!h*PO)Y)Ri)^)Ri~O]&cO!V&bO!O#Qq!T#Qq!h#Qq#v#Qq)X#Qq)k#QqQ#Qq!d#Qq(w#Qq~O!OqiQqi!dqi!hqi)Yqi)Xqi~P#IkO]&cO!V+lO!OqiQqi!dqi!hqi)Yqi)Xqi~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!h'Uq)X'Uq!g'Uq)k'Uq!O'Uq!W'Uq(w'Uq!U'UqQ'Uq!d'Uq~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!W'}a!h'}a~P#3zO!W5]O~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h5^O(v#gO)T#mO)U#oO)V#nO)W#pO)X#jO)Y#|O!U)sX~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!h#{i)X#{i~P#3zO]*wO!T$WO!V&bO)k*sO!h(Wa)X(Wa~O!h1iO]'eX!O)eX~P%3PO)Y5`O!T%ra!h%ra#v%ra)k%ra~O!h0vO!T){a#v){a)k){a~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X5cO)Y#|O~P#3zO]1VOd!POl;`O!V1TO!{!dO%w$mO(s$xO)T;|O)V5eO)W5eO~OQ#Pa!d#Pa!h#Pa!O#Pa~P(DxO]1VOd!POr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!V1TO!{!dO!|%RO%w$mO(s$xOQ#kX!d#kX!h#kX!O#kX~Ol%bO)T0}O)V;}O)W;}O~P(EzO]&cOQ#Pa!d#Pa!h#Pa!O#Pa~O!V&bO)k5iO~P(GiO(s%nOQ#dX!d#dX!h#dX!O#dX~O)V;}O)W;}OQ#nX!d#nX!h#nX!O#nX~P' kO!V+lO~P(GiO]1VOa!TOd!POl;aO{#RO!V1TO!{!dO#a#VO#b#TO%f#UO%m#SO%w$mO&n!RO&s#WO&t!TO(s;UO)QYO)T;|O)V5eO)W5eO)Y+oO!O)eP~P&?zO!h1WOQ)ma!d)ma~Op&fO)k5nOQ#`al)OX!d#`a!h#`a)Y)OX~P$GXO(s-VOQ#ga!d#ga!h#ga~Op&fO)k5nOQ#`a])_Xd)_Xl)_Xr)_Xs)_Xt)_Xu)_Xv)_Xw)_Xx)_Xy)_X})_X!T)_X!V)_X!d#`a!h#`a!l)_X!r)_X!s)_X!t)_X!u)_X!v)_X!x)_X!{)_X%w)_X&s)_X&t)_X(s)_X(w)_X)T)_X)V)_X)W)_X)Y)_X~O#a5qO#b5qO~O]&cO!V+lO!O#ki!T#ki#v#ki)X#ki)k#kiQ#ki!d#ki!h#ki)Y#ki!x#ki(w#ki~O!W5sO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!W5sO~P!(zO!W5sO)T5uO~P$%pO]#ji!T#ji!V#ji!O#ji#v#ji)X#ji)k#jiQ#ji!d#ji!h#ji)Y#ji!x#ji(w#ji~P$ xO)QYO)Y5wO~P8zO!h1iO!O)ea~O&s#WO&t$wO!T#qa!x#qa#v#qa(w#qa)k#qa!O#qa!h#qa)X#qaQ#qa!d#qa)Y#qa~P#NeO!O5|O~P!(zO!O)pP~P!4xO)U6SO)V6QO]#Ua!T#Ua!V#Ua)T#Ua)W#Uar#Uas#Uat#Uau#Uav#Uaw#Uax#Uay#Ua!l#Ua!x#Ua#T#Ua#V#Ua#p#Ua#v#Ua(w#Ua(y#Ua)k#Uaa#Uad#Ual#Ua{#Ua}#Ua!o#Ua!r#Ua!s#Ua!t#Ua!u#Ua!v#Ua!{#Ua#a#Ua#b#Ua#i#Ua#t#Ua$|#Ua%d#Ua%f#Ua%l#Ua%m#Ua%p#Ua%w#Ua&n#Ua&s#Ua&t#Ua(s#Ua)Q#Ua)X#Ua!O#Ua!h#UaQ#Ua!d#Ua~O!x!cO]#Rq!T#Rq!V#Rq#v#Rq(w#Rq)k#Rq!O#Rq!h#Rq)X#RqQ#Rq!d#Rq~O!W6XO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!W6XO~P!(zO!h2POQ({a!d({a~O)X6^O~Ol-hO!T'eO)k6_O~O]*wO!T$WO!V&bO!h*uO)X)rX~O)k6cO~P)+qO!O6eO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!O6eO~O$d6gOP$`q]$`qa$`qd$`ql$`qr$`qs$`qt$`qu$`qv$`qw$`qx$`qy$`q{$`q}$`q!T$`q!V$`q!X$`q!Y$`q!i$`q!o$`q!r$`q!s$`q!t$`q!u$`q!v$`q!x$`q!{$`q#V$`q#a$`q#b$`q#i$`q#p$`q#t$`q#v$`q$S$`q$U$`q$Z$`q$[$`q$a$`q$f$`q$h$`q$i$`q$l$`q$n$`q$p$`q$r$`q$t$`q$v$`q$x$`q$|$`q%O$`q%V$`q%`$`q%a$`q%b$`q%d$`q%f$`q%h$`q%m$`q%p$`q%w$`q%}$`q&n$`q&s$`q&t$`q'R$`q'S$`q'W$`q'Z$`q'b$`q'c$`q(l$`q(p$`q(s$`q)Q$`q)T$`q)V$`q)W$`q)X$`q)Y$`q)Z$`q)i$`q)j$`q!U$`q~O)X6hO~OPmO]$eOa!]Ol;PO{#RO!V$fO!X!XO!Y!WO!i!YO#V#QO#a#VO#b#TO%`#ZO%a#[O%b#YO%f#UO%m#SO%w$mO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s;RO)T$kO)W$kO)X6jO)Y!ZO)ZXO)icO)jdO~P&?zO(w6lO)k*sO~P)+qO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X6jO)Y#|O~P#3zO!O6nO~P!(zO)X6rO~O)X6sO~O]-ZOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!{!dO(s-VO)T-WO~O]&cO!V2xO!h%Pa)X%Pa!O%Pa~O!W6yO)T6zO~P$%pO!h2yO)X)va~O]&cO!O6}O!V2xO~O!TxO$a!iO$f!jO$h!kO$i!lO$l-cO$n!nO$p!oO$r!pO$t!qO$v!rO$x!sO%O!uO(s:rOd$Yq!o$Yq!{$Yq#i$Yq#p$Yq#t$Yq#v$Yq$S$Yq$U$Yq$Z$Yq$[$Yq$|$Yq%V$Yq%d$Yq%h$Yq%p$Yq%}$Yq(l$Yq)V$Yq!U$Yq$d$Yq~P$0kOPmO]$eOa!]Ol;PO{#RO!V$fO!X!XO!Y!WO!i!YO#V#QO#a#VO#b#TO%`#ZO%a#[O%b#YO%f#UO%m#SO%w$mO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s;RO)QYO)T$kO)W$kO)X7PO)Y!ZO)ZXO)icO)jdO~P&?zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X7SO)Y#|O~P#3zO)X7TO~OP7UO(pQO~Ol*]O)X)_X~P$GXOp&fOl)OX)X)_X~P$GXO)X7WO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O)X&Ta~P#3zO!U7YO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO)X7ZO~OPmO]$eOa!]Ol;QO{#RO!V$fO!X!XO!Y!WO!i!YO#V#QO#a#VO#b#TO%`#ZO%a#[O%b#YO%f#UO%m#SO%w$mO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s;YO)QYO)T$kO)W$kO)Y0qO)ZXO)icO)jdO!O)eP~P&?zO!h3tO)Y7_O!T)`a~O!h3tO!T)`a~O)X7dO)k7fO~P(&sO)X7hO~PGVO]4OOl(|Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!{!dO!|%RO%w$mO&s#WO(s({O)T3{O)V4PO)W4PO~O)T7lO~O]&cO!T*rO!V7nO!h7oO#v!eO(w4SO~O)X7dO)k7qO~P)GVO]4OOl(|O!{!dO%w$mO&s#WO(s({O)T3{O)V4PO)W4PO~Op&fO])dX!T)dX!V)dX!h)dX#v)dX(w)dX)X)dX)k)dX!O)dX~O)X7dO~O!T(RO!l7wO(w(QO])Pid)Pil)Pir)Pis)Pit)Piu)Piv)Piw)Pix)Piy)Pi})Pi!V)Pi!r)Pi!s)Pi!t)Pi!u)Pi!v)Pi!x)Pi!{)Pi%w)Pi&s)Pi&t)Pi(s)Pi)T)Pi)V)Pi)W)Pi)X)Pi!O)Pi!X)Pi!Y)Pi![)Pi!^)Pi!_)Pi!a)Pi!b)Pi!c)Pi!e)Pi!f)Pi!h)Pi(v)Pi(x)Pi(y)Pi)U)Pi)Y)Pi!g)Pi)k)Pi!W)PiQ)Pi!d)Pi!U)Pi#v)Pi~O(s%nO!U(gX!h(gX~O!h4]O!U*Ra~Op&fO]*Qad*Qal*Qar*Qas*Qat*Qau*Qav*Qaw*Qax*Qay*Qa}*Qa!T*Qa!V*Qa!r*Qa!s*Qa!t*Qa!u*Qa!v*Qa!x*Qa!{*Qa%w*Qa&s*Qa&t*Qa(s*Qa)T*Qa)V*Qa)W*Qa)X*Qa!O*Qa!X*Qa!Y*Qa![*Qa!^*Qa!_*Qa!a*Qa!b*Qa!c*Qa!e*Qa!f*Qa!h*Qa(v*Qa(x*Qa(y*Qa)U*Qa)Y*Qa!g*Qa)k*Qa!W*QaQ*Qa!d*Qa(w*Qa!U*Qa#v*Qa~O!T([O]&lqd&lql&lqr&lqs&lqt&lqu&lqv&lqw&lqx&lqy&lq}&lq!V&lq!r&lq!s&lq!t&lq!u&lq!v&lq!x&lq!{&lq%w&lq&s&lq&t&lq(s&lq)T&lq)V&lq)W&lq)X&lq!O&lq!X&lq!Y&lq![&lq!^&lq!_&lq!a&lq!b&lq!c&lq!e&lq!f&lq!h&lq(v&lq(x&lq(y&lq)U&lq)Y&lq!g&lq)k&lq!W&lqQ&lq!d&lq(w&lq!U&lq#v&lq~OPmOa%QOl;OO!T$WO!i!YO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)ZXO)icO)jdO~O]*Vi!V*Vi!X*Vi!Y*Vi![*Vi!^*Vi!_*Vi!a*Vi!b*Vi!c*Vi!e*Vi!f*Vi!h*Vi(v*Vi(x*Vi(y*Vi)T*Vi)U*Vi)V*Vi)W*Vi)X*Vi)Y*Vi!g*Vi)k*Vi!O*Vi!W*Vi(w*Vi!U*ViQ*Vi!d*Vi~P*&fO!O7|O~O!W7}O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!h'_q)X'_q!g'_q)k'_q!O'_q!W'_q(w'_q!U'_qQ'_q!d'_q~P#3zO!h8OO!O*ZX~O!O8QO~O*X8RO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!h^y)X^y!g^y)k^y!O^y!W^y(w^y!U^yQ^y!d^y~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!O(ia!h(ia~P#3zO]#}O!T$WO!V'[y!X'[y!Y'[y!['[y!^'[y!_'[y!a'[y!b'[y!c'[y!e'[y!f'[y!h'[y(v'[y(x'[y(y'[y)T'[y)U'[y)V'[y)W'[y)X'[y)Y'[y!g'[y)k'[y!O'[y!W'[y(w'[y!U'[yQ'[y!d'[y~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!h'_y)X'_y!g'_y)k'_y!O'_y!W'_y(w'_y!U'_yQ'_y!d'_y~P#3zO]&cO!V+lO!T%vy#v%vy)X%vy)k%vy~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!U(Va!h(Va~P#3zO!W4|O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!U#}i!h#}i~P#3zO!U8TO~P&7QO!W8TO~P&7QO!O8TO~P&7QO!O8VO~P&7QO]&cO!V&bO!O#Qy!T#Qy!h#Qy#v#Qy)X#Qy)k#QyQ#Qy!d#Qy(w#Qy~O]&cO!V+lO!OqqQqq!dqq!hqq)Yqq)Xqq~O]&cOQ#Pi!d#Pi!h#Pi!O#Pi~O!V+lO~P*9xOQ#nX!d#nX!h#nX!O#nX~P(DxO!V&bO~P*9xOQ(PX](PXd'rXl'rXr(PXs(PXt(PXu(PXv(PXw(PXx(PXy(PX!V(PX!d(PX!h(PX!{'rX%w'rX(s'rX)T(PX)V(PX)W(PX!O(PX~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|OQ#_i!d#_i!h#_i!O#_i~P#3zO&s#WO&t$wOQ#fi!d#fi!h#fi~O(s-VO)Y1]O)k1[OQ#`X!d#`X!h#`X~O!W8[O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!W8[O~P!(zO!T#qi!x#qi#v#qi(w#qi)k#qi!O#qi!h#qi)X#qiQ#qi!d#qi)Y#qi~O]&cO!V+lO~P*?tO]&YO!V&WO&s#WO&t$wO)T&VO)V&ZO)W&ZO~P*?tO!O8^O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!h8_O!O)pX~O!O8aO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|OQ*UX!d*UX!h*UX~P#3zO)Y8dOQ*TX!d*TX!h*TX~O)X8fO~O!O$ci!h#{a)X#{a~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X8iO)Y#|O~P#3zO!O8kO~P!(zO!O8kO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!O8kO~O]&cO!V&bO(w8qO~O)X8rO~O]&cO!V2xO!h%Pi)X%Pi!O%Pi~O!W8uO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!W8uO)T8wO~P$%pO!W8uO~P!(zO]&cO!V2xO!h(Za)X(Za~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO)T#mO)U#oO)V#nO)W#pO)X8xO)Y#|O~P#3zO)X2lO~P!(zO)X8xO~OP%oO!O8yO(pQO~O!O8yO~O)X8zO~P%%lO#T8}O(y.SO)X8{O~O!h3tO!T)`i~O)Y9RO!T'xa!h'xa~O)X9TO)k9VO~P)GVO)X9TO~O)X9TO)k9ZO~P(&sOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O~P)GuO]&cO!V7nO!T!ya!h!ya#v!ya(w!ya)X!ya)k!ya!O!ya~O!W9bO)T9cO~P$%pO!T$WO!h7oO(w4SO)X9TO)k9ZO~O!T$WO~P#EfO]&cO!O9fO!V7nO~O]&cO!V7nO!T&ba!h&ba#v&ba(w&ba)X&ba)k&ba!O&ba~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O)X&ca~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X9TO)Y#|O~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!U&pi!h&pi~P#3zO!V/QO]'^i!T'^i!X'^i!Y'^i!['^i!^'^i!_'^i!a'^i!b'^i!c'^i!e'^i!f'^i!h'^i(v'^i(x'^i(y'^i)T'^i)U'^i)V'^i)W'^i)X'^i)Y'^i!g'^i)k'^i!O'^i!W'^i(w'^i!U'^iQ'^i!d'^i~O(s%nO)Y9iO~O!h8OO!O*Za~O!O9kO~P&7QO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!U(Va)X#Zi~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|OQ#_q!d#_q!h#_q!O#_q~P#3zO&s#WO&t$wOQ#fq!d#fq!h#fq~O)k5nOQ#`a!d#`a!h#`a~O]&cO!V+lO!T#qq!x#qq#v#qq(w#qq)k#qq!O#qq!h#qq)X#qqQ#qq!d#qq)Y#qq~O!h8_O!O)pa~O)V6QO]&Wi!T&Wi!V&Wi)T&Wi)U&Wi)W&Wir&Wis&Wit&Wiu&Wiv&Wiw&Wix&Wiy&Wi!l&Wi!x&Wi#T&Wi#V&Wi#p&Wi#v&Wi(w&Wi(y&Wi)k&Wia&Wid&Wil&Wi{&Wi}&Wi!o&Wi!r&Wi!s&Wi!t&Wi!u&Wi!v&Wi!{&Wi#a&Wi#b&Wi#i&Wi#t&Wi$|&Wi%d&Wi%f&Wi%l&Wi%m&Wi%p&Wi%w&Wi&n&Wi&s&Wi&t&Wi(s&Wi)Q&Wi)X&Wi!O&Wi!h&WiQ&Wi!d&Wi~O)X9nO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!O$cq!h#{i)X#{i~P#3zO!O9pO~P!(zO!O9pO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!O9pO~O]&cO!V&bO(w9sO~O!O9tO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!O9tO~O]&cO!V2xO!h%Pq)X%Pq!O%Pq~O!W9xO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!W9xO~P!(zO)X6jO~P!(zO)X9yO~O)X9zO~O(y.SO)X9zO~O!h3tO!T)`q~O)Y9|O!T'xi!h'xi~O!T$WO!h7oO(w4SO)X9}O)k:PO~O)X9}O~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X9}O)Y#|O~P#3zO)X9}O)k:SO~P)GVO]&cO!V7nO!T!yi!h!yi#v!yi(w!yi)X!yi)k!yi!O!yi~O!W:WO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!W:WO)T:YO~P$%pO!W:WO~P!(zO]&cO!V7nO!T(ea!h(ea(w(ea)X(ea)k(ea~O!O:[O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!O:[O~O!O:aO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!O:aO~O]&cO!V2xO!h%Py)X%Py!O%Py~O)X:bO~O)X:cO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X:cO)Y#|O~P#3zO!T$WO!h7oO(w4SO)X:cO)k:fO~O]&cO!V7nO!T!yq!h!yq#v!yq(w!yq)X!yq)k!yq!O!yq~O!W:hO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!W:hO~P!(zO!O:jO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!O:jO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X:lO)Y#|O~P#3zO)X:lO~O]&cO!V7nO!T!yy!h!yy#v!yy(w!yy)X!yy)k!yy!O!yy~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X:pO)Y#|O~P#3zO)X:pO~O]ZXlgXpZXpiX!TiX!VZX!XZX!YZX![ZX!^ZX!_ZX!aZX!bZX!cZX!eZX!fZX!gZX!hZX(vZX(w$^X(xZX(yZX)TZX)UZX)VZX)WZX)XZX)YZX)kZX~O]%XXlmXpnXp%XX!TnX!V%XX!X%XX!Y%XX![%XX!^%XX!_%XX!a%XX!b%XX!c%XX!e%XX!f%XX!gmX!h%XX(v%XX(x%XX(y%XX)T%XX)U%XX)V%XX)W%XX)Y%XX)kmX!O%XXQ%XX!d%XX~O)X%XX!W%XX(w%XX!U%XX~P+HQO]nX]%XXdnXlmXpnXp%XXrnXsnXtnXunXvnXwnXxnXynX}nX!VnX!V%XX!rnX!snX!tnX!unX!vnX!xnX!{nX%wnX&snX&tnX(snX)TnX)VnX)WnX!OnX!O%XX!hnX)YnX~O)XnX)knX~P+JbO]%XXlmXpnXp%XX!V%XX!h%XXQ%XX!d%XX!O%XX~O!T%XX#v%XX)X%XX)k%XX(w%XX~P+L{OQnXQ%XX!TnX!X%XX!Y%XX![%XX!^%XX!_%XX!a%XX!b%XX!c%XX!dnX!d%XX!e%XX!f%XX!gmX!h%XX(v%XX(x%XX(y%XX)T%XX)U%XX)V%XX)W%XX)Y%XX)kmX~P+JbO]nX]%XXlmXpnXp%XXrnXsnXtnXunXvnXwnXxnXynX}nX!V%XX!rnX!snX!tnX!unX!vnX!xnX!{nX%wnX&snX&tnX(snX)TnX)VnX)WnX~O!TnX(wnX)XnX)knX~P, sOdnX!VnX)X%XX~P, sOlmXpnX)X%XX~Od)pO%Z)qO(z:sO~Od)pO%Z)qO(z:xO~Od)pO%Z)qO(z:tO~Od$RO%Z*UO']$TO'`$UO(z:sO~Od$RO%Z*UO']$TO'`$UO(z:uO~Od$RO%Z*UO']$TO'`$UO(z:wO~O]iXriXsiXtiXuiXviXwiXxiXyiX!OiX!ViX&siX&tiX)TiX)ViX)WiXdiX}iX!riX!siX!tiX!uiX!viX!xiX!{iX%wiX(siX~P#1jO]ZXlgXpZXpiX!VZX!hZX)XZX)kZX~O!TZX#vZX(wZX~P,(ZOlgXpiX)QiX)XZX)kiX~O]ZX]iXdiXlgXpZXpiXriXsiXtiXuiXviXwiXxiXyiX}iX!VZX!ViX!riX!siX!tiX!uiX!viX!xiX!{iX%wiX&siX&tiX(siX)TiX)ViX)WiX!OZX!OiX!hiX)YiX)kiX~O)XZX~P,)eO]ZX]iXlgXpZXpiXriXsiXtiXuiXviXwiXxiXyiX!TiX!VZX!ViX!XZX!YZX![ZX!^ZX!_ZX!aZX!bZX!cZX!eZX!fZX!gZX!hZX!hiX&siX&tiX(vZX(xZX(yZX)TZX)TiX)UZX)VZX)ViX)WZX)WiX)YZX)YiX)kZX~OQZXQiX!dZX!diX~P,,OO]iXdiXriXsiXtiXuiXviXwiXxiXyiX}iX!ViX!riX!siX!tiX!uiX!viX!xiX!{iX%wiX&siX&tiX(siX)TiX)ViX)WiX~P#1jO]ZX]iXdiXlgXpZXpiXriXsiXtiXuiXviXwiXxiXyiX}iX!VZX!ViX!riX!siX!tiX!uiX!viX!xiX!{iX%wiX&siX&tiX(siX)TiX)ViX)WiX~O)XiX~P,1QOdiX}iX!OZX!OiX!riX!siX!tiX!uiX!viX!xiX!{iX%wiX(siX)kiX~P,,OO]ZX]iXlgXpZXpiXriXsiXtiXuiXviXwiXxiXyiX}iX!TiX!VZX!riX!siX!tiX!uiX!viX!xiX!{iX%wiX&siX&tiX(siX(wiX)TiX)ViX)WiX)XiX)kiX~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O~PBUOd$RO%Z*UO(z:sO~Od$RO%Z*UO(z:tO~Od$RO%Z*UO(z:zO~Od$RO%Z*UO(z:yO~O]%hOd!POl%bOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!V%kO!{!dO!|%RO%w$mO(s$xO)T;eO)V;fO)W;fO~O]%hOd!POl%bO!V%kO!{!dO%w$mO(s$xO)T;eO)V;fO)W;fO~Od$RO%Z$SO(z:tO~Od$RO%Z$SO(z:xO~Ol:}O~Ol:|O~O]cXlgXpiX!TcX~Od)pO%Z*UO(z:sO~Od)pO%Z*UO(z:tO~Od)pO%Z*UO(z:uO~Od)pO%Z*UO(z:vO~Od)pO%Z*UO(z:wO~Od)pO%Z*UO(z:yO~Od)pO%Z*UO(z:zO~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O~P,9^O])OXr)OXs)OXt)OXu)OXv)OXw)OXx)OXy)OX})OX!r)OX!s)OX!t)OX!u)OX!v)OX!x)OX!{)OX%w)OX&s)OX&t)OX(s)OX)T)OX)V)OX)W)OX)k)OX~Ol:|O!T)OX(w)OX)X)OX~P,=]O]&xXlmXpnX!T&xX~Od4oO%Z*UO(z;xO~Ol;`O)T;|O)V5eO)W5eO~P(EzOd!POl%bO!{!dO%w$mO(s$xO~O]1VO!V1TO)T0}O)V;}O)W;}OQ#nX!d#nX!h#nX!O#nX~P,@XO)T;^O~Ol;lO~Ol;mO~Ol;nO~Ol;pO~Ol;qO~Ol;rO~Ol;pO!T$WOQ)OX!d)OX!h)OX)Y)OX!O)OX)k)OX~P$GXOl;nO!T$WO~P$GXOl;lO!g$YO)k$YO~Ol;nO!g$YO)k$YO~Ol;pO!g$YO)k$YO~Ol;mO!O)OX!h)OX)Y)OX)k)OX~P$GXOd/aO%Z*UO(z;xO~Ol;yO~O)T<^O~OV'f'i'j'h(p)Z!R(sST%[!Y!['kd%]!i'S!f]'g*['l(x!^!_'m'n'm~",
  goto: "%8]*[PPPPPP*]P*`PP.W4nP7o7o:{P:{>XP>r?U?jFdMf!&l!-UP!4Q!4u!5jP!6UPPPPPPPP!6oP!8ZPP!9n!;YP!;`PPPPPP!;cP!;cPP!;cPPPPPPPPP!;o!?XP!?[PP!?x!@mPPPPP!@qP>u!BUPP>u!D_!F`!Fn!HV!IxP!JTP!Jd!Jd!Mv##X#$q#(P#+]!F`#+gPP!F`#+n#+t#+g#+g#+wP#+{#,j#,j#,j#,j!IxP#-T#-f#/lP#0SP#1qP#1u#2P#2v#3R#5a#5i#5i#5p#1uP#1uP#6U#6[P#6fPP#7T#7t#8h#7TP#9[#9hP#7TP#7TPP#7T#7TP#7TP#7TP#7TP#7TP#7TP#7TP#9k#6f#:ZP#:rP#;Z#;Z#;Z#;Z#;h#1uP#<Q#AO#AmPPPPPPPP#BeP#BuP#BuP#CT#Fd#:hPP#Bo#FxP#G_#Gj#Gp#Gp#Bo#HfP#1u#1u#1u#1u#1uP!Jd#IS#IZ#IZ#IZ#I_!Mp#Ii!Mp#Im!Fn!Fn!Fn#Ip#N[!Fn>u>u>u$%V!@m!@m!@m!@m!@m!@m!6o!6o!6o$%jP$'X$'g!6o$'mPP!6o$)}$*Q#B[$*T:{7o$-]$/W$0w$2g7oPP7o$4Z7oP7o7oP7oP$7c7oP7oPP7o$7oPPPPPPPPP*]P$:y$;P$=h$?p$?v$@^$@h$@s$AS$AY$Bj$Ci$Cp$Cw$C}$DV$Da$Dg$Dv$D|$EV$E_$Ej$Ep$Ez$FQ$F[$Fc$Ft$Fz$GQP$GW$G`$Gg$Gu$Ie$Ik$Iq$Ix$JRPPPPPPPP$JX$J]PPPPP%#a$)}%#d%&n%(xP%)V%)YPPPPPPPPPP%)f%*i%*o%*s%,l%-{%.n%.u%1W%1^PPP%1h%1s%1v%1|%3T%3W%3d%3n%3r%4x%5m%5s#BeP%6^%6p%6s%7V%7e%7i%7o%7u$)}$*Q$*Q%7x%7{P%8V%8YR#cP'dmO[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-f-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jU%om%p7UQ&m!`Q(k#]d0S*O0P0Q0R0U5R5S5T5W8UR7U3Xf}Oaewx{!g&S'e*r-f&v$i[!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&W&b&f&x&y&|'O'P'b'j'k'z(a(c(j)m)s*i*j*m*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-j.S.T.X/Q/T/_/f/o/q/v/x1O1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jS%`f0k#d%jgnp|#O$g$|$}%S%d%h%i%w&s'u'v(R*Z*a*c*u+^,m,w-`-s-z.i.p.r0`0|0}1R1V2b2m5e6k;[;];^;d;e;f;s;t;u;v;z;{;|;}<[<]<^S%qm!YS&u!h#PQ']!tQ'h!yQ'i!zQ(k#`Q(l#]Q(m#^Q*y%kQ,X&lQ,^&nQ-T'^Q-g'gQ-n'rS.u([4]Q/i)hQ0h*nQ2T,]Q2[,dQ3S-hQ4f/PQ4j/WQ5j1QQ6`2WQ7R3TQ8e6_Q9i8OR;_1T$|#hS!]$y%Q%T%Z&j&k'Q'X'Z'a'c(b(f(i(x(y)S)T)U)V)W)X)Y)Z)[)])^)_)`)l)r)y+Y+h,P,T,k,v-k-l.P.|/s0c0e0j0l0z1c1|2d2k3V3g3h4g4h4n4q4w4y4}5O5h5t5{6Y6i6m6w7O7u7v7x8W8X8g8j8n8v9X9`9o9u:Q:X:^:d:mQ&p!dQ(h#ZQ(t#bQ)k$T[*t%e*X0n2c2j3OQ,_&oQ/R(gQ/V(lQ/^(uS/l)j/SQ0u+RS4u/m/nR8S4v'e![O[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-f-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:j'e!VO[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-f-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jQ)P#kS+R%y0vQ/u)tk4R.j3w3{4O4P7g7i7j7l7o9]9^:VQ)R#kk4Q.j3w3{4O4P7g7i7j7l7o9]9^:Vl)Q#k.j3w3{4O4P7g7i7j7l7o9]9^:VT+R%y0v`UOwx!g&S'e*r-fW$`[e$e(c#l$p_!f!u!}#R#S#T#U#V#Z$S$T$l%U&U&Y&c&m'_(O(Q(V(_(h)k)q+]+b+c+u+z,Y,l,{-R-r-w.Z.[.b.c.g.t.x1W1[1i1n1p2o3`3a3b3t3x5n6R6T7`8_![%cg$g%d%i&s*Z*u+^,m,w-`0}1R2b;[;];^;e;f;s;t;u;v;z;{;}<[<]<^Y%snp%w-s.il(}#k.j3w3{4O4P7g7i7j7l7o9]9^:VS;i'u-zU;j(R.p.r&|<Paf{|!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$f$k$|$}%S%]%h%m&Q&W&b&y&|'O'j'k'v'z(a(j)m)s*a*c*i*j*m*s+X+Z+i+k+l,Q,S,o,r-j.S.T.X/Q/T/_/f/o/q/v/x0`0k0|1O1T1d1e1o1s1}2f2l2m2x4S4V4[4e5^5e5i5u6c6g6j6k6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:j;d;|Q<Q1Vd<R&x'P'b,x-^-_-b2i2}3QW<S&f*w2P3mQ<T#O[<U!t'^'g,]2W6_T<a%y0v`VOwx!g&S'e*r-fW$a[e$e(cQ$p.x!j$q_!f!u!}#V#Z$S$T$l%U&U&Y&c&m'_(h)k)q+]+b+u,Y,l,{-R-r.g1W1[1i1n1p2o3x5n8_&^$zaf{!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$f$k%]%m&Q&W&b&y&|'O'j'k'z(a(j)m)s*i*j*m*s+X+Z+i+k+l,Q,S,o,r-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2f2l2x4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:j![%cg$g%d%i&s*Z*u+^,m,w-`0}1R2b;[;];^;e;f;s;t;u;v;z;{;}<[<]<^Y%snp%w-s.iQ's#O|'}#R#S#T#U(O(Q(V(_+c+z.Z.[.b.c.t3`3a3b3t6R6T7`l(}#k.j3w3{4O4P7g7i7j7l7o9]9^:VS-q'u-zQ3[-wU;w(R.p.rn<P|$|$}%S%h'v*a*c0`0|2m5e6k;d;|[<U!t'^'g,]2W6_W<V&f*w2P3md<W&x'P'b,x-^-_-b2i2}3QQ<_1VT<a%y0v!U!UO[ewx!g$e&S&f&x'P'b'e(c*r*w,x-^-_-b-f2P2i2}3Q3m!v$t_!f!u!}#O#V#Z$S$T$l%U&U&Y&c&m'_'u(R(h)k)q+]+u,Y,l,{-R-r-z.g.p.r1V1W1[1i1n1p2o3x5n8_&^%Paf{!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$f$k%]%m&Q&W&b&y&|'O'j'k'z(a(j)m)s*i*j*m*s+X+Z+i+k+l,Q,S,o,r-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2f2l2x4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:j$Q%lgnp|#k$g$|$}%S%d%h%i%w%y&s'^'g'v*Z*a*c*u+^,],m,w-`-s.i.j0`0v0|0}1R2W2b2m3w3{4O4P5e6_6k7g7i7j7l7o9]9^:V;[;];^;d;e;f;s;t;u;v;z;{;|;}<[<]<^Q'[!tz(P#R#S#T#U(O(Q(V(_+z.Z.[.b.c.t3`3a3b3t6R6T7`f-['`-U-W-Z2s2t2v2y6u6v8tQ1Z+bQ1^+cQ2n,zQ3]-wQ4`.xQ5p1]R8Z5q!U!UO[ewx!g$e&S&f&x'P'b'e(c*r*w,x-^-_-b-f2P2i2}3Q3m!x$t_!f!u!}#O#V#Z$S$T$l%U&U&Y&c&m'_'u(R(h)k)q+]+b+u,Y,l,{-R-r-z.g.p.r1V1W1[1i1n1p2o3x5n8_&^%Paf{!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$f$k%]%m&Q&W&b&y&|'O'j'k'z(a(j)m)s*i*j*m*s+X+Z+i+k+l,Q,S,o,r-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2f2l2x4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:j$S%lgnp|!t#k$g$|$}%S%d%h%i%w%y&s'^'g'v*Z*a*c*u+^,],m,w-`-s.i.j0`0v0|0}1R2W2b2m3w3{4O4P5e6_6k7g7i7j7l7o9]9^:V;[;];^;d;e;f;s;t;u;v;z;{;|;}<[<]<^|(P#R#S#T#U(O(Q(V(_+c+z.Z.[.b.c.t3`3a3b3t6R6T7`Q3]-wR4`.x`WOwx!g&S'e*r-fW$b[e$e(c#l$p_!f!u!}#R#S#T#U#V#Z$S$T$l%U&U&Y&c&m'_(O(Q(V(_(h)k)q+]+b+c+u+z,Y,l,{-R-r-w.Z.[.b.c.g.t.x1W1[1i1n1p2o3`3a3b3t3x5n6R6T7`8_![%cg$g%d%i&s*Z*u+^,m,w-`0}1R2b;[;];^;e;f;s;t;u;v;z;{;}<[<]<^Y%snp%w-s.il(}#k.j3w3{4O4P7g7i7j7l7o9]9^:VS;i'u-zU;j(R.p.rn<P|$|$}%S%h'v*a*c0`0|2m5e6k;d;|Q<Q1VQ<T#O[<U!t'^'g,]2W6_&^<Xaf{!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$f$k%]%m&Q&W&b&y&|'O'j'k'z(a(j)m)s*i*j*m*s+X+Z+i+k+l,Q,S,o,r-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2f2l2x4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jd<Y&x'P'b,x-^-_-b2i2}3QW<Z&f*w2P3mT<a%y0vp$PT$_$o%b%r(|;O;P;Q;`;a;b;c;g;h<`o)n$V*V*]/b:{:|:};l;m;n;o;p;q;r;yp$QT$_$o%b%r(|;O;P;Q;`;a;b;c;g;h<`o)o$V*V*]/b:{:|:};l;m;n;o;p;q;r;y^&e}!O$i$j%`%j;_d&i!U$t%P%l'[(P1Z1^3]4`V/d)P)Q4RS%Ye$eQ,U&fQ/O(cQ2p-RQ5}1pQ6Z2PQ6q2oR9l8_$R!TO[_ewx!f!g!u!}#O#V#Z$S$T$e$l%U&S&U&Y&c&f&m&x'P'_'b'e'u(R(c(h)k)q*r*w+]+b+u,Y,l,x,{-R-^-_-b-f-r-w-z.g.p.r1V1W1[1i1n1p2P2i2o2}3Q3m3x5n8_#`^O[_`wx!f!g!}#O$S$d$l$s$u&S&U&Y&c&m&r&x'P'b'e'u(R)q*^*r*w+],Y,l,x,{-^-_-b-f-r-w-z.g.p.r1V1W1i2i2}3Q3m3x_(V#R#S#T+c3`3a3b$RZO[wx!g!k#R#S#T%m&S&U&Y&c&m&w&x&y&|'O'P'['b'e'u'y(O(Q(R(V*r*w+]+c,Y,i,l,r-Q-^-_-b-f-r-w-z-}.b.g.p.t1V1W1i2f2n2}3Q3`3a3b3m6g6n8k9p9t:[:a:jQ$]YR0W*PR*R$]e0S*O0P0Q0R0U5R5S5T5W8U'd!YO[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-f-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:je0S*O0P0Q0R0U5R5S5T5W8UR5X0W^(U#R#S#T+c3`3a3bY.`(O(S(V(W7XU3o.^.a.tS7]3p4ZR9g7w^(T#R#S#T+c3`3a3b[._(O(S(U(V(W7XW3n.^.`.a.tU7[3o3p4ZS9O7]7wR:Z9gT.n(R.ph]Owx!g&S'e'u(R*r-f-z.p!v^[_`!f!}#O$S$d$l$s$u&U&Y&c&m&r&x'P'b)q*^*w+],Y,l,x,{-^-_-b-r-w.g.r1V1W1i2i2}3Q3m3xQ%tnT1x,O1y!nbOaenpwx{|!g#O$|$}%S%h%w&S'e'u'v(R*a*c*r-f-s-z.i.p.r0`0|1V2m5e6k;d;|f-X'`-U-W-Z2s2t2v2y6u6v8tj3|.j3w3{4O4P7g7i7j7l7o9]9^:Vr<Og$g%d%i&s*Z*u,m,w-`2b;[;];^;s;u;zi<b+^0}1R;e;f;t;v;{;}<[<]<^!O&^y%X&V&Y&Z'l)i*e*g+^+f+y/p0a0|0}1R1V1m5e5z;|;}z&az%O%W%e&d't*X*`,c-{0^0_0n1P2c2j3O5Z5f6p8mS'|#Q.[n+m&X*h+g+n+q-m/k0b1U1a4x5[5d5y8]Q2Z,b^2w-Y2u2{6t6{8s9we7m3}7c7k7s7t9Y9[9d:U:gS+_&U1WY+o&Y&c*w1V3mR5w1i#{!POaegnpwx{|!g#O$g$|$}%S%d%h%i%w&S&s'e'u'v(R*Z*a*c*r*u+^,m,w-`-f-s-z.i.p.r0`0|0}1R1V2b2m5e6k;[;];^;d;e;f;s;t;u;v;z;{;|;}<[<]<^doOwx!g&S'e'u*r-f-z#U!Paeg{|#O$g$|$}%S%d%h%i&s'v*Z*a*c*u+^,m,w-`0`0|0}1R1V2b2m5e6k;[;];^;d;e;f;s;t;u;v;z;{;|;}<[<]<^U%vnp-sQ+O%wS.h(R.pT3z.i.rW+s&^+m+t1fV+{&a+|7mQ+y&`U+{&a+|7mQ-z'uT.V'z.X'd![O[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-f-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jX1u+z.[6R6T'[!VO[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-f-j.S.T.X/Q/_/f/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jW1u+z.[6R6TR2h,t![jO[wx!g!k%m&S&y&|'O'b'e*r,r-^-_-b-f2f2}6g6n8k9p9t:[:a:jY%Ve$e(c1s3mQ'S!nS(z#i5^Q,n&xQ,y'PS.R'z.XQ2e,oQ6o2lQ7Q3QQ8l6jR9q8i'[![O[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-f-j.S.T.X/Q/_/f/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jX1u+z.[6R6T'eyO[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l+z,Q,S,o,r,x-^-_-b-f-j.S.T.X.[/Q/_/f/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[5^5i5u6R6T6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jQ&`yS'u#O-xR1_+dS+_&U1WR5r1_Q1S+^R5k1RR1S+^T+_&U1Wz&[%X&V&Y&Z'l)i*e*g+^+f/p0a0|0}1R1V1m5e5z;|;}Q&]yR1q+y!P&[y%X&V&Y&Z'l)i*e*g+^+f+y/p0a0|0}1R1V1m5e5z;|;}Q+v&^S+}&a7mS1g+m+tQ1w+|R5v1f![kO[wx!g!k%m&S&y&|'O'b'e*r,r-^-_-b-f2f2}6g6n8k9p9t:[:a:jS%zo.hS&Oq-uQ&_yQ&q!eQ*q%eU*|%v%{3zS+Q%x%}Q+r&]Q,s&{S0[*X,cS0r*}+OQ0t+PQ1r+yQ5Y0^Q5_0sQ6P1qQ6a2ZQ7r3}Q9W7cR:T9Y`uOwx!g&S'e*r-fQ,Z&mQ-y'uQ3^-wR3c-z|lOwx!g!k%m&S&y'O'e*r,r-f2f6g6n8k9p9t:[:a:jU$h[&|-_S%zo.hS&Oq-uQ*q%eU*|%v%{3zS+Q%x%}S0[*X,cS0r*}+OQ0t+PQ5Y0^Q5_0sQ7r3}Q9W7cR:T9YT,`&q,aauOwx!g&S'e*r-f`uOwx!g&S'e*r-fQ,Z&mQ,o&xQ,x'PW-a'b-^-b2}Q-y'uQ3^-wQ3c-zR7P3Q[%fg$g,m,w-`2bR0o*u^$XV!U$a$z%P<V<WQ'S!nS)a#}*wS)w$W*rQ)z$YY*t%e*X0n2j3OQ/R(gS/l)j/SS0d*i4eS0m*s6cQ0u+RQ4U.jQ4r/fS4u/m/nS4z/q5^Q5P/xQ6d2cU7e3w3}4VQ8S4vQ8o6lY9U7c7f7g7p7qQ9v8qW:O9S9V9Y9ZQ:_9sU:e:P:R:SR:n:fS)w$W*rT4z/q5^Z)u$W)v*r/q5^Q&t!gQ'f!yQ,Z&mS,[&n'hS2V,^-iR6^2UQ&w!hR'y#PS,h&v'wQ2_,fR6b2^|lOwx!g!k%m&S&y'O'e*r,r-f2f6g6n8k9p9t:[:a:jV$h[&|-_!]kO[wx!g!k%m&S&y&|'O'b'e*r,r-^-_-b-f2f2}6g6n8k9p9t:[:a:j![hO[wx!g!k%m&S&y&|'O'b'e*r,r-^-_-b-f2f2}6g6n8k9p9t:[:a:jR'W!q![kO[wx!g!k%m&S&y&|'O'b'e*r,r-^-_-b-f2f2}6g6n8k9p9t:[:a:jR,o&xQ&y!iQ&{!jQ'O!lR,r&zR,p&x|lOwx!g!k%m&S&y'O'e*r,r-f2f6g6n8k9p9t:[:a:jX-a'b-^-b2}`uOwx!g&S'e*r-fQ,{'PQ-y'uS.n(R.pR3c-z`uOwx!g&S'e*r-fQ,{'PW-a'b-^-b2}T.n(R.pg-['`-U-W-Z2s2t2v2y6u6v8t}lOwx!g!k%m&S&y'O'e*r,r-f2f6g6n8k9p9t:[:a:jf!OOaewx{!g&S'e*r-f&|$j[f!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&W&b&f&x&y&|'O'P'b'j'k'z(a(c(j)m)s*i*j*m*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:j#d%jgnp|#O$g$|$}%S%d%h%i%w&s'u'v(R*Z*a*c*u+^,m,w-`-s-z.i.p.r0`0|0}1R1V2b2m5e6k;[;];^;d;e;f;s;t;u;v;z;{;|;}<[<]<^Q']!tQ-T'^Q-g'gQ2T,]Q6`2WR8e6_j$RT$_%b%r;O;P;Q;`;a;b;c;g;hi)p$V*V:{:|:};l;m;n;o;p;q;rj$RT$_%b%r;O;P;Q;`;a;b;c;g;hh)p$V*V:{:|:};l;m;n;o;p;q;rS/a(|<`V4o/b/c;y`uOwx!g&S'e*r-fQ-y'uR3c-z`uOwx!g&S'e*r-fT.n(R.p'd!YO[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-f-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jR7V3X`uOwx!g&S'e*r-fQ-y'uS.n(R.pR3c-z`pOwx!g&S'e*r-fQ%wnS-s'u-zT.i(R.pS%{o.hS*}%v3zR0s+OQ+S%yR5a0vS%zo.hS&Oq-uU*|%v%{3zS+Q%x%}S0r*}+OQ0t+PQ5_0sQ7r3}Q9W7cR:T9YdqOwx!g&S'e(R*r-f.pS%xn-sU%}p.i.rQ+P%wT-u'u-zS'{#Q.[R.]'|T.U'z.XS.V'z.XQ8|7YR9{8}T6R1t8cR6T1t#d!Pgnp|#O$g$|$}%S%d%h%i%w&s'u'v(R*Z*a*c*u+^,m,w-`-s-z.i.p.r0`0|0}1R1V2b2m5e6k;[;];^;d;e;f;s;t;u;v;z;{;|;}<[<]<^f!QOaewx{!g&S'e*r-f&}![[f!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&W&b&f&x&y&|'O'P'b'j'k'z(a(c(j)m)s*i*j*m*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:j#d!Pgnp|#O$g$|$}%S%d%h%i%w&s'u'v(R*Z*a*c*u+^,m,w-`-s-z.i.p.r0`0|0}1R1V2b2m5e6k;[;];^;d;e;f;s;t;u;v;z;{;|;}<[<]<^f!QOaewx{!g&S'e*r-f&|![[f!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&W&b&f&x&y&|'O'P'b'j'k'z(a(c(j)m)s*i*j*m*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jk4Q.j3w3{4O4P7g7i7j7l7o9]9^:VQ4U.jS7e3w3}U9U7c7g7pS:O9S9YR:e:R$Q!TO[_ewx!f!g!u!}#O#V#Z$S$T$e$l%U&S&U&Y&c&f&m&x'P'_'b'e'u(R(c(h)k)q*r*w+]+b+u,Y,l,x,{-R-^-_-b-f-r-w-z.g.p.r1V1W1[1i1n1p2P2i2o2}3Q3m3x5n8_R4a.xQ(^#US.y(](_S4b.z.{R7{4cQ.v([R7y4]$Q!TO[_ewx!f!g!u!}#O#V#Z$S$T$e$l%U&S&U&Y&c&f&m&x'P'_'b'e'u(R(c(h)k)q*r*w+]+b+u,Y,l,x,{-R-^-_-b-f-r-w-z.g.p.r1V1W1[1i1n1p2P2i2o2}3Q3m3x5n8_p$w`$d$s%X&r'`(`(g)j*e-U/n1m5o5z8Yq)O#k%y.j0v3w3{4O4P7g7i7j7l7o9]9^:VR,V&fR6[2P']!VO[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-f-j.S.T.X/Q/_/f/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:j$q#rS%T%Z'Q'X'Z'a'c(b(f(i(x(y)S)T)V)W)X)Y)Z)[)])^)_)`)l)r)y+Y+h,P,T,k,v-k-l.P.|/s0c0e0j0l0z1c1|2d2k3V3g3h4g4h4n4q4w4y4}5O5h5t5{6Y6i6m6w7O7u7v7x8W8X8g8j8n8v9X9`9o9u:Q:X:^:d:m$]#sS%T%Z'Q'X'Z'a'c(i(x(y)S)W)_)`)l)r)y+Y+h,P,T,k,v-k-l.P.|/s0c0e0j0l0z1c1|2d2k3V3g3h4g4h4n4q4w4y4}5O5h5t5{6Y6i6m6w7O7u7v7x8W8X8g8j8n8v9X9`9o9u:Q:X:^:d:m$Z#tS%T%Z'Q'X'Z'a'c(i(x(y)S)_)`)l)r)y+Y+h,P,T,k,v-k-l.P.|/s0c0e0j0l0z1c1|2d2k3V3g3h4g4h4n4q4w4y4}5O5h5t5{6Y6i6m6w7O7u7v7x8W8X8g8j8n8v9X9`9o9u:Q:X:^:d:m$c#wS%T%Z'Q'X'Z'a'c(i(x(y)S)V)W)X)Y)_)`)l)r)y+Y+h,P,T,k,v-k-l.P.|/s0c0e0j0l0z1c1|2d2k3V3g3h4g4h4n4q4w4y4}5O5h5t5{6Y6i6m6w7O7u7v7x8W8X8g8j8n8v9X9`9o9u:Q:X:^:d:m']![O[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-f-j.S.T.X/Q/_/f/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jQ/S(gQ/m)jQ4v/nR9h7}'a![O[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-f-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jQ#eQR(v#eU$|a;d;|b%Ue$e&f(c-R1p2P2o8_Q'_!u!Q*_$|%U'_*a*g+i,Q0`0a1e2s6u6x7i8t9]9a:V;[;s;t;z;{<[S*a$}%SQ*g%XS+i&W1TQ,Q&bQ0`*cQ0a*eQ1e+lQ2s-WS6u2t2vQ6x2xQ7i3{Q8t6vS9]7j7lQ9a7nQ:V9^Q;[%dS;s;];^S;t<]<^Q;z;uQ;{;vT<[0};e`[Owx!g&S'e*r-fl$c[&|(O+],Y,i,l-Q-_-r-}.b.g.tl&|!k%m&y'O,r2f6g6n8k9p9t:[:a:j^(O#R#S#T+c3`3a3b`+]&U&Y&c*w1V1W1i3mS,Y&m-wQ,i&wU,l&x'P3QS-Q'[2nW-_'b-^-b2}S-r'u-zQ-}'yQ.b(QS.g(R.pR.t(VQ)}$[R/{)}Q0U*OQ5R0PQ5S0QQ5T0RY5U0U5R5S5T8UR8U5WQ*Q$]S0X*Q0YR0Y*RS.c(Q.bS3r.c7`R7`3tQ3u.dS7^3s3vU7b3u7^9PR9P7_Q.p(RR4W.p#Q_O[wx!f!g!}#O$S$l&S&U&Y&c&m&x'P'b'e'u(R)q*r*w+],Y,l,x,{-^-_-b-f-r-w-z.g.p.r1V1W1i2i2}3Q3m3xU$r_$u*^U$u`$d&rR*^$sU$}a;d;|d*b$}*c2t6v7j9^;];u;v<]Q*c%SQ2t-WQ6v2vQ7j3{Q9^7lQ;]%dQ;u;^Q;v<^T<]0};eS+|&a7mR1v+|S*k%Z/sR0f*kQ1X+`R5m1XU+f&V0};|R1`+fQ+t&^Q1f+mT1l+t1fQ8`5}R9m8`QwOU&Rw&S-fS&Sx*rR-f'eQ,a&qR2Y,aW)v$W*r/q5^R/w)vU/r)r)w0jR4{/r[*v%e%f*X2c2j3OR0p*vQ,e&uR2],eQ-b'bQ2}-^T3P-b2}Q2z-YR6|2zQ-i'hQ2U,^T3U-i2US%pm7UR*{%phnOwx!g&S'e'u(R*r-f-z.pR%unQ0w+SR5b0wQ.X'zR3j.XQ1y,OR6U1yU*o%`*y;_R0i*oS1j+o0qR5x1jQ7p3}Q9S7cU9e7p9S:RR:R9Y$S!SO[_ewx!f!g!u!}#O#V#Z$S$T$e$l%U&S&U&Y&c&f&m&x'P'_'b'e'u(R(c(h)k)q*r*w+]+b+u,Y,l,x,{-R-^-_-b-f-r-w-z.g.p.r.x1V1W1[1i1n1p2P2i2o2}3Q3m3x5n8_R&g!SQ4^.vR7z4^Q2Q,VR6]2QS/g)`)aR4s/gW(p#a(k(l/VR/Z(pQ8P4jR9j8PT)b#}*w!YSO[wx!g!k%m&S&y&|'O'b'e,r-^-_-b-f2f2}6g6n8k9p9t:[:a:jj$ya{$k%]+k,S1d1}5u6z8w9c:YY%Te$e(c1s3mY%Zf$f(j)m*mQ&j!WQ&k!XQ'Q!nQ'X!rQ'Z!sQ'a!vQ'c!xQ(b#XQ(f#YS(i#[+ZQ(x#gQ(y#iQ)S#lQ)T#qQ)U#rQ)V#sQ)W#tQ)X#uQ)Y#vQ)Z#wQ)[#xQ)]#yQ)^#zQ)_#{S)`#}*wQ)l$UQ)r$WQ)y$YQ+Y&QS+h&W1TQ,P&bQ,T&fQ,k&xQ,v'PQ-k'jQ-l'kS.P'z.XQ.|(aS/s)s0kS0c*i4eQ0e*jQ0j*rQ0l*sQ0z+XS1c+i+lQ1|,QQ2d,oS2k,x7PQ3V-jQ3g.SQ3h.TQ4g/QQ4h/TQ4n/_Q4q/fQ4w/oQ4y/qQ4}/vQ5O/xQ5h1OQ5t1eQ5{1oQ6Y2PS6i2i8xQ6m2lQ6w2xQ7O3QQ7u4SQ7v4VQ7x4[Q8W5^Q8X5iQ8g6cQ8j6jQ8n6lQ8v6xS9X7f7qQ9`7nQ9o8iQ9u8qS:Q9V9ZQ:X9aQ:^9sS:d:P:SR:m:fR,W&fh]Owx!g&S'e'u(R*r-f-z.p!v^[_`!f!}#O$S$d$l$s$u&U&Y&c&m&r&x'P'b)q*^*w+],Y,l,x,{-^-_-b-r-w.g.r1V1W1i2i2}3Q3m3x#r${ae!u$e$|$}%S%U%X%d&W&b&f'_(c*a*c*e*g+i+l,Q-R-W0`0a1T1e1p2P2o2s2t2v2x3{6u6v6x7i7j7l7n8_8t9]9^9a:V;[;];^;d;e;s;t;u;v;z;{<[<]<^Q%tnS+e&V+fW+s&^+m+t1fU+{&a+|7mQ1n+uT5g0};|d`Owx!g&S'e'u*r-f-zS$d[-rQ$s_b%Xe$e&f(c-R1p2P2o8_!h&r!f!}#O$S$l&U&Y&c&m&x'P'b(R)q*w+],Y,l,x,{-^-_-b-w.g.p.r1V1W1i2i2}3Q3m3xQ'`!uS(`#V+bQ(g#ZS)j$T(hQ*e%UQ-U'_Q/n)kQ1m+uQ5o1[Q5z1nR8Y5nS(X#R3aS(Y#S3bV(Z#T+c3`R$^Ye0T*O0P0Q0R0U5R5S5T5W8UW(S#R#S#T+cQ(]#US.^(O(VS.d(Q.bQ.{(_W1u+z.[6R6TQ3_-wQ3l.ZQ3s.cQ4Z.tU7X3`3a3bQ7a3tR9Q7`Q.e(QR3q.bT.o(R.phgOwx!g&S&m'e'u*r-f-w-zU$g[,Y-rQ&s!fQ'l!}Q'v#OQ)i$SQ*Z$l`+^&U&Y&c*w1V1W1i3mQ,m&xQ,w'PY-`'b-^-b2}3QS.j(R.pQ/p)qQ0|+]S2b,l-_S2m,x,{S3w.g.rQ6k2iR7g3xh]Owx!g&S'e'u(R*r-f-z.p!v^[_`!f!}#O$S$d$l$s$u&U&Y&c&m&r&x'P'b)q*^*w+],Y,l,x,{-^-_-b-r-w.g.r1V1W1i2i2}3Q3m3xR%tnQ3}.jQ7c3wQ7k3{Q7s4OQ7t4PQ9Y7gU9[7i7j7lQ9d7oS:U9]9^R:g:VZ+p&Y&c*w1V3mtzOnpwx!g%w&S'e'u(R*r-f-s-z.i.p.r[%Oa%d0};d;e;|U%We%h1VQ%eg^&d{|%i1R5e;f;}Q't#OQ*X$gb*`$|$}%S;[;];^<[<]<^Q,c&sQ-{'vQ0^*Z[0_*a*c;s;t;u;vQ0n*uQ1P+^Q2c,mQ2j,wS3O-`2bU5Z0`;z;{Q5f0|Q6p2mR8m6kQ,O&aR9_7mS1t+z.[Q8b6RR8c6T[%^f$f(j)m)s0kR0g*mR+a&UQ+`&UR5l1WS&Xy+yQ*h%XU+g&V0};|S+n&Y1VW+q&Z1R5e;}Q-m'lQ/k)iS0b*e*gQ1U+^Q1a+fQ4x/pQ5[0aQ5d0|Q5y1mR8]5zR6O1p^vOwx&S'e*r-fR&t!gW%gg,m,w-`T*Y$g2bT)x$W*r`uOwx!g&S'e*r-fQ&}!kQ*z%mQ,q&yQ,u'OQ2g,rQ6f2fQ8h6gQ8p6nQ9r8kQ:]9pQ:`9tQ:i:[Q:k:aR:o:j|lOwx!g!k%m&S&y'O'e*r,r-f2f6g6n8k9p9t:[:a:jU$h[&|-_X-a'b-^-b2}Q-]'`R2r-US-Y'`-UQ2u-WQ2{-ZU6t2s2t2vQ6{2yS8s6u6vR9w8t`rOwx!g&S'e*r-fS-t'u-zT.k(R.pR+T%y`sOwx!g&S'e*r-fS-v'u-zT.l(R.p`tOwx!g&S'e*r-fT.m(R.pT.W'z.XX%af%k0k1TQ.z(]R4c.{R.w([R(e#XQ(s#aS/U(k(lR4i/VR/Y(mR4k/W",
  nodeNames: "⚠ RawString > MacroName LineComment BlockComment PreprocDirective #include String EscapeSequence SystemLibString Identifier ArgumentList ( ConditionalExpression AssignmentExpression CallExpression PrimitiveType FieldExpression FieldIdentifier DestructorName TemplateMethod ScopedFieldIdentifier NamespaceIdentifier TemplateType TypeIdentifier ScopedTypeIdentifier ScopedNamespaceIdentifier :: NamespaceIdentifier TypeIdentifier TemplateArgumentList < TypeDescriptor const volatile restrict _Atomic mutable constexpr constinit consteval StructSpecifier struct MsDeclspecModifier __declspec ) Attribute AttributeName Identifier AttributeArgs { } [ ] UpdateOp ArithOp ArithOp ArithOp LogicOp BitOp BitOp BitOp CompareOp CompareOp CompareOp > CompareOp BitOp UpdateOp , Number CharLiteral AttributeArgs VirtualSpecifier BaseClassClause Access virtual FieldDeclarationList FieldDeclaration extern static register inline thread_local AttributeSpecifier __attribute__ PointerDeclarator MsBasedModifier __based MsPointerModifier FunctionDeclarator ParameterList ParameterDeclaration PointerDeclarator FunctionDeclarator Noexcept noexcept RequiresClause requires True False ParenthesizedExpression CommaExpression LambdaExpression LambdaCaptureSpecifier TemplateParameterList OptionalParameterDeclaration TypeParameterDeclaration typename class VariadicParameterDeclaration VariadicDeclarator ReferenceDeclarator OptionalTypeParameterDeclaration VariadicTypeParameterDeclaration TemplateTemplateParameterDeclaration template AbstractFunctionDeclarator AbstractPointerDeclarator AbstractArrayDeclarator AbstractParenthesizedDeclarator AbstractReferenceDeclarator ThrowSpecifier throw TrailingReturnType CompoundStatement FunctionDefinition MsCallModifier TryStatement try CatchClause catch LinkageSpecification Declaration InitDeclarator InitializerList InitializerPair SubscriptDesignator FieldDesignator DeclarationList ExportDeclaration export ImportDeclaration import ModuleName PartitionName HeaderName CaseStatement case default LabeledStatement StatementIdentifier ExpressionStatement IfStatement if ConditionClause Declaration else SwitchStatement switch DoStatement do while WhileStatement ForStatement for ReturnStatement return BreakStatement break ContinueStatement continue GotoStatement goto CoReturnStatement co_return CoYieldStatement co_yield AttributeStatement ForRangeLoop AliasDeclaration using TypeDefinition typedef PointerDeclarator FunctionDeclarator ArrayDeclarator ParenthesizedDeclarator ThrowStatement NamespaceDefinition namespace ScopedIdentifier Identifier OperatorName operator ArithOp BitOp CompareOp LogicOp new delete co_await ConceptDefinition concept UsingDeclaration enum StaticAssertDeclaration static_assert ConcatenatedString TemplateDeclaration FriendDeclaration friend union FunctionDefinition ExplicitFunctionSpecifier explicit FieldInitializerList FieldInitializer DefaultMethodClause DeleteMethodClause FunctionDefinition OperatorCast operator TemplateInstantiation FunctionDefinition FunctionDefinition Declaration ModuleDeclaration module RequiresExpression RequirementList SimpleRequirement TypeRequirement CompoundRequirement ReturnTypeRequirement ConstraintConjuction LogicOp ConstraintDisjunction LogicOp ArrayDeclarator ParenthesizedDeclarator ReferenceDeclarator TemplateFunction OperatorName StructuredBindingDeclarator ArrayDeclarator ParenthesizedDeclarator ReferenceDeclarator BitfieldClause FunctionDefinition FunctionDefinition Declaration FunctionDefinition Declaration AccessSpecifier UnionSpecifier ClassSpecifier EnumSpecifier SizedTypeSpecifier TypeSize EnumeratorList Enumerator DependentType Decltype decltype auto PlaceholderTypeSpecifier ParameterPackExpansion ParameterPackExpansion FieldIdentifier PointerExpression SubscriptExpression BinaryExpression ArithOp LogicOp LogicOp BitOp UnaryExpression LogicOp BitOp UpdateExpression CastExpression SizeofExpression sizeof CoAwaitExpression CompoundLiteralExpression NULL NewExpression new NewDeclarator DeleteExpression delete ParameterPackExpansion nullptr this UserDefinedLiteral ParamPack #define PreprocArg #if #ifdef #ifndef #else #endif #elif PreprocDirectiveName Macro Program",
  maxTerm: 426,
  nodeProps: [
    ["group", -35, 1, 8, 11, 14, 15, 16, 18, 71, 72, 100, 101, 102, 104, 192, 209, 230, 243, 244, 271, 272, 273, 278, 281, 282, 283, 285, 286, 287, 288, 291, 293, 294, 295, 296, 297, "Expression", -13, 17, 24, 25, 26, 42, 256, 257, 258, 259, 263, 264, 266, 267, "Type", -19, 126, 129, 148, 151, 153, 154, 159, 161, 164, 165, 167, 169, 171, 173, 175, 177, 179, 180, 189, "Statement"]
  ],
  propSources: [Pz],
  skippedNodes: [0, 3, 4, 5, 6, 7, 10, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 348, 349],
  repeatNodeCount: 41,
  tokenData: "&*r7ZR!UOX$eXY({YZ.gZ]$e]^+P^p$epq({qr.}rs0}st2ktu$euv!7dvw!9bwx!;exy!<Yyz!=Tz{!>O{|!?R|}!AV}!O!BQ!O!P!DX!P!Q#+y!Q!R#Az!R![$(x![!]$Ag!]!^$Cc!^!_$D^!_!`%1W!`!a%2X!a!b%5_!b!c$e!c!n%6Y!n!o%7q!o!w%6Y!w!x%7q!x!}%6Y!}#O%:n#O#P%<g#P#Q%Kz#Q#R%Ms#R#S%6Y#S#T$e#T#i%6Y#i#j%Nv#j#o%6Y#o#p&!e#p#q&#`#q#r&%f#r#s&&a#s;'S$e;'S;=`(u<%lO$e&t$nY)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e&r%eW)[W'g&jOY%^Zw%^wx%}x#O%^#O#P&f#P;'S%^;'S;=`'x<%lO%^&j&SU'g&jOY%}Z#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}&j&kX'g&jOY%}YZ%}Z]%}]^'W^#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}&j']V'g&jOY%}YZ%}Z#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}&j'uP;=`<%l%}&r'{P;=`<%l%^&l(VW(qQ'g&jOY(OZr(Ors%}s#O(O#O#P&f#P;'S(O;'S;=`(o<%lO(O&l(rP;=`<%l(O&t(xP;=`<%l$e7Z)Y`)[W(qQ(o.o'g&j*[)`OX$eXY({YZ*[Z]$e]^+P^p$epq({qr$ers%^sw$ewx(Ox#O$e#O#P,^#P;'S$e;'S;=`(u<%lO$e.o*aT(o.oXY*[YZ*[]^*[pq*[#O#P*p.o*sQYZ*[]^*y.o*|PYZ*[4e+[`)[W(qQ(o.o'g&jOX$eXY+PYZ*[Z]$e]^+P^p$epq+Pqr$ers%^sw$ewx(Ox#O$e#O#P,^#P;'S$e;'S;=`(u<%lO$e4Z,cX'g&jOY%}YZ-OZ]%}]^-{^#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}4Z-V[(o.o'g&jOX%}XY-OYZ*[Z]%}]^-O^p%}pq-Oq#O%}#O#P,^#P;'S%};'S;=`'r<%lO%}4Z.QV'g&jOY%}YZ-OZ#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}7P.nT*X)`(o.oXY*[YZ*[]^*[pq*[#O#P*p3o/[[%_!b'RP)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox!_$e!_!`0Q!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o0_Y%^!b!a,g)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e6e1YY)[W(rQ(p/]'g&jOY%^Zr%^rs1xsw%^wx%}x#O%^#O#P&f#P;'S%^;'S;=`'x<%lO%^(U2RW)y!b)[W'g&jOY%^Zw%^wx%}x#O%^#O#P&f#P;'S%^;'S;=`'x<%lO%^4e2tf)[W(qQ'g&jOX$eXY2kZp$epq2kqr$ers%^sw$ewx(Ox!c$e!c!}4Y!}#O$e#O#P&f#P#T$e#T#W4Y#W#X5m#X#Y>u#Y#]4Y#]#^NZ#^#o4Y#o;'S$e;'S;=`(u<%lO$e4e4eb)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e4e5xd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#X4Y#X#Y7W#Y#o4Y#o;'S$e;'S;=`(u<%lO$e4e7cd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#Y4Y#Y#Z8q#Z#o4Y#o;'S$e;'S;=`(u<%lO$e4e8|d)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#]4Y#]#^:[#^#o4Y#o;'S$e;'S;=`(u<%lO$e4e:gd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#b4Y#b#c;u#c#o4Y#o;'S$e;'S;=`(u<%lO$e4e<Qd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#X4Y#X#Y=`#Y#o4Y#o;'S$e;'S;=`(u<%lO$e4e=mb)[W(qQ'f.o'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e4e?Qf)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#`4Y#`#a@f#a#b4Y#b#cHV#c#o4Y#o;'S$e;'S;=`(u<%lO$e4e@qf)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#]4Y#]#^BV#^#g4Y#g#hEV#h#o4Y#o;'S$e;'S;=`(u<%lO$e4eBbd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#Y4Y#Y#ZCp#Z#o4Y#o;'S$e;'S;=`(u<%lO$e4eC}b)[W(qQ'g&j'm.o'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e4eEbd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#X4Y#X#YFp#Y#o4Y#o;'S$e;'S;=`(u<%lO$e4eF}b)[W(qQ'k.o'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e4eHbd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#W4Y#W#XIp#X#o4Y#o;'S$e;'S;=`(u<%lO$e4eI{d)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#]4Y#]#^KZ#^#o4Y#o;'S$e;'S;=`(u<%lO$e4eKfd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#Y4Y#Y#ZLt#Z#o4Y#o;'S$e;'S;=`(u<%lO$e4eMRb)[W(qQ'g&j'l.o'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e4eNff)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#Y4Y#Y#Z! z#Z#b4Y#b#c!.[#c#o4Y#o;'S$e;'S;=`(u<%lO$e4e!!Xf)[W(qQ'h.o'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#W4Y#W#X!#m#X#b4Y#b#c!(W#c#o4Y#o;'S$e;'S;=`(u<%lO$e4e!#xd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#X4Y#X#Y!%W#Y#o4Y#o;'S$e;'S;=`(u<%lO$e4e!%cd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#Y4Y#Y#Z!&q#Z#o4Y#o;'S$e;'S;=`(u<%lO$e4e!'Ob)[W(qQ'i.o'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e4e!(cd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#W4Y#W#X!)q#X#o4Y#o;'S$e;'S;=`(u<%lO$e4e!)|d)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#X4Y#X#Y!+[#Y#o4Y#o;'S$e;'S;=`(u<%lO$e4e!+gd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#Y4Y#Y#Z!,u#Z#o4Y#o;'S$e;'S;=`(u<%lO$e4e!-Sb)[W(qQ'j.o'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e4e!.gd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#V4Y#V#W!/u#W#o4Y#o;'S$e;'S;=`(u<%lO$e4e!0Qd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#`4Y#`#a!1`#a#o4Y#o;'S$e;'S;=`(u<%lO$e4e!1kd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#i4Y#i#j!2y#j#o4Y#o;'S$e;'S;=`(u<%lO$e4e!3Ud)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#W4Y#W#X!4d#X#o4Y#o;'S$e;'S;=`(u<%lO$e4e!4od)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#X4Y#X#Y!5}#Y#o4Y#o;'S$e;'S;=`(u<%lO$e4e!6[b)[W(qQV.o'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e3o!7q[)[W(qQ%[!b![,g'g&jOY$eZr$ers%^sw$ewx(Ox!_$e!_!`!8g!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!8rY!g-y)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!9o])W,g)[W(qQ%]!b'g&jOY$eZr$ers%^sv$evw!:hwx(Ox!_$e!_!`!8g!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!:uY)V,g%_!b)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2X!;pW)]S(qQ)Z,g'g&jOY(OZr(Ors%}s#O(O#O#P&f#P;'S(O;'S;=`(o<%lO(O6i!<eY)[W(qQ]6_'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e'V!=`Y!Oa)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!>][)T,g)[W(qQ%[!b'g&jOY$eZr$ers%^sw$ewx(Ox!_$e!_!`!8g!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!?`^)[W(qQ%[!b!Y,g'g&jOY$eZr$ers%^sw$ewx(Ox{$e{|!@[|!_$e!_!`!8g!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!@gY)[W!X-y(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2a!AbY!h,k)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!B__)[W(qQ%[!b!Y,g'g&jOY$eZr$ers%^sw$ewx(Ox}$e}!O!@[!O!_$e!_!`!8g!`!a!C^!a#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!CiY(y-y)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2a!Dd^)[W(qQ'g&j(x,gOY$eZr$ers%^sw$ewx(Ox!O$e!O!P!E`!P!Q$e!Q![!GY![#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2a!Ei[)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox!O$e!O!P!F_!P#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2a!FjY)Y,k)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2]!Gen)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx!Icx!Q$e!Q![!GY![!g$e!g!h#$w!h!i#*Y!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#X$e#X#Y#$w#Y#Z#*Y#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2T!IjY(qQ'g&jOY(OZr(Ors%}s!Q(O!Q![!JY![#O(O#O#P&f#P;'S(O;'S;=`(o<%lO(O2T!Jcn(qQ!i,g'g&jOY(OZr(Ors%}sw(Owx!Icx!Q(O!Q![!JY![!g(O!g!h!La!h!i##`!i!n(O!n!o##`!o!r(O!r!s!La!s!w(O!w!x##`!x#O(O#O#P&f#P#X(O#X#Y!La#Y#Z##`#Z#`(O#`#a##`#a#d(O#d#e!La#e#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2T!Ljl(qQ!i,g'g&jOY(OZr(Ors%}s{(O{|!Nb|}(O}!O!Nb!O!Q(O!Q![# e![!c(O!c!h# e!h!i# e!i!n(O!n!o##`!o!w(O!w!x##`!x#O(O#O#P&f#P#T(O#T#Y# e#Y#Z# e#Z#`(O#`#a##`#a#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2T!Ni^(qQ'g&jOY(OZr(Ors%}s!Q(O!Q![# e![!c(O!c!i# e!i#O(O#O#P&f#P#T(O#T#Z# e#Z;'S(O;'S;=`(o<%lO(O2T# nj(qQ!i,g'g&jOY(OZr(Ors%}sw(Owx!Nbx!Q(O!Q![# e![!c(O!c!h# e!h!i# e!i!n(O!n!o##`!o!w(O!w!x##`!x#O(O#O#P&f#P#T(O#T#Y# e#Y#Z# e#Z#`(O#`#a##`#a#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2T##id(qQ!i,g'g&jOY(OZr(Ors%}s!h(O!h!i##`!i!n(O!n!o##`!o!w(O!w!x##`!x#O(O#O#P&f#P#Y(O#Y#Z##`#Z#`(O#`#a##`#a#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2]#%Sn)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx(Ox{$e{|#'Q|}$e}!O#'Q!O!Q$e!Q![#(]![!c$e!c!h#(]!h!i#(]!i!n$e!n!o#*Y!o!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#Y#(]#Y#Z#(]#Z#`$e#`#a#*Y#a#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2]#'Z`)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![#(]![!c$e!c!i#(]!i#O$e#O#P&f#P#T$e#T#Z#(]#Z;'S$e;'S;=`(u<%lO$e2]#(hj)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx!Nbx!Q$e!Q![#(]![!c$e!c!h#(]!h!i#(]!i!n$e!n!o#*Y!o!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#Y#(]#Y#Z#(]#Z#`$e#`#a#*Y#a#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2]#*ef)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx(Ox!h$e!h!i#*Y!i!n$e!n!o#*Y!o!w$e!w!x#*Y!x#O$e#O#P&f#P#Y$e#Y#Z#*Y#Z#`$e#`#a#*Y#a#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e7Z#,W`)[W(qQ%[!b![,g'g&jOY$eZr$ers%^sw$ewx(Oxz$ez{#-Y{!P$e!P!Q#:s!Q!_$e!_!`!8g!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e7Z#-c])[W(qQ'g&jOY#-YYZ#.[Zr#-Yrs#/csw#-Ywx#5wxz#-Yz{#8j{#O#-Y#O#P#2`#P;'S#-Y;'S;=`#:m<%lO#-Y1e#._TOz#.[z{#.n{;'S#.[;'S;=`#/]<%lO#.[1e#.qVOz#.[z{#.n{!P#.[!P!Q#/W!Q;'S#.[;'S;=`#/]<%lO#.[1e#/]OT1e1e#/`P;=`<%l#.[7X#/jZ)[W'g&jOY#/cYZ#.[Zw#/cwx#0]xz#/cz{#4O{#O#/c#O#P#2`#P;'S#/c;'S;=`#5q<%lO#/c7P#0bX'g&jOY#0]YZ#.[Zz#0]z{#0}{#O#0]#O#P#2`#P;'S#0];'S;=`#3x<%lO#0]7P#1SZ'g&jOY#0]YZ#.[Zz#0]z{#0}{!P#0]!P!Q#1u!Q#O#0]#O#P#2`#P;'S#0];'S;=`#3x<%lO#0]7P#1|UT1e'g&jOY%}Z#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}7P#2eZ'g&jOY#0]YZ#0]Z]#0]]^#3W^z#0]z{#0}{#O#0]#O#P#2`#P;'S#0];'S;=`#3x<%lO#0]7P#3]X'g&jOY#0]YZ#0]Zz#0]z{#0}{#O#0]#O#P#2`#P;'S#0];'S;=`#3x<%lO#0]7P#3{P;=`<%l#0]7X#4V])[W'g&jOY#/cYZ#.[Zw#/cwx#0]xz#/cz{#4O{!P#/c!P!Q#5O!Q#O#/c#O#P#2`#P;'S#/c;'S;=`#5q<%lO#/c7X#5XW)[WT1e'g&jOY%^Zw%^wx%}x#O%^#O#P&f#P;'S%^;'S;=`'x<%lO%^7X#5tP;=`<%l#/c7R#6OZ(qQ'g&jOY#5wYZ#.[Zr#5wrs#0]sz#5wz{#6q{#O#5w#O#P#2`#P;'S#5w;'S;=`#8d<%lO#5w7R#6x](qQ'g&jOY#5wYZ#.[Zr#5wrs#0]sz#5wz{#6q{!P#5w!P!Q#7q!Q#O#5w#O#P#2`#P;'S#5w;'S;=`#8d<%lO#5w7R#7zW(qQT1e'g&jOY(OZr(Ors%}s#O(O#O#P&f#P;'S(O;'S;=`(o<%lO(O7R#8gP;=`<%l#5w7Z#8s_)[W(qQ'g&jOY#-YYZ#.[Zr#-Yrs#/csw#-Ywx#5wxz#-Yz{#8j{!P#-Y!P!Q#9r!Q#O#-Y#O#P#2`#P;'S#-Y;'S;=`#:m<%lO#-Y7Z#9}Y)[W(qQT1e'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e7Z#:pP;=`<%l#-Y7Z#;OY)[W(qQS1e'g&jOY#:sZr#:srs#;nsw#:swx#@{x#O#:s#O#P#<z#P;'S#:s;'S;=`#At<%lO#:s7X#;wW)[WS1e'g&jOY#;nZw#;nwx#<ax#O#;n#O#P#<z#P;'S#;n;'S;=`#@u<%lO#;n7P#<hUS1e'g&jOY#<aZ#O#<a#O#P#<z#P;'S#<a;'S;=`#>[<%lO#<a7P#=RXS1e'g&jOY#<aYZ%}Z]#<a]^#=n^#O#<a#O#P#>b#P;'S#<a;'S;=`#>[<%lO#<a7P#=uVS1e'g&jOY#<aYZ%}Z#O#<a#O#P#<z#P;'S#<a;'S;=`#>[<%lO#<a7P#>_P;=`<%l#<a7P#>i]S1e'g&jOY#<aYZ%}Z]#<a]^#=n^#O#<a#O#P#>b#P#b#<a#b#c#<a#c#f#<a#f#g#?b#g;'S#<a;'S;=`#>[<%lO#<a7P#?iUS1e'g&jOY#<aZ#O#<a#O#P#?{#P;'S#<a;'S;=`#>[<%lO#<a7P#@SZS1e'g&jOY#<aYZ%}Z]#<a]^#=n^#O#<a#O#P#>b#P#b#<a#b#c#<a#c;'S#<a;'S;=`#>[<%lO#<a7X#@xP;=`<%l#;n7R#AUW(qQS1e'g&jOY#@{Zr#@{rs#<as#O#@{#O#P#<z#P;'S#@{;'S;=`#An<%lO#@{7R#AqP;=`<%l#@{7Z#AwP;=`<%l#:s2]#BVt)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx#Dgx!O$e!O!P$ m!P!Q$e!Q![$(x![!g$e!g!h#$w!h!i#*Y!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#U$e#U#V$+X#V#X$e#X#Y#$w#Y#Z#*Y#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j#l$e#l#m$=`#m;'S$e;'S;=`(u<%lO$e2T#DnY(qQ'g&jOY(OZr(Ors%}s!Q(O!Q![#E^![#O(O#O#P&f#P;'S(O;'S;=`(o<%lO(O2T#Egp(qQ!i,g'g&jOY(OZr(Ors%}sw(Owx#Dgx!O(O!O!P#Gk!P!Q(O!Q![#E^![!g(O!g!h!La!h!i##`!i!n(O!n!o##`!o!r(O!r!s!La!s!w(O!w!x##`!x#O(O#O#P&f#P#X(O#X#Y!La#Y#Z##`#Z#`(O#`#a##`#a#d(O#d#e!La#e#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2T#Gtn(qQ!i,g'g&jOY(OZr(Ors%}s!Q(O!Q![#Ir![!c(O!c!g#Ir!g!h#MS!h!i#Ir!i!n(O!n!o##`!o!r(O!r!s!La!s!w(O!w!x##`!x#O(O#O#P&f#P#T(O#T#X#Ir#X#Y#MS#Y#Z#Ir#Z#`(O#`#a##`#a#d(O#d#e!La#e#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2T#I{p(qQ!i,g'g&jOY(OZr(Ors%}sw(Owx#LPx!Q(O!Q![#Ir![!c(O!c!g#Ir!g!h#MS!h!i#Ir!i!n(O!n!o##`!o!r(O!r!s!La!s!w(O!w!x##`!x#O(O#O#P&f#P#T(O#T#X#Ir#X#Y#MS#Y#Z#Ir#Z#`(O#`#a##`#a#d(O#d#e!La#e#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2T#LW^(qQ'g&jOY(OZr(Ors%}s!Q(O!Q![#Ir![!c(O!c!i#Ir!i#O(O#O#P&f#P#T(O#T#Z#Ir#Z;'S(O;'S;=`(o<%lO(O2T#M]t(qQ!i,g'g&jOY(OZr(Ors%}sw(Owx#LPx{(O{|!Nb|}(O}!O!Nb!O!Q(O!Q![#Ir![!c(O!c!g#Ir!g!h#MS!h!i#Ir!i!n(O!n!o##`!o!r(O!r!s!La!s!w(O!w!x##`!x#O(O#O#P&f#P#T(O#T#X#Ir#X#Y#MS#Y#Z#Ir#Z#`(O#`#a##`#a#d(O#d#e!La#e#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2]$ xp)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![$#|![!c$e!c!g$#|!g!h$&]!h!i$#|!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#X$#|#X#Y$&]#Y#Z$#|#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2]$$Xp)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx#LPx!Q$e!Q![$#|![!c$e!c!g$#|!g!h$&]!h!i$#|!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#X$#|#X#Y$&]#Y#Z$#|#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2]$&ht)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx#LPx{$e{|#'Q|}$e}!O#'Q!O!Q$e!Q![$#|![!c$e!c!g$#|!g!h$&]!h!i$#|!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#X$#|#X#Y$&]#Y#Z$#|#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2]$)Tp)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx#Dgx!O$e!O!P$ m!P!Q$e!Q![$(x![!g$e!g!h#$w!h!i#*Y!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#X$e#X#Y#$w#Y#Z#*Y#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2]$+b_)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox!O$e!O!P$,a!P!Q$e!Q!R$-`!R![$(x![#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2]$,j[)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![!GY![#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2]$-kt)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx#Dgx!O$e!O!P$ m!P!Q$e!Q![$(x![!g$e!g!h#$w!h!i#*Y!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#U$e#U#V$/{#V#X$e#X#Y#$w#Y#Z#*Y#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j#l$e#l#m$0z#m;'S$e;'S;=`(u<%lO$e2]$0U[)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![$(x![#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2]$1T`)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![$2V![!c$e!c!i$2V!i#O$e#O#P&f#P#T$e#T#Z$2V#Z;'S$e;'S;=`(u<%lO$e2]$2br)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx$4lx!O$e!O!P$ m!P!Q$e!Q![$2V![!c$e!c!g$2V!g!h$:p!h!i$2V!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#X$2V#X#Y$:p#Y#Z$2V#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2T$4s^(qQ'g&jOY(OZr(Ors%}s!Q(O!Q![$5o![!c(O!c!i$5o!i#O(O#O#P&f#P#T(O#T#Z$5o#Z;'S(O;'S;=`(o<%lO(O2T$5xr(qQ!i,g'g&jOY(OZr(Ors%}sw(Owx$4lx!O(O!O!P#Gk!P!Q(O!Q![$5o![!c(O!c!g$5o!g!h$8S!h!i$5o!i!n(O!n!o##`!o!r(O!r!s!La!s!w(O!w!x##`!x#O(O#O#P&f#P#T(O#T#X$5o#X#Y$8S#Y#Z$5o#Z#`(O#`#a##`#a#d(O#d#e!La#e#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2T$8]u(qQ!i,g'g&jOY(OZr(Ors%}sw(Owx$4lx{(O{|!Nb|}(O}!O!Nb!O!P#Gk!P!Q(O!Q![$5o![!c(O!c!g$5o!g!h$8S!h!i$5o!i!n(O!n!o##`!o!r(O!r!s!La!s!w(O!w!x##`!x#O(O#O#P&f#P#T(O#T#X$5o#X#Y$8S#Y#Z$5o#Z#`(O#`#a##`#a#d(O#d#e!La#e#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2]$:{u)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx$4lx{$e{|#'Q|}$e}!O#'Q!O!P$ m!P!Q$e!Q![$2V![!c$e!c!g$2V!g!h$:p!h!i$2V!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#X$2V#X#Y$:p#Y#Z$2V#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2]$=ic)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox!O$e!O!P$,a!P!Q$e!Q!R$>t!R![$2V![!c$e!c!i$2V!i#O$e#O#P&f#P#T$e#T#Z$2V#Z;'S$e;'S;=`(u<%lO$e2]$?Pv)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx$4lx!O$e!O!P$ m!P!Q$e!Q![$2V![!c$e!c!g$2V!g!h$:p!h!i$2V!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#U$2V#U#V$2V#V#X$2V#X#Y$:p#Y#Z$2V#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j#l$e#l#m$0z#m;'S$e;'S;=`(u<%lO$e4e$Ar[(w-X)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox![$e![!]$Bh!]#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3s$BsYl-})[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2]$CnY)X,g)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e7V$Dk_p,g%^!b)[W(qQ'g&jOY$EjYZ$FlZr$Ejrs$GZsw$Ejwx%)Px!^$Ej!^!_%+w!_!`%.U!`!a%0]!a#O$Ej#O#P$Ib#P;'S$Ej;'S;=`%+q<%lO$Ej*[$Es])[W(qQ'g&jOY$EjYZ$FlZr$Ejrs$GZsw$Ejwx%)Px!`$Ej!`!a%*t!a#O$Ej#O#P$Ib#P;'S$Ej;'S;=`%+q<%lO$Ejp$FoTO!`$Fl!`!a$GO!a;'S$Fl;'S;=`$GT<%lO$Flp$GTO$Xpp$GWP;=`<%l$Fl*Y$GbZ)[W'g&jOY$GZYZ$FlZw$GZwx$HTx!`$GZ!`!a%(U!a#O$GZ#O#P$Ib#P;'S$GZ;'S;=`%(y<%lO$GZ*Q$HYX'g&jOY$HTYZ$FlZ!`$HT!`!a$Hu!a#O$HT#O#P$Ib#P;'S$HT;'S;=`$Mx<%lO$HT*Q$IOU$XpY#t'g&jOY%}Z#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}*Q$Ig['g&jOY$HTYZ$HTZ]$HT]^$J]^!`$HT!`!a$NO!a#O$HT#O#P%&n#P;'S$HT;'S;=`%'f;=`<%l%$z<%lO$HT*Q$JbX'g&jOY$HTYZ$J}Z!`$HT!`!a$Hu!a#O$HT#O#P$Ib#P;'S$HT;'S;=`$Mx<%lO$HT'[$KSX'g&jOY$J}YZ$FlZ!`$J}!`!a$Ko!a#O$J}#O#P$LY#P;'S$J};'S;=`$Mr<%lO$J}'[$KvU$Xp'g&jOY%}Z#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}'[$L_Z'g&jOY$J}YZ$J}Z]$J}]^$MQ^!`$J}!`!a$Ko!a#O$J}#O#P$LY#P;'S$J};'S;=`$Mr<%lO$J}'[$MVX'g&jOY$J}YZ$J}Z!`$J}!`!a$Ko!a#O$J}#O#P$LY#P;'S$J};'S;=`$Mr<%lO$J}'[$MuP;=`<%l$J}*Q$M{P;=`<%l$HT*Q$NVW$Xp'g&jOY$NoZ!`$No!`!a% ^!a#O$No#O#P% w#P;'S$No;'S;=`%#^<%lO$No)`$NtW'g&jOY$NoZ!`$No!`!a% ^!a#O$No#O#P% w#P;'S$No;'S;=`%#^<%lO$No)`% eUY#t'g&jOY%}Z#O%}#O#P&f#P;'S%};'S;=`'r<%lO%})`% |Y'g&jOY$NoYZ$NoZ]$No]^%!l^#O$No#O#P%#d#P;'S$No;'S;=`%$[;=`<%l%$z<%lO$No)`%!qX'g&jOY$NoYZ%}Z!`$No!`!a% ^!a#O$No#O#P% w#P;'S$No;'S;=`%#^<%lO$No)`%#aP;=`<%l$No)`%#iZ'g&jOY$NoYZ%}Z]$No]^%!l^!`$No!`!a% ^!a#O$No#O#P% w#P;'S$No;'S;=`%#^<%lO$No)`%$_XOY%$zZ!`%$z!`!a%%g!a#O%$z#O#P%%l#P;'S%$z;'S;=`%&h;=`<%l$No<%lO%$z#t%$}WOY%$zZ!`%$z!`!a%%g!a#O%$z#O#P%%l#P;'S%$z;'S;=`%&h<%lO%$z#t%%lOY#t#t%%oRO;'S%$z;'S;=`%%x;=`O%$z#t%%{XOY%$zZ!`%$z!`!a%%g!a#O%$z#O#P%%l#P;'S%$z;'S;=`%&h;=`<%l%$z<%lO%$z#t%&kP;=`<%l%$z*Q%&sZ'g&jOY$HTYZ$J}Z]$HT]^$J]^!`$HT!`!a$Hu!a#O$HT#O#P$Ib#P;'S$HT;'S;=`$Mx<%lO$HT*Q%'iXOY%$zZ!`%$z!`!a%%g!a#O%$z#O#P%%l#P;'S%$z;'S;=`%&h;=`<%l$HT<%lO%$z*Y%(aW$XpY#t)[W'g&jOY%^Zw%^wx%}x#O%^#O#P&f#P;'S%^;'S;=`'x<%lO%^*Y%(|P;=`<%l$GZ*S%)WZ(qQ'g&jOY%)PYZ$FlZr%)Prs$HTs!`%)P!`!a%)y!a#O%)P#O#P$Ib#P;'S%)P;'S;=`%*n<%lO%)P*S%*UW$XpY#t(qQ'g&jOY(OZr(Ors%}s#O(O#O#P&f#P;'S(O;'S;=`(o<%lO(O*S%*qP;=`<%l%)P*[%+RY$XpY#t)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e*[%+tP;=`<%l$Ej7V%,U^)[W(qQ%]!b!f,g'g&jOY$EjYZ$FlZr$Ejrs$GZsw$Ejwx%)Px!_$Ej!_!`%-Q!`!a%*t!a#O$Ej#O#P$Ib#P;'S$Ej;'S;=`%+q<%lO$Ej7V%-]]!g-y)[W(qQ'g&jOY$EjYZ$FlZr$Ejrs$GZsw$Ejwx%)Px!`$Ej!`!a%*t!a#O$Ej#O#P$Ib#P;'S$Ej;'S;=`%+q<%lO$Ej7V%.c]%^!b!b,g)[W(qQ'g&jOY$EjYZ$FlZr$Ejrs$GZsw$Ejwx%)Px!`$Ej!`!a%/[!a#O$Ej#O#P$Ib#P;'S$Ej;'S;=`%+q<%lO$Ej7V%/mY%^!b!b,g$XpY#t)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e)j%0hYY#t)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o%1c[)k!c)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox!_$e!_!`0Q!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o%2f]%^!b)[W(qQ!d,g'g&jOY$eZr$ers%^sw$ewx(Ox!_$e!_!`%3_!`!a%4[!a#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o%3lY%^!b!b,g)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o%4i[)[W(qQ%]!b!f,g'g&jOY$eZr$ers%^sw$ewx(Ox!_$e!_!`!8g!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e&u%5jY(vP)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e7Z%6ib)[W(zS(qQ!R,f(s%y'g&jOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![%6Y![!c$e!c!}%6Y!}#O$e#O#P&f#P#R$e#R#S%6Y#S#T$e#T#o%6Y#o;'S$e;'S;=`(u<%lO$e7Z%8Qb)[W(zS(qQ!R,f(s%y'g&jOY$eZr$ers%9Ysw$ewx%9{x!Q$e!Q![%6Y![!c$e!c!}%6Y!}#O$e#O#P&f#P#R$e#R#S%6Y#S#T$e#T#o%6Y#o;'S$e;'S;=`(u<%lO$e5P%9cW)[W(p/]'g&jOY%^Zw%^wx%}x#O%^#O#P&f#P;'S%^;'S;=`'x<%lO%^2T%:UW(qQ)Z,g'g&jOY(OZr(Ors%}s#O(O#O#P&f#P;'S(O;'S;=`(o<%lO(O3o%:yZ!V-y)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox!}$e!}#O%;l#O#P&f#P;'S$e;'S;=`(u<%lO$e&u%;wY)QP)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e4e%<la'g&jOY%=qYZ%>[Z]%=q]^%?Z^!Q%=q!Q![%?w![!w%=q!w!x%AX!x#O%=q#O#P%H_#P#i%=q#i#j%Ds#j#l%=q#l#m%IR#m;'S%=q;'S;=`%Kt<%lO%=q&t%=xUXY'g&jOY%}Z#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}4e%>e[XY(o.o'g&jOX%}XY-OYZ*[Z]%}]^-O^p%}pq-Oq#O%}#O#P,^#P;'S%};'S;=`'r<%lO%}4e%?bVXY'g&jOY%}YZ-OZ#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}&t%@OWXY'g&jOY%}Z!Q%}!Q![%@h![#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}&t%@oWXY'g&jOY%}Z!Q%}!Q![%=q![#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}&t%A^['g&jOY%}Z!Q%}!Q![%BS![!c%}!c!i%BS!i#O%}#O#P&f#P#T%}#T#Z%BS#Z;'S%};'S;=`'r<%lO%}&t%BX['g&jOY%}Z!Q%}!Q![%B}![!c%}!c!i%B}!i#O%}#O#P&f#P#T%}#T#Z%B}#Z;'S%};'S;=`'r<%lO%}&t%CS['g&jOY%}Z!Q%}!Q![%Cx![!c%}!c!i%Cx!i#O%}#O#P&f#P#T%}#T#Z%Cx#Z;'S%};'S;=`'r<%lO%}&t%C}['g&jOY%}Z!Q%}!Q![%Ds![!c%}!c!i%Ds!i#O%}#O#P&f#P#T%}#T#Z%Ds#Z;'S%};'S;=`'r<%lO%}&t%Dx['g&jOY%}Z!Q%}!Q![%En![!c%}!c!i%En!i#O%}#O#P&f#P#T%}#T#Z%En#Z;'S%};'S;=`'r<%lO%}&t%Es['g&jOY%}Z!Q%}!Q![%Fi![!c%}!c!i%Fi!i#O%}#O#P&f#P#T%}#T#Z%Fi#Z;'S%};'S;=`'r<%lO%}&t%Fn['g&jOY%}Z!Q%}!Q![%Gd![!c%}!c!i%Gd!i#O%}#O#P&f#P#T%}#T#Z%Gd#Z;'S%};'S;=`'r<%lO%}&t%Gi['g&jOY%}Z!Q%}!Q![%=q![!c%}!c!i%=q!i#O%}#O#P&f#P#T%}#T#Z%=q#Z;'S%};'S;=`'r<%lO%}&t%HfXXY'g&jOY%}YZ%}Z]%}]^'W^#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}&t%IW['g&jOY%}Z!Q%}!Q![%I|![!c%}!c!i%I|!i#O%}#O#P&f#P#T%}#T#Z%I|#Z;'S%};'S;=`'r<%lO%}&t%JR['g&jOY%}Z!Q%}!Q![%Jw![!c%}!c!i%Jw!i#O%}#O#P&f#P#T%}#T#Z%Jw#Z;'S%};'S;=`'r<%lO%}&t%KO[XY'g&jOY%}Z!Q%}!Q![%Jw![!c%}!c!i%Jw!i#O%}#O#P&f#P#T%}#T#Z%Jw#Z;'S%};'S;=`'r<%lO%}&t%KwP;=`<%l%=q2a%LVZ!W,V)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P#Q%Lx#Q;'S$e;'S;=`(u<%lO$e'Y%MTY)^d)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o%NQ[)[W(qQ%]!b'g&j!_,gOY$eZr$ers%^sw$ewx(Ox!_$e!_!`!8g!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e7Z& Vd)[W(zS(qQ!R,f(s%y'g&jOY$eZr$ers%9Ysw$ewx%9{x!Q$e!Q!Y%6Y!Y!Z%7q!Z![%6Y![!c$e!c!}%6Y!}#O$e#O#P&f#P#R$e#R#S%6Y#S#T$e#T#o%6Y#o;'S$e;'S;=`(u<%lO$e2]&!pY!T,g)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o&#m^)[W(qQ%]!b'g&j!^,gOY$eZr$ers%^sw$ewx(Ox!_$e!_!`!8g!`#O$e#O#P&f#P#p$e#p#q&$i#q;'S$e;'S;=`(u<%lO$e3o&$vY)U,g%_!b)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e'V&%qY!Ua)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e(]&&nc)[W(qQ%]!b'SP'g&jOX$eXY&'yZp$epq&'yqr$ers%^sw$ewx(Ox!c$e!c!}&)_!}#O$e#O#P&f#P#R$e#R#S&)_#S#T$e#T#o&)_#o;'S$e;'S;=`(u<%lO$e&y&(Sc)[W(qQ'g&jOX$eXY&'yZp$epq&'yqr$ers%^sw$ewx(Ox!c$e!c!}&)_!}#O$e#O#P&f#P#R$e#R#S&)_#S#T$e#T#o&)_#o;'S$e;'S;=`(u<%lO$e&y&)jb)[W(qQdT'g&jOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![&)_![!c$e!c!}&)_!}#O$e#O#P&f#P#R$e#R#S&)_#S#T$e#T#o&)_#o;'S$e;'S;=`(u<%lO$e",
  tokenizers: [mz, Sz, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
  topRules: { Program: [0, 308] },
  dynamicPrecedences: { 87: 1, 94: 1, 119: 1, 185: 1, 188: -10, 241: -10, 242: 1, 245: -1, 247: -10, 248: 1, 263: -1, 268: 2, 269: 2, 307: -10, 366: 3, 418: 1, 419: 3, 420: 1, 421: 1 },
  specialized: [{ term: 357, get: (t) => yz[t] || -1 }, { term: 32, get: (t) => bz[t] || -1 }, { term: 66, get: (t) => vz[t] || -1 }, { term: 364, get: (t) => Xz[t] || -1 }],
  tokenPrec: 24905
});
var wz = Kt.define({
  name: "cpp",
  parser: xz.configure({
    props: [
      ci.add({
        IfStatement: gt({ except: /^\s*({|else\b)/ }),
        TryStatement: gt({ except: /^\s*({|catch)\b/ }),
        LabeledStatement: Ep,
        CaseStatement: (t) => t.baseIndent + t.unit,
        BlockComment: () => null,
        CompoundStatement: dO({ closing: "}" }),
        Statement: gt({ except: /^{/ })
      }),
      ui.add({
        "DeclarationList CompoundStatement EnumeratorList FieldDeclarationList InitializerList": Mn,
        BlockComment(t) {
          return { from: t.from + 2, to: t.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\})$/,
    closeBrackets: { stringPrefixes: ["L", "u", "U", "u8", "LR", "UR", "uR", "u8R", "R"] }
  }
});
function Tz() {
  return new li(wz);
}
var kz = 1;
var _z = 2;
var Wz = 263;
var Yz = 3;
var Rz = 264;
var $S = 265;
var Zz = 266;
var Uz = 4;
var Vz = 5;
var qz = 6;
var zz = 7;
var QS = 8;
var Cz = 9;
var Ez = 10;
var jz = 11;
var Iz = 12;
var Az = 13;
var Gz = 14;
var Lz = 15;
var Dz = 16;
var Mz = 17;
var Nz = 18;
var Bz = 19;
var Fz = 20;
var Hz = 21;
var Kz = 22;
var Jz = 23;
var eC = 24;
var tC = 25;
var iC = 26;
var nC = 27;
var OC = 28;
var rC = 29;
var aC = 30;
var oC = 31;
var sC = 32;
var lC = 33;
var cC = 34;
var uC = 35;
var fC = 36;
var hC = 37;
var dC = 38;
var pC = 39;
var $C = 40;
var QC = 41;
var gC = 42;
var mC = 43;
var SC = 44;
var PC = 45;
var yC = 46;
var bC = 47;
var vC = 48;
var XC = 49;
var xC = 50;
var wC = 51;
var TC = 52;
var kC = 53;
var _C = 54;
var WC = 55;
var YC = 56;
var RC = 57;
var ZC = 58;
var UC = 59;
var VC = 60;
var qC = 61;
var vf = 62;
var zC = 63;
var CC = 64;
var EC = 65;
var jC = {
  abstract: Uz,
  and: Vz,
  array: qz,
  as: zz,
  true: QS,
  false: QS,
  break: Cz,
  case: Ez,
  catch: jz,
  clone: Iz,
  const: Az,
  continue: Gz,
  declare: Dz,
  default: Lz,
  do: Mz,
  echo: Nz,
  else: Bz,
  elseif: Fz,
  enddeclare: Hz,
  endfor: Kz,
  endforeach: Jz,
  endif: eC,
  endswitch: tC,
  endwhile: iC,
  enum: nC,
  extends: OC,
  final: rC,
  finally: aC,
  fn: oC,
  for: sC,
  foreach: lC,
  from: cC,
  function: uC,
  global: fC,
  goto: hC,
  if: dC,
  implements: pC,
  include: $C,
  include_once: QC,
  instanceof: gC,
  insteadof: mC,
  interface: SC,
  list: PC,
  match: yC,
  namespace: bC,
  new: vC,
  null: XC,
  or: xC,
  print: wC,
  require: TC,
  require_once: kC,
  return: _C,
  switch: WC,
  throw: YC,
  trait: RC,
  try: ZC,
  unset: UC,
  use: VC,
  var: qC,
  public: vf,
  private: vf,
  protected: vf,
  while: zC,
  xor: CC,
  yield: EC,
  __proto__: null
};
function gS(t) {
  let e = jC[t.toLowerCase()];
  return e ?? -1;
}
function mS(t) {
  return t == 9 || t == 10 || t == 13 || t == 32;
}
function WX(t) {
  return t >= 97 && t <= 122 || t >= 65 && t <= 90;
}
function To(t) {
  return t == 95 || t >= 128 || WX(t);
}
function Xf(t) {
  return t >= 48 && t <= 55 || t >= 97 && t <= 102 || t >= 65 && t <= 70;
}
var IC = {
  int: true,
  integer: true,
  bool: true,
  boolean: true,
  float: true,
  double: true,
  real: true,
  string: true,
  array: true,
  object: true,
  unset: true,
  __proto__: null
};
var AC = new Ie((t) => {
  if (t.next == 40) {
    t.advance();
    let e = 0;
    for (; mS(t.peek(e)); )
      e++;
    let i = "", n;
    for (; WX(n = t.peek(e)); )
      i += String.fromCharCode(n), e++;
    for (; mS(t.peek(e)); )
      e++;
    t.peek(e) == 41 && IC[i.toLowerCase()] && t.acceptToken(kz);
  } else if (t.next == 60 && t.peek(1) == 60 && t.peek(2) == 60) {
    for (let n = 0; n < 3; n++)
      t.advance();
    for (; t.next == 32 || t.next == 9; )
      t.advance();
    let e = t.next == 39;
    if (e && t.advance(), !To(t.next))
      return;
    let i = String.fromCharCode(t.next);
    for (; t.advance(), !(!To(t.next) && !(t.next >= 48 && t.next <= 55)); )
      i += String.fromCharCode(t.next);
    if (e) {
      if (t.next != 39)
        return;
      t.advance();
    }
    if (t.next != 10 && t.next != 13)
      return;
    for (; ; ) {
      let n = t.next == 10 || t.next == 13;
      if (t.advance(), t.next < 0)
        return;
      if (n) {
        for (; t.next == 32 || t.next == 9; )
          t.advance();
        let O = true;
        for (let r = 0; r < i.length; r++) {
          if (t.next != i.charCodeAt(r)) {
            O = false;
            break;
          }
          t.advance();
        }
        if (O)
          return t.acceptToken(_z);
      }
    }
  }
});
var GC = new Ie((t) => {
  t.next < 0 && t.acceptToken(Zz);
});
var LC = new Ie((t, e) => {
  t.next == 63 && e.canShift($S) && t.peek(1) == 62 && t.acceptToken($S);
});
function DC(t) {
  let e = t.peek(1);
  if (e == 110 || e == 114 || e == 116 || e == 118 || e == 101 || e == 102 || e == 92 || e == 36 || e == 34 || e == 123)
    return 2;
  if (e >= 48 && e <= 55) {
    let i = 2, n;
    for (; i < 5 && (n = t.peek(i)) >= 48 && n <= 55; )
      i++;
    return i;
  }
  if (e == 120 && Xf(t.peek(2)))
    return Xf(t.peek(3)) ? 4 : 3;
  if (e == 117 && t.peek(2) == 123)
    for (let i = 3; ; i++) {
      let n = t.peek(i);
      if (n == 125)
        return i == 2 ? 0 : i + 1;
      if (!Xf(n))
        break;
    }
  return 0;
}
var MC = new Ie((t, e) => {
  let i = false;
  for (; !(t.next == 34 || t.next < 0 || t.next == 36 && (To(t.peek(1)) || t.peek(1) == 123) || t.next == 123 && t.peek(1) == 36); i = true) {
    if (t.next == 92) {
      let n = DC(t);
      if (n) {
        if (i)
          break;
        return t.acceptToken(Yz, n);
      }
    } else if (!i && (t.next == 91 || t.next == 45 && t.peek(1) == 62 && To(t.peek(2)) || t.next == 63 && t.peek(1) == 45 && t.peek(2) == 62 && To(t.peek(3))) && e.canShift(Rz))
      break;
    t.advance();
  }
  i && t.acceptToken(Wz);
});
var NC = ti({
  "Visibility abstract final static": f.modifier,
  "for foreach while do if else elseif switch try catch finally return throw break continue default case": f.controlKeyword,
  "endif endfor endforeach endswitch endwhile declare enddeclare goto match": f.controlKeyword,
  "and or xor yield unset clone instanceof insteadof": f.operatorKeyword,
  "function fn class trait implements extends const enum global interface use var": f.definitionKeyword,
  "include include_once require require_once namespace": f.moduleKeyword,
  "new from echo print array list as": f.keyword,
  null: f.null,
  Boolean: f.bool,
  VariableName: f.variableName,
  "NamespaceName/...": f.namespace,
  "NamedType/...": f.typeName,
  Name: f.name,
  "CallExpression/Name": f.function(f.variableName),
  "LabelStatement/Name": f.labelName,
  "MemberExpression/Name": f.propertyName,
  "MemberExpression/VariableName": f.special(f.propertyName),
  "ScopedExpression/ClassMemberName/Name": f.propertyName,
  "ScopedExpression/ClassMemberName/VariableName": f.special(f.propertyName),
  "CallExpression/MemberExpression/Name": f.function(f.propertyName),
  "CallExpression/ScopedExpression/ClassMemberName/Name": f.function(f.propertyName),
  "MethodDeclaration/Name": f.function(f.definition(f.variableName)),
  "FunctionDefinition/Name": f.function(f.definition(f.variableName)),
  "ClassDeclaration/Name": f.definition(f.className),
  UpdateOp: f.updateOperator,
  ArithOp: f.arithmeticOperator,
  LogicOp: f.logicOperator,
  BitOp: f.bitwiseOperator,
  CompareOp: f.compareOperator,
  ControlOp: f.controlOperator,
  AssignOp: f.definitionOperator,
  "$ ConcatOp": f.operator,
  LineComment: f.lineComment,
  BlockComment: f.blockComment,
  Integer: f.integer,
  Float: f.float,
  String: f.string,
  ShellExpression: f.special(f.string),
  "=> ->": f.punctuation,
  "( )": f.paren,
  "#[ [ ]": f.squareBracket,
  "${ { }": f.brace,
  "-> ?->": f.derefOperator,
  ", ; :: : \\": f.separator,
  "PhpOpen PhpClose": f.processingInstruction
});
var BC = { __proto__: null, static: 311, STATIC: 311, class: 333, CLASS: 333 };
var FC = Jt.deserialize({
  version: 14,
  states: "$GSQ`OWOOQhQaOOP%oO`OOOOO#t'#H_'#H_O%tO#|O'#DtOOO#u'#Dw'#DwQ&SOWO'#DwO&XO$VOOOOQ#u'#Dx'#DxO&lQaO'#D|O(mQdO'#E}O(tQdO'#EQO*kQaO'#EWO,zQ`O'#ETO-PQ`O'#E^O/nQaO'#E^O/uQ`O'#EfO/zQ`O'#EoO*kQaO'#EoO0VQ`O'#HhO0[Q`O'#E{O0[Q`O'#E{OOQS'#Ic'#IcO0aQ`O'#EvOOQS'#IZ'#IZO2oQdO'#IWO6tQeO'#FUO*kQaO'#FeO*kQaO'#FfO*kQaO'#FgO*kQaO'#FhO*kQaO'#FhO*kQaO'#FkOOQO'#Id'#IdO7RQ`O'#FqOOQO'#Hi'#HiO7ZQ`O'#HOO7uQ`O'#FlO8QQ`O'#H]O8]Q`O'#FvO8eQaO'#FwO*kQaO'#GVO*kQaO'#GYO8}OrO'#G]OOQS'#Iq'#IqOOQS'#Ip'#IpOOQS'#IW'#IWO,zQ`O'#GdO,zQ`O'#GfO,zQ`O'#GkOhQaO'#GmO9UQ`O'#GnO9ZQ`O'#GqO9`Q`O'#GtO9eQeO'#GuO9eQeO'#GvO9eQeO'#GwO9oQ`O'#GxO9tQ`O'#GzO9yQaO'#G{O<YQ`O'#G|O<_Q`O'#G}O<dQ`O'#G}O9oQ`O'#HOO<iQ`O'#HQO<nQ`O'#HRO<sQ`O'#HSO<xQ`O'#HVO=TQ`O'#HWO9yQaO'#H[OOQ#u'#IV'#IVOOQ#u'#Ha'#HaQhQaOOO=fQ`O'#HPO7pQ`O'#HPO=kO#|O'#DrPOOO)CCw)CCwOOO#t-E;]-E;]OOO#u,5:c,5:cOOO#u'#H`'#H`O&XO$VOOO=vQ$VO'#IUOOOO'#IU'#IUQOOOOOOOQ#y,5:h,5:hO=}QaO,5:hOOQ#u,5:j,5:jO@eQaO,5:mO@lQaO,5;UO*kQaO,5;UO@sQ`O,5;VOCbQaO'#EsOOQS,5;^,5;^OCiQ`O,5;jOOQP'#F]'#F]O*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qOOQ#u'#Im'#ImOOQS,5<q,5<qOOQ#u,5:l,5:lOEbQ`O,5:rOEiQdO'#E}OF]Q`O'#FlOFeQ`O'#FlOFmQ`O,5:oOFrQaO'#E_OOQS,5:x,5:xOHyQ`O'#I]O9yQaO'#EaO9yQaO'#I]OOQS'#I]'#I]OIQQ`O'#I[OIYQ`O,5:xO-UQaO,5:xOI_QaO'#EgOOQS,5;Q,5;QOOQS,5;Z,5;ZOIiQ`O,5;ZOOQO,5>S,5>SOJ[QdO,5;gOOQO-E;f-E;fOL^Q`O,5;gOLcQpO,5;bO0aQ`O'#EyOLkQtO'#E}OOQS'#Ez'#EzOOQS'#Ib'#IbOM`QaO,5:wO*kQaO,5;nOOQS,5;p,5;pO*kQaO,5;pOMgQdO,5<POMwQdO,5<QONXQdO,5<RONiQdO,5<SO!!sQdO,5<SO!!zQdO,5<VO!#[Q`O'#FrO!#gQ`O'#IgO!#oQ`O,5<]OOQO-E;g-E;gO!#tQ`O'#IoO<_Q`O,5=iO!#|Q`O,5=iO9oQ`O,5=jO!$RQ`O,5=nO!$WQ`O,5=kO!$]Q`O,5=kO!$bQ`O'#FnO!$xQ`O,5<WO!%TQ`O,5<WO!%WQ`O,5?ZO!%]Q`O,5<WO!%eQ`O,5<bO!%mQdO'#GPO!%{QdO'#InO!&WQdO,5=wO!&`Q`O,5<bO!%WQ`O,5<bO!&hQdO,5<cO!&xQ`O,5<cO!'lQdO,5<qO!)nQdO,5<tO!*OOrO'#HsOOOQ'#It'#ItO*kQaO'#GbOOOQ'#Hs'#HsO!*pOrO,5<wOOQS,5<w,5<wO!*wQaO,5=OO!+OQ`O,5=QO!+WQeO,5=VO!+bQ`O,5=XO!+gQaO'#GoO!+WQeO,5=YO9yQaO'#GrO!+WQeO,5=]O!&WQdO,5=`O(tQdO,5=aOOQ#u,5=a,5=aO(tQdO,5=bOOQ#u,5=b,5=bO(tQdO,5=cOOQ#u,5=c,5=cO!+nQ`O,5=dO!+vQ`O,5=fO!+{QdO'#IvOOQS'#Iv'#IvO!&WQdO,5=gO>UQaO,5=hO!-eQ`O'#F}O!-jQdO'#IlO!&WQdO,5=iOOQ#u,5=j,5=jO!-uQ`O,5=lO!-xQ`O,5=mO!-}Q`O,5=nO!.YQdO,5=qOOQ#u,5=q,5=qO!.eQ`O,5=rO!.eQ`O,5=rO!.mQdO'#IwO!.{Q`O'#HXO!&WQdO,5=rO!/ZQ`O,5=rO!/fQdO'#IYO!&WQdO,5=vOOQ#u-E;_-E;_O!1RQ`O,5=kOOO#u,5:^,5:^O!1^O#|O,5:^OOO#u-E;^-E;^OOOO,5>p,5>pOOQ#y1G0S1G0SO!1fQ`O1G0XO*kQaO1G0XO!2xQ`O1G0pOOQS1G0p1G0pO!4[Q`O1G0pOOQS'#I_'#I_O*kQaO'#I_OOQS1G0q1G0qO!4cQ`O'#IaO!7lQ`O'#E}O!7yQaO'#EuOOQO'#Ia'#IaO!8TQ`O'#I`O!8]Q`O,5;_OOQS'#FQ'#FQOOQS1G1U1G1UO!8bQdO1G1]O!:dQdO1G1]O!<PQdO1G1]O!=lQdO1G1]O!?XQdO1G1]O!@tQdO1G1]O!BaQdO1G1]O!C|QdO1G1]O!EiQdO1G1]O!GUQdO1G1]O!HqQdO1G1]O!J^QdO1G1]O!KyQdO1G1]O!MfQdO1G1]O# RQdO1G1]O#!nQdO1G1]OOQT1G0^1G0^O!%WQ`O,5<WO#$ZQaO'#EXOOQS1G0Z1G0ZO#$bQ`O,5:yOFuQaO,5:yO#$gQaO,5:}O#$nQdO,5:{O#&jQdO,5>wO#(fQaO'#HdO#(vQ`O,5>vOOQS1G0d1G0dO#)OQ`O1G0dO#)TQ`O'#I^O#*mQ`O'#I^O#*uQ`O,5;ROIbQaO,5;ROOQS1G0u1G0uPOQO'#E}'#E}O#+fQdO1G1RO0aQ`O'#HgO#-hQtO,5;cO#.YQaO1G0|OOQS,5;e,5;eO#0iQtO,5;gO#0vQdO1G0cO*kQaO1G0cO#2cQdO1G1YO#4OQdO1G1[OOQO,5<^,5<^O#4`Q`O'#HjO#4nQ`O,5?ROOQO1G1w1G1wO#4vQ`O,5?ZO!&WQdO1G3TO<_Q`O1G3TOOQ#u1G3U1G3UO#4{Q`O1G3YO!1RQ`O1G3VO#5WQ`O1G3VO#5]QpO'#FoO#5kQ`O'#FoO#5{Q`O'#FoO#6WQ`O'#FoO#6`Q`O'#FsO#6eQ`O'#FtOOQO'#If'#IfO#6lQ`O'#IeO#6tQ`O,5<YOOQS1G1r1G1rO0aQ`O1G1rO#6yQ`O1G1rO#7OQ`O1G1rO!%WQ`O1G4uO#7ZQdO1G4uO!%WQ`O1G1rO#7iQ`O1G1|O!%WQ`O1G1|O9yQaO,5<kO#7qQdO'#HqO#8PQdO,5?YOOQ#u1G3c1G3cO*kQaO1G1|O0aQ`O1G1|O#8[QdO1G1}O7RQ`O'#FyO7RQ`O'#FzO#:nQ`O'#F{OOQS1G1}1G1}O!-xQ`O1G1}O!1UQ`O1G1}O!1RQ`O1G1}O#;eO`O,5<xO#;jO`O,5<xO#;uO!bO,5<yO#<TQ`O,5<|OOOQ-E;q-E;qOOQS1G2c1G2cO#<[QaO'#GeO#<uQ$VO1G2jO#AuQ`O1G2jO#BQQ`O'#GgO#B]Q`O'#GjOOQ#u1G2l1G2lO#BhQ`O1G2lOOQ#u'#Gl'#GlOOQ#u'#Iu'#IuOOQ#u1G2q1G2qO#BmQ`O1G2qO,zQ`O1G2sO#BrQaO,5=ZO#ByQ`O,5=ZOOQ#u1G2t1G2tO#COQ`O1G2tO#CTQ`O,5=^OOQ#u1G2w1G2wO#DgQ`O1G2wOOQ#u1G2z1G2zOOQ#u1G2{1G2{OOQ#u1G2|1G2|OOQ#u1G2}1G2}O#DlQ`O'#HxO9oQ`O'#HxO#DqQ$VO1G3OO#IwQ`O1G3QO9yQaO'#HwO#I|QdO,5=[OOQ#u1G3R1G3RO#JXQ`O1G3SO9yQaO,5<iO#J^QdO'#HpO#JlQdO,5?WOOQ#u1G3T1G3TOOQ#u1G3W1G3WO!-xQ`O1G3WOOQ#u1G3X1G3XO#KfQ`O'#HTOOQ#u1G3Y1G3YO#KmQ`O1G3YO0aQ`O1G3YOOQ#u1G3]1G3]O!&WQdO1G3^O#KrQ`O1G3^O#KzQdO'#HzO#L]QdO,5?cO#LhQ`O,5?cO#LmQ`O'#HYO7RQ`O'#HYO#LxQ`O'#IxO#MQQ`O,5=sOOQ#u1G3^1G3^O!.eQ`O1G3^O!.eQ`O1G3^O#MVQeO'#HbO#MgQdO,5>tOOQ#u1G3b1G3bOOQ#u1G3V1G3VO!-xQ`O1G3VO!1UQ`O1G3VOOO#u1G/x1G/xO*kQaO7+%sO#MuQdO7+%sOOQS7+&[7+&[O$ bQ`O,5>yO>UQaO,5;`O$ iQ`O,5;aO$#OQaO'#HfO$#YQ`O,5>zOOQS1G0y1G0yO$#bQ`O'#EYO$#gQ`O'#IXO$#oQ`O,5:sOOQS1G0e1G0eO$#tQ`O1G0eO$#yQ`O1G0iO9yQaO1G0iOOQO,5>O,5>OOOQO-E;b-E;bOOQS7+&O7+&OO>UQaO,5;SO$%`QaO'#HeO$%jQ`O,5>xOOQS1G0m1G0mO$%rQ`O1G0mOOQS,5>R,5>ROOQS-E;e-E;eO$%wQdO7+&hO$'yQtO1G1RO$(WQdO7+%}OOQS1G0i1G0iOOQO,5>U,5>UOOQO-E;h-E;hOOQ#u7+(o7+(oO!&WQdO7+(oOOQ#u7+(t7+(tO#KmQ`O7+(tO0aQ`O7+(tOOQ#u7+(q7+(qO!-xQ`O7+(qO!1UQ`O7+(qO!1RQ`O7+(qO$)sQ`O,5<ZO$*OQ`O,5<ZO$*WQ`O,5<_O$*]QpO,5<ZO>UQaO,5<ZOOQO,5<_,5<_O$*kQpO,5<`O$*sQ`O,5<`O$+OQ`O'#HkO$+iQ`O,5?POOQS1G1t1G1tO$+qQpO7+'^O$+yQ`O'#FuO$,UQ`O7+'^OOQS7+'^7+'^O0aQ`O7+'^O#6yQ`O7+'^O$,^QdO7+*aO0aQ`O7+*aO$,lQ`O7+'^O*kQaO7+'hO0aQ`O7+'hO$,wQ`O7+'hO$-PQdO1G2VOOQS,5>],5>]OOQS-E;o-E;oO$.iQdO7+'hO$.yQpO7+'hO$/RQdO'#IiOOQO,5<e,5<eOOQO,5<f,5<fO$/dQpO'#GOO$/lQ`O'#GOOOQO'#Ik'#IkOOQO'#Ho'#HoO$0]Q`O'#GOO<_Q`O'#F|O!&WQdO'#GOO!.YQdO'#GQO7RQ`O'#GROOQO'#Ij'#IjOOQO'#Hn'#HnO$0yQ`O,5<gOOQ#y,5<g,5<gOOQS7+'i7+'iO!-xQ`O7+'iO!1UQ`O7+'iOOOQ1G2d1G2dO$1pO`O1G2dO$1uO!bO1G2eO$2TO`O'#G`O$2YO`O1G2eOOOQ1G2h1G2hO$2_QaO,5=PO,zQ`O'#HtO$2xQ$VO7+(UOhQaO7+(UO,zQ`O'#HuO$7xQ`O7+(UO!&WQdO7+(UO$8TQ`O7+(UO$8YQaO'#GhO$:iQ`O'#GiOOQO'#Hv'#HvO$:qQ`O,5=ROOQ#u,5=R,5=RO$:|Q`O,5=UO!&WQdO7+(WO!&WQdO7+(]O!&WQdO7+(_O$;XQaO1G2uO$;`Q`O1G2uO$;eQaO1G2uO!&WQdO7+(`O9yQaO1G2xO!&WQdO7+(cO0aQ`O'#GyO9oQ`O,5>dOOQ#u,5>d,5>dOOQ#u-E;v-E;vO$;lQaO7+(lO$<TQdO,5>cOOQS-E;u-E;uO!&WQdO7+(nO$=mQdO1G2TOOQS,5>[,5>[OOQS-E;n-E;nOOQ#u7+(r7+(rO$?nQ`O'#GQO$?uQ`O'#GQO$@ZQ`O'#HUOOQO'#Hy'#HyO$@`Q`O,5=oOOQ#u,5=o,5=oO$@gQpO7+(tOOQ#u7+(x7+(xO!&WQdO7+(xO$@rQdO,5>fOOQS-E;x-E;xO$AQQdO1G4}O$A]Q`O,5=tO$AbQ`O,5=tO$AmQ`O'#H{O$BRQ`O,5?dOOQS1G3_1G3_O#KrQ`O7+(xO$BZQdO,5=|OOQS-E;`-E;`O$CvQdO<<I_OOQS1G4e1G4eO$EcQ`O1G0zOOQO,5>Q,5>QOOQO-E;d-E;dO$8YQaO,5:tO$FxQaO'#HcO$GVQ`O,5>sOOQS1G0_1G0_OOQS7+&P7+&PO$G_Q`O7+&TO$HtQ`O1G0nO$JZQ`O,5>POOQO,5>P,5>POOQO-E;c-E;cOOQS7+&X7+&XOOQS7+&T7+&TOOQ#u<<LZ<<LZOOQ#u<<L`<<L`O$@gQpO<<L`OOQ#u<<L]<<L]O!-xQ`O<<L]O!1UQ`O<<L]O>UQaO1G1uO$KsQ`O1G1uO$LOQ`O1G1yOOQO1G1y1G1yO$LTQ`O1G1uO$L]Q`O1G1uO$MrQ`O1G1zO>UQaO1G1zOOQO,5>V,5>VOOQO-E;i-E;iOOQS<<Jx<<JxO$M}Q`O'#IhO$NVQ`O'#IhO$N[Q`O,5<aO0aQ`O<<JxO$+qQpO<<JxO$NaQ`O<<JxO0aQ`O<<M{O$NiQtO<<M{O#6yQ`O<<JxO$NwQdO<<KSO% XQpO<<KSO*kQaO<<KSO0aQ`O<<KSO% aQdO'#HmO% xQdO,5?TO!&WQdO,5<jO$/dQpO,5<jO%!ZQ`O,5<jO<_Q`O,5<hO!.YQdO,5<lOOQO-E;m-E;mO!&WQdO,5<hOOQO,5<j,5<jOOQO,5<l,5<lO%!tQdO,5<mOOQO-E;l-E;lOOQ#y1G2R1G2ROOQS<<KT<<KTO!-xQ`O<<KTOOOQ7+(O7+(OO%#PO`O7+(POOOO,5<z,5<zOOOQ7+(P7+(POhQaO,5>`OOQ#u-E;r-E;rOhQaO<<KpOOQ#u<<Kp<<KpO$8TQ`O,5>aOOQO-E;s-E;sO!&WQdO<<KpO$8TQ`O<<KpO%#UQ`O<<KpO%#ZQ`O,5=SO%$pQaO,5=TOOQO-E;t-E;tOOQ#u1G2m1G2mOOQ#u<<Kr<<KrOOQ#u<<Kw<<KwOOQ#u<<Ky<<KyOOQT7+(a7+(aO%%QQ`O7+(aO%%VQaO7+(aO%%^Q`O7+(aOOQ#u<<Kz<<KzO%%cQ`O7+(dO%&xQ`O7+(dOOQ#u<<K}<<K}O%&}QpO,5=eOOQ#u1G4O1G4OO%'YQ`O<<LWOOQ#u<<LY<<LYO$?uQ`O,5<lO%'_Q`O,5=pO%'dQdO,5=pOOQO-E;w-E;wOOQ#u1G3Z1G3ZO#KmQ`O<<L`OOQ#u<<Ld<<LdO%'oQ`O1G4QO%'tQdO7+*iOOQO1G3`1G3`O%(PQ`O1G3`O%(UQ`O'#HZO7RQ`O'#HZOOQO,5>g,5>gOOQO-E;y-E;yO!&WQdO<<LdO%(aQ`O1G0`OOQO,5=},5=}OOQO-E;a-E;aO>UQaO,5;TOOQ#uANAzANAzO#KmQ`OANAzOOQ#uANAwANAwO!-xQ`OANAwO%)vQ`O7+'aO>UQaO7+'aOOQO7+'e7+'eO%+]Q`O7+'aO%+hQ`O7+'eO>UQaO7+'fO%+mQ`O7+'fO%-SQ`O'#HlO%-bQ`O,5?SO%-bQ`O,5?SOOQO1G1{1G1{O$+qQpOAN@dOOQSAN@dAN@dO0aQ`OAN@dO%-jQtOANCgO%-xQ`OAN@dO*kQaOAN@nO%.QQdOAN@nO%.bQpOAN@nOOQS,5>X,5>XOOQS-E;k-E;kOOQO1G2U1G2UO!&WQdO1G2UO$/dQpO1G2UO<_Q`O1G2SO!.YQdO1G2WO!&WQdO1G2SOOQO1G2W1G2WOOQO1G2S1G2SO%.jQaO'#GSOOQO1G2X1G2XOOQSAN@oAN@oOOOQ<<Kk<<KkOOQ#u1G3z1G3zOOQ#uANA[ANA[OOQO1G3{1G3{O%0iQ`OANA[O!&WQdOANA[O%0nQaO1G2nO%1OQaO1G2oOOQT<<K{<<K{O%1`Q`O<<K{O%1eQaO<<K{O*kQaO,5=_OOQT<<LO<<LOOOQO1G3P1G3PO%1lQ`O1G3PO!+WQeOANArO%1qQdO1G3[OOQO1G3[1G3[O%1|Q`O1G3[OOQS7+)l7+)lOOQO7+(z7+(zO%2UQ`O,5=uO%2ZQ`O,5=uOOQ#uANBOANBOO%2fQ`O1G0oOOQ#uG27fG27fOOQ#uG27cG27cO%3{Q`O<<J{O>UQaO<<J{OOQO<<KP<<KPO%5bQ`O<<KQOOQO,5>W,5>WO%6wQ`O,5>WOOQO-E;j-E;jO%6|Q`O1G4nOOQSG26OG26OO$+qQpOG26OO0aQ`OG26OO%7UQdOG26YO*kQaOG26YOOQO7+'p7+'pO!&WQdO7+'pO!&WQdO7+'nOOQO7+'r7+'rOOQO7+'n7+'nO%7fQ`OLD+tO%8uQ`O'#E}O%9PQ`O'#IZO!&WQdO'#HrO%:|QaO,5<nOOQO,5<n,5<nO!&WQdOG26vOOQ#uG26vG26vO%<{QaO7+(YOOQTANAgANAgO%=]Q`OANAgO%=bQ`O1G2yOOQO7+(k7+(kOOQ#uG27^G27^O%=iQ`OG27^OOQO7+(v7+(vO%=nQ`O7+(vO!&WQdO7+(vOOQO1G3a1G3aO%=vQ`O1G3aO%={Q`OAN@gOOQO1G3r1G3rOOQSLD+jLD+jO$+qQpOLD+jO%?bQdOLD+tOOQO<<K[<<K[OOQO<<KY<<KYO%?rQ`O,5<oO%?wQ`O,5<pOOQP,5>^,5>^OOQP-E;p-E;pOOQO1G2Y1G2YOOQ#uLD,bLD,bOOQTG27RG27RO!&WQdOLD,xO!&WQdO<<LbOOQO<<Lb<<LbOOQO7+({7+({OOQS!$( U!$( UOOQS1G2Z1G2ZOOQS1G2[1G2[O%@PQdO1G2[OOQ#u!$(!d!$(!dOOQOANA|ANA|OOQS7+'v7+'vO%@[Q`O'#E{O%@[Q`O'#E{O%@aQ`O,5;gO%@fQdO,5<cO%BbQaO,5:}O*kQaO1G0iO%BiQaO'#FwO#.YQaO'#GVO#.YQaO'#GYO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO%BpQdO'#I]O%D`QdO'#I]O#.YQaO'#EaO#.YQaO'#I]O%FbQaO,5:wO#.YQaO,5;nO#.YQaO,5;pO%FiQdO,5<PO%HeQdO,5<QO%JaQdO,5<RO%L]QdO,5<SO%NXQdO,5<SO%NoQdO,5<VO&!kQdO,5<tO#.YQaO1G0XO&$gQdO1G1]O&&cQdO1G1]O&(_QdO1G1]O&*ZQdO1G1]O&,VQdO1G1]O&.RQdO1G1]O&/}QdO1G1]O&1yQdO1G1]O&3uQdO1G1]O&5qQdO1G1]O&7mQdO1G1]O&9iQdO1G1]O&;eQdO1G1]O&=aQdO1G1]O&?]QdO1G1]O&AXQdO,5:{O&CTQdO,5>wO&EPQdO1G0cO#.YQaO1G0cO&F{QdO1G1YO&HwQdO1G1[O#.YQaO1G1|O#.YQaO7+%sO&JsQdO7+%sO&LoQdO7+%}O#.YQaO7+'hO&NkQdO7+'hO'!gQdO<<I_O'$cQdO<<KSO#.YQaO<<KSO#.YQaOAN@nO'&_QdOAN@nO'(ZQdOG26YO#.YQaOG26YO'*VQdOLD+tO',RQaO,5:}O'.QQaO1G0iO'/|QdO'#IWO'0aQeO'#FUO'4aQeO'#FUO#.YQaO'#FeO'.QQaO'#FeO#.YQaO'#FfO'.QQaO'#FfO#.YQaO'#FgO'.QQaO'#FgO#.YQaO'#FhO'.QQaO'#FhO#.YQaO'#FhO'.QQaO'#FhO#.YQaO'#FkO'.QQaO'#FkO'8gQaO,5:mO'8nQ`O,5<bO'8vQ`O1G0XO'.QQaO1G0|O':YQ`O1G1|O':bQ`O7+'hO':jQpO7+'hO':rQpO<<KSO':zQpOAN@nO';SQaO'#FwO'.QQaO'#GVO'.QQaO'#GYO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO'#EaO'.QQaO'#I]O'=RQaO,5:wO'.QQaO,5;nO'.QQaO,5;pO'?QQdO,5<PO'ASQdO,5<QO'CUQdO,5<RO'EWQdO,5<SO'GYQdO,5<SO'GvQdO,5<VO'IxQdO,5<tO'.QQaO1G0XO'KzQdO1G1]O'M|QdO1G1]O(!OQdO1G1]O($QQdO1G1]O(&SQdO1G1]O((UQdO1G1]O(*WQdO1G1]O(,YQdO1G1]O(.[QdO1G1]O(0^QdO1G1]O(2`QdO1G1]O(4bQdO1G1]O(6dQdO1G1]O(8fQdO1G1]O(:hQdO1G1]O(<jQdO,5:{O(>lQdO,5>wO(@nQdO1G0cO'.QQaO1G0cO(BpQdO1G1YO(DrQdO1G1[O'.QQaO1G1|O'.QQaO7+%sO(FtQdO7+%sO(HvQdO7+%}O'.QQaO7+'hO(JxQdO7+'hO(LzQdO<<I_O(N|QdO<<KSO'.QQaO<<KSO'.QQaOAN@nO)#OQdOAN@nO)%QQdOG26YO'.QQaOG26YO)'SQdOLD+tO))UQaO,5:}O#.YQaO1G0iO))]Q`O'#FvO))eQpO,5;bO))mQ`O,5<bO!%WQ`O,5<bO!%WQ`O1G1|O0aQ`O1G1|O0aQ`O7+'hO0aQ`O<<KSO))uQdO,5<cO)+wQdO'#I]O)-vQdO'#IWO).aQaO,5:mO).hQ`O,5<bO).pQ`O1G0XO)0SQ`O1G1|O)0[Q`O7+'hO)0dQpO7+'hO)0lQpO<<KSO)0tQpOAN@nO0aQ`O'#EvO9yQaO'#FeO9yQaO'#FfO9yQaO'#FgO9yQaO'#FhO9yQaO'#FhO9yQaO'#FkO)0|QaO'#FwO9yQaO'#GVO9yQaO'#GYO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO)1TQ`O'#FlO*kQaO'#EaO*kQaO'#I]O)1]QaO,5:wO9yQaO,5;nO9yQaO,5;pO)1dQdO,5<PO)3`QdO,5<QO)5[QdO,5<RO)7WQdO,5<SO)9SQdO,5<SO)9jQdO,5<VO);fQdO,5<cO)=bQdO,5<tO)?^Q`O'#IvO)@sQ`O'#IYO9yQaO1G0XO)BYQdO1G1]O)DUQdO1G1]O)FQQdO1G1]O)G|QdO1G1]O)IxQdO1G1]O)KtQdO1G1]O)MpQdO1G1]O* lQdO1G1]O*#hQdO1G1]O*%dQdO1G1]O*'`QdO1G1]O*)[QdO1G1]O*+WQdO1G1]O*-SQdO1G1]O*/OQdO1G1]O*0zQaO,5:}O*1RQdO,5:{O*1cQdO,5>wO*1sQaO'#HdO*2TQ`O,5>vO*2]QdO1G0cO9yQaO1G0cO*4XQdO1G1YO*6TQdO1G1[O9yQaO1G1|O>UQaO'#HwO*8PQ`O,5=[O*8XQaO'#HbO*8cQ`O,5>tO9yQaO7+%sO*8kQdO7+%sO*:gQ`O1G0iO>UQaO1G0iO*;|QdO7+%}O9yQaO7+'hO*=xQdO7+'hO*?tQ`O,5>cO*AZQ`O,5=|O*BpQdO<<I_O*DlQ`O7+&TO*FRQdO<<KSO9yQaO<<KSO9yQaOAN@nO*G}QdOAN@nO*IyQdOG26YO9yQaOG26YO*KuQdOLD+tO*MqQaO,5:}O9yQaO1G0iO*MxQdO'#I]O*NcQ`O'#FvO*NkQ`O,5<bO!%WQ`O,5<bO!%WQ`O1G1|O0aQ`O1G1|O0aQ`O7+'hO0aQ`O<<KSO*NsQdO'#IWO+ ^QeO'#FUO+ zQaO'#FUO+#sQaO'#FUO+%`QaO'#FUO>UQaO'#FeO>UQaO'#FfO>UQaO'#FgO>UQaO'#FhO>UQaO'#FhO>UQaO'#FkO+'XQaO'#FwO>UQaO'#GVO>UQaO'#GYO+'`QaO,5:mO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO+'gQ`O'#I]O$8YQaO'#EaO+)PQaOG26YO$8YQaO'#I]O+*{Q`O'#I[O++TQaO,5:wO>UQaO,5;nO>UQaO,5;pO++[Q`O,5<PO+,wQ`O,5<QO+.dQ`O,5<RO+0PQ`O,5<SO+1lQ`O,5<SO+3XQ`O,5<VO+4tQ`O,5<bO+4|Q`O,5<cO+6iQ`O,5<tO+8UQ`O1G0XO>UQaO1G0XO+9hQ`O1G1]O+;TQ`O1G1]O+<pQ`O1G1]O+>]Q`O1G1]O+?xQ`O1G1]O+AeQ`O1G1]O+CQQ`O1G1]O+DmQ`O1G1]O+FYQ`O1G1]O+GuQ`O1G1]O+IbQ`O1G1]O+J}Q`O1G1]O+LjQ`O1G1]O+NVQ`O1G1]O, rQ`O1G1]O,#_Q`O1G0cO>UQaO1G0cO,$zQ`O1G1YO,&gQ`O1G1[O,(SQ`O1G1|O>UQaO1G1|O>UQaO7+%sO,([Q`O7+%sO,)wQ`O7+%}O>UQaO7+'hO,+dQ`O7+'hO,+lQ`O7+'hO,-XQpO7+'hO,-aQ`O<<I_O,.|Q`O<<KSO,0iQpO<<KSO>UQaO<<KSO>UQaOAN@nO,0qQ`OAN@nO,2^QpOAN@nO,2fQ`OG26YO>UQaOG26YO,4RQ`OLD+tO,5nQaO,5:}O>UQaO1G0iO,5uQ`O'#I]O$8YQaO'#FeO$8YQaO'#FfO$8YQaO'#FgO$8YQaO'#FhO$8YQaO'#FhO+)PQaO'#FhO$8YQaO'#FkO,6SQaO'#FwO,6ZQaO'#FwO$8YQaO'#GVO+)PQaO'#GVO$8YQaO'#GYO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO,8YQ`O'#FlO>UQaO'#EaO>UQaO'#I]O,8bQaO,5:wO,8iQaO,5:wO$8YQaO,5;nO+)PQaO,5;nO$8YQaO,5;pO,:hQ`O,5<PO,<TQ`O,5<QO,=pQ`O,5<RO,?]Q`O,5<SO,@xQ`O,5<SO,BeQ`O,5<SO,CtQ`O,5<VO,EaQ`O,5<cO%7fQ`O,5<cO,F|Q`O,5<tO$8YQaO1G0XO+)PQaO1G0XO,HiQ`O1G1]O,JUQ`O1G1]O,KeQ`O1G1]O,MQQ`O1G1]O,NaQ`O1G1]O- |Q`O1G1]O-#]Q`O1G1]O-$xQ`O1G1]O-&XQ`O1G1]O-'tQ`O1G1]O-)TQ`O1G1]O-*pQ`O1G1]O-,PQ`O1G1]O--lQ`O1G1]O-.{Q`O1G1]O-0hQ`O1G1]O-1wQ`O1G1]O-3dQ`O1G1]O-4sQ`O1G1]O-6`Q`O1G1]O-7oQ`O1G1]O-9[Q`O1G1]O-:kQ`O1G1]O-<WQ`O1G1]O-=gQ`O1G1]O-?SQ`O1G1]O-@cQ`O1G1]O-BOQ`O1G1]O-C_Q`O1G1]O-DzQ`O1G1]O-FZQ`O,5:{O-GvQ`O,5>wO-IcQ`O1G0cO-KOQ`O1G0cO$8YQaO1G0cO+)PQaO1G0cO-L_Q`O1G1YO-MzQ`O1G1YO. ZQ`O1G1[O$8YQaO1G1|O$8YQaO7+%sO+)PQaO7+%sO.!vQ`O7+%sO.$cQ`O7+%sO.%rQ`O7+%}O.'_Q`O7+%}O$8YQaO7+'hO.(nQ`O7+'hO.*ZQ`O<<I_O.+vQ`O<<I_O.-VQ`O<<KSO$8YQaO<<KSO$8YQaOAN@nO..rQ`OAN@nO.0_Q`OG26YO$8YQaOG26YO.1zQ`OLD+tO.3gQaO,5:}O.3nQaO,5:}O$8YQaO1G0iO+)PQaO1G0iO.5mQ`O'#I]O.7PQ`O'#I]O.:fQ`O'#IWO.:vQ`O'#FvO.;OQaO,5:mO.;VQ`O,5<bO.;_Q`O,5<bO!%WQ`O,5<bO.;gQ`O1G0XO.<yQ`O,5:{O.>fQ`O,5>wO.@RQ`O1G1|O!%WQ`O1G1|O0aQ`O1G1|O0aQ`O7+'hO.@ZQ`O7+'hO.@cQpO7+'hO.@kQpO<<KSO0aQ`O<<KSO.@sQpOAN@nO.@{Q`O'#IWO.A]Q`O'#IWO.CSQaO,5:mO.CZQaO,5:mO.CbQ`O,5<bO.CjQ`O7+'hO.CrQ`O1G0XO.EUQ`O1G0XO.FhQ`O1G1|O.FpQ`O7+'hO.FxQpO7+'hO.GQQpOAN@nO.GYQpO<<KSO.GbQpOAN@nO.GjQ`O'#FvO.GrQ`O'#FlO.GzQ`O,5<bO!%WQ`O,5<bO!%WQ`O1G1|O0aQ`O1G1|O0aQ`O7+'hO0aQ`O<<KSO.HSQ`O'#FvO.H[Q`O,5<bO.HdQ`O,5<bO!%WQ`O,5<bO!%WQ`O1G1|O!%WQ`O1G1|O0aQ`O1G1|O0aQ`O<<KSO0aQ`O7+'hO0aQ`O<<KSO.HlQ`O'#FlO.HtQ`O'#FlO.H|Q`O'#Fl",
  stateData: ".Ic~O!dOS!eOS&vOS!gQQ~O!iTO&wRO~OPgOQ|OS!lOU^OW}OX!XO[mO]!_O^!WO`![Oa!SOb!]Ok!dOm!lOowOp!TOq!UOsuOt!gOu!VOv!POxkOykO|!bO}`O!O]O!P!eO!QxO!R}O!TpO!UlO!VlO!W!YO!X!QO!YzO!Z!cO![!ZO!]!^O!^!fO!`!`O!a!RO!cjO!mWO!oXO!sYO!y[O#W_O#bhO#daO#ebO#peO$ToO$]nO$^oO$aqO$drO$l!kO$zyO${!OO$}}O%O}O%V|O'g{O~O!g!mO~O&wRO!i!hX&p!hX&t!hX~O!i!pO~O!d!qO!e!qO!g!mO&t!tO&v!qO~PhO!n!vO~PhOT'VXz'VX!S'VX!b'VX!m'VX!o'VX!v'VX!y'VX#S'VX#W'VX#`'VX#a'VX#p#qX#s'VX#z'VX#{'VX#|'VX#}'VX$O'VX$Q'VX$R'VX$S'VX$T'VX$U'VX$V'VX$W'VX$z'VX&s'VX~O!q!xO~P&sOT#TOz#RO!S#UO!b#VO!m#cO!o!{O!v!yO!y!}O#S#QO#W!zO#`!|O#a!|O#s#PO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dO&s#cO~OPgOQ|OU^OW}O[mOowOs#hOxkOykO}`O!O]O!QxO!R}O!TpO!UlO!VlO!YzO!cjO!s#gO!y[O#W_O#bhO#daO#ebO#peO$ToO$]nO$^oO$aqO$zyO${!OO$}}O%O}O%V|O'g{O~O!y[O~O!y#kO~OP6]OQ|OU^OW}O[6`Oo=YOs#hOx6^Oy6^O}`O!O]O!Q6dO!R}O!T6cO!U6_O!V6_O!Y6fO!c8fO!s#gO!y[O#S#oO#U#nO#W_O#bhO#daO#ebO#peO$T6bO$]6aO$^6bO$aqO$z6eO${!OO$}}O%O}O%V|O'g{O#X'OP~O!}#sO~P-UO!y#tO~O#b#vO#daO#ebO~O#p#xO~O!s#yO~OU$PO!R$PO!s$OO!v#}O#p2XO~OT&zXz&zX!S&zX!b&zX!m&zX!o&zX!v&zX!y&zX#S&zX#W&zX#`&zX#a&zX#s&zX#z&zX#{&zX#|&zX#}&zX$O&zX$Q&zX$R&zX$S&zX$T&zX$U&zX$V&zX$W&zX$z&zX&s&zX!x&zX!n&zX~O#u$RO#w$SO~P0rOP6]OQ|OU^OW}O[6`Oo=YOs#hOx6^Oy6^O}`O!O]O!Q6dO!R}O!T6cO!U6_O!V6_O!Y6fO!c8fO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T6bO$]6aO$^6bO$aqO$z6eO${!OO$}}O%O}O%V|O'g{OT#xXz#xX!S#xX!b#xX!m#xX!o#xX!v#xX#`#xX#a#xX#s#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX&s#xX!x#xX!n#xX~Or$UO#S6yO#U6xO~P2yO!s#gO#peO~OS$gO]$bOk$eOm$gOs$aO!`$cO$drO$l$fO~O!s$kO!y$hO#S$jO~Oo$mOs$lO#b$nO~O!y$hO#S$rO~O$l$tO~P*kOR$zO!o$yO#b$xO#e$yO&q$zO~O'f$|O~P8lO!y%RO~O!y%TO~O!s%VO~O!m#cO&s#cO~P*kO!oXO~O!y%_O~OP6]OQ|OU^OW}O[6`Oo=YOs#hOx6^Oy6^O}`O!O]O!Q6dO!R}O!T6cO!U6_O!V6_O!Y6fO!c8fO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T6bO$]6aO$^6bO$aqO$z6eO${!OO$}}O%O}O%V|O'g{O~O!y%cO~O!s%dO~O]$bO~O!s%hO~O!s%iO~O!s%jO~O!oXO!s#gO#peO~O]%rOs%rO!o%pO!s#gO#p%nO~O!s%vO~O!i%wO&t%wO&wRO~O&t%zO~PhO!n%{O~PhOPgOQ|OU^OW}O[8lOo=yOs#hOx8jOy8jO}`O!O]O!Q8pO!R}O!T8oO!U8kO!V8kO!Y8rO!c8iO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T8nO$]8mO$^8nO$aqO$z8qO${!OO$}}O%O}O%V|O'g{O~O!q%}O~P>UO#X&PO~P>UO!o&SO!s&RO#b&RO~OPgOQ|OU^OW}O[8lOo=yOs#hOx8jOy8jO}`O!O]O!Q8pO!R}O!T8oO!U8kO!V8kO!Y8rO!c8iO!s&VO!y[O#U&WO#W_O#bhO#daO#ebO#peO$T8nO$]8mO$^8nO$aqO$z8qO${!OO$}}O%O}O%V|O'g{O~O!x'SP~PAOO!s&[O#b&[O~OT#TOz#RO!S#UO!b#VO!o!{O!v!yO!y!}O#S#QO#W!zO#`!|O#a!|O#s#PO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dO~O!x&nO~PCqO!x'VX!}'VX#O'VX#X'VX!n'VXV'VX!q'VX#u'VX#w'VXw'VX~P&sO!y$hO#S&oO~Oo$mOs$lO~O!o&pO~O!}&sO#S;dO#U;cO!x'OP~P9yOT6iOz6gO!S6jO!b6kO!o!{O!v8sO!y!}O#S#QO#W!zO#`!|O#a!|O#s#PO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}'PX#X'PX~O#O&tO~PGSO!}&wO#X'OX~O#X&yO~O!}'OO!x'QP~P9yO!n'PO~PCqO!m#oa!o#oa#S#oa#p#qX&s#oa!x#oa#O#oaw#oa~OT#oaz#oa!S#oa!b#oa!v#oa!y#oa#W#oa#`#oa#a#oa#s#oa#z#oa#{#oa#|#oa#}#oa$O#oa$Q#oa$R#oa$S#oa$T#oa$U#oa$V#oa$W#oa$z#oa!}#oa#X#oa!n#oaV#oa!q#oa#u#oa#w#oa~PIpO!s'RO~O!x'UO#l'SO~O!x'VX#l'VX#p#qX#S'VX#U'VX#b'VX!o'VX#O'VXw'VX!m'VX&s'VX~O#S'YO~P*kO!m$Xa&s$Xa!x$Xa!n$Xa~PCqO!m$Ya&s$Ya!x$Ya!n$Ya~PCqO!m$Za&s$Za!x$Za!n$Za~PCqO!m$[a&s$[a!x$[a!n$[a~PCqO!o!{O!y!}O#W!zO#`!|O#a!|O#s#PO$z#dOT$[a!S$[a!b$[a!m$[a!v$[a#S$[a#z$[a#{$[a#|$[a#}$[a$O$[a$Q$[a$R$[a$S$[a$T$[a$U$[a$V$[a$W$[a&s$[a!x$[a!n$[a~Oz#RO~PNyO!m$_a&s$_a!x$_a!n$_a~PCqO!y!}O!}$fX#X$fX~O!}'^O#X'ZX~O#X'`O~O!s$kO#S'aO~O]'cO~O!s'eO~O!s'fO~O$l'gO~O!`'mO#S'kO#U'lO#b'jO$drO!x'XP~P0aO!^'sO!oXO!q'rO~O!s'uO!y$hO~O!y$hO#S'wO~O!y$hO#S'yO~O#u'zO!m$sX!}$sX&s$sX~O!}'{O!m'bX&s'bX~O!m#cO&s#cO~O!q(PO#O(OO~O!m$ka&s$ka!x$ka!n$ka~PCqOl(ROw(SO!o(TO!y!}O~O!o!{O!y!}O#W!zO#`!|O#a!|O#s#PO~OT$yaz$ya!S$ya!b$ya!m$ya!v$ya#S$ya#z$ya#{$ya#|$ya#}$ya$O$ya$Q$ya$R$ya$S$ya$T$ya$U$ya$V$ya$W$ya$z$ya&s$ya!x$ya!}$ya#O$ya#X$ya!n$ya!q$yaV$ya#u$ya#w$ya~P!'WO!m$|a&s$|a!x$|a!n$|a~PCqO#W([O#`(YO#a(YO&r(ZOR&gX!o&gX#b&gX#e&gX&q&gX'f&gX~O'f(_O~P8lO!q(`O~PhO!o(cO!q(dO~O!q(`O&s(gO~PhO!a(kO~O!m(lO~P9yOZ(wOn(xO~O!s(zO~OT6iOz6gO!S6jO!b6kO!v8sO!}({O#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m'jX&s'jX~P!'WO#u)PO~O!})QO!m'`X&s'`X~Ol(RO!o(TO~Ow(SO!o)WO!q)ZO~O!m#cO!oXO&s#cO~O!o%pO!s#yO~OV)aO!})_O!m'kX&s'kX~O])cOs)cO!s#gO#peO~O!o%pO!s#gO#p)hO~OT6iOz6gO!S6jO!b6kO!v8sO!})iO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m&|X&s&|X#O&|X~P!'WOl(ROw(SO!o(TO~O!i)oO&t)oO~OT8vOz8tO!S8wO!b8xO!q)pO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#X)rO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WO!n)rO~PCqOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x'TX!}'TX~P!'WOT'VXz'VX!S'VX!b'VX!o'VX!v'VX!y'VX#S'VX#W'VX#`'VX#a'VX#p#qX#s'VX#z'VX#{'VX#|'VX#}'VX$O'VX$Q'VX$R'VX$S'VX$T'VX$U'VX$V'VX$W'VX$z'VX~O!q)tO!x'VX!}'VX~P!5xO!x#iX!}#iX~P>UO!})vO!x'SX~O!x)xO~O$z#dOT#yiz#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi$W#yi&s#yi!x#yi!}#yi#O#yi#X#yi!n#yi!q#yiV#yi#u#yi#w#yi~P!'WOz#RO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi&s#yi!x#yi!n#yi~P!'WOz#RO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi&s#yi!x#yi!n#yi~P!'WOT#TOz#RO!b#VO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dO!S#yi!m#yi&s#yi!x#yi!n#yi~P!'WOT#TOz#RO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dO!S#yi!b#yi!m#yi&s#yi!x#yi!n#yi~P!'WOz#RO#S#QO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#z#yi#{#yi&s#yi!x#yi!n#yi~P!'WOz#RO#S#QO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#z#yi#{#yi#|#yi&s#yi!x#yi!n#yi~P!'WOz#RO#S#QO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#z#yi#{#yi#|#yi#}#yi&s#yi!x#yi!n#yi~P!'WOz#RO#S#QO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#z#yi#{#yi#|#yi#}#yi$O#yi&s#yi!x#yi!n#yi~P!'WOz#RO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi&s#yi!x#yi!n#yi~P!'WOz#RO$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi&s#yi!x#yi!n#yi~P!'WOz#RO$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi&s#yi!x#yi!n#yi~P!'WOz#RO$T#`O$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi&s#yi!x#yi!n#yi~P!'WOz#RO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi&s#yi!x#yi!n#yi~P!'WOz#RO$S#_O$T#`O$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi&s#yi!x#yi!n#yi~P!'WOz#RO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi&s#yi!x#yi!n#yi~P!'WO_)yO~P9yO!x)|O~O#S*PO~P9yOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}#Ta#X#Ta#O#Ta!m#Ta&s#Ta!x#Ta!n#TaV#Ta!q#Ta~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}'Pa#X'Pa#O'Pa!m'Pa&s'Pa!x'Pa!n'PaV'Pa!q'Pa~P!'WO#S#oO#U#nO!}&WX#X&WX~P9yO!}&wO#X'Oa~O#X*SO~OT6iOz6gO!S6jO!b6kO!v8sO!}*UO#O*TO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!x'QX~P!'WO!}*UO!x'QX~O!x*WO~O!m#oi!o#oi#S#oi#p#qX&s#oi!x#oi#O#oiw#oi~OT#oiz#oi!S#oi!b#oi!v#oi!y#oi#W#oi#`#oi#a#oi#s#oi#z#oi#{#oi#|#oi#}#oi$O#oi$Q#oi$R#oi$S#oi$T#oi$U#oi$V#oi$W#oi$z#oi!}#oi#X#oi!n#oiV#oi!q#oi#u#oi#w#oi~P#*zO#l'SO!x#ka#S#ka#U#ka#b#ka!o#ka#O#kaw#ka!m#ka&s#ka~OPgOQ|OU^OW}O[4OOo5xOs#hOx3zOy3zO}`O!O]O!Q2^O!R}O!T4UO!U3|O!V3|O!Y2`O!c3xO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T4SO$]4QO$^4SO$aqO$z2_O${!OO$}}O%O}O%V|O'g{O~O#l#oa#U#oa#b#oa~PIpOz#RO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#Pi!S#Pi!b#Pi!m#Pi&s#Pi!x#Pi!n#Pi~P!'WOz#RO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#vi!S#vi!b#vi!m#vi&s#vi!x#vi!n#vi~P!'WO!m#xi&s#xi!x#xi!n#xi~PCqO!s#gO#peO!}&^X#X&^X~O!}'^O#X'Za~O!s'uO~Ow(SO!o)WO!q*fO~O!s*jO~O#S*lO#U*mO#b*kO#l'SO~O#S*lO#U*mO#b*kO$drO~P0aO#u*oO!x$cX!}$cX~O#U*mO#b*kO~O#b*pO~O#b*rO~P0aO!}*sO!x'XX~O!x*uO~O!y*wO~O!^*{O!oXO!q*zO~O!q*}O!o'ci!m'ci&s'ci~O!q+QO#O+PO~O#b$nO!m&eX!}&eX&s&eX~O!}'{O!m'ba&s'ba~OT$kiz$ki!S$ki!b$ki!m$ki!o$ki!v$ki!y$ki#S$ki#W$ki#`$ki#a$ki#s$ki#u#fa#w#fa#z$ki#{$ki#|$ki#}$ki$O$ki$Q$ki$R$ki$S$ki$T$ki$U$ki$V$ki$W$ki$z$ki&s$ki!x$ki!}$ki#O$ki#X$ki!n$ki!q$kiV$ki~OS+^O]+aOm+^Os$aO!^+dO!_+^O!`+^O!n+hO#b$nO$aqO$drO~P0aO!s+lO~O#W+nO#`+mO#a+mO~O!s+pO#b+pO$}+pO%T+oO~O!n+qO~PCqOc%XXd%XXh%XXj%XXf%XXg%XXe%XX~PhOc+uOd+sOP%WiQ%WiS%WiU%WiW%WiX%Wi[%Wi]%Wi^%Wi`%Wia%Wib%Wik%Wim%Wio%Wip%Wiq%Wis%Wit%Wiu%Wiv%Wix%Wiy%Wi|%Wi}%Wi!O%Wi!P%Wi!Q%Wi!R%Wi!T%Wi!U%Wi!V%Wi!W%Wi!X%Wi!Y%Wi!Z%Wi![%Wi!]%Wi!^%Wi!`%Wi!a%Wi!c%Wi!m%Wi!o%Wi!s%Wi!y%Wi#W%Wi#b%Wi#d%Wi#e%Wi#p%Wi$T%Wi$]%Wi$^%Wi$a%Wi$d%Wi$l%Wi$z%Wi${%Wi$}%Wi%O%Wi%V%Wi&p%Wi'g%Wi&t%Wi!n%Wih%Wij%Wif%Wig%WiY%Wi_%Wii%Wie%Wi~Oc+yOd+vOh+xO~OY+zO_+{O!n,OO~OY+zO_+{Oi%^X~Oi,QO~Oj,RO~O!m,TO~P9yO!m,VO~Of,WO~OT6iOV,XOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO~P!'WOg,YO~O!y,ZO~OZ(wOn(xOP%liQ%liS%liU%liW%liX%li[%li]%li^%li`%lia%lib%lik%lim%lio%lip%liq%lis%lit%liu%liv%lix%liy%li|%li}%li!O%li!P%li!Q%li!R%li!T%li!U%li!V%li!W%li!X%li!Y%li!Z%li![%li!]%li!^%li!`%li!a%li!c%li!m%li!o%li!s%li!y%li#W%li#b%li#d%li#e%li#p%li$T%li$]%li$^%li$a%li$d%li$l%li$z%li${%li$}%li%O%li%V%li&p%li'g%li&t%li!n%lic%lid%lih%lij%lif%lig%liY%li_%lii%lie%li~O#u,_O~O!}({O!m%da&s%da~O!x,bO~O!s%dO!m&dX!}&dX&s&dX~O!})QO!m'`a&s'`a~OS+^OY,iOm+^Os$aO!^+dO!_+^O!`+^O$aqO$drO~O!n,lO~P#JwO!o)WO~O!o%pO!s'RO~O!s#gO#peO!m&nX!}&nX&s&nX~O!})_O!m'ka&s'ka~O!s,rO~OV,sO!n%|X!}%|X~O!},uO!n'lX~O!n,wO~O!m&UX!}&UX&s&UX#O&UX~P9yO!})iO!m&|a&s&|a#O&|a~Oz#RO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT!uq!S!uq!b!uq!m!uq!v!uq&s!uq!x!uq!n!uq~P!'WO!n,|O~PCqOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#ia!}#ia~P!'WO!x&YX!}&YX~PAOO!})vO!x'Sa~O#O-QO~O!}-RO!n&{X~O!n-TO~O!x-UO~OT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}#Vi#X#Vi~P!'WO!x&XX!}&XX~P9yO!}*UO!x'Qa~O!x-[O~OT#jqz#jq!S#jq!b#jq!m#jq!v#jq#S#jq#u#jq#w#jq#z#jq#{#jq#|#jq#}#jq$O#jq$Q#jq$R#jq$S#jq$T#jq$U#jq$V#jq$W#jq$z#jq&s#jq!x#jq!}#jq#O#jq#X#jq!n#jq!q#jqV#jq~P!'WO#l#oi#U#oi#b#oi~P#*zOz#RO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#Pq!S#Pq!b#Pq!m#Pq&s#Pq!x#Pq!n#Pq~P!'WO#u-dO!x$ca!}$ca~O#U-fO#b-eO~O#b-gO~O#S-hO#U-fO#b-eO#l'SO~O#b-jO#l'SO~O#u-kO!x$ha!}$ha~O!`'mO#S'kO#U'lO#b'jO$drO!x&_X!}&_X~P0aO!}*sO!x'Xa~O!oXO#l'SO~O#S-pO#b-oO!x'[P~O!oXO!q-rO~O!q-uO!o'cq!m'cq&s'cq~O!^-wO!oXO!q-rO~O!q-{O#O-zO~OT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m$si!}$si&s$si~P!'WO!m$jq&s$jq!x$jq!n$jq~PCqO#O-zO#l'SO~O!}-|Ow']X!o']X!m']X&s']X~O#b$nO#l'SO~OS+^O].ROm+^Os$aO!_+^O!`+^O#b$nO$aqO$drO~P0aOS+^O].ROm+^Os$aO!_+^O!`+^O#b$nO$aqO~P0aOS+^O]+aOm+^Os$aO!^+dO!_+^O!`+^O!n.ZO#b$nO$aqO$drO~P0aO!s.^O~O!s._O#b._O$}._O%T+oO~O$}.`O~O#X.aO~Oc%Xad%Xah%Xaj%Xaf%Xag%Xae%Xa~PhOc.dOd+sOP%WqQ%WqS%WqU%WqW%WqX%Wq[%Wq]%Wq^%Wq`%Wqa%Wqb%Wqk%Wqm%Wqo%Wqp%Wqq%Wqs%Wqt%Wqu%Wqv%Wqx%Wqy%Wq|%Wq}%Wq!O%Wq!P%Wq!Q%Wq!R%Wq!T%Wq!U%Wq!V%Wq!W%Wq!X%Wq!Y%Wq!Z%Wq![%Wq!]%Wq!^%Wq!`%Wq!a%Wq!c%Wq!m%Wq!o%Wq!s%Wq!y%Wq#W%Wq#b%Wq#d%Wq#e%Wq#p%Wq$T%Wq$]%Wq$^%Wq$a%Wq$d%Wq$l%Wq$z%Wq${%Wq$}%Wq%O%Wq%V%Wq&p%Wq'g%Wq&t%Wq!n%Wqh%Wqj%Wqf%Wqg%WqY%Wq_%Wqi%Wqe%Wq~Oc.iOd+vOh.hO~O!q(`O~OP6]OQ|OU^OW}O[:fOo>ROs#hOx:dOy:dO}`O!O]O!Q:kO!R}O!T:jO!U:eO!V:eO!Y:oO!c8gO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T:hO$]:gO$^:hO$aqO$z:mO${!OO$}}O%O}O%V|O'g{O~O!m.lO!q.lO~OY+zO_+{O!n.nO~OY+zO_+{Oi%^a~O!x.rO~P>UO!m.tO~O!m.tO~P9yOQ|OW}O!R}O$}}O%O}O%V|O'g{O~OT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m&ka!}&ka&s&ka~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m$qi!}$qi&s$qi~P!'WOS+^Om+^Os$aO!_+^O!`+^O$aqO$drO~OY/PO~P$?VOS+^Om+^Os$aO!_+^O!`+^O$aqO~O!s/QO~O!n/SO~P#JwOw(SO!o)WO#l'SO~OV/VO!m&na!}&na&s&na~O!})_O!m'ki&s'ki~O!s/XO~OV/YO!n%|a!}%|a~O]/[Os/[O!s#gO#peO!n&oX!}&oX~O!},uO!n'la~OT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m&Ua!}&Ua&s&Ua#O&Ua~P!'WOz#RO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT!uy!S!uy!b!uy!m!uy!v!uy&s!uy!x!uy!n!uy~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#hi!}#hi~P!'WO_)yO!n&VX!}&VX~P9yO!}-RO!n&{a~OT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}#Vq#X#Vq~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#[i!}#[i~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#O/cO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!x&Xa!}&Xa~P!'WO#u/iO!x$ci!}$ci~O#b/jO~O#U/lO#b/kO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$ci!}$ci~P!'WO#u/mO!x$hi!}$hi~O!}/oO!x'[X~O#b/qO~O!x/rO~O!oXO!q/uO~O#l'SO!o'cy!m'cy&s'cy~O!m$jy&s$jy!x$jy!n$jy~PCqO#O/xO#l'SO~O!s#gO#peOw&aX!o&aX!}&aX!m&aX&s&aX~O!}-|Ow']a!o']a!m']a&s']a~OU$PO]0QO!R$PO!s$OO!v#}O#b$nO#p2XO~P$?uO!m#cO!o0VO&s#cO~O#X0YO~Oh0_O~OT:tOz:pO!S:vO!b:xO!m0`O!q0`O!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO~P!'WOY%]a_%]a!n%]ai%]a~PhO!x0bO~O!x0bO~P>UO!m0dO~OT6iOz6gO!S6jO!b6kO!v8sO!x0fO#O0eO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO~P!'WO!x0fO~O!x0gO#b0hO#l'SO~O!x0iO~O!s0jO~O!m#cO#u0lO&s#cO~O!s0mO~O!})_O!m'kq&s'kq~O!s0nO~OV0oO!n%}X!}%}X~OT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!n!|i!}!|i~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$cq!}$cq~P!'WO#u0vO!x$cq!}$cq~O#b0wO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$hq!}$hq~P!'WO#S0zO#b0yO!x&`X!}&`X~O!}/oO!x'[a~O#l'SO!o'c!R!m'c!R&s'c!R~O!oXO!q1PO~O!m$j!R&s$j!R!x$j!R!n$j!R~PCqO#O1RO#l'SO~OP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!n1^O!s1YO!y[O#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$z:nO${!OO~P$;lOh1_O~OY%[i_%[i!n%[ii%[i~PhOY%]i_%]i!n%]ii%]i~PhO!x1bO~O!x1bO~P>UO!x1eO~O!m#cO#u1iO&s#cO~O$}1jO%V1jO~O!s1kO~OV1lO!n%}a!}%}a~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#]i!}#]i~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$cy!}$cy~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$hy!}$hy~P!'WO#b1nO~O!}/oO!x'[i~O!m$j!Z&s$j!Z!x$j!Z!n$j!Z~PCqOT:uOz:qO!S:wO!b:yO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dO~P!'WOV1uO{1tO~P!5xOV1uO{1tOT&}Xz&}X!S&}X!b&}X!o&}X!v&}X!y&}X#S&}X#W&}X#`&}X#a&}X#s&}X#u&}X#w&}X#z&}X#{&}X#|&}X#}&}X$O&}X$Q&}X$R&}X$S&}X$T&}X$U&}X$V&}X$W&}X$z&}X~OP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!n1xO!s1YO!y[O#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$z:nO${!OO~P$;lOY%[q_%[q!n%[qi%[q~PhO!x1zO~O!x%gi~PCqOe1{O~O$}1|O%V1|O~O!s2OO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$c!R!}$c!R~P!'WO!m$j!c&s$j!c!x$j!c!n$j!c~PCqO!s2QO~O!`2SO!s2RO~O!s2VO!m$xi&s$xi~O!s'WO~O!s*]O~OT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$ka#u$ka#w$ka&s$ka!x$ka!n$ka!q$ka#X$ka!}$ka~P!'WO#S2]O~P*kO$l$tO~P#.YOT6iOz6gO!S6jO!b6kO!v8sO#O2[O#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m'PX&s'PX!x'PX!n'PX~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#O3uO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}'PX#X'PX#u'PX#w'PX!m'PX&s'PX!x'PX!n'PXV'PX!q'PX~P!'WO#S3dO~P#.YOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$Xa#u$Xa#w$Xa&s$Xa!x$Xa!n$Xa!q$Xa#X$Xa!}$Xa~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$Ya#u$Ya#w$Ya&s$Ya!x$Ya!n$Ya!q$Ya#X$Ya!}$Ya~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$Za#u$Za#w$Za&s$Za!x$Za!n$Za!q$Za#X$Za!}$Za~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$[a#u$[a#w$[a&s$[a!x$[a!n$[a!q$[a#X$[a!}$[a~P!'WOz2aO#u$[a#w$[a!q$[a#X$[a!}$[a~PNyOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$_a#u$_a#w$_a&s$_a!x$_a!n$_a!q$_a#X$_a!}$_a~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$|a#u$|a#w$|a&s$|a!x$|a!n$|a!q$|a#X$|a!}$|a~P!'WOz2aO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#u#yi#w#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi#u#yi#w#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOT2cOz2aO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!S#yi!m#yi#u#yi#w#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOT2cOz2aO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!S#yi!b#yi!m#yi#u#yi#w#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO#S#QO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#u#yi#w#yi#z#yi#{#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO#S#QO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#u#yi#w#yi#z#yi#{#yi#|#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO#S#QO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO#S#QO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$T2nO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$S2mO$T2nO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m#Ta#u#Ta#w#Ta&s#Ta!x#Ta!n#Ta!q#Ta#X#Ta!}#Ta~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m'Pa#u'Pa#w'Pa&s'Pa!x'Pa!n'Pa!q'Pa#X'Pa!}'Pa~P!'WOz2aO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#Pi!S#Pi!b#Pi!m#Pi#u#Pi#w#Pi&s#Pi!x#Pi!n#Pi!q#Pi#X#Pi!}#Pi~P!'WOz2aO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#vi!S#vi!b#vi!m#vi#u#vi#w#vi&s#vi!x#vi!n#vi!q#vi#X#vi!}#vi~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m#xi#u#xi#w#xi&s#xi!x#xi!n#xi!q#xi#X#xi!}#xi~P!'WOz2aO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT!uq!S!uq!b!uq!m!uq!v!uq#u!uq#w!uq&s!uq!x!uq!n!uq!q!uq#X!uq!}!uq~P!'WOz2aO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#Pq!S#Pq!b#Pq!m#Pq#u#Pq#w#Pq&s#Pq!x#Pq!n#Pq!q#Pq#X#Pq!}#Pq~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$jq#u$jq#w$jq&s$jq!x$jq!n$jq!q$jq#X$jq!}$jq~P!'WOz2aO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT!uy!S!uy!b!uy!m!uy!v!uy#u!uy#w!uy&s!uy!x!uy!n!uy!q!uy#X!uy!}!uy~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$jy#u$jy#w$jy&s$jy!x$jy!n$jy!q$jy#X$jy!}$jy~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$j!R#u$j!R#w$j!R&s$j!R!x$j!R!n$j!R!q$j!R#X$j!R!}$j!R~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$j!Z#u$j!Z#w$j!Z&s$j!Z!x$j!Z!n$j!Z!q$j!Z#X$j!Z!}$j!Z~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$j!c#u$j!c#w$j!c&s$j!c!x$j!c!n$j!c!q$j!c#X$j!c!}$j!c~P!'WOP6]OU^O[4POo8^Os#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#S3vO#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$z4bO${!OO~P$;lOP6]OU^O[4POo8^Os#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$z4bO${!OO~P$;lO#u2uO#w2vO!q&zX#X&zX!}&zX~P0rOP6]OU^O[4POo8^Or2wOs#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#S2tO#U2sO#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$z4bO${!OOT#xXz#xX!S#xX!b#xX!m#xX!o#xX!v#xX#`#xX#a#xX#s#xX#u#xX#w#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX&s#xX!x#xX!n#xX!q#xX#X#xX!}#xX~P$;lOP6]OU^O[4POo8^Or4xOs#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#S4uO#U4tO#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$z4bO${!OOT#xXz#xX!S#xX!b#xX!o#xX!v#xX!}#xX#O#xX#X#xX#`#xX#a#xX#s#xX#u#xX#w#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX!m#xX&s#xX!x#xX!n#xXV#xX!q#xX~P$;lO!q3PO~P>UO!q5}O#O3gO~OT8vOz8tO!S8wO!b8xO!q3hO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WO!q6OO#O3kO~O!q6PO#O3oO~O#O3oO#l'SO~O#O3pO#l'SO~O#O3sO#l'SO~OP6]OU^O[4POo8^Os#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$l$tO$z4bO${!OO~P$;lOP6]OU^O[4POo8^Os#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#S5eO#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$z4bO${!OO~P$;lOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$Xa#O$Xa#X$Xa#u$Xa#w$Xa!m$Xa&s$Xa!x$Xa!n$XaV$Xa!q$Xa~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$Ya#O$Ya#X$Ya#u$Ya#w$Ya!m$Ya&s$Ya!x$Ya!n$YaV$Ya!q$Ya~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$Za#O$Za#X$Za#u$Za#w$Za!m$Za&s$Za!x$Za!n$ZaV$Za!q$Za~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$[a#O$[a#X$[a#u$[a#w$[a!m$[a&s$[a!x$[a!n$[aV$[a!q$[a~P!'WOz4dO!}$[a#O$[a#X$[a#u$[a#w$[aV$[a!q$[a~PNyOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$_a#O$_a#X$_a#u$_a#w$_a!m$_a&s$_a!x$_a!n$_aV$_a!q$_a~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$|a#O$|a#X$|a#u$|a#w$|a!m$|a&s$|a!x$|a!n$|aV$|a!q$|a~P!'WOz4dO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#u#yi#w#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!}#yi#O#yi#X#yi#u#yi#w#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOT4fOz4dO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!S#yi!}#yi#O#yi#X#yi#u#yi#w#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOT4fOz4dO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!S#yi!b#yi!}#yi#O#yi#X#yi#u#yi#w#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO#S#QO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#u#yi#w#yi#z#yi#{#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO#S#QO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO#S#QO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO#S#QO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$T4qO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$S4pO$T4qO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}#Ta#O#Ta#X#Ta#u#Ta#w#Ta!m#Ta&s#Ta!x#Ta!n#TaV#Ta!q#Ta~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}'Pa#O'Pa#X'Pa#u'Pa#w'Pa!m'Pa&s'Pa!x'Pa!n'PaV'Pa!q'Pa~P!'WOz4dO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#Pi!S#Pi!b#Pi!}#Pi#O#Pi#X#Pi#u#Pi#w#Pi!m#Pi&s#Pi!x#Pi!n#PiV#Pi!q#Pi~P!'WOz4dO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#vi!S#vi!b#vi!}#vi#O#vi#X#vi#u#vi#w#vi!m#vi&s#vi!x#vi!n#viV#vi!q#vi~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}#xi#O#xi#X#xi#u#xi#w#xi!m#xi&s#xi!x#xi!n#xiV#xi!q#xi~P!'WOz4dO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT!uq!S!uq!b!uq!v!uq!}!uq#O!uq#X!uq#u!uq#w!uq!m!uq&s!uq!x!uq!n!uqV!uq!q!uq~P!'WOz4dO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#Pq!S#Pq!b#Pq!}#Pq#O#Pq#X#Pq#u#Pq#w#Pq!m#Pq&s#Pq!x#Pq!n#PqV#Pq!q#Pq~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$jq#O$jq#X$jq#u$jq#w$jq!m$jq&s$jq!x$jq!n$jqV$jq!q$jq~P!'WOz4dO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT!uy!S!uy!b!uy!v!uy!}!uy#O!uy#X!uy#u!uy#w!uy!m!uy&s!uy!x!uy!n!uyV!uy!q!uy~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$jy#O$jy#X$jy#u$jy#w$jy!m$jy&s$jy!x$jy!n$jyV$jy!q$jy~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$j!R#O$j!R#X$j!R#u$j!R#w$j!R!m$j!R&s$j!R!x$j!R!n$j!RV$j!R!q$j!R~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$j!Z#O$j!Z#X$j!Z#u$j!Z#w$j!Z!m$j!Z&s$j!Z!x$j!Z!n$j!ZV$j!Z!q$j!Z~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$j!c#O$j!c#X$j!c#u$j!c#w$j!c!m$j!c&s$j!c!x$j!c!n$j!cV$j!c!q$j!c~P!'WO#S5wO~P#.YO!y$hO#S5{O~O!x4ZO#l'SO~O!y$hO#S5|O~OT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$ka#O$ka#X$ka#u$ka#w$ka!m$ka&s$ka!x$ka!n$kaV$ka!q$ka~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#O5vO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!m'PX#u'PX#w'PX&s'PX!x'PX!n'PX!q'PX#X'PX!}'PX~P!'WO#u4vO#w4wO!}&zX#O&zX#X&zXV&zX!q&zX~P0rO!q5QO~P>UO!q8bO#O5hO~OT8vOz8tO!S8wO!b8xO!q5iO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WO!q8cO#O5lO~O!q8dO#O5pO~O#O5pO#l'SO~O#O5qO#l'SO~O#O5tO#l'SO~O$l$tO~P9yOo5zOs$lO~O#S7oO~P9yOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$Xa#O$Xa#X$Xa!m$Xa&s$Xa!x$Xa!n$XaV$Xa!q$Xa~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$Ya#O$Ya#X$Ya!m$Ya&s$Ya!x$Ya!n$YaV$Ya!q$Ya~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$Za#O$Za#X$Za!m$Za&s$Za!x$Za!n$ZaV$Za!q$Za~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$[a#O$[a#X$[a!m$[a&s$[a!x$[a!n$[aV$[a!q$[a~P!'WOz6gO!}$[a#O$[a#X$[aV$[a!q$[a~PNyOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$_a#O$_a#X$_a!m$_a&s$_a!x$_a!n$_aV$_a!q$_a~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$ka#O$ka#X$ka!m$ka&s$ka!x$ka!n$kaV$ka!q$ka~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$|a#O$|a#X$|a!m$|a&s$|a!x$|a!n$|aV$|a!q$|a~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO!}7sO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x'jX~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO!}7uO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x&|X~P!'WOz6gO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!}#yi#O#yi#X#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOT6iOz6gO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!S#yi!}#yi#O#yi#X#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOT6iOz6gO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!S#yi!b#yi!}#yi#O#yi#X#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO#S#QO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#z#yi#{#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO#S#QO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#z#yi#{#yi#|#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO#S#QO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#z#yi#{#yi#|#yi#}#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO#S#QO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$T6tO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$S6sO$T6tO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WO#S7zO~P>UO!m#Ta&s#Ta!x#Ta!n#Ta~PCqO!m'Pa&s'Pa!x'Pa!n'Pa~PCqO#S;dO#U;cO!x&WX!}&WX~P9yO!}7lO!x'Oa~Oz6gO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#Pi!S#Pi!b#Pi!}#Pi#O#Pi#X#Pi!m#Pi&s#Pi!x#Pi!n#PiV#Pi!q#Pi~P!'WOz6gO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#vi!S#vi!b#vi!}#vi#O#vi#X#vi!m#vi&s#vi!x#vi!n#viV#vi!q#vi~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}#xi#O#xi#X#xi!m#xi&s#xi!x#xi!n#xiV#xi!q#xi~P!'WO!}7sO!x%da~O!x&UX!}&UX~P>UO!}7uO!x&|a~Oz6gO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT!uq!S!uq!b!uq!v!uq!}!uq#O!uq#X!uq!m!uq&s!uq!x!uq!n!uqV!uq!q!uq~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#Vi!}#Vi~P!'WOz6gO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#Pq!S#Pq!b#Pq!}#Pq#O#Pq#X#Pq!m#Pq&s#Pq!x#Pq!n#PqV#Pq!q#Pq~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$jq#O$jq#X$jq!m$jq&s$jq!x$jq!n$jqV$jq!q$jq~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x&ka!}&ka~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x&Ua!}&Ua~P!'WOz6gO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT!uy!S!uy!b!uy!v!uy!}!uy#O!uy#X!uy!m!uy&s!uy!x!uy!n!uyV!uy!q!uy~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#Vq!}#Vq~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$jy#O$jy#X$jy!m$jy&s$jy!x$jy!n$jyV$jy!q$jy~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$j!R#O$j!R#X$j!R!m$j!R&s$j!R!x$j!R!n$j!RV$j!R!q$j!R~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$j!Z#O$j!Z#X$j!Z!m$j!Z&s$j!Z!x$j!Z!n$j!ZV$j!Z!q$j!Z~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$j!c#O$j!c#X$j!c!m$j!c&s$j!c!x$j!c!n$j!cV$j!c!q$j!c~P!'WO#S8[O~P9yO#O8ZO!m'PX&s'PX!x'PX!n'PXV'PX!q'PX~PGSO!y$hO#S8`O~O!y$hO#S8aO~O#u6zO#w6{O!}&zX#O&zX#X&zXV&zX!q&zX~P0rOr6|O#S#oO#U#nO!}#xX#O#xX#X#xXV#xX!q#xX~P2yOr;iO#S9XO#U9VOT#xXz#xX!S#xX!b#xX!m#xX!o#xX!q#xX!v#xX#`#xX#a#xX#s#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX!n#xX!}#xX~P9yOr9WO#S9WO#U9WOT#xXz#xX!S#xX!b#xX!o#xX!v#xX#`#xX#a#xX#s#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX~P9yOr9]O#S;dO#U;cOT#xXz#xX!S#xX!b#xX!o#xX!q#xX!v#xX#`#xX#a#xX#s#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX#X#xX!x#xX!}#xX~P9yO$l$tO~P>UO!q7XO~P>UOT6iOz6gO!S6jO!b6kO!v8sO#O7iO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!x'PX!}'PX~P!'WOP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$z:nO${!OO~P$;lO!}7lO!x'OX~O#S9yO~P>UOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$Xa#X$Xa!x$Xa!}$Xa~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$Ya#X$Ya!x$Ya!}$Ya~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$Za#X$Za!x$Za!}$Za~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$[a#X$[a!x$[a!}$[a~P!'WOz8tO$z#dOT$[a!S$[a!b$[a!q$[a!v$[a#S$[a#z$[a#{$[a#|$[a#}$[a$O$[a$Q$[a$R$[a$S$[a$T$[a$U$[a$V$[a$W$[a#X$[a!x$[a!}$[a~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$_a#X$_a!x$_a!}$_a~P!'WO!q=dO#O7rO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$ka#X$ka!x$ka!}$ka~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$|a#X$|a!x$|a!}$|a~P!'WOT8vOz8tO!S8wO!b8xO!q7wO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WOz8tO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#X#yi!x#yi!}#yi~P!'WOz8tO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi#X#yi!x#yi!}#yi~P!'WOT8vOz8tO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!S#yi!q#yi#X#yi!x#yi!}#yi~P!'WOT8vOz8tO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!S#yi!b#yi!q#yi#X#yi!x#yi!}#yi~P!'WOz8tO#S#QO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#z#yi#{#yi#X#yi!x#yi!}#yi~P!'WOz8tO#S#QO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#z#yi#{#yi#|#yi#X#yi!x#yi!}#yi~P!'WOz8tO#S#QO$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#z#yi#{#yi#|#yi#}#yi#X#yi!x#yi!}#yi~P!'WOz8tO#S#QO$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#z#yi#{#yi#|#yi#}#yi$O#yi#X#yi!x#yi!}#yi~P!'WOz8tO$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi#X#yi!x#yi!}#yi~P!'WOz8tO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi#X#yi!x#yi!}#yi~P!'WOz8tO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi#X#yi!x#yi!}#yi~P!'WOz8tO$T9RO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi#X#yi!x#yi!}#yi~P!'WOz8tO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi#X#yi!x#yi!}#yi~P!'WOz8tO$S9QO$T9RO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi#X#yi!x#yi!}#yi~P!'WOz8tO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi#X#yi!x#yi!}#yi~P!'WOz8tO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#Pi!S#Pi!b#Pi!q#Pi#X#Pi!x#Pi!}#Pi~P!'WOz8tO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#vi!S#vi!b#vi!q#vi#X#vi!x#vi!}#vi~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q#xi#X#xi!x#xi!}#xi~P!'WO!q=eO#O7|O~Oz8tO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT!uq!S!uq!b!uq!q!uq!v!uq#X!uq!x!uq!}!uq~P!'WOz8tO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#Pq!S#Pq!b#Pq!q#Pq#X#Pq!x#Pq!}#Pq~P!'WO!q=iO#O8TO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$jq#X$jq!x$jq!}$jq~P!'WO#O8TO#l'SO~Oz8tO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT!uy!S!uy!b!uy!q!uy!v!uy#X!uy!x!uy!}!uy~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$jy#X$jy!x$jy!}$jy~P!'WO#O8UO#l'SO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$j!R#X$j!R!x$j!R!}$j!R~P!'WO#O8XO#l'SO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$j!Z#X$j!Z!x$j!Z!}$j!Z~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$j!c#X$j!c!x$j!c!}$j!c~P!'WO#S:bO~P>UO#O:aO!q'PX!x'PX~PGSO$l$tO~P$8YOP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$l$tO$z:nO${!OO~P$;lOo8_Os$lO~O#S<jO~P$8YOP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!s#gO!y[O#S<kO#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$z:nO${!OO~P$;lOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$Xa!q$Xa!n$Xa!}$Xa~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$Ya!q$Ya!n$Ya!}$Ya~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$Za!q$Za!n$Za!}$Za~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$[a!q$[a!n$[a!}$[a~P!'WOz:pO$z#dOT$[a!S$[a!b$[a!m$[a!q$[a!v$[a#S$[a#z$[a#{$[a#|$[a#}$[a$O$[a$Q$[a$R$[a$S$[a$T$[a$U$[a$V$[a$W$[a!n$[a!}$[a~P!'WOz:qO$z#dOT$[a!S$[a!b$[a!v$[a#S$[a#z$[a#{$[a#|$[a#}$[a$O$[a$Q$[a$R$[a$S$[a$T$[a$U$[a$V$[a$W$[a~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$_a!q$_a!n$_a!}$_a~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$ka!q$ka!n$ka!}$ka~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$|a!q$|a!n$|a!}$|a~P!'WOz:pO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi!n#yi!}#yi~P!'WOz:qO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi~P!'WOz:pO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!n#yi!}#yi~P!'WOz:qO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi~P!'WOT:tOz:pO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!S#yi!m#yi!q#yi!n#yi!}#yi~P!'WOT:uOz:qO!b:yO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dO!S#yi~P!'WOT:tOz:pO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!S#yi!b#yi!m#yi!q#yi!n#yi!}#yi~P!'WOT:uOz:qO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dO!S#yi!b#yi~P!'WOz:pO#S#QO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#z#yi#{#yi!n#yi!}#yi~P!'WOz:qO#S#QO#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#z#yi#{#yi~P!'WOz:pO#S#QO#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#z#yi#{#yi#|#yi!n#yi!}#yi~P!'WOz:qO#S#QO#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#z#yi#{#yi#|#yi~P!'WOz:pO#S#QO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#z#yi#{#yi#|#yi#}#yi!n#yi!}#yi~P!'WOz:qO#S#QO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#z#yi#{#yi#|#yi#}#yi~P!'WOz:pO#S#QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#z#yi#{#yi#|#yi#}#yi$O#yi!n#yi!}#yi~P!'WOz:qO#S#QO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#z#yi#{#yi#|#yi#}#yi$O#yi~P!'WOz:pO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi!n#yi!}#yi~P!'WOz:qO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi~P!'WOz:pO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi!n#yi!}#yi~P!'WOz:qO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi~P!'WOz:pO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi!n#yi!}#yi~P!'WOz:qO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi~P!'WOz:pO$T;[O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi!n#yi!}#yi~P!'WOz:qO$T;]O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi~P!'WOz:pO$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi!n#yi!}#yi~P!'WOz:qO$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi~P!'WOz:pO$S;YO$T;[O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi!n#yi!}#yi~P!'WOz:qO$S;ZO$T;]O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi~P!'WOz:pO$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi!n#yi!}#yi~P!'WOz:qO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#Ta!}#Ta!q#Ta#X#Ta~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x'Pa!}'Pa!q'Pa#X'Pa~P!'WOz:pO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#Pi!S#Pi!b#Pi!m#Pi!q#Pi!n#Pi!}#Pi~P!'WOz:qO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#Pi!S#Pi!b#Pi~P!'WOz:pO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#vi!S#vi!b#vi!m#vi!q#vi!n#vi!}#vi~P!'WOz:qO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#vi!S#vi!b#vi~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m#xi!q#xi!n#xi!}#xi~P!'WOz:pO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT!uq!S!uq!b!uq!m!uq!q!uq!v!uq!n!uq!}!uq~P!'WOz:qO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT!uq!S!uq!b!uq!v!uq~P!'WOz:pO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#Pq!S#Pq!b#Pq!m#Pq!q#Pq!n#Pq!}#Pq~P!'WOz:qO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#Pq!S#Pq!b#Pq~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$jq!q$jq!n$jq!}$jq~P!'WOz:pO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT!uy!S!uy!b!uy!m!uy!q!uy!v!uy!n!uy!}!uy~P!'WOz:qO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT!uy!S!uy!b!uy!v!uy~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$jy!q$jy!n$jy!}$jy~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$j!R!q$j!R!n$j!R!}$j!R~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$j!Z!q$j!Z!n$j!Z!}$j!Z~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$j!c!q$j!c!n$j!c!}$j!c~P!'WO#S=TO~P$8YOP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!s#gO!y[O#S=UO#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$z:nO${!OO~P$;lOT6iOz6gO!S6jO!b6kO!v8sO#O=SO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#O=RO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m'PX!q'PX!n'PX!}'PX~P!'WOT&zXz&zX!S&zX!b&zX!o&zX!q&zX!v&zX!y&zX#S&zX#W&zX#`&zX#a&zX#s&zX#z&zX#{&zX#|&zX#}&zX$O&zX$Q&zX$R&zX$S&zX$T&zX$U&zX$V&zX$W&zX$z&zX!}&zX~O#u9ZO#w9[O#X&zX!x&zX~P.8oO!y$hO#S=^O~O!q9hO~P>UO!y$hO#S=cO~O!q>OO#O9}O~OT8vOz8tO!S8wO!b8xO!q:OO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m#Ta!q#Ta!n#Ta!}#Ta~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m'Pa!q'Pa!n'Pa!}'Pa~P!'WO!q>PO#O:RO~O!q>QO#O:YO~O#O:YO#l'SO~O#O:ZO#l'SO~O#O:_O#l'SO~O#u;eO#w;gO!m&zX!n&zX~P.8oO#u;fO#w;hOT&zXz&zX!S&zX!b&zX!o&zX!v&zX!y&zX#S&zX#W&zX#`&zX#a&zX#s&zX#z&zX#{&zX#|&zX#}&zX$O&zX$Q&zX$R&zX$S&zX$T&zX$U&zX$V&zX$W&zX$z&zX~O!q;tO~P>UO!q;uO~P>UO!q>XO#O<oO~O!q>YO#O9WO~OT8vOz8tO!S8wO!b8xO!q<pO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WOT8vOz8tO!S8wO!b8xO!q<qO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WO!q>ZO#O<vO~O!q>[O#O<{O~O#O<{O#l'SO~O#O9WO#l'SO~O#O<|O#l'SO~O#O=PO#l'SO~O!y$hO#S=|O~Oo=[Os$lO~O!y$hO#S=}O~O!y$hO#S>UO~O!y$hO#S>VO~O!y$hO#S>WO~Oo={Os$lO~Oo>TOs$lO~Oo>SOs$lO~O%O$U$}$d!d$V#b%V#e'g!s#d~",
  goto: "%&y'mPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP'nP'uPP'{(OPPP(hP(OP(O*ZP*ZPP2W:j:mPP*Z:sBpPBsPBsPP:sCSCVCZ:s:sPPPC^PP:sK^!$S!$S:s!$WP!$W!$W!%UP!.]!7pP!?oP*ZP*Z*ZPPPPP!?rPPPPPPP*Z*Z*Z*ZPP*Z*ZP!E]!GRP!GV!Gy!GR!GR!HP*Z*ZP!HY!Hl!Ib!J`!Jd!J`!Jo!J}!J}!KV!KY!KY*ZPP*ZPP!K^#%[#%[#%`P#%fP(O#%j(O#&S#&V#&V#&](O#&`(O(O#&f#&i(O#&r#&u(O(O(O(O(O#&x(O(O(O(O(O(O(O(O(O#&{!KR(O(O#'_#'o#'r(O(OP#'u#'|#(S#(o#(y#)P#)Z#)b#)h#*d#4X#5T#5Z#5a#5k#5q#5w#6]#6c#6i#6o#6u#6{#7R#7]#7g#7m#7s#7}PPPPPPPP#8T#8X#8}#NO#NR#N]$(f$(r$)X$)_$)b$)e$)k$,X$5v$>_$>b$>h$>k$>n$>w$>{$?X$?k$Bk$CO$C{$K{PP%%y%%}%&Z%&p%&vQ!nQT!qV!rQUOR%x!mRVO}!hPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1a|!hPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1aQ%^!ZQ%g!aQ%l!eQ'd$dQ'q$iQ)[%kQ*y'tQ,](xU-n*v*x+OQ.W+cQ.{,[S/t-s-tQ0T.SS0}/s/wQ1V0RQ1o1OR2P1p0u!OPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=n0t!OPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nQ#j]Q$}!PQ%O!QQ%P!RQ,S(kQ.b+sR.f+vR&q#jQ)z&pR/a-R0uhPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nR#l^k#p_j#k#s&s&w3x3y7l8f8g8h8iR#u`T&|#t'OR-Y*U0thPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nR#va-r#OZ#f#m#w$V$W$X$Y$Z$[$u$v%W%Y%[%`%s%|&O&Q&U&^&_&`&a&b&c&d&e&f&g&h&i&j&k&l&m&u&v&{'X'Z'[(](p)q)s)u*O*[*^+S+V,`,c,y,{,}-V-W-X-i-x.k.w/`/h/n/y0r0u0x1Q1X1d1m1q2q2r2x2y2z2{2|2}3O3Q3R3S3T3U3V3W3X3Y3Z3[3]3^3_3`3a3b3c3e3f3i3j3l3m3n3q3r3t4Y4y4z4{4|4}5O5P5R5S5T5U5V5W5X5Y5Z5[5]5^5_5`5a5b5c5d5f5g5j5k5m5n5o5r5s5u6R6V6}7O7P7Q7R7S7U7V7W7Y7Z7[7]7^7_7`7a7b7c7d7e7f7g7h7j7k7n7p7q7x7y7{7}8O8P8Q8R8S8V8W8Y8]9U9^9_9`9a9b9c9f9g9i9j9k9l9m9n9o9p9q9r9s9t9u9v9w9x9z9{:P:Q:T:V:W:[:^:`:c;j;k;l;m;n;o;p;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<[<]<^<_<`<a<b<c<d<e<f<g<h<i<l<m<n<r<s<t<u<w<x<y<z<}=O=Q=V=W=_=`=a=q=rQ']$]Y(Q$s7T9e;q;rS(U2Z6QR(X$tT&X!})v!w$Qg#}$h'S'i'm'r(P(T)Z*f*s*z*}+Q+]+`+g,Z-r-u-{.Q/u1P5}6O6P6]8b8c8d=d=e=i>O>P>Q>X>Y>Z>[3ZfPVX[_bgjklmnoprxyz!S!W!X!Y!]!e!f!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t#}$R$S$U$h$y$}%P%R%S%T%U%c%p%r%}&S&W&p&s&t&w'O'S'U'Y'^'i'm'r'z(O(P(R(S(T(`(l({)P)Z)_)c)i)p)t)v*P*T*U*f*o*s*z*}+P+Q+]+`+d+g+r+u+z,T,V,X,Z,u-Q-R-d-k-r-u-z-{-|.Q.b.d.l.t/[/c/i/m/u/x0V0`0a0d0e0i0v1P1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w5}6O6P6T6]6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8b8c8d8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=d=e=i=m=n>O>P>Q>X>Y>Z>[3scPVX[_bdegjklmnoprxyz!S!W!X!Y!]!e!f!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t#{#}$R$S$U$h$y$}%P%R%S%T%U%c%m%n%p%r%}&S&W&p&s&t&w'O'S'U'Y'^'i'm'r'z(O(P(R(S(T(`(l({)P)Z)^)_)c)g)h)i)p)t)v*P*T*U*f*o*s*z*}+P+Q+]+`+d+g+r+u+z,T,V,X,Z,u,x-Q-R-d-k-r-u-z-{-|.Q.b.d.l.t/[/c/i/m/u/x0V0`0a0d0e0i0v1P1R1]1a2W2X2Y2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w5}6O6P6T6]6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8b8c8d8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=d=e=i=m=n>O>P>Q>X>Y>Z>[0phPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0`0a0d0e0i0v1R1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nT1Z0V1]R&]#P!n#[Z#f#w$V$W$X$Y$[$s$v%W%Y%[&Q&_&`&a&b&c&d&e&f'X'Z'[(])q)s*^+V,{-x/y1Q1d1q7j7k!Y2j2Z2x2y2z2{2}3O3Q3R3S3T3U3V3W3X3a3b3c3e3f3i3j3l3m3n3q3r3t!^4m2r4y4z4{4|5O5P5R5S5T5U5V5W5X5Y5b5c5d5f5g5j5k5m5n5o5r5s5u6Q6R#Q6p#m%`%s&u&v&{(p*O+S,`,c,y-V-X.w2q6}7O7P7Q7S7T7U7Y7Z7[7]7^7_7`7a7n7p7q7x7{7}8Q8S8V8W8Y8]9U:c=V=W#^8}%|&O&U)u,}-W-i/h/n0r0u0x1m4Y6V7V7W7y8O8P8R9^9_9`9a9c9e9f9g9i9j9k9l9m9n9o9p9x9z9{:P:Q:T:V:W:[:^:`<f<g=_=q=r!^;S.k/`;j;k;l;m;p;q;s;v;x;z;|<O<Q<S<U<h<l<n<r<t<w<x<z<}=O=Q=`=ao;T1X;r;w;y;{;}<P<R<T<V<i<m<s<u<yS$iu#hQ$qwU't$j$l&oQ'v$kS'x$m$rQ*|'uQ+O'wQ+R'yQ4X5xS4[5z5{Q4]5|Q6U8^S6W8_8`Q6X8aQ9d=YS9|=[=^Q:S=cQ=]=yS=b={=|Q=f=}Q=o>RS=p>S>VS=s>T>UR=t>WT'n$h*s!csPVXt!S!j!r!s!w$h$}%P%S%U'i(T(`)W*s+]+g+r+u,g,k.b.d.l0`0a0i1aQ$^rR*`'^Q*x'sQ-t*{R/w-wQ(W$tQ)U%hQ)n%vQ*i'fQ+k(XR-c*jQ(V$tQ)Y%jQ)m%vQ*e'eS*h'f)nS+j(W(XS-b*i*jQ.]+kQ/T,mQ/e-`R/g-cQ(U$tQ)T%hQ)V%iQ)l%vU*g'f)m)nU+i(V(W(XQ,f)UU-a*h*i*jS.[+j+kS/f-b-cQ0X.]R0t/gT+e(T+g[%e!_$b'c+a.R0QR,d)Qb$ov(T+[+]+`+g.P.Q0PR+T'{S+e(T+gT,j)W,kR0W.XT1[0V1]0w|PVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X,_-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nT$x{${Q+p([R._+nT$z{${Q(b$}Q(j%PQ(o%SQ(r%UQ.j+yQ0].fQ0^.iR1g0iR(e%OX+|(c(d+},PR(f%OX(h%P%S%U0iR%S!T_%a!]%R(l,T,V.t0dR%U!UR.x,XR,[(wQ)X%jS*d'e)YS-_*e,mS/d-`/TR0s/eQ%q!fU)]%m%n%rU,o)^)g)hR/_,xR)d%pR/],uSSO!mR!oSQ!rVR%y!rQ!jPS!sV!rQ!wX[%u!j!s!w+r0a1aQ+r(`Q0a.lR1a0`Q)j%sS,z)j7vR7v7WQ-S)zR/b-SQ&x#qS*R&x7mR7m9YS*V&{&|R-Z*VQ)w&YR-P)w!l'T#|'h*n*q*v+W+[,m-`-s-v-y.P.z/s/v/z0P1O1p4^4_4`5y6Y6Z6[:U:X:]=g=h=j=u=v=w=xR*Z'T1^dPVX[_bjklmnoprxyz!S!W!X!Y!]!e!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%p%}&S&W&p&s&t&w'O'U'Y'^'z(O(R(S(`(l({)P)_)c)i)p)t)v*P*T*U*o+P+d+r+u+z,T,V,X,u-Q-R-d-k-z-|.b.d.l.t/[/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=n`#zd#{%m)^)g,x2W2YQ#{eQ%m!fQ)^%nQ)g%rQ,x)h!v2Wg#}$h'S'i'm'r(P(T)Z*f*s*z*}+Q+]+`+g,Z-r-u-{.Q/u1P5}6O6P6]8b8c8d=d=e=i>O>P>Q>X>Y>Z>[R2Y2X|tPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1aW$`t'i+],gS'i$h*sS+](T+gT,g)W,kQ'_$^R*a'_Q*t'oR-m*tQ/p-oS0{/p0|R0|/qQ-}+XR/|-}Q+g(TR.Y+gS+`(T+gS,h)W,kQ.Q+]W.T+`,h.Q/OR/O,gQ)R%eR,e)RQ'|$oR+U'|Q1]0VR1w1]Q${{R(^${Q+t(aR.c+tQ+w(bR.g+wQ+}(cQ,P(dT.m+},PQ(|%`S,a(|7tR7t7VQ(y%^R,^(yQ,k)WR/R,kQ)`%oS,q)`/WR/W,rQ,v)dR/^,vT!uV!rj!iPVX!j!r!s!w(`+r.l0`0a1aQ%Q!SQ(a$}W(h%P%S%U0iQ.e+uQ0Z.bR0[.d|ZPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1aQ#f[U#m_#s&wQ#wbQ$VkQ$WlQ$XmQ$YnQ$ZoQ$[pQ$sx^$uy2_4b6e8q:m:nQ$vzQ%W!WQ%Y!XQ%[!YW%`!]%R(l,VU%s!g&p-RQ%|!yQ&O!zQ&Q!{S&U!})v^&^#R2a4d6g8t:p:qQ&_#SQ&`#TQ&a#UQ&b#VQ&c#WQ&d#XQ&e#YQ&f#ZQ&g#[Q&h#]Q&i#^Q&j#_Q&k#`Q&l#aQ&m#bQ&u#nQ&v#oS&{#t'OQ'X$RQ'Z$SQ'[$UQ(]$yQ(p%TQ)q%}Q)s&SQ)u&WQ*O&tS*['U4ZQ*^'Y^*_2[3u5v8Z:a=R=SQ+S'zQ+V(OQ,`({Q,c)PQ,y)iQ,{)pQ,})tQ-V*PQ-W*TQ-X*U^-]2]3v5w8[:b=T=UQ-i*oQ-x+PQ.k+zQ.w,XQ/`-QQ/h-dQ/n-kQ/y-zQ0r/cQ0u/iQ0x/mQ1Q/xU1X0V1]9WQ1d0eQ1m0vQ1q1RQ2Z2^Q2qjQ2r3yQ2x3zQ2y3|Q2z4OQ2{4QQ2|4SQ2}4UQ3O2`Q3Q2bQ3R2cQ3S2dQ3T2eQ3U2fQ3V2gQ3W2hQ3X2iQ3Y2jQ3Z2kQ3[2lQ3]2mQ3^2nQ3_2oQ3`2pQ3a2sQ3b2tQ3c2uQ3e2vQ3f2wQ3i3PQ3j3dQ3l3gQ3m3hQ3n3kQ3q3oQ3r3pQ3t3sQ4Y4WQ4y3{Q4z3}Q4{4PQ4|4RQ4}4TQ5O4VQ5P4cQ5R4eQ5S4fQ5T4gQ5U4hQ5V4iQ5W4jQ5X4kQ5Y4lQ5Z4mQ5[4nQ5]4oQ5^4pQ5_4qQ5`4rQ5a4sQ5b4tQ5c4uQ5d4vQ5f4wQ5g4xQ5j5QQ5k5eQ5m5hQ5n5iQ5o5lQ5r5pQ5s5qQ5u5tQ6Q4aQ6R3xQ6V6TQ6}6^Q7O6_Q7P6`Q7Q6aQ7R6bQ7S6cQ7T6dQ7U6fU7V,T.t0dQ7W%cQ7Y6hQ7Z6iQ7[6jQ7]6kQ7^6lQ7_6mQ7`6nQ7a6oQ7b6pQ7c6qQ7d6rQ7e6sQ7f6tQ7g6uQ7h6vQ7j6xQ7k6yQ7n6zQ7p6{Q7q6|Q7x7XQ7y7iQ7{7oQ7}7rQ8O7sQ8P7uQ8Q7wQ8R7zQ8S7|Q8V8TQ8W8UQ8Y8XQ8]8fU9U#k&s7lQ9^8jQ9_8kQ9`8lQ9a8mQ9b8nQ9c8oQ9e8pQ9f8rQ9g8sQ9i8uQ9j8vQ9k8wQ9l8xQ9m8yQ9n8zQ9o8{Q9p8|Q9q8}Q9r9OQ9s9PQ9t9QQ9u9RQ9v9SQ9w9TQ9x9ZQ9z9[Q9{9]Q:P9hQ:Q9yQ:T9}Q:V:OQ:W:RQ:[:YQ:^:ZQ:`:_Q:c8iQ;j:dQ;k:eQ;l:fQ;m:gQ;n:hQ;o:iQ;p:jQ;q:kQ;r:lQ;s:oQ;v:rQ;w:sQ;x:tQ;y:uQ;z:vQ;{:wQ;|:xQ;}:yQ<O:zQ<P:{Q<Q:|Q<R:}Q<S;OQ<T;PQ<U;QQ<V;RQ<W;SQ<X;TQ<Y;UQ<Z;VQ<[;WQ<];XQ<^;YQ<_;ZQ<`;[Q<a;]Q<b;^Q<c;_Q<d;`Q<e;aQ<f;cQ<g;dQ<h;eQ<i;fQ<l;gQ<m;hQ<n;iQ<r;tQ<s;uQ<t<jQ<u<kQ<w<oQ<x<pQ<y<qQ<z<vQ<}<{Q=O<|Q=Q=PQ=V8hQ=W8gQ=_=ZQ=`9VQ=a9XQ=q=mR=r=nR){&pQ%t!gQ)O%cT)y&p-R$SiPVX[bklmnopxyz!S!W!X!Y!j!r!s!w!{#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b$R$S$U$y$}%P%S%U%}&S'Y(O(`)p+P+r+u-z.b.d.l/x0`0a0e0i1R1a2[2]6x6y!t3w'U2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3z3|4O4Q4S4U5v5w!x6S3u3v3x3y3{3}4P4R4T4V4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t$O8e_j!]!g#k#n#o#s#t%R%T&p&s&t&w'O'z(l({)P)i*P*U,V,X-R6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6z6{6|7X7l7o7r7w7|8T8U8X8Z8[8f8g8h8i#|=X!y!z!}%c&W)t)v*T*o,T-d-k.t/c/i/m0d0v4W6T7i7s7u7z8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9Z9[9]9h9y9}:O:R:Y:Z:_:a:b;c;d=Z=m=n!v=k+z-Q9V9X:d:e:f:g:h:j:k:m:o:p:r:t:v:x:z:|;O;Q;S;U;W;Y;[;^;`;e;g;i;t<j<o<p<v<{<|=P=R=T!]=l0V1]9W:i:l:n:q:s:u:w:y:{:};P;R;T;V;X;Z;];_;a;f;h;u<k<q=S=UQ#r_Q&r#kQ&z#sR)}&sS#q_#s^$Tj3x3y8f8g8h8iS*Q&w7lT9Y#k&sQ&}#tR*X'OR&T!|R&Z!}Q&Y!}R-O)vQ#|gQ'V#}S'h$h*sQ*Y'SQ*n'iQ*q'mQ*v'rQ+W(PS+[(T+gQ,m)ZQ-`*fQ-s*zQ-v*}Q-y+QS.P+]+`Q.z,ZQ/s-rQ/v-uQ/z-{Q0P.QQ1O/uQ1p1PQ4^5}Q4_6OQ4`6PQ5y6]Q6Y8bQ6Z8cQ6[8dQ:U=dQ:X=eQ:]=iQ=g>OQ=h>PQ=j>QQ=u>XQ=v>YQ=w>ZR=x>[0t!OPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=n!v$Pg#}$h'S'i'm'r(P(T)Z*f*s*z*}+Q+]+`+g,Z-r-u-{.Q/u1P5}6O6P6]8b8c8d=d=e=i>O>P>Q>X>Y>Z>[S$]r'^Q%k!eS%o!f%rQ)b%pU+X(R(S+dQ,p)_Q,t)cQ/Z,uQ/{-|R0p/[|vPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1a#U#i[bklmnopxyz!W!X!Y!{#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b$R$S$U$y%}&S'Y(O)p+P-z/x0e1R2[2]6x6yd+^(T)W+]+`+g,g,h,k.Q/O!t6w'U2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3z3|4O4Q4S4U5v5w!x;b3u3v3x3y3{3}4P4R4T4V4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t$O=z_j!]!g#k#n#o#s#t%R%T&p&s&t&w'O'z(l({)P)i*P*U,V,X-R6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6z6{6|7X7l7o7r7w7|8T8U8X8Z8[8f8g8h8i#|>]!y!z!}%c&W)t)v*T*o,T-d-k.t/c/i/m0d0v4W6T7i7s7u7z8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9Z9[9]9h9y9}:O:R:Y:Z:_:a:b;c;d=Z=m=n!v>^+z-Q9V9X:d:e:f:g:h:j:k:m:o:p:r:t:v:x:z:|;O;Q;S;U;W;Y;[;^;`;e;g;i;t<j<o<p<v<{<|=P=R=T!]>_0V1]9W:i:l:n:q:s:u:w:y:{:};P;R;T;V;X;Z;];_;a;f;h;u<k<q=S=UR'p$hQ'o$hR-l*sR$_rR-q*wQ+Y(RQ+Z(SR.X+dT+f(T+ge+_(T)W+]+`+g,g,h,k.Q/OQ%f!_Q'b$bQ*c'cQ.U+aQ0S.RR1U0QQ#eZQ%X!WQ%Z!XQ%]!YQ'}$pQ(s%VQ(t%WQ(u%YQ(v%[Q(}%bQ)S%fQ)[%kQ)f%qQ)k%tQ*b'bQ,n)]Q-^*cQ.V+bQ.W+cQ.e+xQ.o,QQ.p,RQ.q,SQ.v,WQ.y,YQ.},bQ/U,oQ/}.OQ0T.SQ0U.UQ0W.XQ0[.hQ0k/QQ0q/_Q1S0OQ1V0RQ1W0SQ1`0_Q1h0jQ1r1TQ1s1UQ1v1[Q1y1_Q1}1jQ2T1{R2U1|Q$pvS+b(T+gU.O+[+]+`S0O.P.QR1T0P|!aPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1aQ$dtW+c(T)W+g,kW.S+]+`,g,hT0R.Q/O0t!OPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nR.|,_0w}PVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X,_-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nT$w{${Q(i%PQ(n%SQ(q%UR1f0iQ%b!]Q(m%RQ,U(lQ.s,TQ.u,VQ0c.tR1c0dQ%q!fR)]%rR)e%p",
  nodeNames: "⚠ ( HeredocString EscapeSequence abstract LogicOp array as Boolean break case catch clone const continue default declare do echo else elseif enddeclare endfor endforeach endif endswitch endwhile enum extends final finally fn for foreach from function global goto if implements include include_once LogicOp insteadof interface list match namespace new null LogicOp print require require_once return switch throw trait try unset use var Visibility while LogicOp yield LineComment BlockComment TextInterpolation PhpClose Text PhpOpen Template TextInterpolation EmptyStatement ; } { Block : LabelStatement Name ExpressionStatement ConditionalExpression LogicOp MatchExpression ) ( ParenthesizedExpression MatchBlock MatchArm , => AssignmentExpression ArrayExpression ValueList & VariadicUnpacking ... Pair [ ] ListExpression ValueList Pair Pair SubscriptExpression MemberExpression -> ?-> VariableName DynamicVariable $ ${ CallExpression ArgList NamedArgument SpreadArgument CastExpression UnionType LogicOp OptionalType NamedType QualifiedName \\ NamespaceName ScopedExpression :: ClassMemberName AssignOp UpdateExpression UpdateOp YieldExpression BinaryExpression LogicOp LogicOp LogicOp BitOp BitOp BitOp CompareOp CompareOp BitOp ArithOp ConcatOp ArithOp ArithOp IncludeExpression RequireExpression CloneExpression UnaryExpression ControlOp LogicOp PrintIntrinsic FunctionExpression static ParamList Parameter #[ Attributes Attribute VariadicParameter PropertyParameter UseList ArrowFunction NewExpression class BaseClause ClassInterfaceClause DeclarationList ConstDeclaration VariableDeclarator PropertyDeclaration VariableDeclarator MethodDeclaration UseDeclaration UseList UseInsteadOfClause UseAsClause UpdateExpression ArithOp ShellExpression ThrowExpression Integer Float String MemberExpression SubscriptExpression UnaryExpression ArithOp Interpolation String IfStatement ColonBlock SwitchStatement Block CaseStatement DefaultStatement ColonBlock WhileStatement EmptyStatement DoStatement ForStatement ForSpec SequenceExpression ForeachStatement ForSpec Pair GotoStatement ContinueStatement BreakStatement ReturnStatement TryStatement CatchDeclarator DeclareStatement EchoStatement UnsetStatement ConstDeclaration FunctionDefinition ClassDeclaration InterfaceDeclaration TraitDeclaration EnumDeclaration EnumBody EnumCase NamespaceDefinition NamespaceUseDeclaration UseGroup UseClause UseClause GlobalDeclaration FunctionStaticDeclaration Program",
  maxTerm: 304,
  nodeProps: [
    ["group", -36, 2, 8, 49, 81, 83, 85, 88, 93, 94, 102, 106, 107, 110, 111, 114, 118, 123, 126, 130, 132, 133, 147, 148, 149, 150, 153, 154, 164, 165, 179, 181, 182, 183, 184, 185, 191, "Expression", -28, 74, 78, 80, 82, 192, 194, 199, 201, 202, 205, 208, 209, 210, 211, 212, 214, 215, 216, 217, 218, 219, 220, 221, 222, 225, 226, 230, 231, "Statement", -3, 119, 121, 122, "Type"],
    ["openedBy", 69, "phpOpen", 76, "{", 86, "(", 101, "#["],
    ["closedBy", 71, "phpClose", 77, "}", 87, ")", 158, "]"]
  ],
  propSources: [NC],
  skippedNodes: [0],
  repeatNodeCount: 29,
  tokenData: "!F|_R!]OX$zXY&^YZ'sZ]$z]^&^^p$zpq&^qr)Rrs+Pst+otu2buv5evw6rwx8Vxy>]yz>yz{?g{|@}|}Bb}!OCO!O!PDh!P!QKT!Q!R!!o!R![!$q![!]!,P!]!^!-a!^!_!-}!_!`!1S!`!a!2d!a!b!3t!b!c!7^!c!d!7z!d!e!9W!e!}!7z!}#O!;^#O#P!;z#P#Q!<h#Q#R!=U#R#S!7z#S#T!=u#T#U!7z#U#V!9W#V#o!7z#o#p!Co#p#q!D]#q#r!Er#r#s!F`#s$f$z$f$g&^$g&j!7z&j$I_$z$I_$I`&^$I`$KW$z$KW$KX&^$KX;'S$z;'S;=`&W<%l?HT$z?HT?HU&^?HUO$zP%PV&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zP%kO&wPP%nWOY$zYZ%fZ!a$z!b;'S$z;'S;=`&W<%l~$z~O$z~~%fP&ZP;=`<%l$zV&ed&wP&vUOX$zXY&^YZ'sZ]$z]^&^^p$zpq&^q!^$z!^!_%k!_$f$z$f$g&^$g$I_$z$I_$I`&^$I`$KW$z$KW$KX&^$KX;'S$z;'S;=`&W<%l?HT$z?HT?HU&^?HUO$zV'zW&wP&vUXY(dYZ(d]^(dpq(d$f$g(d$I_$I`(d$KW$KX(d?HT?HU(dU(iW&vUXY(dYZ(d]^(dpq(d$f$g(d$I_$I`(d$KW$KX(d?HT?HU(dR)YW$^Q&wPOY$zYZ%fZ!^$z!^!_%k!_!`)r!`;'S$z;'S;=`&W<%lO$zR)yW$QQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`*c!`;'S$z;'S;=`&W<%lO$zR*jV$QQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV+YV'fS&wP'gQOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV+v]&wP!dUOY,oYZ%fZ],o]^$z^!^,o!^!_-i!_!a,o!a!b/y!b!},o!}#O1f#O;'S,o;'S;=`/s<%lO,oV,vZ&wP!dUOY,oYZ%fZ],o]^$z^!^,o!^!_-i!_!a,o!a!b/y!b;'S,o;'S;=`/s<%lO,oV-nZ!dUOY,oYZ%fZ],o]^$z^!a,o!a!b.a!b;'S,o;'S;=`/s<%l~,o~O,o~~%fU.dWOY.|YZ/nZ].|]^/n^!`.|!a;'S.|;'S;=`/h<%lO.|U/RV!dUOY.|Z].|^!a.|!a!b.a!b;'S.|;'S;=`/h<%lO.|U/kP;=`<%l.|U/sO!dUV/vP;=`<%l,oV0OZ&wPOY,oYZ0qZ],o]^0x^!^,o!^!_-i!_!`,o!`!a$z!a;'S,o;'S;=`/s<%lO,oV0xO&wP!dUV1PV&wP!dUOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV1oZ&wP$dQ!dUOY,oYZ%fZ],o]^$z^!^,o!^!_-i!_!a,o!a!b/y!b;'S,o;'S;=`/s<%lO,o_2i`&wP#dQOY$zYZ%fZ!^$z!^!_%k!_!c$z!c!}3k!}#R$z#R#S3k#S#T$z#T#o3k#o#p4w#p$g$z$g&j3k&j;'S$z;'S;=`&W<%lO$z_3ra&wP#b^OY$zYZ%fZ!Q$z!Q![3k![!^$z!^!_%k!_!c$z!c!}3k!}#R$z#R#S3k#S#T$z#T#o3k#o$g$z$g&j3k&j;'S$z;'S;=`&W<%lO$zV5OV&wP#eUOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR5lW&wP$VQOY$zYZ%fZ!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zR6]V#wQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV6yY#SU&wPOY$zYZ%fZv$zvw7iw!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zR7pV#|Q&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR8^Z&wP%VQOY8VYZ9PZw8Vwx;_x!^8V!^!_;{!_#O8V#O#P<y#P;'S8V;'S;=`>V<%lO8VR9WV&wP%VQOw9mwx:Xx#O9m#O#P:^#P;'S9m;'S;=`;X<%lO9mQ9rV%VQOw9mwx:Xx#O9m#O#P:^#P;'S9m;'S;=`;X<%lO9mQ:^O%VQQ:aRO;'S9m;'S;=`:j;=`O9mQ:oW%VQOw9mwx:Xx#O9m#O#P:^#P;'S9m;'S;=`;X;=`<%l9m<%lO9mQ;[P;=`<%l9mR;fV&wP%VQOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR<Q]%VQOY8VYZ9PZw8Vwx;_x!a8V!a!b9m!b#O8V#O#P<y#P;'S8V;'S;=`>V<%l~8V~O8V~~%fR=OW&wPOY8VYZ9PZ!^8V!^!_;{!_;'S8V;'S;=`=h;=`<%l9m<%lO8VR=mW%VQOw9mwx:Xx#O9m#O#P:^#P;'S9m;'S;=`;X;=`<%l8V<%lO9mR>YP;=`<%l8VR>dV!yQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV?QV!xU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR?nY&wP$VQOY$zYZ%fZz$zz{@^{!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zR@eW$WQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zRAUY$TQ&wPOY$zYZ%fZ{$z{|At|!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zRA{V$zQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zRBiV!}Q&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$z_CXZ$TQ%TW&wPOY$zYZ%fZ}$z}!OAt!O!^$z!^!_%k!_!`6U!`!aCz!a;'S$z;'S;=`&W<%lO$zVDRV#`U&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zVDo[&wP$UQOY$zYZ%fZ!O$z!O!PEe!P!Q$z!Q![Fs![!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zVEjX&wPOY$zYZ%fZ!O$z!O!PFV!P!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zVF^V#UU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zRFz_&wP%OQOY$zYZ%fZ!Q$z!Q![Fs![!^$z!^!_%k!_!g$z!g!hGy!h#R$z#R#SJc#S#X$z#X#YGy#Y;'S$z;'S;=`&W<%lO$zRHO]&wPOY$zYZ%fZ{$z{|Hw|}$z}!OHw!O!Q$z!Q![Ii![!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zRH|X&wPOY$zYZ%fZ!Q$z!Q![Ii![!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zRIpZ&wP%OQOY$zYZ%fZ!Q$z!Q![Ii![!^$z!^!_%k!_#R$z#R#SHw#S;'S$z;'S;=`&W<%lO$zRJhX&wPOY$zYZ%fZ!Q$z!Q![Fs![!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zVK[[&wP$VQOY$zYZ%fZz$zz{LQ{!P$z!P!Q,o!Q!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zVLVX&wPOYLQYZLrZzLQz{N_{!^LQ!^!_! s!_;'SLQ;'S;=`!!i<%lOLQVLwT&wPOzMWz{Mj{;'SMW;'S;=`NX<%lOMWUMZTOzMWz{Mj{;'SMW;'S;=`NX<%lOMWUMmVOzMWz{Mj{!PMW!P!QNS!Q;'SMW;'S;=`NX<%lOMWUNXO!eUUN[P;=`<%lMWVNdZ&wPOYLQYZLrZzLQz{N_{!PLQ!P!Q! V!Q!^LQ!^!_! s!_;'SLQ;'S;=`!!i<%lOLQV! ^V!eU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV! vZOYLQYZLrZzLQz{N_{!aLQ!a!bMW!b;'SLQ;'S;=`!!i<%l~LQ~OLQ~~%fV!!lP;=`<%lLQZ!!vm&wP$}YOY$zYZ%fZ!O$z!O!PFs!P!Q$z!Q![!$q![!^$z!^!_%k!_!d$z!d!e!&o!e!g$z!g!hGy!h!q$z!q!r!(a!r!z$z!z!{!){!{#R$z#R#S!%}#S#U$z#U#V!&o#V#X$z#X#YGy#Y#c$z#c#d!(a#d#l$z#l#m!){#m;'S$z;'S;=`&W<%lO$zZ!$xa&wP$}YOY$zYZ%fZ!O$z!O!PFs!P!Q$z!Q![!$q![!^$z!^!_%k!_!g$z!g!hGy!h#R$z#R#S!%}#S#X$z#X#YGy#Y;'S$z;'S;=`&W<%lO$zZ!&SX&wPOY$zYZ%fZ!Q$z!Q![!$q![!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zZ!&tY&wPOY$zYZ%fZ!Q$z!Q!R!'d!R!S!'d!S!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zZ!'k[&wP$}YOY$zYZ%fZ!Q$z!Q!R!'d!R!S!'d!S!^$z!^!_%k!_#R$z#R#S!&o#S;'S$z;'S;=`&W<%lO$zZ!(fX&wPOY$zYZ%fZ!Q$z!Q!Y!)R!Y!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zZ!)YZ&wP$}YOY$zYZ%fZ!Q$z!Q!Y!)R!Y!^$z!^!_%k!_#R$z#R#S!(a#S;'S$z;'S;=`&W<%lO$zZ!*Q]&wPOY$zYZ%fZ!Q$z!Q![!*y![!^$z!^!_%k!_!c$z!c!i!*y!i#T$z#T#Z!*y#Z;'S$z;'S;=`&W<%lO$zZ!+Q_&wP$}YOY$zYZ%fZ!Q$z!Q![!*y![!^$z!^!_%k!_!c$z!c!i!*y!i#R$z#R#S!){#S#T$z#T#Z!*y#Z;'S$z;'S;=`&W<%lO$zR!,WX!qQ&wPOY$zYZ%fZ![$z![!]!,s!]!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!,zV#sQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV!-hV!mU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!.S[$RQOY$zYZ%fZ!^$z!^!_!.x!_!`!/i!`!a*c!a!b!0]!b;'S$z;'S;=`&W<%l~$z~O$z~~%fR!/PW$SQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zR!/pX$RQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`$z!`!a*c!a;'S$z;'S;=`&W<%lO$zP!0bR!iP!_!`!0k!r!s!0p#d#e!0pP!0pO!iPP!0sQ!j!k!0y#[#]!0yP!0|Q!r!s!0k#d#e!0kV!1ZX#uQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`)r!`!a!1v!a;'S$z;'S;=`&W<%lO$zV!1}V#OU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!2kX$RQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`!3W!`!a!.x!a;'S$z;'S;=`&W<%lO$zR!3_V$RQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV!3{[!vQ&wPOY$zYZ%fZ}$z}!O!4q!O!^$z!^!_%k!_!`$z!`!a!6P!a!b!6m!b;'S$z;'S;=`&W<%lO$zV!4vX&wPOY$zYZ%fZ!^$z!^!_%k!_!`$z!`!a!5c!a;'S$z;'S;=`&W<%lO$zV!5jV#aU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV!6WV!gU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!6tW#zQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zR!7eV$]Q&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$z_!8Ra&wP!s^OY$zYZ%fZ!Q$z!Q![!7z![!^$z!^!_%k!_!c$z!c!}!7z!}#R$z#R#S!7z#S#T$z#T#o!7z#o$g$z$g&j!7z&j;'S$z;'S;=`&W<%lO$z_!9_e&wP!s^OY$zYZ%fZr$zrs!:psw$zwx8Vx!Q$z!Q![!7z![!^$z!^!_%k!_!c$z!c!}!7z!}#R$z#R#S!7z#S#T$z#T#o!7z#o$g$z$g&j!7z&j;'S$z;'S;=`&W<%lO$zR!:wV&wP'gQOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV!;eV#WU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV!<RV#pU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!<oV#XQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!=]W$OQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zR!=zZ&wPOY!=uYZ!>mZ!^!=u!^!_!@u!_#O!=u#O#P!Aq#P#S!=u#S#T!B{#T;'S!=u;'S;=`!Ci<%lO!=uR!>rV&wPO#O!?X#O#P!?q#P#S!?X#S#T!@j#T;'S!?X;'S;=`!@o<%lO!?XQ!?[VO#O!?X#O#P!?q#P#S!?X#S#T!@j#T;'S!?X;'S;=`!@o<%lO!?XQ!?tRO;'S!?X;'S;=`!?};=`O!?XQ!@QWO#O!?X#O#P!?q#P#S!?X#S#T!@j#T;'S!?X;'S;=`!@o;=`<%l!?X<%lO!?XQ!@oO${QQ!@rP;=`<%l!?XR!@x]OY!=uYZ!>mZ!a!=u!a!b!?X!b#O!=u#O#P!Aq#P#S!=u#S#T!B{#T;'S!=u;'S;=`!Ci<%l~!=u~O!=u~~%fR!AvW&wPOY!=uYZ!>mZ!^!=u!^!_!@u!_;'S!=u;'S;=`!B`;=`<%l!?X<%lO!=uR!BcWO#O!?X#O#P!?q#P#S!?X#S#T!@j#T;'S!?X;'S;=`!@o;=`<%l!=u<%lO!?XR!CSV${Q&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!ClP;=`<%l!=uV!CvV!oU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV!DfY#}Q#lS&wPOY$zYZ%fZ!^$z!^!_%k!_!`6U!`#p$z#p#q!EU#q;'S$z;'S;=`&W<%lO$zR!E]V#{Q&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!EyV!nQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!FgV$^Q&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$z",
  tokenizers: [AC, MC, LC, 0, 1, 2, 3, GC],
  topRules: { Template: [0, 72], Program: [1, 232] },
  dynamicPrecedences: { 284: 1 },
  specialized: [{ term: 81, get: (t, e) => gS(t) << 1, external: gS }, { term: 81, get: (t) => BC[t] || -1 }],
  tokenPrec: 29354
});
var HC = Kt.define({
  name: "php",
  parser: FC.configure({
    props: [
      ci.add({
        IfStatement: gt({ except: /^\s*({|else\b|elseif\b|endif\b)/ }),
        TryStatement: gt({ except: /^\s*({|catch\b|finally\b)/ }),
        SwitchBody: (t) => {
          let e = t.textAfter, i = /^\s*\}/.test(e), n = /^\s*(case|default)\b/.test(e);
          return t.baseIndent + (i ? 0 : n ? 1 : 2) * t.unit;
        },
        ColonBlock: (t) => t.baseIndent + t.unit,
        "Block EnumBody DeclarationList": dO({ closing: "}" }),
        ArrowFunction: (t) => t.baseIndent + t.unit,
        "String BlockComment": () => null,
        Statement: gt({ except: /^({|end(for|foreach|switch|while)\b)/ })
      }),
      ui.add({
        "Block EnumBody DeclarationList SwitchBody ArrayExpression ValueList": Mn,
        ColonBlock(t) {
          return { from: t.from + 1, to: t.to };
        },
        BlockComment(t) {
          return { from: t.from + 2, to: t.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" }, line: "//" },
    indentOnInput: /^\s*(?:case |default:|end(?:if|for(?:each)?|switch|while)|else(?:if)?|\{|\})$/,
    wordChars: "$",
    closeBrackets: { stringPrefixes: ["b", "B"] }
  }
});
function KC(t = {}) {
  let e = [], i;
  if (t.baseLanguage !== null)
    if (t.baseLanguage)
      i = t.baseLanguage;
    else {
      let n = u$({ matchClosingTags: false });
      e.push(n.support), i = n.language;
    }
  return new li(HC.configure({
    wrap: i && Vp((n) => n.type.isTop ? {
      parser: i.parser,
      overlay: (O) => O.name == "Text"
    } : null),
    top: t.plain ? "Program" : "Template"
  }), e);
}
var JC = 36;
var SS = 1;
var e4 = 2;
var ol = 3;
var xf = 4;
var t4 = 5;
var i4 = 6;
var n4 = 7;
var O4 = 8;
var r4 = 9;
var a4 = 10;
var o4 = 11;
var s4 = 12;
var l4 = 13;
var c4 = 14;
var u4 = 15;
var f4 = 16;
var h4 = 17;
var PS = 18;
var d4 = 19;
var YX = 20;
var RX = 21;
var yS = 22;
var p4 = 23;
var $4 = 24;
function Qd(t) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t >= 48 && t <= 57;
}
function Q4(t) {
  return t >= 48 && t <= 57 || t >= 97 && t <= 102 || t >= 65 && t <= 70;
}
function EO(t, e, i) {
  for (let n = false; ; ) {
    if (t.next < 0)
      return;
    if (t.next == e && !n) {
      t.advance();
      return;
    }
    n = i && !n && t.next == 92, t.advance();
  }
}
function g4(t) {
  for (; ; ) {
    if (t.next < 0 || t.peek(1) < 0)
      return;
    if (t.next == 36 && t.peek(1) == 36) {
      t.advance(2);
      return;
    }
    t.advance();
  }
}
function ZX(t, e) {
  for (; !(t.next != 95 && !Qd(t.next)); )
    e != null && (e += String.fromCharCode(t.next)), t.advance();
  return e;
}
function m4(t) {
  if (t.next == 39 || t.next == 34 || t.next == 96) {
    let e = t.next;
    t.advance(), EO(t, e, false);
  } else
    ZX(t);
}
function bS(t, e) {
  for (; t.next == 48 || t.next == 49; )
    t.advance();
  e && t.next == e && t.advance();
}
function vS(t, e) {
  for (; ; ) {
    if (t.next == 46) {
      if (e)
        break;
      e = true;
    } else if (t.next < 48 || t.next > 57)
      break;
    t.advance();
  }
  if (t.next == 69 || t.next == 101)
    for (t.advance(), (t.next == 43 || t.next == 45) && t.advance(); t.next >= 48 && t.next <= 57; )
      t.advance();
}
function XS(t) {
  for (; !(t.next < 0 || t.next == 10); )
    t.advance();
}
function vr(t, e) {
  for (let i = 0; i < e.length; i++)
    if (e.charCodeAt(i) == t)
      return true;
  return false;
}
var xS = ` 	\r
`;
function UX(t, e, i) {
  let n = /* @__PURE__ */ Object.create(null);
  n.true = n.false = t4, n.null = n.unknown = i4;
  for (let O of t.split(" "))
    O && (n[O] = YX);
  for (let O of e.split(" "))
    O && (n[O] = RX);
  for (let O of (i || "").split(" "))
    O && (n[O] = $4);
  return n;
}
var S4 = "array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying ";
var P4 = "absolute action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded case cast catalog check close collate collation column commit condition connect connection constraint constraints constructor continue corresponding count create cross cube current current_date current_default_transform_group current_transform_group_for_type current_path current_role current_time current_timestamp current_user cursor cycle data day deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exists exit external fetch first for foreign found from free full function general get global go goto grant group grouping handle having hold hour identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local localtime localtimestamp locator loop map match method minute modifies module month names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search second section select session session_user set sets signal similar size some space specific specifictype sql sqlexception sqlstate sqlwarning start state static system_user table temporary then timezone_hour timezone_minute to trailing transaction translation treat trigger under undo union unique unnest until update usage user using value values view when whenever where while with without work write year zone ";
var gd = {
  backslashEscapes: false,
  hashComments: false,
  spaceAfterDashes: false,
  slashComments: false,
  doubleQuotedStrings: false,
  doubleDollarQuotedStrings: false,
  unquotedBitLiterals: false,
  treatBitsAsBytes: false,
  charSetCasts: false,
  operatorChars: "*+-%<>!=&|~^/",
  specialVar: "?",
  identifierQuotes: '"',
  words: UX(P4, S4)
};
function y4(t, e, i, n) {
  let O = {};
  for (let r in gd)
    O[r] = (t.hasOwnProperty(r) ? t : gd)[r];
  return e && (O.words = UX(e, i || "", n)), O;
}
function VX(t) {
  return new Ie((e) => {
    var i;
    let { next: n } = e;
    if (e.advance(), vr(n, xS)) {
      for (; vr(e.next, xS); )
        e.advance();
      e.acceptToken(JC);
    } else if (n == 36 && e.next == 36 && t.doubleDollarQuotedStrings)
      g4(e), e.acceptToken(ol);
    else if (n == 39 || n == 34 && t.doubleQuotedStrings)
      EO(e, n, t.backslashEscapes), e.acceptToken(ol);
    else if (n == 35 && t.hashComments || n == 47 && e.next == 47 && t.slashComments)
      XS(e), e.acceptToken(SS);
    else if (n == 45 && e.next == 45 && (!t.spaceAfterDashes || e.peek(1) == 32))
      XS(e), e.acceptToken(SS);
    else if (n == 47 && e.next == 42) {
      e.advance();
      for (let O = -1, r = 1; !(e.next < 0); )
        if (e.advance(), O == 42 && e.next == 47) {
          if (r--, !r) {
            e.advance();
            break;
          }
          O = -1;
        } else
          O == 47 && e.next == 42 ? (r++, O = -1) : O = e.next;
      e.acceptToken(e4);
    } else if ((n == 101 || n == 69) && e.next == 39)
      e.advance(), EO(e, 39, true);
    else if ((n == 110 || n == 78) && e.next == 39 && t.charSetCasts)
      e.advance(), EO(e, 39, t.backslashEscapes), e.acceptToken(ol);
    else if (n == 95 && t.charSetCasts)
      for (let O = 0; ; O++) {
        if (e.next == 39 && O > 1) {
          e.advance(), EO(e, 39, t.backslashEscapes), e.acceptToken(ol);
          break;
        }
        if (!Qd(e.next))
          break;
        e.advance();
      }
    else if (n == 40)
      e.acceptToken(n4);
    else if (n == 41)
      e.acceptToken(O4);
    else if (n == 123)
      e.acceptToken(r4);
    else if (n == 125)
      e.acceptToken(a4);
    else if (n == 91)
      e.acceptToken(o4);
    else if (n == 93)
      e.acceptToken(s4);
    else if (n == 59)
      e.acceptToken(l4);
    else if (t.unquotedBitLiterals && n == 48 && e.next == 98)
      e.advance(), bS(e), e.acceptToken(yS);
    else if ((n == 98 || n == 66) && (e.next == 39 || e.next == 34)) {
      const O = e.next;
      e.advance(), t.treatBitsAsBytes ? (EO(e, O, t.backslashEscapes), e.acceptToken(p4)) : (bS(e, O), e.acceptToken(yS));
    } else if (n == 48 && (e.next == 120 || e.next == 88) || (n == 120 || n == 88) && e.next == 39) {
      let O = e.next == 39;
      for (e.advance(); Q4(e.next); )
        e.advance();
      O && e.next == 39 && e.advance(), e.acceptToken(xf);
    } else if (n == 46 && e.next >= 48 && e.next <= 57)
      vS(e, true), e.acceptToken(xf);
    else if (n == 46)
      e.acceptToken(c4);
    else if (n >= 48 && n <= 57)
      vS(e, false), e.acceptToken(xf);
    else if (vr(n, t.operatorChars)) {
      for (; vr(e.next, t.operatorChars); )
        e.advance();
      e.acceptToken(u4);
    } else if (vr(n, t.specialVar))
      e.next == n && e.advance(), m4(e), e.acceptToken(h4);
    else if (vr(n, t.identifierQuotes))
      EO(e, n, false), e.acceptToken(d4);
    else if (n == 58 || n == 44)
      e.acceptToken(f4);
    else if (Qd(n)) {
      let O = ZX(e, String.fromCharCode(n));
      e.acceptToken(e.next == 46 ? PS : (i = t.words[O.toLowerCase()]) !== null && i !== void 0 ? i : PS);
    }
  });
}
var qX = VX(gd);
var b4 = Jt.deserialize({
  version: 14,
  states: "%vQ]QQOOO#wQRO'#DSO$OQQO'#CwO%eQQO'#CxO%lQQO'#CyO%sQQO'#CzOOQQ'#DS'#DSOOQQ'#C}'#C}O'UQRO'#C{OOQQ'#Cv'#CvOOQQ'#C|'#C|Q]QQOOQOQQOOO'`QQO'#DOO(xQRO,59cO)PQQO,59cO)UQQO'#DSOOQQ,59d,59dO)cQQO,59dOOQQ,59e,59eO)jQQO,59eOOQQ,59f,59fO)qQQO,59fOOQQ-E6{-E6{OOQQ,59b,59bOOQQ-E6z-E6zOOQQ,59j,59jOOQQ-E6|-E6|O+VQRO1G.}O+^QQO,59cOOQQ1G/O1G/OOOQQ1G/P1G/POOQQ1G/Q1G/QP+kQQO'#C}O+rQQO1G.}O)PQQO,59cO,PQQO'#Cw",
  stateData: ",[~OtOSPOSQOS~ORUOSUOTUOUUOVROXSOZTO]XO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O^]ORvXSvXTvXUvXVvXXvXZvX]vX_vX`vXavXbvXcvXdvXevXfvXgvXhvX~OsvX~P!jOa_Ob_Oc_O~ORUOSUOTUOUUOVROXSOZTO^tO_UO`UOa`Ob`Oc`OdUOeUOfUOgUOhUO~OWaO~P$ZOYcO~P$ZO[eO~P$ZORUOSUOTUOUUOVROXSOZTO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O]hOsoX~P%zOajObjOcjO~O^]ORkaSkaTkaUkaVkaXkaZka]ka_ka`kaakabkackadkaekafkagkahka~Oska~P'kO^]O~OWvXYvX[vX~P!jOWnO~P$ZOYoO~P$ZO[pO~P$ZO^]ORkiSkiTkiUkiVkiXkiZki]ki_ki`kiakibkickidkiekifkigkihki~Oski~P)xOWkaYka[ka~P'kO]hO~P$ZOWkiYki[ki~P)xOasObsOcsO~O",
  goto: "#hwPPPPPPPPPPPPPPPPPPPPPPPPPPx||||!Y!^!d!xPPP#[TYOZeUORSTWZbdfqT[OZQZORiZSWOZQbRQdSQfTZgWbdfqQ^PWk^lmrQl_Qm`RrseVORSTWZbdfq",
  nodeNames: "⚠ LineComment BlockComment String Number Bool Null ( ) { } [ ] ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Bits Bytes Builtin Script Statement CompositeIdentifier Parens Braces Brackets Statement",
  maxTerm: 38,
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 3,
  tokenData: "RORO",
  tokenizers: [0, qX],
  topRules: { Script: [0, 25] },
  tokenPrec: 0
});
function md(t) {
  let e = t.cursor().moveTo(t.from, -1);
  for (; /Comment/.test(e.name); )
    e.moveTo(e.from, -1);
  return e.node;
}
function as(t, e) {
  let i = t.sliceString(e.from, e.to), n = /^([`'"])(.*)\1$/.exec(i);
  return n ? n[2] : i;
}
function Sc(t) {
  return t && (t.name == "Identifier" || t.name == "QuotedIdentifier");
}
function v4(t, e) {
  if (e.name == "CompositeIdentifier") {
    let i = [];
    for (let n = e.firstChild; n; n = n.nextSibling)
      Sc(n) && i.push(as(t, n));
    return i;
  }
  return [as(t, e)];
}
function wS(t, e) {
  for (let i = []; ; ) {
    if (!e || e.name != ".")
      return i;
    let n = md(e);
    if (!Sc(n))
      return i;
    i.unshift(as(t, n)), e = md(n);
  }
}
function X4(t, e) {
  let i = Ye(t).resolveInner(e, -1), n = w4(t.doc, i);
  return i.name == "Identifier" || i.name == "QuotedIdentifier" || i.name == "Keyword" ? {
    from: i.from,
    quoted: i.name == "QuotedIdentifier" ? t.doc.sliceString(i.from, i.from + 1) : null,
    parents: wS(t.doc, md(i)),
    aliases: n
  } : i.name == "." ? { from: e, quoted: null, parents: wS(t.doc, i), aliases: n } : { from: e, quoted: null, parents: [], empty: true, aliases: n };
}
var x4 = new Set("where group having order union intersect except all distinct limit offset fetch for".split(" "));
function w4(t, e) {
  let i;
  for (let O = e; !i; O = O.parent) {
    if (!O)
      return null;
    O.name == "Statement" && (i = O);
  }
  let n = null;
  for (let O = i.firstChild, r = false, a = null; O; O = O.nextSibling) {
    let o = O.name == "Keyword" ? t.sliceString(O.from, O.to).toLowerCase() : null, s = null;
    if (!r)
      r = o == "from";
    else if (o == "as" && a && Sc(O.nextSibling))
      s = as(t, O.nextSibling);
    else {
      if (o && x4.has(o))
        break;
      a && Sc(O) && (s = as(t, O));
    }
    s && (n || (n = /* @__PURE__ */ Object.create(null)), n[s] = v4(t, a)), a = /Identifier$/.test(O.name) ? O : null;
  }
  return n;
}
function T4(t, e) {
  return t ? e.map((i) => Object.assign(Object.assign({}, i), { label: t + i.label + t, apply: void 0 })) : e;
}
var k4 = /^\w*$/;
var _4 = /^[`'"]?\w*[`'"]?$/;
var d$ = class {
  constructor() {
    this.list = [], this.children = void 0;
  }
  child(e) {
    let i = this.children || (this.children = /* @__PURE__ */ Object.create(null));
    return i[e] || (i[e] = new d$());
  }
  childCompletions(e) {
    return this.children ? Object.keys(this.children).filter((i) => i).map((i) => ({ label: i, type: e })) : [];
  }
};
function W4(t, e, i, n, O) {
  let r = new d$(), a = r.child(O || "");
  for (let o in t) {
    let s = o.indexOf("."), c = (s > -1 ? r.child(o.slice(0, s)) : a).child(s > -1 ? o.slice(s + 1) : o);
    c.list = t[o].map((u) => typeof u == "string" ? { label: u, type: "property" } : u);
  }
  a.list = (e || a.childCompletions("type")).concat(n ? a.child(n).list : []);
  for (let o in r.children) {
    let s = r.child(o);
    s.list.length || (s.list = s.childCompletions("type"));
  }
  return r.list = a.list.concat(i || r.childCompletions("type")), (o) => {
    let { parents: s, from: l, quoted: c, empty: u, aliases: h10 } = X4(o.state, o.pos);
    if (u && !o.explicit)
      return null;
    h10 && s.length == 1 && (s = h10[s[0]] || s);
    let d = r;
    for (let g of s) {
      for (; !d.children || !d.children[g]; )
        if (d == r)
          d = a;
        else if (d == a && n)
          d = d.child(n);
        else
          return null;
      d = d.child(g);
    }
    let p = c && o.state.sliceDoc(o.pos, o.pos + 1) == c, $ = d.list;
    return d == r && h10 && ($ = $.concat(Object.keys(h10).map((g) => ({ label: g, type: "constant" })))), {
      from: l,
      to: p ? o.pos + 1 : void 0,
      options: T4(c, $),
      validFor: c ? _4 : k4
    };
  };
}
function Y4(t, e) {
  let i = Object.keys(t).map((n) => ({
    label: e ? n.toUpperCase() : n,
    type: t[n] == RX ? "type" : t[n] == YX ? "keyword" : "variable",
    boost: -1
  }));
  return Jp(["QuotedIdentifier", "SpecialVar", "String", "LineComment", "BlockComment", "."], au(i));
}
var R4 = b4.configure({
  props: [
    ci.add({
      Statement: gt()
    }),
    ui.add({
      Statement(t) {
        return { from: t.firstChild.to, to: t.to };
      },
      BlockComment(t) {
        return { from: t.from + 2, to: t.to - 2 };
      }
    }),
    ti({
      Keyword: f.keyword,
      Type: f.typeName,
      Builtin: f.standard(f.name),
      Bits: f.number,
      Bytes: f.string,
      Bool: f.bool,
      Null: f.null,
      Number: f.number,
      String: f.string,
      Identifier: f.name,
      QuotedIdentifier: f.special(f.string),
      SpecialVar: f.special(f.name),
      LineComment: f.lineComment,
      BlockComment: f.blockComment,
      Operator: f.operator,
      "Semi Punctuation": f.punctuation,
      "( )": f.paren,
      "{ }": f.brace,
      "[ ]": f.squareBracket
    })
  ]
});
var p$ = class {
  constructor(e, i) {
    this.dialect = e, this.language = i;
  }
  /**
  Returns the language for this dialect as an extension.
  */
  get extension() {
    return this.language.extension;
  }
  /**
  Define a new dialect.
  */
  static define(e) {
    let i = y4(e, e.keywords, e.types, e.builtin), n = Kt.define({
      name: "sql",
      parser: R4.configure({
        tokenizers: [{ from: qX, to: VX(i) }]
      }),
      languageData: {
        commentTokens: { line: "--", block: { open: "/*", close: "*/" } },
        closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }
      }
    });
    return new p$(i, n);
  }
};
function Z4(t, e = false) {
  return Y4(t.dialect.words, e);
}
function U4(t, e = false) {
  return t.language.data.of({
    autocomplete: Z4(t, e)
  });
}
function V4(t) {
  return t.schema ? W4(t.schema, t.tables, t.schemas, t.defaultTable, t.defaultSchema) : () => null;
}
function q4(t) {
  return t.schema ? (t.dialect || zX).language.data.of({
    autocomplete: V4(t)
  }) : [];
}
function z4(t = {}) {
  let e = t.dialect || zX;
  return new li(e.language, [q4(t), U4(e, !!t.upperCaseKeywords)]);
}
var zX = p$.define({});
var Pc = class {
  constructor(e, i, n, O, r, a, o) {
    this.type = e, this.value = i, this.from = n, this.hash = O, this.end = r, this.children = a, this.positions = o, this.hashProp = [[se.contextHash, O]];
  }
  static create(e, i, n, O, r) {
    let a = O + (O << 8) + e + (i << 4) | 0;
    return new Pc(e, i, n, a, r, [], []);
  }
  addChild(e, i) {
    e.prop(se.contextHash) != this.hash && (e = new ve(e.type, e.children, e.positions, e.length, this.hashProp)), this.children.push(e), this.positions.push(i);
  }
  toTree(e, i = this.end) {
    let n = this.children.length - 1;
    return n >= 0 && (i = Math.max(i, this.positions[n] + this.children[n].length + this.from)), new ve(e.types[this.type], this.children, this.positions, i - this.from).balance({
      makeTree: (r, a, o) => new ve(lt.none, r, a, o, this.hashProp)
    });
  }
};
var j;
(function(t) {
  t[t.Document = 1] = "Document", t[t.CodeBlock = 2] = "CodeBlock", t[t.FencedCode = 3] = "FencedCode", t[t.Blockquote = 4] = "Blockquote", t[t.HorizontalRule = 5] = "HorizontalRule", t[t.BulletList = 6] = "BulletList", t[t.OrderedList = 7] = "OrderedList", t[t.ListItem = 8] = "ListItem", t[t.ATXHeading1 = 9] = "ATXHeading1", t[t.ATXHeading2 = 10] = "ATXHeading2", t[t.ATXHeading3 = 11] = "ATXHeading3", t[t.ATXHeading4 = 12] = "ATXHeading4", t[t.ATXHeading5 = 13] = "ATXHeading5", t[t.ATXHeading6 = 14] = "ATXHeading6", t[t.SetextHeading1 = 15] = "SetextHeading1", t[t.SetextHeading2 = 16] = "SetextHeading2", t[t.HTMLBlock = 17] = "HTMLBlock", t[t.LinkReference = 18] = "LinkReference", t[t.Paragraph = 19] = "Paragraph", t[t.CommentBlock = 20] = "CommentBlock", t[t.ProcessingInstructionBlock = 21] = "ProcessingInstructionBlock", t[t.Escape = 22] = "Escape", t[t.Entity = 23] = "Entity", t[t.HardBreak = 24] = "HardBreak", t[t.Emphasis = 25] = "Emphasis", t[t.StrongEmphasis = 26] = "StrongEmphasis", t[t.Link = 27] = "Link", t[t.Image = 28] = "Image", t[t.InlineCode = 29] = "InlineCode", t[t.HTMLTag = 30] = "HTMLTag", t[t.Comment = 31] = "Comment", t[t.ProcessingInstruction = 32] = "ProcessingInstruction", t[t.URL = 33] = "URL", t[t.HeaderMark = 34] = "HeaderMark", t[t.QuoteMark = 35] = "QuoteMark", t[t.ListMark = 36] = "ListMark", t[t.LinkMark = 37] = "LinkMark", t[t.EmphasisMark = 38] = "EmphasisMark", t[t.CodeMark = 39] = "CodeMark", t[t.CodeText = 40] = "CodeText", t[t.CodeInfo = 41] = "CodeInfo", t[t.LinkTitle = 42] = "LinkTitle", t[t.LinkLabel = 43] = "LinkLabel";
})(j || (j = {}));
var C4 = class {
  /// @internal
  constructor(e, i) {
    this.start = e, this.content = i, this.marks = [], this.parsers = [];
  }
};
var E4 = class {
  constructor() {
    this.text = "", this.baseIndent = 0, this.basePos = 0, this.depth = 0, this.markers = [], this.pos = 0, this.indent = 0, this.next = -1;
  }
  /// @internal
  forward() {
    this.basePos > this.pos && this.forwardInner();
  }
  /// @internal
  forwardInner() {
    let e = this.skipSpace(this.basePos);
    this.indent = this.countIndent(e, this.pos, this.indent), this.pos = e, this.next = e == this.text.length ? -1 : this.text.charCodeAt(e);
  }
  /// Skip whitespace after the given position, return the position of
  /// the next non-space character or the end of the line if there's
  /// only space after `from`.
  skipSpace(e) {
    return ko(this.text, e);
  }
  /// @internal
  reset(e) {
    for (this.text = e, this.baseIndent = this.basePos = this.pos = this.indent = 0, this.forwardInner(), this.depth = 1; this.markers.length; )
      this.markers.pop();
  }
  /// Move the line's base position forward to the given position.
  /// This should only be called by composite [block
  /// parsers](#BlockParser.parse) or [markup skipping
  /// functions](#NodeSpec.composite).
  moveBase(e) {
    this.basePos = e, this.baseIndent = this.countIndent(e, this.pos, this.indent);
  }
  /// Move the line's base position forward to the given _column_.
  moveBaseColumn(e) {
    this.baseIndent = e, this.basePos = this.findColumn(e);
  }
  /// Store a composite-block-level marker. Should be called from
  /// [markup skipping functions](#NodeSpec.composite) when they
  /// consume any non-whitespace characters.
  addMarker(e) {
    this.markers.push(e);
  }
  /// Find the column position at `to`, optionally starting at a given
  /// position and column.
  countIndent(e, i = 0, n = 0) {
    for (let O = i; O < e; O++)
      n += this.text.charCodeAt(O) == 9 ? 4 - n % 4 : 1;
    return n;
  }
  /// Find the position corresponding to the given column.
  findColumn(e) {
    let i = 0;
    for (let n = 0; i < this.text.length && n < e; i++)
      n += this.text.charCodeAt(i) == 9 ? 4 - n % 4 : 1;
    return i;
  }
  /// @internal
  scrub() {
    if (!this.baseIndent)
      return this.text;
    let e = "";
    for (let i = 0; i < this.basePos; i++)
      e += " ";
    return e + this.text.slice(this.basePos);
  }
};
function TS(t, e, i) {
  if (i.pos == i.text.length || t != e.block && i.indent >= e.stack[i.depth + 1].value + i.baseIndent)
    return true;
  if (i.indent >= i.baseIndent + 4)
    return false;
  let n = (t.type == j.OrderedList ? g$ : Q$)(i, e, false);
  return n > 0 && (t.type != j.BulletList || $$(i, e, false) < 0) && i.text.charCodeAt(i.pos + n - 1) == t.value;
}
var CX = {
  [j.Blockquote](t, e, i) {
    return i.next != 62 ? false : (i.markers.push(_e(j.QuoteMark, e.lineStart + i.pos, e.lineStart + i.pos + 1)), i.moveBase(i.pos + (Ei(i.text.charCodeAt(i.pos + 1)) ? 2 : 1)), t.end = e.lineStart + i.text.length, true);
  },
  [j.ListItem](t, e, i) {
    return i.indent < i.baseIndent + t.value && i.next > -1 ? false : (i.moveBaseColumn(i.baseIndent + t.value), true);
  },
  [j.OrderedList]: TS,
  [j.BulletList]: TS,
  [j.Document]() {
    return true;
  }
};
function Ei(t) {
  return t == 32 || t == 9 || t == 10 || t == 13;
}
function ko(t, e = 0) {
  for (; e < t.length && Ei(t.charCodeAt(e)); )
    e++;
  return e;
}
function kS(t, e, i) {
  for (; e > i && Ei(t.charCodeAt(e - 1)); )
    e--;
  return e;
}
function EX(t) {
  if (t.next != 96 && t.next != 126)
    return -1;
  let e = t.pos + 1;
  for (; e < t.text.length && t.text.charCodeAt(e) == t.next; )
    e++;
  if (e < t.pos + 3)
    return -1;
  if (t.next == 96) {
    for (let i = e; i < t.text.length; i++)
      if (t.text.charCodeAt(i) == 96)
        return -1;
  }
  return e;
}
function jX(t) {
  return t.next != 62 ? -1 : t.text.charCodeAt(t.pos + 1) == 32 ? 2 : 1;
}
function $$(t, e, i) {
  if (t.next != 42 && t.next != 45 && t.next != 95)
    return -1;
  let n = 1;
  for (let O = t.pos + 1; O < t.text.length; O++) {
    let r = t.text.charCodeAt(O);
    if (r == t.next)
      n++;
    else if (!Ei(r))
      return -1;
  }
  return i && t.next == 45 && GX(t) > -1 && t.depth == e.stack.length || n < 3 ? -1 : 1;
}
function IX(t, e) {
  for (let i = t.stack.length - 1; i >= 0; i--)
    if (t.stack[i].type == e)
      return true;
  return false;
}
function Q$(t, e, i) {
  return (t.next == 45 || t.next == 43 || t.next == 42) && (t.pos == t.text.length - 1 || Ei(t.text.charCodeAt(t.pos + 1))) && (!i || IX(e, j.BulletList) || t.skipSpace(t.pos + 2) < t.text.length) ? 1 : -1;
}
function g$(t, e, i) {
  let n = t.pos, O = t.next;
  for (; O >= 48 && O <= 57; ) {
    n++;
    if (n == t.text.length)
      return -1;
    O = t.text.charCodeAt(n);
  }
  return n == t.pos || n > t.pos + 9 || O != 46 && O != 41 || n < t.text.length - 1 && !Ei(t.text.charCodeAt(n + 1)) || i && !IX(e, j.OrderedList) && (t.skipSpace(n + 1) == t.text.length || n > t.pos + 1 || t.next != 49) ? -1 : n + 1 - t.pos;
}
function AX(t) {
  if (t.next != 35)
    return -1;
  let e = t.pos + 1;
  for (; e < t.text.length && t.text.charCodeAt(e) == 35; )
    e++;
  if (e < t.text.length && t.text.charCodeAt(e) != 32)
    return -1;
  let i = e - t.pos;
  return i > 6 ? -1 : i;
}
function GX(t) {
  if (t.next != 45 && t.next != 61 || t.indent >= t.baseIndent + 4)
    return -1;
  let e = t.pos + 1;
  for (; e < t.text.length && t.text.charCodeAt(e) == t.next; )
    e++;
  let i = e;
  for (; e < t.text.length && Ei(t.text.charCodeAt(e)); )
    e++;
  return e == t.text.length ? i : -1;
}
var Sd = /^[ \t]*$/;
var LX = /-->/;
var DX = /\?>/;
var Pd = [
  [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
  [/^\s*<!--/, LX],
  [/^\s*<\?/, DX],
  [/^\s*<![A-Z]/, />/],
  [/^\s*<!\[CDATA\[/, /\]\]>/],
  [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, Sd],
  [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, Sd]
];
function MX(t, e, i) {
  if (t.next != 60)
    return -1;
  let n = t.text.slice(t.pos);
  for (let O = 0, r = Pd.length - (i ? 1 : 0); O < r; O++)
    if (Pd[O][0].test(n))
      return O;
  return -1;
}
function _S(t, e) {
  let i = t.countIndent(e, t.pos, t.indent), n = t.countIndent(t.skipSpace(e), e, i);
  return n >= i + 5 ? i + 1 : n;
}
function VO(t, e, i) {
  let n = t.length - 1;
  n >= 0 && t[n].to == e && t[n].type == j.CodeText ? t[n].to = i : t.push(_e(j.CodeText, e, i));
}
var sl = {
  LinkReference: void 0,
  IndentedCode(t, e) {
    let i = e.baseIndent + 4;
    if (e.indent < i)
      return false;
    let n = e.findColumn(i), O = t.lineStart + n, r = t.lineStart + e.text.length, a = [], o = [];
    for (VO(a, O, r); t.nextLine() && e.depth >= t.stack.length; )
      if (e.pos == e.text.length) {
        VO(o, t.lineStart - 1, t.lineStart);
        for (let s of e.markers)
          o.push(s);
      } else {
        if (e.indent < i)
          break;
        {
          if (o.length) {
            for (let l of o)
              l.type == j.CodeText ? VO(a, l.from, l.to) : a.push(l);
            o = [];
          }
          VO(a, t.lineStart - 1, t.lineStart);
          for (let l of e.markers)
            a.push(l);
          r = t.lineStart + e.text.length;
          let s = t.lineStart + e.findColumn(e.baseIndent + 4);
          s < r && VO(a, s, r);
        }
      }
    return o.length && (o = o.filter((s) => s.type != j.CodeText), o.length && (e.markers = o.concat(e.markers))), t.addNode(t.buffer.writeElements(a, -O).finish(j.CodeBlock, r - O), O), true;
  },
  FencedCode(t, e) {
    let i = EX(e);
    if (i < 0)
      return false;
    let n = t.lineStart + e.pos, O = e.next, r = i - e.pos, a = e.skipSpace(i), o = kS(e.text, e.text.length, a), s = [_e(j.CodeMark, n, n + r)];
    a < o && s.push(_e(j.CodeInfo, t.lineStart + a, t.lineStart + o));
    for (let l = true; t.nextLine() && e.depth >= t.stack.length; l = false) {
      let c = e.pos;
      if (e.indent - e.baseIndent < 4)
        for (; c < e.text.length && e.text.charCodeAt(c) == O; )
          c++;
      if (c - e.pos >= r && e.skipSpace(c) == e.text.length) {
        for (let u of e.markers)
          s.push(u);
        s.push(_e(j.CodeMark, t.lineStart + e.pos, t.lineStart + c)), t.nextLine();
        break;
      } else {
        l || VO(s, t.lineStart - 1, t.lineStart);
        for (let d of e.markers)
          s.push(d);
        let u = t.lineStart + e.basePos, h10 = t.lineStart + e.text.length;
        u < h10 && VO(s, u, h10);
      }
    }
    return t.addNode(t.buffer.writeElements(s, -n).finish(j.FencedCode, t.prevLineEnd() - n), n), true;
  },
  Blockquote(t, e) {
    let i = jX(e);
    return i < 0 ? false : (t.startContext(j.Blockquote, e.pos), t.addNode(j.QuoteMark, t.lineStart + e.pos, t.lineStart + e.pos + 1), e.moveBase(e.pos + i), null);
  },
  HorizontalRule(t, e) {
    if ($$(e, t, false) < 0)
      return false;
    let i = t.lineStart + e.pos;
    return t.nextLine(), t.addNode(j.HorizontalRule, i), true;
  },
  BulletList(t, e) {
    let i = Q$(e, t, false);
    if (i < 0)
      return false;
    t.block.type != j.BulletList && t.startContext(j.BulletList, e.basePos, e.next);
    let n = _S(e, e.pos + 1);
    return t.startContext(j.ListItem, e.basePos, n - e.baseIndent), t.addNode(j.ListMark, t.lineStart + e.pos, t.lineStart + e.pos + i), e.moveBaseColumn(n), null;
  },
  OrderedList(t, e) {
    let i = g$(e, t, false);
    if (i < 0)
      return false;
    t.block.type != j.OrderedList && t.startContext(j.OrderedList, e.basePos, e.text.charCodeAt(e.pos + i - 1));
    let n = _S(e, e.pos + i);
    return t.startContext(j.ListItem, e.basePos, n - e.baseIndent), t.addNode(j.ListMark, t.lineStart + e.pos, t.lineStart + e.pos + i), e.moveBaseColumn(n), null;
  },
  ATXHeading(t, e) {
    let i = AX(e);
    if (i < 0)
      return false;
    let n = e.pos, O = t.lineStart + n, r = kS(e.text, e.text.length, n), a = r;
    for (; a > n && e.text.charCodeAt(a - 1) == e.next; )
      a--;
    (a == r || a == n || !Ei(e.text.charCodeAt(a - 1))) && (a = e.text.length);
    let o = t.buffer.write(j.HeaderMark, 0, i).writeElements(t.parser.parseInline(e.text.slice(n + i + 1, a), O + i + 1), -O);
    a < e.text.length && o.write(j.HeaderMark, a - n, r - n);
    let s = o.finish(j.ATXHeading1 - 1 + i, e.text.length - n);
    return t.nextLine(), t.addNode(s, O), true;
  },
  HTMLBlock(t, e) {
    let i = MX(e, t, false);
    if (i < 0)
      return false;
    let n = t.lineStart + e.pos, O = Pd[i][1], r = [], a = O != Sd;
    for (; !O.test(e.text) && t.nextLine(); ) {
      if (e.depth < t.stack.length) {
        a = false;
        break;
      }
      for (let l of e.markers)
        r.push(l);
    }
    a && t.nextLine();
    let o = O == LX ? j.CommentBlock : O == DX ? j.ProcessingInstructionBlock : j.HTMLBlock, s = t.prevLineEnd();
    return t.addNode(t.buffer.writeElements(r, -n).finish(o, s - n), n), true;
  },
  SetextHeading: void 0
  // Specifies relative precedence for block-continue function
};
var j4 = class {
  constructor(e) {
    this.stage = 0, this.elts = [], this.pos = 0, this.start = e.start, this.advance(e.content);
  }
  nextLine(e, i, n) {
    if (this.stage == -1)
      return false;
    let O = n.content + `
` + i.scrub(), r = this.advance(O);
    return r > -1 && r < O.length ? this.complete(e, n, r) : false;
  }
  finish(e, i) {
    return (this.stage == 2 || this.stage == 3) && ko(i.content, this.pos) == i.content.length ? this.complete(e, i, i.content.length) : false;
  }
  complete(e, i, n) {
    return e.addLeafElement(i, _e(j.LinkReference, this.start, this.start + n, this.elts)), true;
  }
  nextStage(e) {
    return e ? (this.pos = e.to - this.start, this.elts.push(e), this.stage++, true) : (e === false && (this.stage = -1), false);
  }
  advance(e) {
    for (; ; ) {
      if (this.stage == -1)
        return -1;
      if (this.stage == 0) {
        if (!this.nextStage(ix(e, this.pos, this.start, true)))
          return -1;
        if (e.charCodeAt(this.pos) != 58)
          return this.stage = -1;
        this.elts.push(_e(j.LinkMark, this.pos + this.start, this.pos + this.start + 1)), this.pos++;
      } else if (this.stage == 1) {
        if (!this.nextStage(ex(e, ko(e, this.pos), this.start)))
          return -1;
      } else if (this.stage == 2) {
        let i = ko(e, this.pos), n = 0;
        if (i > this.pos) {
          let O = tx(e, i, this.start);
          if (O) {
            let r = wf(e, O.to - this.start);
            r > 0 && (this.nextStage(O), n = r);
          }
        }
        return n || (n = wf(e, this.pos)), n > 0 && n < e.length ? n : -1;
      } else
        return wf(e, this.pos);
    }
  }
};
function wf(t, e) {
  for (; e < t.length; e++) {
    let i = t.charCodeAt(e);
    if (i == 10)
      break;
    if (!Ei(i))
      return -1;
  }
  return e;
}
var I4 = class {
  nextLine(e, i, n) {
    let O = i.depth < e.stack.length ? -1 : GX(i), r = i.next;
    if (O < 0)
      return false;
    let a = _e(j.HeaderMark, e.lineStart + i.pos, e.lineStart + O);
    return e.nextLine(), e.addLeafElement(n, _e(r == 61 ? j.SetextHeading1 : j.SetextHeading2, n.start, e.prevLineEnd(), [
      ...e.parser.parseInline(n.content, n.start),
      a
    ])), true;
  }
  finish() {
    return false;
  }
};
var A4 = {
  LinkReference(t, e) {
    return e.content.charCodeAt(0) == 91 ? new j4(e) : null;
  },
  SetextHeading() {
    return new I4();
  }
};
var G4 = [
  (t, e) => AX(e) >= 0,
  (t, e) => EX(e) >= 0,
  (t, e) => jX(e) >= 0,
  (t, e) => Q$(e, t, true) >= 0,
  (t, e) => g$(e, t, true) >= 0,
  (t, e) => $$(e, t, true) >= 0,
  (t, e) => MX(e, t, true) >= 0
];
var L4 = { text: "", end: 0 };
var D4 = class {
  /// @internal
  constructor(e, i, n, O) {
    this.parser = e, this.input = i, this.ranges = O, this.line = new E4(), this.atEnd = false, this.dontInject = /* @__PURE__ */ new Set(), this.stoppedAt = null, this.rangeI = 0, this.to = O[O.length - 1].to, this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = O[0].from, this.block = Pc.create(j.Document, 0, this.lineStart, 0, 0), this.stack = [this.block], this.fragments = n.length ? new F4(n, i) : null, this.readLine();
  }
  get parsedPos() {
    return this.absoluteLineStart;
  }
  advance() {
    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
      return this.finish();
    let { line: e } = this;
    for (; ; ) {
      for (; e.depth < this.stack.length; )
        this.finishContext();
      for (let n of e.markers)
        this.addNode(n.type, n.from, n.to);
      if (e.pos < e.text.length)
        break;
      if (!this.nextLine())
        return this.finish();
    }
    if (this.fragments && this.reuseFragment(e.basePos))
      return null;
    e:
      for (; ; ) {
        for (let n of this.parser.blockParsers)
          if (n) {
            let O = n(this, e);
            if (O != false) {
              if (O == true)
                return null;
              e.forward();
              continue e;
            }
          }
        break;
      }
    let i = new C4(this.lineStart + e.pos, e.text.slice(e.pos));
    for (let n of this.parser.leafBlockParsers)
      if (n) {
        let O = n(this, i);
        O && i.parsers.push(O);
      }
    e:
      for (; this.nextLine() && e.pos != e.text.length; ) {
        if (e.indent < e.baseIndent + 4) {
          for (let n of this.parser.endLeafBlock)
            if (n(this, e, i))
              break e;
        }
        for (let n of i.parsers)
          if (n.nextLine(this, e, i))
            return null;
        i.content += `
` + e.scrub();
        for (let n of e.markers)
          i.marks.push(n);
      }
    return this.finishLeaf(i), null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  reuseFragment(e) {
    if (!this.fragments.moveTo(this.absoluteLineStart + e, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
      return false;
    let i = this.fragments.takeNodes(this);
    if (!i)
      return false;
    let n = i, O = this.absoluteLineStart + i;
    for (let r = 1; r < this.ranges.length; r++) {
      let a = this.ranges[r - 1].to, o = this.ranges[r].from;
      a >= this.lineStart && o < O && (n -= o - a);
    }
    return this.lineStart += n, this.absoluteLineStart += i, this.moveRangeI(), this.absoluteLineStart < this.to ? (this.lineStart++, this.absoluteLineStart++, this.readLine()) : (this.atEnd = true, this.readLine()), true;
  }
  /// The number of parent blocks surrounding the current block.
  get depth() {
    return this.stack.length;
  }
  /// Get the type of the parent block at the given depth. When no
  /// depth is passed, return the type of the innermost parent.
  parentType(e = this.depth - 1) {
    return this.parser.nodeSet.types[this.stack[e].type];
  }
  /// Move to the next input line. This should only be called by
  /// (non-composite) [block parsers](#BlockParser.parse) that consume
  /// the line directly, or leaf block parser
  /// [`nextLine`](#LeafBlockParser.nextLine) methods when they
  /// consume the current line (and return true).
  nextLine() {
    return this.lineStart += this.line.text.length, this.absoluteLineEnd >= this.to ? (this.absoluteLineStart = this.absoluteLineEnd, this.atEnd = true, this.readLine(), false) : (this.lineStart++, this.absoluteLineStart = this.absoluteLineEnd + 1, this.moveRangeI(), this.readLine(), true);
  }
  moveRangeI() {
    for (; this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to; )
      this.rangeI++, this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
  }
  /// @internal
  scanLine(e) {
    let i = L4;
    if (i.end = e, e >= this.to)
      i.text = "";
    else if (i.text = this.lineChunkAt(e), i.end += i.text.length, this.ranges.length > 1) {
      let n = this.absoluteLineStart, O = this.rangeI;
      for (; this.ranges[O].to < i.end; ) {
        O++;
        let r = this.ranges[O].from, a = this.lineChunkAt(r);
        i.end = r + a.length, i.text = i.text.slice(0, this.ranges[O - 1].to - n) + a, n = i.end - i.text.length;
      }
    }
    return i;
  }
  /// @internal
  readLine() {
    let { line: e } = this, { text: i, end: n } = this.scanLine(this.absoluteLineStart);
    for (this.absoluteLineEnd = n, e.reset(i); e.depth < this.stack.length; e.depth++) {
      let O = this.stack[e.depth], r = this.parser.skipContextMarkup[O.type];
      if (!r)
        throw new Error("Unhandled block context " + j[O.type]);
      if (!r(O, this, e))
        break;
      e.forward();
    }
  }
  lineChunkAt(e) {
    let i = this.input.chunk(e), n;
    if (this.input.lineChunks)
      n = i == `
` ? "" : i;
    else {
      let O = i.indexOf(`
`);
      n = O < 0 ? i : i.slice(0, O);
    }
    return e + n.length > this.to ? n.slice(0, this.to - e) : n;
  }
  /// The end position of the previous line.
  prevLineEnd() {
    return this.atEnd ? this.lineStart : this.lineStart - 1;
  }
  /// @internal
  startContext(e, i, n = 0) {
    this.block = Pc.create(e, n, this.lineStart + i, this.block.hash, this.lineStart + this.line.text.length), this.stack.push(this.block);
  }
  /// Start a composite block. Should only be called from [block
  /// parser functions](#BlockParser.parse) that return null.
  startComposite(e, i, n = 0) {
    this.startContext(this.parser.getNodeType(e), i, n);
  }
  /// @internal
  addNode(e, i, n) {
    typeof e == "number" && (e = new ve(this.parser.nodeSet.types[e], oa, oa, (n ?? this.prevLineEnd()) - i)), this.block.addChild(e, i - this.block.from);
  }
  /// Add a block element. Can be called by [block
  /// parsers](#BlockParser.parse).
  addElement(e) {
    this.block.addChild(e.toTree(this.parser.nodeSet), e.from - this.block.from);
  }
  /// Add a block element from a [leaf parser](#LeafBlockParser). This
  /// makes sure any extra composite block markup (such as blockquote
  /// markers) inside the block are also added to the syntax tree.
  addLeafElement(e, i) {
    this.addNode(this.buffer.writeElements(bd(i.children, e.marks), -i.from).finish(i.type, i.to - i.from), i.from);
  }
  /// @internal
  finishContext() {
    let e = this.stack.pop(), i = this.stack[this.stack.length - 1];
    i.addChild(e.toTree(this.parser.nodeSet), e.from - i.from), this.block = i;
  }
  finish() {
    for (; this.stack.length > 1; )
      this.finishContext();
    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
  }
  addGaps(e) {
    return this.ranges.length > 1 ? NX(this.ranges, 0, e.topNode, this.ranges[0].from, this.dontInject) : e;
  }
  /// @internal
  finishLeaf(e) {
    for (let n of e.parsers)
      if (n.finish(this, e))
        return;
    let i = bd(this.parser.parseInline(e.content, e.start), e.marks);
    this.addNode(this.buffer.writeElements(i, -e.start).finish(j.Paragraph, e.content.length), e.start);
  }
  elt(e, i, n, O) {
    return typeof e == "string" ? _e(this.parser.getNodeType(e), i, n, O) : new HX(e, i);
  }
  /// @internal
  get buffer() {
    return new FX(this.parser.nodeSet);
  }
};
function NX(t, e, i, n, O) {
  if (O.has(i.tree))
    return i.tree;
  let r = t[e].to, a = [], o = [], s = i.from + n;
  function l(c, u) {
    for (; u ? c >= r : c > r; ) {
      let h10 = t[e + 1].from - r;
      n += h10, c += h10, e++, r = t[e].to;
    }
  }
  for (let c = i.firstChild; c; c = c.nextSibling) {
    l(c.from + n, true);
    let u = c.from + n, h10;
    c.to + n > r ? (h10 = NX(t, e, c, n, O), l(c.to + n, false)) : h10 = c.toTree(), a.push(h10), o.push(u - s);
  }
  return l(i.to + n, false), new ve(i.type, a, o, i.to + n - s, i.tree ? i.tree.propValues : void 0);
}
var fu = class extends Hc {
  /// @internal
  constructor(e, i, n, O, r, a, o, s, l) {
    super(), this.nodeSet = e, this.blockParsers = i, this.leafBlockParsers = n, this.blockNames = O, this.endLeafBlock = r, this.skipContextMarkup = a, this.inlineParsers = o, this.inlineNames = s, this.wrappers = l, this.nodeTypes = /* @__PURE__ */ Object.create(null);
    for (let c of e.types)
      this.nodeTypes[c.name] = c.id;
  }
  createParse(e, i, n) {
    let O = new D4(this, e, i, n);
    for (let r of this.wrappers)
      O = r(O, e, i, n);
    return O;
  }
  /// Reconfigure the parser.
  configure(e) {
    let i = yd(e);
    if (!i)
      return this;
    let { nodeSet: n, skipContextMarkup: O } = this, r = this.blockParsers.slice(), a = this.leafBlockParsers.slice(), o = this.blockNames.slice(), s = this.inlineParsers.slice(), l = this.inlineNames.slice(), c = this.endLeafBlock.slice(), u = this.wrappers;
    if (Fa(i.defineNodes)) {
      O = Object.assign({}, O);
      let h10 = n.types.slice(), d;
      for (let p of i.defineNodes) {
        let { name: $, block: g, composite: Q, style: m } = typeof p == "string" ? { name: p } : p;
        if (h10.some((S) => S.name == $))
          continue;
        Q && (O[h10.length] = (S, y, v) => Q(y, v, S.value));
        let b = h10.length, P = Q ? ["Block", "BlockContext"] : g ? b >= j.ATXHeading1 && b <= j.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"] : void 0;
        h10.push(lt.define({
          id: b,
          name: $,
          props: P && [[se.group, P]]
        })), m && (d || (d = {}), Array.isArray(m) || m instanceof Hi ? d[$] = m : Object.assign(d, m));
      }
      n = new _a(h10), d && (n = n.extend(ti(d)));
    }
    if (Fa(i.props) && (n = n.extend(...i.props)), Fa(i.remove))
      for (let h10 of i.remove) {
        let d = this.blockNames.indexOf(h10), p = this.inlineNames.indexOf(h10);
        d > -1 && (r[d] = a[d] = void 0), p > -1 && (s[p] = void 0);
      }
    if (Fa(i.parseBlock))
      for (let h10 of i.parseBlock) {
        let d = o.indexOf(h10.name);
        if (d > -1)
          r[d] = h10.parse, a[d] = h10.leaf;
        else {
          let p = h10.before ? ll(o, h10.before) : h10.after ? ll(o, h10.after) + 1 : o.length - 1;
          r.splice(p, 0, h10.parse), a.splice(p, 0, h10.leaf), o.splice(p, 0, h10.name);
        }
        h10.endLeaf && c.push(h10.endLeaf);
      }
    if (Fa(i.parseInline))
      for (let h10 of i.parseInline) {
        let d = l.indexOf(h10.name);
        if (d > -1)
          s[d] = h10.parse;
        else {
          let p = h10.before ? ll(l, h10.before) : h10.after ? ll(l, h10.after) + 1 : l.length - 1;
          s.splice(p, 0, h10.parse), l.splice(p, 0, h10.name);
        }
      }
    return i.wrap && (u = u.concat(i.wrap)), new fu(n, r, a, o, c, O, s, l, u);
  }
  /// @internal
  getNodeType(e) {
    let i = this.nodeTypes[e];
    if (i == null)
      throw new RangeError(`Unknown node type '${e}'`);
    return i;
  }
  /// Parse the given piece of inline text at the given offset,
  /// returning an array of [`Element`](#Element) objects representing
  /// the inline content.
  parseInline(e, i) {
    let n = new N4(this, e, i);
    e:
      for (let O = i; O < n.end; ) {
        let r = n.char(O);
        for (let a of this.inlineParsers)
          if (a) {
            let o = a(n, r, O);
            if (o >= 0) {
              O = o;
              continue e;
            }
          }
        O++;
      }
    return n.resolveMarkers(0);
  }
};
function Fa(t) {
  return t != null && t.length > 0;
}
function yd(t) {
  if (!Array.isArray(t))
    return t;
  if (t.length == 0)
    return null;
  let e = yd(t[0]);
  if (t.length == 1)
    return e;
  let i = yd(t.slice(1));
  if (!i || !e)
    return e || i;
  let n = (a, o) => (a || oa).concat(o || oa), O = e.wrap, r = i.wrap;
  return {
    props: n(e.props, i.props),
    defineNodes: n(e.defineNodes, i.defineNodes),
    parseBlock: n(e.parseBlock, i.parseBlock),
    parseInline: n(e.parseInline, i.parseInline),
    remove: n(e.remove, i.remove),
    wrap: O ? r ? (a, o, s, l) => O(r(a, o, s, l), o, s, l) : O : r
  };
}
function ll(t, e) {
  let i = t.indexOf(e);
  if (i < 0)
    throw new RangeError(`Position specified relative to unknown parser ${e}`);
  return i;
}
var BX = [lt.none];
for (let t = 1, e; e = j[t]; t++)
  BX[t] = lt.define({
    id: t,
    name: e,
    props: t >= j.Escape ? [] : [[se.group, t in CX ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]]
  });
var oa = [];
var FX = class {
  constructor(e) {
    this.nodeSet = e, this.content = [], this.nodes = [];
  }
  write(e, i, n, O = 0) {
    return this.content.push(e, i, n, 4 + O * 4), this;
  }
  writeElements(e, i = 0) {
    for (let n of e)
      n.writeTo(this, i);
    return this;
  }
  finish(e, i) {
    return ve.build({
      buffer: this.content,
      nodeSet: this.nodeSet,
      reused: this.nodes,
      topID: e,
      length: i
    });
  }
};
var os = class {
  /// @internal
  constructor(e, i, n, O = oa) {
    this.type = e, this.from = i, this.to = n, this.children = O;
  }
  /// @internal
  writeTo(e, i) {
    let n = e.content.length;
    e.writeElements(this.children, i), e.content.push(this.type, this.from + i, this.to + i, e.content.length + 4 - n);
  }
  /// @internal
  toTree(e) {
    return new FX(e).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
  }
};
var HX = class {
  constructor(e, i) {
    this.tree = e, this.from = i;
  }
  get to() {
    return this.from + this.tree.length;
  }
  get type() {
    return this.tree.type.id;
  }
  get children() {
    return oa;
  }
  writeTo(e, i) {
    e.nodes.push(this.tree), e.content.push(e.nodes.length - 1, this.from + i, this.to + i, -1);
  }
  toTree() {
    return this.tree;
  }
};
function _e(t, e, i, n) {
  return new os(t, e, i, n);
}
var KX = { resolve: "Emphasis", mark: "EmphasisMark" };
var JX = { resolve: "Emphasis", mark: "EmphasisMark" };
var Ha = {};
var WS = {};
var Ki = class {
  constructor(e, i, n, O) {
    this.type = e, this.from = i, this.to = n, this.side = O;
  }
};
var YS = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
var ss = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
  ss = new RegExp("[\\p{Pc}|\\p{Pd}|\\p{Pe}|\\p{Pf}|\\p{Pi}|\\p{Po}|\\p{Ps}]", "u");
} catch {
}
var Tf = {
  Escape(t, e, i) {
    if (e != 92 || i == t.end - 1)
      return -1;
    let n = t.char(i + 1);
    for (let O = 0; O < YS.length; O++)
      if (YS.charCodeAt(O) == n)
        return t.append(_e(j.Escape, i, i + 2));
    return -1;
  },
  Entity(t, e, i) {
    if (e != 38)
      return -1;
    let n = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(t.slice(i + 1, i + 31));
    return n ? t.append(_e(j.Entity, i, i + 1 + n[0].length)) : -1;
  },
  InlineCode(t, e, i) {
    if (e != 96 || i && t.char(i - 1) == 96)
      return -1;
    let n = i + 1;
    for (; n < t.end && t.char(n) == 96; )
      n++;
    let O = n - i, r = 0;
    for (; n < t.end; n++)
      if (t.char(n) == 96) {
        if (r++, r == O && t.char(n + 1) != 96)
          return t.append(_e(j.InlineCode, i, n + 1, [
            _e(j.CodeMark, i, i + O),
            _e(j.CodeMark, n + 1 - O, n + 1)
          ]));
      } else
        r = 0;
    return -1;
  },
  HTMLTag(t, e, i) {
    if (e != 60 || i == t.end - 1)
      return -1;
    let n = t.slice(i + 1, t.end), O = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(n);
    if (O)
      return t.append(_e(j.URL, i, i + 1 + O[0].length));
    let r = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(n);
    if (r)
      return t.append(_e(j.Comment, i, i + 1 + r[0].length));
    let a = /^\?[^]*?\?>/.exec(n);
    if (a)
      return t.append(_e(j.ProcessingInstruction, i, i + 1 + a[0].length));
    let o = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(n);
    return o ? t.append(_e(j.HTMLTag, i, i + 1 + o[0].length)) : -1;
  },
  Emphasis(t, e, i) {
    if (e != 95 && e != 42)
      return -1;
    let n = i + 1;
    for (; t.char(n) == e; )
      n++;
    let O = t.slice(i - 1, i), r = t.slice(n, n + 1), a = ss.test(O), o = ss.test(r), s = /\s|^$/.test(O), l = /\s|^$/.test(r), c = !l && (!o || s || a), u = !s && (!a || l || o), h10 = c && (e == 42 || !u || a), d = u && (e == 42 || !c || o);
    return t.append(new Ki(e == 95 ? KX : JX, i, n, (h10 ? 1 : 0) | (d ? 2 : 0)));
  },
  HardBreak(t, e, i) {
    if (e == 92 && t.char(i + 1) == 10)
      return t.append(_e(j.HardBreak, i, i + 2));
    if (e == 32) {
      let n = i + 1;
      for (; t.char(n) == 32; )
        n++;
      if (t.char(n) == 10 && n >= i + 2)
        return t.append(_e(j.HardBreak, i, n + 1));
    }
    return -1;
  },
  Link(t, e, i) {
    return e == 91 ? t.append(new Ki(
      Ha,
      i,
      i + 1,
      1
      /* Open */
    )) : -1;
  },
  Image(t, e, i) {
    return e == 33 && t.char(i + 1) == 91 ? t.append(new Ki(
      WS,
      i,
      i + 2,
      1
      /* Open */
    )) : -1;
  },
  LinkEnd(t, e, i) {
    if (e != 93)
      return -1;
    for (let n = t.parts.length - 1; n >= 0; n--) {
      let O = t.parts[n];
      if (O instanceof Ki && (O.type == Ha || O.type == WS)) {
        if (!O.side || t.skipSpace(O.to) == i && !/[(\[]/.test(t.slice(i + 1, i + 2)))
          return t.parts[n] = null, -1;
        let r = t.takeContent(n), a = t.parts[n] = M4(t, r, O.type == Ha ? j.Link : j.Image, O.from, i + 1);
        if (O.type == Ha)
          for (let o = 0; o < n; o++) {
            let s = t.parts[o];
            s instanceof Ki && s.type == Ha && (s.side = 0);
          }
        return a.to;
      }
    }
    return -1;
  }
};
function M4(t, e, i, n, O) {
  let { text: r } = t, a = t.char(O), o = O;
  if (e.unshift(_e(j.LinkMark, n, n + (i == j.Image ? 2 : 1))), e.push(_e(j.LinkMark, O - 1, O)), a == 40) {
    let s = t.skipSpace(O + 1), l = ex(r, s - t.offset, t.offset), c;
    l && (s = t.skipSpace(l.to), c = tx(r, s - t.offset, t.offset), c && (s = t.skipSpace(c.to))), t.char(s) == 41 && (e.push(_e(j.LinkMark, O, O + 1)), o = s + 1, l && e.push(l), c && e.push(c), e.push(_e(j.LinkMark, s, o)));
  } else if (a == 91) {
    let s = ix(r, O - t.offset, t.offset, false);
    s && (e.push(s), o = s.to);
  }
  return _e(i, n, o, e);
}
function ex(t, e, i) {
  if (t.charCodeAt(e) == 60) {
    for (let O = e + 1; O < t.length; O++) {
      let r = t.charCodeAt(O);
      if (r == 62)
        return _e(j.URL, e + i, O + 1 + i);
      if (r == 60 || r == 10)
        return false;
    }
    return null;
  } else {
    let O = 0, r = e;
    for (let a = false; r < t.length; r++) {
      let o = t.charCodeAt(r);
      if (Ei(o))
        break;
      if (a)
        a = false;
      else if (o == 40)
        O++;
      else if (o == 41) {
        if (!O)
          break;
        O--;
      } else
        o == 92 && (a = true);
    }
    return r > e ? _e(j.URL, e + i, r + i) : r == t.length ? null : false;
  }
}
function tx(t, e, i) {
  let n = t.charCodeAt(e);
  if (n != 39 && n != 34 && n != 40)
    return false;
  let O = n == 40 ? 41 : n;
  for (let r = e + 1, a = false; r < t.length; r++) {
    let o = t.charCodeAt(r);
    if (a)
      a = false;
    else {
      if (o == O)
        return _e(j.LinkTitle, e + i, r + 1 + i);
      o == 92 && (a = true);
    }
  }
  return null;
}
function ix(t, e, i, n) {
  for (let O = false, r = e + 1, a = Math.min(t.length, r + 999); r < a; r++) {
    let o = t.charCodeAt(r);
    if (O)
      O = false;
    else {
      if (o == 93)
        return n ? false : _e(j.LinkLabel, e + i, r + 1 + i);
      if (n && !Ei(o) && (n = false), o == 91)
        return false;
      o == 92 && (O = true);
    }
  }
  return null;
}
var N4 = class {
  /// @internal
  constructor(e, i, n) {
    this.parser = e, this.text = i, this.offset = n, this.parts = [];
  }
  /// Get the character code at the given (document-relative)
  /// position.
  char(e) {
    return e >= this.end ? -1 : this.text.charCodeAt(e - this.offset);
  }
  /// The position of the end of this inline section.
  get end() {
    return this.offset + this.text.length;
  }
  /// Get a substring of this inline section. Again uses
  /// document-relative positions.
  slice(e, i) {
    return this.text.slice(e - this.offset, i - this.offset);
  }
  /// @internal
  append(e) {
    return this.parts.push(e), e.to;
  }
  /// Add a [delimiter](#DelimiterType) at this given position. `open`
  /// and `close` indicate whether this delimiter is opening, closing,
  /// or both. Returns the end of the delimiter, for convenient
  /// returning from [parse functions](#InlineParser.parse).
  addDelimiter(e, i, n, O, r) {
    return this.append(new Ki(e, i, n, (O ? 1 : 0) | (r ? 2 : 0)));
  }
  /// Add an inline element. Returns the end of the element.
  addElement(e) {
    return this.append(e);
  }
  /// Resolve markers between this.parts.length and from, wrapping matched markers in the
  /// appropriate node and updating the content of this.parts. @internal
  resolveMarkers(e) {
    for (let n = e; n < this.parts.length; n++) {
      let O = this.parts[n];
      if (!(O instanceof Ki && O.type.resolve && O.side & 2))
        continue;
      let r = O.type == KX || O.type == JX, a = O.to - O.from, o, s = n - 1;
      for (; s >= e; s--) {
        let $ = this.parts[s];
        if ($ instanceof Ki && $.side & 1 && $.type == O.type && // Ignore emphasis delimiters where the character count doesn't match
        !(r && (O.side & 1 || $.side & 2) && ($.to - $.from + a) % 3 == 0 && (($.to - $.from) % 3 || a % 3))) {
          o = $;
          break;
        }
      }
      if (!o)
        continue;
      let l = O.type.resolve, c = [], u = o.from, h10 = O.to;
      if (r) {
        let $ = Math.min(2, o.to - o.from, a);
        u = o.to - $, h10 = O.from + $, l = $ == 1 ? "Emphasis" : "StrongEmphasis";
      }
      o.type.mark && c.push(this.elt(o.type.mark, u, o.to));
      for (let $ = s + 1; $ < n; $++)
        this.parts[$] instanceof os && c.push(this.parts[$]), this.parts[$] = null;
      O.type.mark && c.push(this.elt(O.type.mark, O.from, h10));
      let d = this.elt(l, u, h10, c);
      this.parts[s] = r && o.from != u ? new Ki(o.type, o.from, u, o.side) : null, (this.parts[n] = r && O.to != h10 ? new Ki(O.type, h10, O.to, O.side) : null) ? this.parts.splice(n, 0, d) : this.parts[n] = d;
    }
    let i = [];
    for (let n = e; n < this.parts.length; n++) {
      let O = this.parts[n];
      O instanceof os && i.push(O);
    }
    return i;
  }
  /// Find an opening delimiter of the given type. Returns `null` if
  /// no delimiter is found, or an index that can be passed to
  /// [`takeContent`](#InlineContext.takeContent) otherwise.
  findOpeningDelimiter(e) {
    for (let i = this.parts.length - 1; i >= 0; i--) {
      let n = this.parts[i];
      if (n instanceof Ki && n.type == e)
        return i;
    }
    return null;
  }
  /// Remove all inline elements and delimiters starting from the
  /// given index (which you should get from
  /// [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),
  /// resolve delimiters inside of them, and return them as an array
  /// of elements.
  takeContent(e) {
    let i = this.resolveMarkers(e);
    return this.parts.length = e, i;
  }
  /// Skip space after the given (document) position, returning either
  /// the position of the next non-space character or the end of the
  /// section.
  skipSpace(e) {
    return ko(this.text, e - this.offset) + this.offset;
  }
  elt(e, i, n, O) {
    return typeof e == "string" ? _e(this.parser.getNodeType(e), i, n, O) : new HX(e, i);
  }
};
function bd(t, e) {
  if (!e.length)
    return t;
  if (!t.length)
    return e;
  let i = t.slice(), n = 0;
  for (let O of e) {
    for (; n < i.length && i[n].to < O.to; )
      n++;
    if (n < i.length && i[n].from < O.from) {
      let r = i[n];
      r instanceof os && (i[n] = new os(r.type, r.from, r.to, bd(r.children, [O])));
    } else
      i.splice(n++, 0, O);
  }
  return i;
}
var B4 = [j.CodeBlock, j.ListItem, j.OrderedList, j.BulletList];
var F4 = class {
  constructor(e, i) {
    this.fragments = e, this.input = i, this.i = 0, this.fragment = null, this.fragmentEnd = -1, this.cursor = null, e.length && (this.fragment = e[this.i++]);
  }
  nextFragment() {
    this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null, this.cursor = null, this.fragmentEnd = -1;
  }
  moveTo(e, i) {
    for (; this.fragment && this.fragment.to <= e; )
      this.nextFragment();
    if (!this.fragment || this.fragment.from > (e ? e - 1 : 0))
      return false;
    if (this.fragmentEnd < 0) {
      let r = this.fragment.to;
      for (; r > 0 && this.input.read(r - 1, r) != `
`; )
        r--;
      this.fragmentEnd = r ? r - 1 : 0;
    }
    let n = this.cursor;
    n || (n = this.cursor = this.fragment.tree.cursor(), n.firstChild());
    let O = e + this.fragment.offset;
    for (; n.to <= O; )
      if (!n.parent())
        return false;
    for (; ; ) {
      if (n.from >= O)
        return this.fragment.from <= i;
      if (!n.childAfter(O))
        return false;
    }
  }
  matches(e) {
    let i = this.cursor.tree;
    return i && i.prop(se.contextHash) == e;
  }
  takeNodes(e) {
    let i = this.cursor, n = this.fragment.offset, O = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0), r = e.absoluteLineStart, a = r, o = e.block.children.length, s = a, l = o;
    for (; ; ) {
      if (i.to - n > O) {
        if (i.type.isAnonymous && i.firstChild())
          continue;
        break;
      }
      if (e.dontInject.add(i.tree), e.addNode(i.tree, i.from - n), i.type.is("Block") && (B4.indexOf(i.type.id) < 0 ? (a = i.to - n, o = e.block.children.length) : (a = s, o = l, s = i.to - n, l = e.block.children.length)), !i.nextSibling())
        break;
    }
    for (; e.block.children.length > o; )
      e.block.children.pop(), e.block.positions.pop();
    return a - r;
  }
};
var H4 = ti({
  "Blockquote/...": f.quote,
  HorizontalRule: f.contentSeparator,
  "ATXHeading1/... SetextHeading1/...": f.heading1,
  "ATXHeading2/... SetextHeading2/...": f.heading2,
  "ATXHeading3/...": f.heading3,
  "ATXHeading4/...": f.heading4,
  "ATXHeading5/...": f.heading5,
  "ATXHeading6/...": f.heading6,
  "Comment CommentBlock": f.comment,
  Escape: f.escape,
  Entity: f.character,
  "Emphasis/...": f.emphasis,
  "StrongEmphasis/...": f.strong,
  "Link/... Image/...": f.link,
  "OrderedList/... BulletList/...": f.list,
  "BlockQuote/...": f.quote,
  "InlineCode CodeText": f.monospace,
  URL: f.url,
  "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": f.processingInstruction,
  "CodeInfo LinkLabel": f.labelName,
  LinkTitle: f.string,
  Paragraph: f.content
});
var K4 = new fu(new _a(BX).extend(H4), Object.keys(sl).map((t) => sl[t]), Object.keys(sl).map((t) => A4[t]), Object.keys(sl), G4, CX, Object.keys(Tf).map((t) => Tf[t]), Object.keys(Tf), []);
function J4(t, e, i) {
  let n = [];
  for (let O = t.firstChild, r = e; ; O = O.nextSibling) {
    let a = O ? O.from : i;
    if (a > r && n.push({ from: r, to: a }), !O)
      break;
    r = O.to;
  }
  return n;
}
function eE(t) {
  let { codeParser: e, htmlParser: i } = t;
  return { wrap: Vp((O, r) => {
    let a = O.type.id;
    if (e && (a == j.CodeBlock || a == j.FencedCode)) {
      let o = "";
      if (a == j.FencedCode) {
        let l = O.node.getChild(j.CodeInfo);
        l && (o = r.read(l.from, l.to));
      }
      let s = e(o);
      if (s)
        return { parser: s, overlay: (l) => l.type.id == j.CodeText };
    } else if (i && (a == j.HTMLBlock || a == j.HTMLTag))
      return { parser: i, overlay: J4(O.node, O.from, O.to) };
    return null;
  }) };
}
var tE = { resolve: "Strikethrough", mark: "StrikethroughMark" };
var iE = {
  defineNodes: [{
    name: "Strikethrough",
    style: { "Strikethrough/...": f.strikethrough }
  }, {
    name: "StrikethroughMark",
    style: f.processingInstruction
  }],
  parseInline: [{
    name: "Strikethrough",
    parse(t, e, i) {
      if (e != 126 || t.char(i + 1) != 126 || t.char(i + 2) == 126)
        return -1;
      let n = t.slice(i - 1, i), O = t.slice(i + 2, i + 3), r = /\s|^$/.test(n), a = /\s|^$/.test(O), o = ss.test(n), s = ss.test(O);
      return t.addDelimiter(tE, i, i + 2, !a && (!s || r || o), !r && (!o || a || s));
    },
    after: "Emphasis"
  }]
};
function _o(t, e, i = 0, n, O = 0) {
  let r = 0, a = true, o = -1, s = -1, l = false, c = () => {
    n.push(t.elt("TableCell", O + o, O + s, t.parser.parseInline(e.slice(o, s), O + o)));
  };
  for (let u = i; u < e.length; u++) {
    let h10 = e.charCodeAt(u);
    h10 == 124 && !l ? ((!a || o > -1) && r++, a = false, n && (o > -1 && c(), n.push(t.elt("TableDelimiter", u + O, u + O + 1))), o = s = -1) : (l || h10 != 32 && h10 != 9) && (o < 0 && (o = u), s = u + 1), l = !l && h10 == 92;
  }
  return o > -1 && (r++, n && c()), r;
}
function RS(t, e) {
  for (let i = e; i < t.length; i++) {
    let n = t.charCodeAt(i);
    if (n == 124)
      return true;
    n == 92 && i++;
  }
  return false;
}
var nx = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
var ZS = class {
  constructor() {
    this.rows = null;
  }
  nextLine(e, i, n) {
    if (this.rows == null) {
      this.rows = false;
      let O;
      if ((i.next == 45 || i.next == 58 || i.next == 124) && nx.test(O = i.text.slice(i.pos))) {
        let r = [];
        _o(e, n.content, 0, r, n.start) == _o(e, O, i.pos) && (this.rows = [
          e.elt("TableHeader", n.start, n.start + n.content.length, r),
          e.elt("TableDelimiter", e.lineStart + i.pos, e.lineStart + i.text.length)
        ]);
      }
    } else if (this.rows) {
      let O = [];
      _o(e, i.text, i.pos, O, e.lineStart), this.rows.push(e.elt("TableRow", e.lineStart + i.pos, e.lineStart + i.text.length, O));
    }
    return false;
  }
  finish(e, i) {
    return this.rows ? (e.addLeafElement(i, e.elt("Table", i.start, i.start + i.content.length, this.rows)), true) : false;
  }
};
var nE = {
  defineNodes: [
    { name: "Table", block: true },
    { name: "TableHeader", style: { "TableHeader/...": f.heading } },
    "TableRow",
    { name: "TableCell", style: f.content },
    { name: "TableDelimiter", style: f.processingInstruction }
  ],
  parseBlock: [{
    name: "Table",
    leaf(t, e) {
      return RS(e.content, 0) ? new ZS() : null;
    },
    endLeaf(t, e, i) {
      if (i.parsers.some((O) => O instanceof ZS) || !RS(e.text, e.basePos))
        return false;
      let n = t.scanLine(t.absoluteLineEnd + 1).text;
      return nx.test(n) && _o(t, e.text, e.basePos) == _o(t, n, e.basePos);
    },
    before: "SetextHeading"
  }]
};
var OE = class {
  nextLine() {
    return false;
  }
  finish(e, i) {
    return e.addLeafElement(i, e.elt("Task", i.start, i.start + i.content.length, [
      e.elt("TaskMarker", i.start, i.start + 3),
      ...e.parser.parseInline(i.content.slice(3), i.start + 3)
    ])), true;
  }
};
var rE = {
  defineNodes: [
    { name: "Task", block: true, style: f.list },
    { name: "TaskMarker", style: f.atom }
  ],
  parseBlock: [{
    name: "TaskList",
    leaf(t, e) {
      return /^\[[ xX]\]/.test(e.content) && t.parentType().name == "ListItem" ? new OE() : null;
    },
    after: "SetextHeading"
  }]
};
var aE = [nE, rE, iE];
function Ox(t, e, i) {
  return (n, O, r) => {
    if (O != t || n.char(r + 1) == t)
      return -1;
    let a = [n.elt(i, r, r + 1)];
    for (let o = r + 1; o < n.end; o++) {
      let s = n.char(o);
      if (s == t)
        return n.addElement(n.elt(e, r, o + 1, a.concat(n.elt(i, o, o + 1))));
      if (s == 92 && a.push(n.elt("Escape", o, o++ + 2)), Ei(s))
        break;
    }
    return -1;
  };
}
var oE = {
  defineNodes: [
    { name: "Superscript", style: f.special(f.content) },
    { name: "SuperscriptMark", style: f.processingInstruction }
  ],
  parseInline: [{
    name: "Superscript",
    parse: Ox(94, "Superscript", "SuperscriptMark")
  }]
};
var sE = {
  defineNodes: [
    { name: "Subscript", style: f.special(f.content) },
    { name: "SubscriptMark", style: f.processingInstruction }
  ],
  parseInline: [{
    name: "Subscript",
    parse: Ox(126, "Subscript", "SubscriptMark")
  }]
};
var lE = {
  defineNodes: [{ name: "Emoji", style: f.character }],
  parseInline: [{
    name: "Emoji",
    parse(t, e, i) {
      let n;
      return e != 58 || !(n = /^[a-zA-Z_0-9]+:/.exec(t.slice(i + 1, t.end))) ? -1 : t.addElement(t.elt("Emoji", i, i + 1 + n[0].length));
    }
  }]
};
var rx = Kc({ block: { open: "<!--", close: "-->" } });
var ax = new se();
var ox = K4.configure({
  props: [
    ui.add((t) => !t.is("Block") || t.is("Document") || vd(t) != null ? void 0 : (e, i) => ({ from: i.doc.lineAt(e.from).to, to: e.to })),
    ax.add(vd),
    ci.add({
      Document: () => null
    }),
    uO.add({
      Document: rx
    })
  ]
});
function vd(t) {
  let e = /^(?:ATX|Setext)Heading(\d)$/.exec(t.name);
  return e ? +e[1] : void 0;
}
function cE(t, e) {
  let i = t;
  for (; ; ) {
    let n = i.nextSibling, O;
    if (!n || (O = vd(n.type)) != null && O <= e)
      break;
    i = n;
  }
  return i.to;
}
var uE = T1.of((t, e, i) => {
  for (let n = Ye(t).resolveInner(i, -1); n && !(n.from < e); n = n.parent) {
    let O = n.type.prop(ax);
    if (O == null)
      continue;
    let r = cE(n, O);
    if (r > i)
      return { from: i, to: r };
  }
  return null;
});
function m$(t) {
  return new gi(rx, t, [uE], "markdown");
}
var fE = m$(ox);
var hE = ox.configure([aE, sE, oE, lE]);
var sx = m$(hE);
function dE(t, e) {
  return (i) => {
    if (i && t) {
      let n = null;
      if (i = /\S*/.exec(i)[0], typeof t == "function" ? n = t(i) : n = ic.matchLanguageName(t, i, true), n instanceof ic)
        return n.support ? n.support.language.parser : er.getSkippingParser(n.load());
      if (n)
        return n.parser;
    }
    return e ? e.parser : null;
  };
}
var cl = class {
  constructor(e, i, n, O, r, a, o) {
    this.node = e, this.from = i, this.to = n, this.spaceBefore = O, this.spaceAfter = r, this.type = a, this.item = o;
  }
  blank(e, i = true) {
    let n = this.spaceBefore + (this.node.name == "Blockquote" ? ">" : "");
    if (e != null) {
      for (; n.length < e; )
        n += " ";
      return n;
    } else {
      for (let O = this.to - this.from - n.length - this.spaceAfter.length; O > 0; O--)
        n += " ";
      return n + (i ? this.spaceAfter : "");
    }
  }
  marker(e, i) {
    let n = this.node.name == "OrderedList" ? String(+cx(this.item, e)[2] + i) : "";
    return this.spaceBefore + n + this.type + this.spaceAfter;
  }
};
function lx(t, e) {
  let i = [];
  for (let O = t; O && O.name != "Document"; O = O.parent)
    (O.name == "ListItem" || O.name == "Blockquote" || O.name == "FencedCode") && i.push(O);
  let n = [];
  for (let O = i.length - 1; O >= 0; O--) {
    let r = i[O], a, o = e.lineAt(r.from), s = r.from - o.from;
    if (r.name == "FencedCode")
      n.push(new cl(r, s, s, "", "", "", null));
    else if (r.name == "Blockquote" && (a = /^[ \t]*>( ?)/.exec(o.text.slice(s))))
      n.push(new cl(r, s, s + a[0].length, "", a[1], ">", null));
    else if (r.name == "ListItem" && r.parent.name == "OrderedList" && (a = /^([ \t]*)\d+([.)])([ \t]*)/.exec(o.text.slice(s)))) {
      let l = a[3], c = a[0].length;
      l.length >= 4 && (l = l.slice(0, l.length - 4), c -= 4), n.push(new cl(r.parent, s, s + c, a[1], l, a[2], r));
    } else if (r.name == "ListItem" && r.parent.name == "BulletList" && (a = /^([ \t]*)([-+*])([ \t]{1,4}\[[ xX]\])?([ \t]+)/.exec(o.text.slice(s)))) {
      let l = a[4], c = a[0].length;
      l.length > 4 && (l = l.slice(0, l.length - 4), c -= 4);
      let u = a[2];
      a[3] && (u += a[3].replace(/[xX]/, " ")), n.push(new cl(r.parent, s, s + c, a[1], l, u, r));
    }
  }
  return n;
}
function cx(t, e) {
  return /^(\s*)(\d+)(?=[.)])/.exec(e.sliceString(t.from, t.from + 10));
}
function kf(t, e, i, n = 0) {
  for (let O = -1, r = t; ; ) {
    if (r.name == "ListItem") {
      let o = cx(r, e), s = +o[2];
      if (O >= 0) {
        if (s != O + 1)
          return;
        i.push({ from: r.from + o[1].length, to: r.from + o[0].length, insert: String(O + 2 + n) });
      }
      O = s;
    }
    let a = r.nextSibling;
    if (!a)
      break;
    r = a;
  }
}
var pE = ({ state: t, dispatch: e }) => {
  let i = Ye(t), { doc: n } = t, O = null, r = t.changeByRange((a) => {
    if (!a.empty || !sx.isActiveAt(t, a.from))
      return O = { range: a };
    let o = a.from, s = n.lineAt(o), l = lx(i.resolveInner(o, -1), n);
    for (; l.length && l[l.length - 1].from > o - s.from; )
      l.pop();
    if (!l.length)
      return O = { range: a };
    let c = l[l.length - 1];
    if (c.to - c.spaceAfter.length > o - s.from)
      return O = { range: a };
    let u = o >= c.to - c.spaceAfter.length && !/\S/.test(s.text.slice(c.to));
    if (c.item && u)
      if (c.node.firstChild.to >= o || s.from > 0 && !/[^\s>]/.test(n.lineAt(s.from - 1).text)) {
        let g = l.length > 1 ? l[l.length - 2] : null, Q, m = "";
        g && g.item ? (Q = s.from + g.from, m = g.marker(n, 1)) : Q = s.from + (g ? g.to : 0);
        let b = [{ from: Q, to: o, insert: m }];
        return c.node.name == "OrderedList" && kf(c.item, n, b, -2), g && g.node.name == "OrderedList" && kf(g.item, n, b), { range: R.cursor(Q + m.length), changes: b };
      } else {
        let g = "";
        for (let Q = 0, m = l.length - 2; Q <= m; Q++)
          g += l[Q].blank(Q < m ? l[Q + 1].from - g.length : null, Q < m);
        return g += t.lineBreak, { range: R.cursor(o + g.length), changes: { from: s.from, insert: g } };
      }
    if (c.node.name == "Blockquote" && u && s.from) {
      let g = n.lineAt(s.from - 1), Q = />\s*$/.exec(g.text);
      if (Q && Q.index == c.from) {
        let m = t.changes([
          { from: g.from + Q.index, to: g.to },
          { from: s.from + c.from, to: s.to }
        ]);
        return { range: a.map(m), changes: m };
      }
    }
    let h10 = [];
    c.node.name == "OrderedList" && kf(c.item, n, h10);
    let d = c.item && c.item.from < s.from, p = "";
    if (!d || /^[\s\d.)\-+*>]*/.exec(s.text)[0].length >= c.to)
      for (let g = 0, Q = l.length - 1; g <= Q; g++)
        p += g == Q && !d ? l[g].marker(n, 1) : l[g].blank(g < Q ? l[g + 1].from - p.length : null);
    let $ = o;
    for (; $ > s.from && /\s/.test(s.text.charAt($ - s.from - 1)); )
      $--;
    return p = t.lineBreak + p, h10.push({ from: $, to: o, insert: p }), { range: R.cursor($ + p.length), changes: h10 };
  });
  return O ? false : (e(t.update(r, { scrollIntoView: true, userEvent: "input" })), true);
};
function US(t) {
  return t.name == "QuoteMark" || t.name == "ListMark";
}
function $E(t, e) {
  let i = t.resolveInner(e, -1), n = e;
  US(i) && (n = i.from, i = i.parent);
  for (let O; O = i.childBefore(n); )
    if (US(O))
      n = O.from;
    else if (O.name == "OrderedList" || O.name == "BulletList")
      i = O.lastChild, n = i.to;
    else
      break;
  return i;
}
var QE = ({ state: t, dispatch: e }) => {
  let i = Ye(t), n = null, O = t.changeByRange((r) => {
    let a = r.from, { doc: o } = t;
    if (r.empty && sx.isActiveAt(t, r.from)) {
      let s = o.lineAt(a), l = lx($E(i, a), o);
      if (l.length) {
        let c = l[l.length - 1], u = c.to - c.spaceAfter.length + (c.spaceAfter ? 1 : 0);
        if (a - s.from > u && !/\S/.test(s.text.slice(u, a - s.from)))
          return {
            range: R.cursor(s.from + u),
            changes: { from: s.from + u, to: a }
          };
        if (a - s.from == u) {
          let h10 = s.from + c.from;
          if (c.item && c.node.from < c.item.from && /\S/.test(s.text.slice(c.from, c.to)))
            return { range: r, changes: { from: h10, to: s.from + c.to, insert: c.blank(c.to - c.from) } };
          if (h10 < a)
            return { range: R.cursor(h10), changes: { from: h10, to: a } };
        }
      }
    }
    return n = { range: r };
  });
  return n ? false : (e(t.update(O, { scrollIntoView: true, userEvent: "delete" })), true);
};
var gE = [
  { key: "Enter", run: pE },
  { key: "Backspace", run: QE }
];
var VS = u$({ matchClosingTags: false });
function mE(t = {}) {
  let { codeLanguages: e, defaultCodeLanguage: i, addKeymap: n = true, base: { parser: O } = fE } = t;
  if (!(O instanceof fu))
    throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
  let r = t.extensions ? [t.extensions] : [], a = [VS.support], o;
  i instanceof li ? (a.push(i.support), o = i.language) : i && (o = i);
  let s = e || o ? dE(e, o) : void 0;
  return r.push(eE({ codeParser: s, htmlParser: VS.language.parser })), n && a.push(wO.high(ka.of(gE))), new li(m$(O.configure(r)), a);
}
var SE = ti({
  null: f.null,
  instanceof: f.operatorKeyword,
  this: f.self,
  "new super assert open to with void": f.keyword,
  "class interface extends implements enum var": f.definitionKeyword,
  "module package import": f.moduleKeyword,
  "switch while for if else case default do break continue return try catch finally throw": f.controlKeyword,
  ["requires exports opens uses provides public private protected static transitive abstract final strictfp synchronized native transient volatile throws"]: f.modifier,
  IntegerLiteral: f.integer,
  FloatingPointLiteral: f.float,
  "StringLiteral TextBlock": f.string,
  CharacterLiteral: f.character,
  LineComment: f.lineComment,
  BlockComment: f.blockComment,
  BooleanLiteral: f.bool,
  PrimitiveType: f.standard(f.typeName),
  TypeName: f.typeName,
  Identifier: f.variableName,
  "MethodName/Identifier": f.function(f.variableName),
  Definition: f.definition(f.variableName),
  ArithOp: f.arithmeticOperator,
  LogicOp: f.logicOperator,
  BitOp: f.bitwiseOperator,
  CompareOp: f.compareOperator,
  AssignOp: f.definitionOperator,
  UpdateOp: f.updateOperator,
  Asterisk: f.punctuation,
  Label: f.labelName,
  "( )": f.paren,
  "[ ]": f.squareBracket,
  "{ }": f.brace,
  ".": f.derefOperator,
  ", ;": f.separator
});
var PE = { __proto__: null, true: 34, false: 34, null: 42, void: 46, byte: 48, short: 48, int: 48, long: 48, char: 48, float: 48, double: 48, boolean: 48, extends: 62, super: 64, class: 76, this: 78, new: 84, public: 100, protected: 102, private: 104, abstract: 106, static: 108, final: 110, strictfp: 112, default: 114, synchronized: 116, native: 118, transient: 120, volatile: 122, throws: 150, implements: 160, interface: 166, enum: 176, instanceof: 236, open: 265, module: 267, requires: 272, transitive: 274, exports: 276, to: 278, opens: 280, uses: 282, provides: 284, with: 286, package: 290, import: 294, if: 306, else: 308, while: 312, for: 316, var: 323, assert: 330, switch: 334, case: 340, do: 344, break: 348, continue: 352, return: 356, throw: 362, try: 366, catch: 370, finally: 378 };
var yE = Jt.deserialize({
  version: 14,
  states: "#!hQ]QPOOO&tQQO'#H[O(xQQO'#CbOOQO'#Cb'#CbO)PQPO'#CaO)XOSO'#CpOOQO'#Ha'#HaOOQO'#Cu'#CuO*tQPO'#D_O+_QQO'#HkOOQO'#Hk'#HkO-sQQO'#HfO-zQQO'#HfOOQO'#Hf'#HfOOQO'#He'#HeO0OQPO'#DUO0]QPO'#GlO3TQPO'#D_O3[QPO'#DzO)PQPO'#E[O3}QPO'#E[OOQO'#DV'#DVO5]QQO'#H_O7dQQO'#EeO7kQPO'#EdO7pQPO'#EfOOQO'#H`'#H`O5sQQO'#H`O8sQQO'#FgO8zQPO'#EwO9PQPO'#E|O9PQPO'#FOOOQO'#H_'#H_OOQO'#HW'#HWOOQO'#Gf'#GfOOQO'#HV'#HVO:aQPO'#FhOOQO'#HU'#HUOOQO'#Ge'#GeQ]QPOOOOQO'#Hq'#HqO:fQPO'#HqO:kQPO'#D{O:kQPO'#EVO:kQPO'#EQO:sQPO'#HnO;UQQO'#EfO)PQPO'#C`O;^QPO'#C`O)PQPO'#FbO;cQPO'#FdO;nQPO'#FjO;nQPO'#FmO:kQPO'#FrO;sQPO'#FoO9PQPO'#FvO;nQPO'#FxO]QPO'#F}O;xQPO'#GPO<TQPO'#GRO<`QPO'#GTO;nQPO'#GVO9PQPO'#GWO<gQPO'#GYOOQO'#H['#H[O=WQQO,58{OOQO'#HY'#HYOOOO'#Gg'#GgO>yOSO,59[OOQO,59[,59[OOQO'#Hg'#HgO?jQPO,59eO@lQPO,59yOOQO-E:d-E:dO)PQPO,58zOA`QPO,58zO)PQPO,5;|OAeQPO'#DQOAjQPO'#DQOOQO'#Gi'#GiOBjQQO,59jOOQO'#Dm'#DmODRQPO'#HsOD]QPO'#DlODkQPO'#HrODsQPO,5<^ODxQPO,59^OEcQPO'#CxOOQO,59c,59cOEjQPO,59bOGrQQO'#H[OJVQQO'#CbOJmQPO'#D_OKrQQO'#HkOLSQQO,59pOLZQPO'#DvOLiQPO'#HzOLqQPO,5:`OLvQPO,5:`OM^QPO,5;mOMiQPO'#IROMtQPO,5;dOMyQPO,5=WOOQO-E:j-E:jOOQO,5:f,5:fO! aQPO,5:fO! hQPO,5:vO! mQPO,5<^O)PQPO,5:vO:kQPO,5:gO:kQPO,5:qO:kQPO,5:lO:kQPO,5<^O!!^QPO,59qO9PQPO,5:}O!!eQPO,5;QO9PQPO,59TO!!sQPO'#DXOOQO,5;O,5;OOOQO'#El'#ElOOQO'#En'#EnO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;eOOQO,5;h,5;hOOQO,5<R,5<RO!!zQPO,5;aO!#]QPO,5;cO!!zQPO'#CyO!#dQQO'#HkO!#rQQO,5;jO]QPO,5<SOOQO-E:c-E:cOOQO,5>],5>]O!%SQPO,5:gO!%bQPO,5:qO!%jQPO,5:lO!%uQPO,5>YOLZQPO,5>YO! {QPO,59UO!&QQQO,58zO!&YQQO,5;|O!&bQQO,5<OO)PQPO,5<OO9PQPO'#DUO]QPO,5<UO]QPO,5<XO!&jQPO'#FqO]QPO,5<ZO]QPO,5<`O!&zQQO,5<bO!'UQPO,5<dO!'ZQPO,5<iOOQO'#Fi'#FiOOQO,5<k,5<kO!'`QPO,5<kOOQO,5<m,5<mO!'eQPO,5<mO!'jQQO,5<oOOQO,5<o,5<oO<jQPO,5<qO!'qQQO,5<rO!'xQPO'#GcO!)OQPO,5<tO<jQPO,5<|O)PQPO,58}O!,|QPO'#ChOOQO1G.k1G.kOOOO-E:e-E:eOOQO1G.v1G.vO!-WQPO,59jO!&QQQO1G.fO)PQPO1G.fO!-eQQO1G1hOOQO,59l,59lO!-mQPO,59lOOQO-E:g-E:gO!-rQPO,5>_O!.ZQPO,5:WO:kQPO'#GnO!.bQPO,5>^OOQO1G1x1G1xOOQO1G.x1G.xO!.{QPO'#CyO!/kQPO'#HkO!/uQPO'#CzO!0TQPO'#HjO!0]QPO,59dOOQO1G.|1G.|OEjQPO1G.|O!0sQPO,59eO!1QQQO'#H[O!1cQQO'#CbOOQO,5:b,5:bO:kQPO,5:cOOQO,5:a,5:aO!1tQQO,5:aOOQO1G/[1G/[O!1yQPO,5:bO!2[QPO'#GqO!2oQPO,5>fOOQO1G/z1G/zO!2wQPO'#DvO!3YQPO'#D_O!3aQPO1G/zO!!zQPO'#GoO!3fQPO1G1XO9PQPO1G1XO:kQPO'#GwO!3nQPO,5>mOOQO1G1O1G1OOOQO1G0Q1G0QO!3vQPO'#E]OOQO1G0b1G0bO!4gQPO1G1xO! hQPO1G0bO!%SQPO1G0RO!%bQPO1G0]O!%jQPO1G0WOOQO1G/]1G/]O!4lQQO1G.pO7kQPO1G0jO)PQPO1G0jO:sQPO'#HnO!6`QQO1G.pOOQO1G.p1G.pO!6eQQO1G0iOOQO1G0l1G0lO!6lQPO1G0lO!6wQQO1G.oO!7_QQO'#HoO!7lQPO,59sO!8{QQO1G0pO!:dQQO1G0pO!;rQQO1G0pO!<PQQO1G0pO!=UQQO1G0pO!=lQQO1G0pO!=vQQO1G1PO!=}QQO'#HkOOQO1G0{1G0{O!?QQQO1G0}OOQO1G0}1G0}OOQO1G1n1G1nO! pQPO'#DqO!ARQPO'#D[O!!zQPO'#D|O!!zQPO'#D}OOQO1G0R1G0RO!AYQPO1G0RO!A_QPO1G0RO!AgQPO1G0RO!ArQPO'#EXOOQO1G0]1G0]O!BVQPO1G0]O!B[QPO'#ETO!!zQPO'#ESOOQO1G0W1G0WO!CUQPO1G0WO!CZQPO1G0WO!CcQPO'#EhO!CjQPO'#EhOOQO'#Gv'#GvO!CrQQO1G0mO!EcQQO1G3tO7kQPO1G3tO!GbQPO'#FWOOQO1G.f1G.fOOQO1G1h1G1hO!GiQPO1G1jOOQO1G1j1G1jO!GtQQO1G1jO!G|QPO1G1pOOQO1G1s1G1sO)aQPO'#D_O+_QQO,5<aO!KtQPO,5<aO!LVQPO,5<]O!L^QPO,5<]OOQO1G1u1G1uOOQO1G1z1G1zOOQO1G1|1G1|O9PQPO1G1|O#!QQPO'#FzOOQO1G2O1G2OO;nQPO1G2TOOQO1G2V1G2VOOQO1G2X1G2XOOQO1G2Z1G2ZOOQO1G2]1G2]OOQO1G2^1G2^O#!XQQO'#H[O##SQQO'#CbO+_QQO'#HkO##}QQOOO#$kQQO'#EeO#$YQQO'#H`OLZQPO'#GdO#$rQPO,5<}OOQO'#HO'#HOO#$zQPO1G2`O#(xQPO'#G[O<jQPO'#G`OOQO1G2`1G2`O#(}QPO1G2hOOQO1G.i1G.iO#.SQQO'#EeO#.dQQO'#H^O#.tQPO'#FSOOQO'#H^'#H^O#/OQPO'#H^O#/mQPO'#IUO#/uQPO,59SOOQO7+$Q7+$QO!&QQQO7+$QOOQO7+'S7+'SOOQO1G/W1G/WO#/zQPO'#DoO#0UQQO'#HtOOQO'#Ht'#HtOOQO1G/r1G/rOOQO,5=Y,5=YOOQO-E:l-E:lO#0fQWO,58{O#0mQPO,59fOOQO,59f,59fO!!zQPO'#HmOD}QPO'#GhO#0{QPO,5>UOOQO1G/O1G/OOOQO7+$h7+$hOOQO1G/{1G/{O#1TQQO1G/{OOQO1G/}1G/}O#1YQPO1G/{OOQO1G/|1G/|O:kQPO1G/}OOQO,5=],5=]OOQO-E:o-E:oOOQO7+%f7+%fOOQO,5=Z,5=ZOOQO-E:m-E:mO9PQPO7+&sOOQO7+&s7+&sOOQO,5=c,5=cOOQO-E:u-E:uO#1_QPO'#EUO#1mQPO'#EUOOQO'#Gu'#GuO#2UQPO,5:wOOQO,5:w,5:wOOQO7+'d7+'dOOQO7+%|7+%|OOQO7+%m7+%mO!AYQPO7+%mO!A_QPO7+%mO!AgQPO7+%mOOQO7+%w7+%wO!BVQPO7+%wOOQO7+%r7+%rO!CUQPO7+%rO!CZQPO7+%rOOQO7+&U7+&UOOQO'#Ee'#EeO7kQPO7+&UO7kQPO,5>YO#2uQPO7+$[OOQO7+&T7+&TOOQO7+&W7+&WO9PQPO'#GjO#3TQPO,5>ZOOQO1G/_1G/_O9PQPO7+&kO#3`QQO,59eO#4cQPO'#DrO! pQPO'#DrO#4nQPO'#HwO#4vQPO,5:]O#5aQQO'#HgO#5|QQO'#CuO! mQPO'#HvO#6lQPO'#DpO#6vQPO'#HvO#7XQPO'#DpO#7aQPO'#IPO#7fQPO'#E`OOQO'#Hp'#HpOOQO'#Gk'#GkO#7nQPO,59vOOQO,59v,59vO#7uQPO'#HqOOQO,5:h,5:hO#9]QPO'#H|OOQO'#EP'#EPOOQO,5:i,5:iO#9hQPO'#EYO:kQPO'#EYO#9yQPO'#H}O#:UQPO,5:sO! mQPO'#HvO!!zQPO'#HvO#:^QPO'#DpOOQO'#Gs'#GsO#:eQPO,5:oOOQO,5:o,5:oOOQO,5:n,5:nOOQO,5;S,5;SO#;_QQO,5;SO#;fQPO,5;SOOQO-E:t-E:tOOQO7+&X7+&XOOQO7+)`7+)`O#;mQQO7+)`OOQO'#Gz'#GzO#=ZQPO,5;rOOQO,5;r,5;rO#=bQPO'#FXO)PQPO'#FXO)PQPO'#FXO)PQPO'#FXO#=pQPO7+'UO#=uQPO7+'UOOQO7+'U7+'UO]QPO7+'[O#>QQPO1G1{O! mQPO1G1{O#>`QQO1G1wO!!sQPO1G1wO#>gQPO1G1wO#>nQQO7+'hOOQO'#G}'#G}O#>uQPO,5<fOOQO,5<f,5<fO#>|QPO'#HqO9PQPO'#F{O#?UQPO7+'oO#?ZQPO,5=OO! mQPO,5=OO#?`QPO1G2iO#@iQPO1G2iOOQO1G2i1G2iOOQO-E:|-E:|OOQO7+'z7+'zO!2[QPO'#G^O<jQPO,5<vOOQO,5<z,5<zO#@qQPO7+(SOOQO7+(S7+(SO#DoQPO,59TO#DvQPO'#ITO#EOQPO,5;nO)PQPO'#GyO#ETQPO,5>pOOQO1G.n1G.nOOQO<<Gl<<GlO#E]QPO'#HuO#EeQPO,5:ZOOQO1G/Q1G/QOOQO,5>X,5>XOOQO,5=S,5=SOOQO-E:f-E:fO#EjQPO7+%gOOQO7+%g7+%gOOQO7+%i7+%iOOQO<<J_<<J_O#FQQPO'#H[O#FXQPO'#CbO#F`QPO,5:pO#FeQPO,5:xO#1_QPO,5:pOOQO-E:s-E:sOOQO1G0c1G0cOOQO<<IX<<IXO!AYQPO<<IXO!A_QPO<<IXOOQO<<Ic<<IcOOQO<<I^<<I^O!CUQPO<<I^OOQO<<Ip<<IpO#FjQQO<<GvO7kQPO<<IpO)PQPO<<IpOOQO<<Gv<<GvO#H^QQO,5=UOOQO-E:h-E:hO#HkQQO<<JVOOQO,5:^,5:^O!!zQPO'#DsO#IRQPO,5:^O! pQPO'#GpO#I^QPO,5>cOOQO1G/w1G/wO#IfQPO'#HsO#ImQPO,59xO#IrQPO,5>bO! mQPO,59xO#I}QPO,5:[O#7fQPO,5:zO! mQPO,5>bO!!zQPO,5>bO#7aQPO,5>kOOQO,5:[,5:[OLvQPO'#DtOOQO,5>k,5>kO#JVQPO'#EaOOQO,5:z,5:zO#MWQPO,5:zO!!zQPO'#DxOOQO-E:i-E:iOOQO1G/b1G/bOOQO,5:y,5:yO!!zQPO'#GrO#M]QPO,5>hOOQO,5:t,5:tO#MhQPO,5:tO#MvQPO,5:tO#NXQPO'#GtO#NoQPO,5>iO#NzQPO'#EZOOQO1G0_1G0_O$ RQPO1G0_O! mQPO,5:pOOQO-E:q-E:qOOQO1G0Z1G0ZOOQO1G0n1G0nO$ WQQO1G0nOOQO<<Lz<<LzOOQO-E:x-E:xOOQO1G1^1G1^O$ _QQO,5;sOOQO'#G{'#G{O#=bQPO,5;sOOQO'#IV'#IVO$ gQQO,5;sO$ xQQO,5;sOOQO<<Jp<<JpO$!QQPO<<JpOOQO<<Jv<<JvO9PQPO7+'gO$!VQPO7+'gO!!sQPO7+'cO$!eQPO7+'cO$!jQQO7+'cOOQO<<KS<<KSOOQO-E:{-E:{OOQO1G2Q1G2QOOQO,5<g,5<gO$!qQQO,5<gOOQO<<KZ<<KZO9PQPO1G2jO$!xQPO1G2jOOQO,5=l,5=lOOQO7+(T7+(TO$!}QPO7+(TOOQO-E;O-E;OO$$lQWO'#HfO$$WQWO'#HfO$$sQPO'#G_O:kQPO,5<xOLZQPO,5<xOOQO1G2b1G2bOOQO<<Kn<<KnO$%UQQO1G.oOOQO1G1Z1G1ZO$%`QPO'#GxO$%mQPO,5>oOOQO1G1Y1G1YO$%uQPO'#FTOOQO,5=e,5=eOOQO-E:w-E:wO$%zQPO'#GmO$&XQPO,5>aOOQO1G/u1G/uOOQO<<IR<<IROOQO1G0[1G0[O$&aQPO1G0dO$&fQPO1G0[O$&kQPO1G0dOOQOAN>sAN>sO!AYQPOAN>sOOQOAN>xAN>xOOQOAN?[AN?[O7kQPOAN?[O$&pQPO,5:_OOQO1G/x1G/xOOQO,5=[,5=[OOQO-E:n-E:nO$&{QPO,5>eOOQO1G/d1G/dOOQO1G3|1G3|O$'^QPO1G/dOOQO1G/v1G/vOOQO1G0f1G0fO#MWQPO1G0fO#7aQPO'#HyO$'cQPO1G3|O! mQPO1G3|OOQO1G4V1G4VOK^QPO'#DvOJmQPO'#D_OOQO,5:{,5:{O$'nQPO,5:{O$'nQPO,5:{O$'uQQO'#H_O$'|QQO'#H`O$(WQQO'#EbO$(cQPO'#EbOOQO,5:d,5:dOOQO,5=^,5=^OOQO-E:p-E:pOOQO1G0`1G0`O$(kQPO1G0`OOQO,5=`,5=`OOQO-E:r-E:rO$(yQPO,5:uOOQO7+%y7+%yOOQO7+&Y7+&YOOQO1G1_1G1_O$)QQQO1G1_OOQO-E:y-E:yO$)YQQO'#IWO$)TQPO1G1_O$ mQPO1G1_O)PQPO1G1_OOQOAN@[AN@[O$)eQQO<<KRO9PQPO<<KRO$)lQPO<<J}OOQO<<J}<<J}O!!sQPO<<J}OOQO1G2R1G2RO$)qQQO7+(UO9PQPO7+(UOOQO<<Ko<<KoP!'xQPO'#HQOLZQPO'#HPO$){QPO,5<yO$*WQPO1G2dO:kQPO1G2dOOQO,5=d,5=dOOQO-E:v-E:vO#DoQPO,5;oOOQO,5=X,5=XOOQO-E:k-E:kO$*]QPO7+&OOOQO7+%v7+%vO$*kQPO7+&OOOQOG24_G24_OOQOG24vG24vO$*pQPO1G/yO$*{QPO1G4POOQO7+%O7+%OOOQO7+&Q7+&QOOQO7+)h7+)hO$+^QPO7+)hO!0bQPO,5:aOOQO1G0g1G0gO$+iQPO1G0gO$+pQPO,59qO$,UQPO,5:|O7kQPO,5:|OOQO7+%z7+%zOOQO7+&y7+&yO)PQPO'#G|O$,ZQPO,5>rO$,cQPO7+&yO$,hQQO'#IXOOQOAN@mAN@mO$,sQQOAN@mOOQOAN@iAN@iO$,zQPOAN@iO$-PQQO<<KpO$-ZQPO,5=kOOQO-E:}-E:}OOQO7+(O7+(OO$-lQPO7+(OO$-qQPO<<IjOOQO<<Ij<<IjO#DoQPO<<IjO$-qQPO<<IjOOQO<<MS<<MSOOQO7+&R7+&RO$.PQPO1G0jO$.[QQO1G0hOOQO1G0h1G0hO$.dQPO1G0hO$.iQQO,5=hOOQO-E:z-E:zOOQO<<Je<<JeO$.tQPO,5>sOOQOG26XG26XOOQOG26TG26TOOQO<<Kj<<KjOOQOAN?UAN?UO#DoQPOAN?UO$.|QPOAN?UO$/RQPOAN?UO7kQPO7+&SO$/aQPO7+&SOOQO7+&S7+&SO$/fQPOG24pOOQOG24pG24pO#DoQPOG24pO$/kQPO<<InOOQO<<In<<InOOQOLD*[LD*[O$/pQPOLD*[OOQOAN?YAN?YOOQO!$'Mv!$'MvO)PQPO'#CaO$/uQQO'#H[O$0YQQO'#CbO!!zQPO'#Cy",
  stateData: "$0u~OPOSQOS%wOS~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOvzOwjOz}O}bO!PuO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO![!_O!]xO!^xO!_xO!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&rcO~OWiXW&OXZ&OXuiXu&OX!P&OX!b&OX#]&OX#_&OX#a&OX#c&OX#d&OX#e&OX#f&OX#g&OX#h&OX#j&OX#n&OX#q&OX%{iX%}iX&PiX&[&OX&]iX&]&OX&l&OX&tiX&t&OX&v!aX~O#o$]X~P$wOWUXW&ZXZUXuUXu&ZX!PUX!bUX#]UX#_UX#aUX#cUX#dUX#eUX#fUX#gUX#hUX#jUX#nUX#qUX%{&ZX%}&ZX&P&ZX&[UX&]UX&]&ZX&lUX&tUX&t&ZX&v!aX~O#o$]X~P&{O%}RO&P!bO~O&U!gO&W!eO~Og]Oh]O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO%{SO%}!hO&PVOg!RXh!RX$g!RX%}!RX&P!RX~O#x!mO#y!lO$V!nOv!RX!u!RX!z!RX&r!RX~P)aOW!xOu!oO%{SO%}!sO&P!sO&t&_X~OW!{Ou&YX%{&YX%}&YX&P&YX&t&YXY&YXw&YX&l&YX&o&YXZ&YXq&YX&[&YX!P&YX#_&YX#a&YX#c&YX#d&YX#e&YX#f&YX#g&YX#h&YX#j&YX#n&YX#q&YX}&YX!r&YX#o&YXs&YX|&YX~O&]!yO~P+sO&]&YX~P+sOZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO#eoO#qnO#soO#toO%{SO&VTO~O%}!}O&P!|OY&nP~P.RO%{SOg%`Xh%`Xv%`X!S%`X!T%`X!U%`X!V%`X!W%`X!X%`X!Y%`X!Z%`X!]%`X!^%`X!_%`X!u%`X!z%`X$g%`X%}%`X&P%`X&r%`X&]%`X~O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xOg!RXh!RXv!RX!u!RX!z!RX%}!RX&P!RX&r!RX&]!RX~O$g!RX~P1sO|#[O~P]Og]Oh]Ov#aO!u#cO!z#bO%}!hO&PVO&r#`O~O$g#dO~P3cOu#fO&t#gO!P&RX#_&RX#a&RX#c&RX#d&RX#e&RX#f&RX#g&RX#h&RX#j&RX#n&RX#q&RX&[&RX&]&RX&l&RX~OW#eOY&RX#o&RXs&RXq&RX|&RX~P4UO!b#hO#]#hOW&SXu&SX!P&SX#_&SX#a&SX#c&SX#d&SX#e&SX#f&SX#g&SX#h&SX#j&SX#n&SX#q&SX&[&SX&]&SX&l&SX&t&SXY&SX#o&SXs&SXq&SX|&SX~OZ#XX~P5sOZ#iO~O&t#gO~O#_#mO#a#nO#c#oO#d#oO#e#pO#f#qO#g#rO#h#rO#j#vO#n#sO#q#tO&[#kO&]#kO&l#lO~O!P#uO~P7uO&v#wO~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O#eoO#qnO#soO#toO%{SO%}0iO&P0hO&VTO~O#o#{O~O![#}O~O%}!sO&P!sO~Og]Oh]O%}!hO&PVO&]!yO~OW$TO&t#gO~O#y!lO~O!W$XO%}RO&P!bO~OZ$YO~OZ$]O~O!P$dO%}$cO&P$cO~O!P$fO%}$cO&P$cO~O!P$iO~P9POZ$lO}bO~OW$oOZ$pOgTahTa%{Ta%}Ta&PTa~OvTa!STa!TTa!UTa!VTa!WTa!XTa!YTa!ZTa!]Ta!^Ta!_Ta!uTa!zTa#xTa#yTa$VTa$gTa&rTauTaYTa&]TaqTa|Ta!PTa~P<oO&U$sO&W!eO~Ou!oO%{SOqma&[maYma&lma!Pma~O&tma}ma!rma~P?RO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO~Og!Rah!Rav!Ra!u!Ra!z!Ra$g!Ra%}!Ra&P!Ra&r!Ra&]!Ra~P?wO#y$vO~Os$xO~Ou$yO%{SO~Ou!oO%{ra%}ra&Pra&traYrawra&lra&ora!Pra&[raqra~OWra#_ra#ara#cra#dra#era#fra#gra#hra#jra#nra#qra&]ra#orasra|ra~PArOu!oO%{SOq&gX!P&gX!b&gX~OY&gX#o&gX~PCpO!b$|Oq!`X!P!`XY!`X~Oq$}O!P&fX~O!P%PO~Ov%QO~Og]Oh]O%{0gO%}!hO&PVO&`%TO~O&[&^P~PD}O%{SO%}!hO&PVO~OWiXW&OXY&OXZ&OXuiXu&OX!b&OX#]&OX#_&OX#a&OX#c&OX#d&OX#e&OX#f&OX#g&OX#h&OX#j&OX#n&OX#q&OX%{iX%}iX&PiX&[&OX&]iX&]&OX&l&OX&tiX&t&OX&v!aX~OYiXY!aXq!aXwiX&liX&oiX~PEuOWUXW&ZXYUXZUXuUXu&ZX!bUX#]UX#_UX#aUX#cUX#dUX#eUX#fUX#gUX#hUX#jUX#nUX#qUX%{&ZX%}&ZX&P&ZX&[UX&]UX&]&ZX&lUX&tUX&t&ZX&v!aX~OY!aXY&ZXq!aXw&ZX&l&ZX&o&ZX~PHYOg]Oh]O%{SO%}!hO&PVOg!RXh!RX%}!RX&P!RX~P?wOu!oOw%_O%{SO%}%[O&P%ZO&o%^O~OW!xOY&_X&l&_X&t&_X~PK^OY%aO~P7uOg]Oh]O%}!hO&PVO~Oq%cOY&nX~OY%eO~Og]Oh]O%{SO%}!hO&PVOY&nP~P?wOY%kO&l%iO&t#gO~Oq%lO&v#wOY&uX~OY%nO~O%{SOg%`ah%`av%`a!S%`a!T%`a!U%`a!V%`a!W%`a!X%`a!Y%`a!Z%`a!]%`a!^%`a!_%`a!u%`a!z%`a$g%`a%}%`a&P%`a&r%`a&]%`a~O|%oO~P]O}%pO~Ou!oO%{SO%}!sO&P!sO~Op%|Ow%}O%}RO&P!bO&]!yO~Oz%{O~P! {Oz&PO%}RO&P!bO&]!yO~OY&cP~P9POg]Oh]O%{SO%}!hO&PVO~O}bO~P9POW!xOu!oO%{SO&t&_X~O#q#tO!P#ra#_#ra#a#ra#c#ra#d#ra#e#ra#f#ra#g#ra#h#ra#j#ra#n#ra&[#ra&]#ra&l#raY#ra#o#ras#raq#ra|#ra~Oo&dO}&cO!r&eO&]&bO~O}&jO!r&eO~Oo&nO}&mO&]&bO~OZ#iOu&rO%{SO~OW$oO}&xO~OW$oO!P&zO~OW&{O!P&|O~O$g!VO%}0iO&P0hO!P&cP~P.RO!P'XO#o'YO~P7uO}'ZO~O$b']O~O!P'^O~O!P'_O~O!P'`O~P7uO!P'bO~P7uOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wO%P'mO%T'nOZ$|a_$|a`$|aa$|ab$|ac$|ae$|ag$|ah$|ap$|av$|aw$|az$|a}$|a!P$|a!S$|a!T$|a!U$|a!V$|a!W$|a!X$|a!Y$|a!Z$|a![$|a!]$|a!^$|a!_$|a!u$|a!z$|a#e$|a#q$|a#s$|a#t$|a#x$|a#y$|a$V$|a$X$|a$_$|a$b$|a$d$|a$g$|a$k$|a$m$|a$r$|a$t$|a$v$|a$x$|a${$|a$}$|a%u$|a%{$|a%}$|a&P$|a&V$|a&r$|a|$|a$`$|a$p$|a~O}'tOY&xP~P9PO}ra!rra&|ra~PArOW$oO!P'{O~Os'|O~Ou!oO%{SOq&ga!P&ga!b&gaY&ga#o&ga~O}'}O~P9POq$}O!P&fa~Og]Oh]O%{0gO%}!hO&PVO~O&`(UO~P!.jOu!oO%{SOq&_X&[&_XY&_X&l&_X!P&_X~O}&_X!r&_X~P!/SOo(WOp(WOqnX&[nX~Oq(XO&[&^X~O&[(ZO~Ou!oOw(]O%{SO%}RO&P!bO~OYma&lma&tma~P!0bOW&OXY!aXq!aXu!aX%{!aX~OWUXY!aXq!aXu!aX%{!aX~OW(`O~Ou!oO%{SO%}!sO&P!sO&o(bO~Og]Oh]O%{SO%}!hO&PVO~P?wOq%cOY&na~Ou!oO%{SO%}!sO&P!sO&o%^O~O%{SO~P1sOY(eO~OY(hO&l%iO~Oq%lOY&ua~Og]Oh]OvzO|(pO!u|O%{SO%}!hO&PVO&rcO~P?wO!P(qO~OW^iZ#XXu^i!P^i!b^i#]^i#_^i#a^i#c^i#d^i#e^i#f^i#g^i#h^i#j^i#n^i#q^i&[^i&]^i&l^i&t^iY^i#o^is^iq^i|^i~OW)QO~Os)RO~P7uOz)SO%}RO&P!bO~O!P]iY]i#o]is]iq]i|]i~P7uOq)TOY&cX!P&cX~P7uOY)VO~O#q#tO!P#^i#_#^i#a#^i#c#^i#d#^i#e#^i#f#^i#j#^i#n#^i&[#^i&]#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#g#rO#h#rO~P!7qO#_#mO#f#qO#g#rO#h#rO#j#vO#q#tO&[#kO&]#kO!P#^i#a#^i#c#^i#d#^i#n#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#e#pO~P!9VO#_#mO#f#qO#g#rO#h#rO#j#vO#q#tO&[#kO&]#kO!P#^i#c#^i#d#^i#n#^iY#^i#o#^is#^iq#^i|#^i~O#a#nO#e#pO&l#lO~P!:kO#e#^i~P!9VO#q#tO!P#^i#a#^i#c#^i#d#^i#e#^i#f#^i#n#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#_#mO#g#rO#h#rO#j#vO&[#kO&]#kO~P!<WO#g#^i#h#^i~P!7qO#o)WO~P7uO#_&_X#a&_X#c&_X#d&_X#e&_X#f&_X#g&_X#h&_X#j&_X#n&_X#q&_X&]&_X#o&_Xs&_X|&_X~P!/SO!P#kiY#ki#o#kis#kiq#ki|#ki~P7uOg]Oh]OvzO}bO!P)fO!SxO!TxO!UxO!VxO!W)jO!XxO!YxO!ZyO!]xO!^xO!_xO!u|O!z{O%{SO%})^O&P)_O&]&bO&rcO~O|)iO~P!?hO}&cO~O}&cO!r&eO~Oo&dO}&cO!r&eO~O%{SO%}!sO&P!sO|&qP!P&qP~P?wO}&jO~Og]Oh]OvzO|)xO!P)vO!u|O!z{O%{SO%}!hO&PVO&]&bO&rcO~P?wO}&mO~Oo&nO}&mO~Os)zO~P9POu)|O%{SO~Ou&rO}'}O%{SOW#Zi!P#Zi#_#Zi#a#Zi#c#Zi#d#Zi#e#Zi#f#Zi#g#Zi#h#Zi#j#Zi#n#Zi#q#Zi&[#Zi&]#Zi&l#Zi&t#ZiY#Zi#o#Zis#Ziq#Zi|#Zi~O}&cOW&biu&bi!P&bi#_&bi#a&bi#c&bi#d&bi#e&bi#f&bi#g&bi#h&bi#j&bi#n&bi#q&bi&[&bi&]&bi&l&bi&t&biY&bi#o&bis&biq&bi|&bi~O#|*UO$O*VO$Q*VO$R*WO$S*XO~O|*TO~P!GPO$Y*YO%}RO&P!bO~OW*ZO!P*[O~O$`*]OZ$^i_$^i`$^ia$^ib$^ic$^ie$^ig$^ih$^ip$^iv$^iw$^iz$^i}$^i!P$^i!S$^i!T$^i!U$^i!V$^i!W$^i!X$^i!Y$^i!Z$^i![$^i!]$^i!^$^i!_$^i!u$^i!z$^i#e$^i#q$^i#s$^i#t$^i#x$^i#y$^i$V$^i$X$^i$_$^i$b$^i$d$^i$g$^i$k$^i$m$^i$r$^i$t$^i$v$^i$x$^i${$^i$}$^i%u$^i%{$^i%}$^i&P$^i&V$^i&r$^i|$^i$p$^i~Og]Oh]O$g#dO%}!hO&PVO~O!P*aO~P9PO!P*bO~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOvzOwjOz}O}bO!PuO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!Z*gO![!_O!]xO!^xO!_xO!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$p*hO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&rcO~O|*fO~P!LcOWiXW&OXY&OXZ&OXuiXu&OX!P&OX%{iX%}iX&PiX&]iX&tiX&t&OX~OWUXW&ZXYUXZUXuUXu&ZX!PUX%{&ZX%}&ZX&P&ZX&]&ZX&tUX&t&ZX~OW#eOu#fO&t#gO~OW&SXY%WXu&SX!P%WX&t&SX~OZ#XX~P#$YOY*nO!P*lO~O%P'mO%T'nOZ$|i_$|i`$|ia$|ib$|ic$|ie$|ig$|ih$|ip$|iv$|iw$|iz$|i}$|i!P$|i!S$|i!T$|i!U$|i!V$|i!W$|i!X$|i!Y$|i!Z$|i![$|i!]$|i!^$|i!_$|i!u$|i!z$|i#e$|i#q$|i#s$|i#t$|i#x$|i#y$|i$V$|i$X$|i$_$|i$b$|i$d$|i$g$|i$k$|i$m$|i$r$|i$t$|i$v$|i$x$|i${$|i$}$|i%u$|i%{$|i%}$|i&P$|i&V$|i&r$|i|$|i$`$|i$p$|i~OZ*qO~O%P'mO%T'nOZ%Ui_%Ui`%Uia%Uib%Uic%Uie%Uig%Uih%Uip%Uiv%Uiw%Uiz%Ui}%Ui!P%Ui!S%Ui!T%Ui!U%Ui!V%Ui!W%Ui!X%Ui!Y%Ui!Z%Ui![%Ui!]%Ui!^%Ui!_%Ui!u%Ui!z%Ui#e%Ui#q%Ui#s%Ui#t%Ui#x%Ui#y%Ui$V%Ui$X%Ui$_%Ui$b%Ui$d%Ui$g%Ui$k%Ui$m%Ui$r%Ui$t%Ui$v%Ui$x%Ui${%Ui$}%Ui%u%Ui%{%Ui%}%Ui&P%Ui&V%Ui&r%Ui|%Ui$`%Ui$p%Ui~OW&SXu&SX#_&SX#a&SX#c&SX#d&SX#e&SX#f&SX#g&SX#h&SX#j&SX#n&SX#q&SX&[&SX&]&SX&l&SX&t&SX~O!b*vO#]#hOY&SXZ#XX~P#,{OY&QXq&QX|&QX!P&QX~P7uO}'tO|&wP~P9POY&QXg%YXh%YX%{%YX%}%YX&P%YXq&QX|&QX!P&QX~Oq*yOY&xX~OY*{O~O}'}O|&iP~P9POq&hX!P&hX|&hXY&hX~P7uO&`Ta~P<oOo(WOp(WOqna&[na~Oq(XO&[&^a~OW+TO~Ow+UO~Ou!oO%{SO%}+YO&P+XO~Og]Oh]Ov#aO!u#cO%}!hO&PVO&r#`O~Og]Oh]OvzO|+_O!u|O%{SO%}!hO&PVO&rcO~P?wOw+jO%}RO&P!bO&]!yO~Oq)TOY&ca!P&ca~O#_ma#ama#cma#dma#ema#fma#gma#hma#jma#nma#qma&]ma#omasma|ma~P?ROo+oOq!fX&[!fX~Oq+qO&[&kX~O&[+sO~OW&ZXu&ZX%{&ZX%}&ZX&P&ZX&]&ZX~OZ!aX~P#4{OWiXuiX%{iX%}iX&PiX&]iX~OZ!aX~P#5hOg]Oh]Ov#aO!u#cO!z#bO&]&bO&r#`O~O%})^O&P)_O~P#6TOg]Oh]O%{SO%})^O&P)_O~O}bO!P+}O~OZ,OO~O},QO!m,TO~O|,VO~P!?hO}bOg&eXh&eXv&eX!S&eX!T&eX!U&eX!V&eX!W&eX!X&eX!Y&eX!Z&eX!]&eX!^&eX!_&eX!u&eX!z&eX%{&eX%}&eX&P&eX&]&eX&r&eX~Oq,XO}&pX!P&pX~OZ#iO}&cOq!|X|!|X!P!|X~Oq,^O|&qX!P&qX~O|,aO!P,`O~O&]&bO~P3cOg]Oh]OvzO|,eO!P)vO!u|O!z{O%{SO%}!hO&PVO&]&bO&rcO~P?wOs,fO~P7uOs,fO~P9PO}&cOW&bqu&bq!P&bq#_&bq#a&bq#c&bq#d&bq#e&bq#f&bq#g&bq#h&bq#j&bq#n&bq#q&bq&[&bq&]&bq&l&bq&t&bqY&bq#o&bqs&bqq&bq|&bq~O|,jO~P!GPO!W,nO#},nO%}RO&P!bO~O!P,qO~O$Y,rO%}RO&P!bO~O!b$|O#o,tOq!`X!P!`X~O!P,vO~P7uO!P,vO~P9PO!P,yO~P7uO|,{O~P!LcO![#}O#o,|O~O!P-OO~O!b-PO~OY-SOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wOY-SO!P-TO~O%P'mO%T'nOZ%Uq_%Uq`%Uqa%Uqb%Uqc%Uqe%Uqg%Uqh%Uqp%Uqv%Uqw%Uqz%Uq}%Uq!P%Uq!S%Uq!T%Uq!U%Uq!V%Uq!W%Uq!X%Uq!Y%Uq!Z%Uq![%Uq!]%Uq!^%Uq!_%Uq!u%Uq!z%Uq#e%Uq#q%Uq#s%Uq#t%Uq#x%Uq#y%Uq$V%Uq$X%Uq$_%Uq$b%Uq$d%Uq$g%Uq$k%Uq$m%Uq$r%Uq$t%Uq$v%Uq$x%Uq${%Uq$}%Uq%u%Uq%{%Uq%}%Uq&P%Uq&V%Uq&r%Uq|%Uq$`%Uq$p%Uq~O}'tO~P9POq-`O|&wX~O|-bO~Oq*yOY&xa~Oq-fO|&iX~O|-hO~Ow-iO~Oq!aXu!aX!P!aX!b!aX%{!aX~OZ&OX~P#EoOZUX~P#EoO!P-jO~OZ-kO~OW^yZ#XXu^y!P^y!b^y#]^y#_^y#a^y#c^y#d^y#e^y#f^y#g^y#h^y#j^y#n^y#q^y&[^y&]^y&l^y&t^yY^y#o^ys^yq^y|^y~OY%^aq%^a!P%^a~P7uO!P#myY#my#o#mys#myq#my|#my~P7uOo+oOq!fa&[!fa~Oq+qO&[&ka~OZ,OO~PCpO!P-xO~O!m,TO}&ja!P&ja~O}bO!P-{O~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op.ZOvzOw.YOz}O|.UO}bO!PuO![!_O!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&]!yO&rcO~P?wO},QO~Oq,XO}&pa!P&pa~O}&cOq!|a|!|a!P!|a~OZ#iO}&cOq!|a|!|a!P!|a~O%{SO%}!sO&P!sOq%hX|%hX!P%hX~P?wOq,^O|&qa!P&qa~O|!}X~P!?hO|.eO~Os.fO~P7uOW$oO!P.gO~OW$oO$P.lO%}RO&P!bO!P&zP~OW$oO$T.mO~O!P.nO~O!b$|O#o.pOq!`X!P!`X~OY.rO~O!P.sO~P7uO#o.tO~P7uO!b.vO~OY.wOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wOW!{Ou&YX%{&YX%}&YX&P&YX&|&YX~O&]!yO~P$$WOu!oO%{SO&|.yO%}%RX&P%RX~OY&QXq&QX~P7uO}'tOq%lX|%lX~P9POq-`O|&wa~O!b/PO~O}'}Oq%aX|%aX~P9POq-fO|&ia~OY/SO~O!P/TO~OZ/UO~O&l%iOq!ga&[!ga~Ou!oO%{SO}&ma!P&ma!m&ma~O!P/ZO~O!m,TO}&ji!P&ji~O|/`O~P]OW/bO~P4UOZ#iO!P&SX~P#,{OW$TOZ#iO&t#gO~Op/dOw/dO~O}&cOq!|i|!|i!P!|i~O|!}a~P!?hOW$oO!P/fO~OW$oOq/gO!P&zX~OY/kO~P7uOY/mO~OY%Wq!P%Wq~P7uO&|.yO%}%Ra&P%Ra~OY/rO~Ou!oO!P/uO!Z/vO%{SO~OY/wO~O&l%iOq!gi&[!gi~Ou!oO%{SO}&mi!P&mi!m&mi~O!m,TO}&jq!P&jq~O|/yO~P]Op/{Ow%}Oz%{O%}RO&P!bO&]!yO~O!P/|O~Oq/gO!P&za~O!P0QO~OW$oOq/gO!P&{X~OY0SO~P7uOY0TO~OY%Wy!P%Wy~P7uOu!oO%{SO%}%sa&P%sa&|%sa~OY0UO~Ou!oO!P0VO!Z0WO%{SO~Op0ZO%}RO&P!bO~OW)QOZ#iO~O!P0]O~OW$oOq%pa!P%pa~Oq/gO!P&{a~O!P0_O~Ou!oO!P0_O!Z0`O%{SO~O!P0bO~O!P0cO~O!P0eO~O!P0fO~O#o&OXY&OXs&OXq&OX|&OX~P$wO#oUXYUXsUXqUX|UX~P&{O`Q_P#f&Vc~",
  goto: "#(V&|PPPP&}'b*q-tP'bPP.Y.^/rPPPPP1^P2vPP4`7P9j<T<m>bPPP>hP@|PPPAv2vPCoPPDjPEaEgPPPPPPPPPPPPFpGXPJ_JgJqKZKaKgMVMZMZMcPMrNx! k! uP!![NxP!!b!!l!!{!#TP!#r!#|!$SNx!$V!$]EaEa!$a!$k!$n2v!&Y2v2v!(RP.^P!(VP!(vPPPPPP.^P.^!)d.^PP.^P.^PP.^!*x!+SPP!+Y!+cPPPPPPPP&}P&}PP!+g!+g!+z!+gPP!+gP!+gP!,e!,hP!+g!-O!+gP!+gP!-R!-UP!+gP!+gP!+gP!+gP!+g!+gP!+gP!-YP!-`!-c!-iP!+g!-u!-x!.Q!.d!2a!2g!2m!3s!3y!4T!5X!5_!5e!5o!5u!5{!6R!6X!6_!6e!6k!6q!6w!6}!7T!7Z!7e!7k!7u!7{PPP!8R!+g!8vP!<XP!=]P!?n!@U!CQ2vPPP!Dn!HY!JwPP!Mb!MeP# n# t##b##q##w#$w#%a#&[#&e#&h#&tP#&w#'TP#'[#'cP#'fP#'oP#'r#'u#'x#'|#(SssObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/a'kqOWX_`bnow!X!Z!^!`!i!p!t!y!{#O#P#U#Y#]#_#f#h#i#m#n#o#p#q#r#s#v#w#x#y#{$R$Y$Z$[$]$^$_$l$p${$|%R%S%X%Y%b%c%f%g%i%k%p&]&b&c&d&e&j&m&n&r&s&u'Q'R'T'Y'Z'e't'}(W(X(h(l(o)T)W)X)Z)`)b)h)s)t)w)|*]*_*a*b*e*h*k*l*q*v+]+o+q+t+w+z+{,O,Q,T,X,^,`,c,t,v-P-T-X-`-f-w.Q.S.T.V.W.d.p.s.v.x/P/S/Y/_/a/p/t/v/w0W0Y0`0j#rgO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`t!dS!P!R!S!l!n$X$v*U*V*W*X,m,o.l.m/g0gQ#^cS%`#P.SQ%s#`U%x#e$T/bQ&P#gW'g$l*l-T.xU'q$o&{*ZQ'r$pS(^%Y/_U(}%z+i/zQ)S&QQ+[(lQ+g)QQ-c*yR-m+]u!dS!P!R!S!l!n$X$v*U*V*W*X,m,o.l.m/g0gT$q!c(T#upO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`#tkO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`X'h$l*l-T.x#}UO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`#}jO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`%tZOW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jQ%W!{Q([%XV-V*q-Z.y%tZOW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jV-V*q-Z.y%t[OW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jV-W*q-Z.yS!zZ-VS$S}%{S%z#e$TQ&Q#gQ+i)QQ.[,QR/z/b$eYO_bnow!X!Z!^!`!y#]#f#h#i#m#n#o#p#q#r#s#v#w#{$Y$Z$[$]$^$_$l$p$|%i%k&d&e&n&r'T'Y'Z't'}(W(X(h)T)W)|*]*a*b*e*h*l*v+o,Q,T,X,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q%U!yR+R(X%u^OW_bdnow!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0j!o!qX!i!r!t#P#_#y$t${%S%Y%b%f&]'R'e(l)X)`)s*_*k+]+t+w+z,c-X-w.Q.S/S/Y/_/p/t/w0Y#|jO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q$Z!TQ$[!UQ$a!YQ$j!_R*i']Q#jhS&v$R)PQ(|%yQ*Q&wQ+f)OQ,[)oQ-q+hQ.a,]Q/W-rS/c.Y.ZQ/}/dQ0[/{R0a0ZQ&f$OW(s%t&g&h&iQ*P&vU+`(t(u(vQ,Z)oQ,h*QS-n+a+bS.`,[,]Q/V-oR/e.aX)f&c)h,`.drdObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW#R_#U%c,OQ'S$]W'i$l*l-T.xS(m%p(oW)a&c)h,`.dS)p&j,^S)u&m)wR-Z*qh!vX!V#_#d'R(l)`)s*_+]+w,cQ(R$}Q(_%^R+V(b#rmObnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`v!tX!V#P#_#d$}%^%b%f'R'e(b(l*_*k+]-Y.S.|Q#W_Q$OzQ$P{Q$Q|Q%t#aQ%u#bQ%v#cQ(j%lS)Y&b+qY)d&c)a)h,`.dS)o&j,^Q+p)ZW+t)`)s+w,cQ+|)bQ,])pT.O+z.QU(P$|'}-fR*O&uW)f&c)h,`.dT)v&m)wQ&i$OQ&q$QQ(v%tQ({%vY)b&c)a)h,`.dV)t&m)u)wQ)[&bR-u+qQ+n)YR-t+p#tmO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`Q,P)dS-w+t.OR.R+|T#U_,OU#S_#U,OR(c%cQ,S)eQ-y+vQ-}+yQ/].PR/x/^ruObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aQ$m!aQ&`#wQ'a$jQ'p$nW)f&c)h,`.dQ*s'nQ+})cQ,W)jQ-[*rR-{+xrsObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aS(n%p(oW)f&c)h,`.dT)v&m)wQ&h$OS(u%t&iR+b(vQ&g$OQ&l$PU(t%t&h&iQ(x%uS+a(u(vR-o+bQ)n&eR)y&nQ&p$QS(z%v&qR+e({Q&o$QU(y%v&p&qS+d(z({R-p+eS(n%p(oT)v&m)wrsObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW)f&c)h,`.dT)v&m)wQ&k$PS(w%u&lR+c(xQ)q&jR.b,^R,b)rQ%q#^R(r%sT(n%p(oQ,R)eS-|+y,SR/[-}R.W,QWj$l*l-T.x#ukO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`#|hO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`U%y#e$T/bS)O%z/zQ+h)QR-r+iT&t$R&u!]#ml#Q$`$h$k&O&R&S&V&W&X&Y&[&_'s(O){*`*c+k+m,g,x,}-^.o.u/l/o!V#nl#Q$`$h$k&O&R&S&W&[&_'s(O){*`*c+k+m,g,x,}-^.o.u/l/o#umO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`a'u$p't*v-`/P/v0W0`Q'w$pR-d*yQ&y$UQ'y$uR*|'zT*R&x*SsuObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/artObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aQ$e![R$g!]R$^!WruObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aR'T$]R$_!WR'[$aT*d'Z*eX'k$m'l'p*tR*r'mQ-Y*qR.|-ZQ'o$mQ*p'lQ*u'pR-]*tR$n!aQ'j$lV-R*l-T.xQwOQ#]bW#|w#].V/aQ.V,QR/a.WrWObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/al!kW!p#O#Y#x%R%X%g&s'Q)Z+{.T0j!j!pX!i!t#P#_#y${%S%Y%b%f&]'R'e(l)X)`)s*_*k+]+t+w+z,c-X-w.Q.S/S/Y/_/p/t/w0YQ#O_Q#Y`#^#xno!X!^!`#f#h#i#m#n#o#p#q#r#s#w$Y$p$|%i%k&d&e&n&r'T'Y't'}(W(h)T)W)|*a*b*h*v+o,T,X,t,v-P-`-f.p.s.v/P/v0W0`S%R!y(XQ%X!{j%g#U%c%p&c&j&m(o)h)w*q,^,`.dS&s$R&uY'Q$]$l*l-T.xS)Z&b+qS+{)b)tQ.T,OR0j#vQ!fTR$r!fQ(Y%UR+S(Y^!rX#P#y&]'R'e)Xx$t!i#_%S%Y%b%f(l)`)s*_*k+]+w+z,c-X.Q.S/_/p[$z!r$t${/Y/t0YS${!t+tQ/Y-wQ/t/SR0Y/wQ)U&SR+l)UQ)h&cS,U)h.dR.d,`!laO_bw!Z#U#]#{$Z$[$]$^$_$l%c%p&c&j&m'Z(o)h)w*]*e*l*q,O,Q,^,`-T.V.W.d.x/aY!jW#O%g'Q.TT#Za!jQ-g*}R/R-gQ%O!vR(S%OQ%j#VS(g%j/XR/X-sQ+r)[R-v+rQ%d#SR(d%dQ,Y)lR._,YQ)w&mR,d)wQ,_)qR.c,_Q(o%pR+^(oQ&u$RR)}&uQ%m#WR(k%mQ-a*wR/O-aQ*z'wR-e*zQ*S&xR,i*SQ,m*UR.i,mQ/h.jS0P/h0RR0R/jQ*e'ZR,z*eQ'l$mS*o'l*tR*t'pQ.z-XR/q.zQ*m'jR-U*m`vObw#],Q.V.W/aQ$b!ZQ&a#{Q'O$ZQ'P$[Q'V$^Q'W$_S*d'Z*eR,s*]'YrOWX_`bnow!X!Z!^!`!i!p!t!y!{#O#P#U#Y#]#_#f#h#i#m#n#o#p#q#r#s#v#w#x#y#{$R$Y$Z$[$]$^$_$l${$|%R%S%X%Y%b%c%f%g%i%k%p&]&b&c&d&e&j&m&n&r&s&u'Q'R'T'Y'Z'e'}(W(X(h(l(o)T)W)X)Z)`)b)h)s)t)w)|*]*_*a*b*e*h*k*l*q+]+o+q+t+w+z+{,O,Q,T,X,^,`,c,t,v-P-T-X-f-w.Q.S.T.V.W.d.p.s.v.x/S/Y/_/a/p/t/w0Y0ja'v$p't*v-`/P/v0W0`Q!cSQ$U!PQ$V!RQ$W!SQ$u!lQ$w!nQ&}$XQ'z$vQ(T0gS,k*U*WQ,o*VQ,p*XQ.h,mS.j,o.lQ/j.mR0O/g%oROS_bcnow!P!R!S!X!Z!^!`!l!n#P#]#`#e#f#g#h#i#m#n#o#p#q#r#s#w#{$T$X$Y$Z$[$]$^$_$l$o$p$v$|%Y%k%z&Q&r&{'T'Y'Z't'}(h(l)Q)T)W)|*U*V*W*X*Z*]*a*b*e*h*l*v*y+]+i,Q,m,o,t,v-P-T-`-f.S.V.W.l.m.p.s.v.x/P/_/a/b/g/v/z0W0`0gQ'x$pQ*w'tS-_*v/PQ.}-`Q0X/vQ0^0WR0d0`rlObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aS#Q_$YQ#tnQ#zoQ$`!XQ$h!^Q$k!`Q&O#fQ&R#hY&S#i$]*a,v.sQ&U#mQ&V#nQ&W#oQ&X#pQ&Y#qQ&Z#rQ&[#sQ&_#w^'s$p't-`/P/v0W0`U(O$|'}-fQ(i%kQ){&rQ*`'TQ*c'YQ+W(hQ+k)TQ+m)WQ,g)|Q,x*bQ,}*hQ-^*vQ.o,tQ.u-PQ/l.pR/o.v#rfO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`W'f$l*l-T.xR.X,QrXObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW!iW#x%R'QQ#P_Q#_d!|#yno!X!^!`#f#h#i#m#n#o#p#q#r#s#w$Y$p$|%k&r'T'Y't'}(h)T)W)|*a*b*h*v,t,v-P-`-f.p.s.v/P/v0W0`d%S!y%i&d&e&n(W(X+o,T,XQ%Y#OQ%b#RS%f#U%cQ&]#vQ'R$]W'e$l*l-T.xS(l%p(oQ)X0jW)`&c)h,`.dS)s&m)wQ*_'SQ*k'iQ+](mQ+w)aS+z)b)tQ,c)uS-X*q-ZQ.Q+{Q.S,OQ/_.TR/p.y%t^OW_bdnow!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0jQ$R}Q&w$SR)P%{&PVOW_bdnow}!X!Z!^!`!y!{#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%X%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0jR%V!y#ziObnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q#V_Q%U!yQ&^#vQ(f%iQ)k&dU)l&e&n,TQ+Q(WQ+R(XQ-s+oR.^,XQ(V%TR+P(U#|eO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`T%w#e/bQ&T#iQ'U$]Q,w*aQ.q,vR/n.sX)g&c)h,`.d!{`OW_abw!Z!j#O#U#]#{$Z$[$]$^$_$l%c%g%p&c&j&m'Q'Z(o)h)w*]*e*l*q,O,Q,^,`-T.T.V.W.d.x/aU!wX!V'RU%r#_#d*_S+Z(l)sQ+u)`S-l+],cR-z+wj!uX!V#_#d$}%^(b(l)`)s+]+w,cU%]#P%f.SQ(a%bQ*^'RQ*j'eQ,u*_Q-Q*kQ.{-YR/s.|Q(Q$|Q*}'}R/Q-fR+O'}[)c&c&m)h)w,`.dT+x)a)uR)]&bW+v)`)s+w,cQ.P+zR/^.QS#T_,OR%h#US)m&e&nR.],TR)r&jW)e&c)h,`.dR+y)aR#X_R*x'tR'x$pT,l*U,mQ.k,oR/i.lR/i.m",
  nodeNames: "⚠ LineComment BlockComment Program ModuleDeclaration MarkerAnnotation Identifier ScopedIdentifier . Annotation ) ( AnnotationArgumentList AssignmentExpression FieldAccess IntegerLiteral FloatingPointLiteral BooleanLiteral CharacterLiteral StringLiteral TextBlock null ClassLiteral void PrimitiveType TypeName ScopedTypeName GenericType TypeArguments AnnotatedType Wildcard extends super , ArrayType ] Dimension [ class this ParenthesizedExpression ObjectCreationExpression new ArgumentList } { ClassBody ; FieldDeclaration Modifiers public protected private abstract static final strictfp default synchronized native transient volatile VariableDeclarator Definition AssignOp ArrayInitializer MethodDeclaration TypeParameters TypeParameter TypeBound FormalParameters ReceiverParameter FormalParameter SpreadParameter Throws throws Block ClassDeclaration Superclass SuperInterfaces implements InterfaceTypeList InterfaceDeclaration interface ExtendsInterfaces InterfaceBody ConstantDeclaration EnumDeclaration enum EnumBody EnumConstant EnumBodyDeclarations AnnotationTypeDeclaration AnnotationTypeBody AnnotationTypeElementDeclaration StaticInitializer ConstructorDeclaration ConstructorBody ExplicitConstructorInvocation ArrayAccess MethodInvocation MethodName MethodReference ArrayCreationExpression Dimension AssignOp BinaryExpression CompareOp CompareOp LogicOp BitOp BitOp LogicOp ArithOp ArithOp ArithOp BitOp InstanceofExpression instanceof LambdaExpression InferredParameters TernaryExpression LogicOp : UpdateExpression UpdateOp UnaryExpression LogicOp BitOp CastExpression ElementValueArrayInitializer ElementValuePair open module ModuleBody ModuleDirective requires transitive exports to opens uses provides with PackageDeclaration package ImportDeclaration import Asterisk ExpressionStatement LabeledStatement Label IfStatement if else WhileStatement while ForStatement for ForSpec LocalVariableDeclaration var EnhancedForStatement ForSpec AssertStatement assert SwitchStatement switch SwitchBlock SwitchLabel case DoStatement do BreakStatement break ContinueStatement continue ReturnStatement return SynchronizedStatement ThrowStatement throw TryStatement try CatchClause catch CatchFormalParameter CatchType FinallyClause finally TryWithResourcesStatement ResourceSpecification Resource",
  maxTerm: 274,
  nodeProps: [
    ["group", -26, 4, 47, 76, 77, 82, 87, 92, 144, 146, 149, 150, 152, 155, 157, 160, 162, 164, 166, 171, 173, 175, 177, 179, 180, 182, 190, "Statement", -25, 6, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 39, 40, 41, 99, 100, 102, 103, 106, 117, 119, 121, 124, 126, 129, "Expression", -7, 23, 24, 25, 26, 27, 29, 34, "Type"],
    ["openedBy", 10, "(", 44, "{"],
    ["closedBy", 11, ")", 45, "}"]
  ],
  propSources: [SE],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 28,
  tokenData: "#$`_R!_OX%QXY'fYZ)bZ^'f^p%Qpq'fqr*|rs,^st%Qtu4euv5qvw7Rwx8ixy@zyzAhz{BU{|Bz|}Db}!OEO!O!PFi!P!Q! c!Q!R!,X!R![!0P![!]!>a!]!^!?q!^!_!@_!_!`!Ax!`!a!Bl!a!b!DY!b!c!Dx!c!}!Kt!}#O!MQ#O#P%Q#P#Q!Mn#Q#R!N[#R#S4e#S#T%Q#T#o4e#o#p# O#p#q# l#q#r##U#r#s##r#s#y%Q#y#z'f#z$f%Q$f$g'f$g#BY%Q#BY#BZ'f#BZ$IS%Q$IS$I_'f$I_$I|%Q$I|$JO'f$JO$JT%Q$JT$JU'f$JU$KV%Q$KV$KW'f$KW&FU%Q&FU&FV'f&FV;'S%Q;'S;=`&s<%lO%QS%VV&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QS%qO&WSS%tVOY&ZYZ%lZr&Zrs&ys;'S&Z;'S;=`'`<%lO&ZS&^VOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QS&vP;=`<%l%QS&|UOY&ZYZ%lZr&Zs;'S&Z;'S;=`'`<%lO&ZS'cP;=`<%l&Z_'mk&WS%wZOX%QXY'fYZ)bZ^'f^p%Qpq'fqr%Qrs%qs#y%Q#y#z'f#z$f%Q$f$g'f$g#BY%Q#BY#BZ'f#BZ$IS%Q$IS$I_'f$I_$I|%Q$I|$JO'f$JO$JT%Q$JT$JU'f$JU$KV%Q$KV$KW'f$KW&FU%Q&FU&FV'f&FV;'S%Q;'S;=`&s<%lO%Q_)iY&WS%wZX^*Xpq*X#y#z*X$f$g*X#BY#BZ*X$IS$I_*X$I|$JO*X$JT$JU*X$KV$KW*X&FU&FV*XZ*^Y%wZX^*Xpq*X#y#z*X$f$g*X#BY#BZ*X$IS$I_*X$I|$JO*X$JT$JU*X$KV$KW*X&FU&FV*XV+TX#sP&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`;'S%Q;'S;=`&s<%lO%QU+wV#_Q&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT,aXOY,|YZ%lZr,|rs3Ys#O,|#O#P2d#P;'S,|;'S;=`3S<%lO,|T-PXOY-lYZ%lZr-lrs.^s#O-l#O#P.x#P;'S-l;'S;=`2|<%lO-lT-qX&WSOY-lYZ%lZr-lrs.^s#O-l#O#P.x#P;'S-l;'S;=`2|<%lO-lT.cVcPOY&ZYZ%lZr&Zrs&ys;'S&Z;'S;=`'`<%lO&ZT.}V&WSOY-lYZ/dZr-lrs1]s;'S-l;'S;=`2|<%lO-lT/iW&WSOY0RZr0Rrs0ns#O0R#O#P0s#P;'S0R;'S;=`1V<%lO0RP0UWOY0RZr0Rrs0ns#O0R#O#P0s#P;'S0R;'S;=`1V<%lO0RP0sOcPP0vTOY0RYZ0RZ;'S0R;'S;=`1V<%lO0RP1YP;=`<%l0RT1`XOY,|YZ%lZr,|rs1{s#O,|#O#P2d#P;'S,|;'S;=`3S<%lO,|T2QUcPOY&ZYZ%lZr&Zs;'S&Z;'S;=`'`<%lO&ZT2gVOY-lYZ/dZr-lrs1]s;'S-l;'S;=`2|<%lO-lT3PP;=`<%l-lT3VP;=`<%l,|T3_VcPOY&ZYZ%lZr&Zrs3ts;'S&Z;'S;=`'`<%lO&ZT3yR&USXY4SYZ4`pq4SP4VRXY4SYZ4`pq4SP4eO&VP_4la%}Z&WSOY%QYZ%lZr%Qrs%qst%Qtu4eu!Q%Q!Q![4e![!c%Q!c!}4e!}#R%Q#R#S4e#S#T%Q#T#o4e#o;'S%Q;'S;=`&s<%lO%QU5xX#gQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QU6lV#]Q&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV7YZ&lR&WSOY%QYZ%lZr%Qrs%qsv%Qvw7{w!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QU8SV#aQ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT8nZ&WSOY9aYZ%lZr9ars:Xsw9awx%Qx#O9a#O#P<a#P;'S9a;'S;=`>t<%lO9aT9fZ&WSOY9aYZ%lZr9ars:Xsw9awx;sx#O9a#O#P<a#P;'S9a;'S;=`>t<%lO9aT:[ZOY:}YZ%lZr:}rs>zsw:}wx?px#O:}#O#P@[#P;'S:};'S;=`@t<%lO:}T;QZOY9aYZ%lZr9ars:Xsw9awx;sx#O9a#O#P<a#P;'S9a;'S;=`>t<%lO9aT;zVbP&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT<fV&WSOY9aYZ<{Zr9ars:Xs;'S9a;'S;=`>t<%lO9aT=QW&WSOY=jZw=jwx>Vx#O=j#O#P>[#P;'S=j;'S;=`>n<%lO=jP=mWOY=jZw=jwx>Vx#O=j#O#P>[#P;'S=j;'S;=`>n<%lO=jP>[ObPP>_TOY=jYZ=jZ;'S=j;'S;=`>n<%lO=jP>qP;=`<%l=jT>wP;=`<%l9aT>}ZOY:}YZ%lZr:}rs=jsw:}wx?px#O:}#O#P@[#P;'S:};'S;=`@t<%lO:}T?uVbPOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT@_VOY9aYZ<{Zr9ars:Xs;'S9a;'S;=`>t<%lO9aT@wP;=`<%l:}_ARVZZ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVAoVYR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVB_X$YP&WS#fQOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QVCRZ#eR&WSOY%QYZ%lZr%Qrs%qs{%Q{|Ct|!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QVC{V#qR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVDiVqR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVEV[#eR&WSOY%QYZ%lZr%Qrs%qs}%Q}!OCt!O!_%Q!_!`6e!`!aE{!a;'S%Q;'S;=`&s<%lO%QVFSV&vR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_FpZWY&WSOY%QYZ%lZr%Qrs%qs!O%Q!O!PGc!P!Q%Q!Q![Hq![;'S%Q;'S;=`&s<%lO%QVGhX&WSOY%QYZ%lZr%Qrs%qs!O%Q!O!PHT!P;'S%Q;'S;=`&s<%lO%QVH[V&oR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QTHxc&WS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hq![!f%Q!f!gJT!g!hJq!h!iJT!i#R%Q#R#SNk#S#W%Q#W#XJT#X#YJq#Y#ZJT#Z;'S%Q;'S;=`&s<%lO%QTJ[V&WS`POY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QTJv]&WSOY%QYZ%lZr%Qrs%qs{%Q{|Ko|}%Q}!OKo!O!Q%Q!Q![La![;'S%Q;'S;=`&s<%lO%QTKtX&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![La![;'S%Q;'S;=`&s<%lO%QTLhc&WS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![La![!f%Q!f!gJT!g!h%Q!h!iJT!i#R%Q#R#SMs#S#W%Q#W#XJT#X#Y%Q#Y#ZJT#Z;'S%Q;'S;=`&s<%lO%QTMxZ&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![La![#R%Q#R#SMs#S;'S%Q;'S;=`&s<%lO%QTNpZ&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hq![#R%Q#R#SNk#S;'S%Q;'S;=`&s<%lO%Q_! j]&WS#fQOY%QYZ%lZr%Qrs%qsz%Qz{!!c{!P%Q!P!Q!)U!Q!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%Q_!!hX&WSOY!!cYZ!#TZr!!crs!$psz!!cz{!&O{;'S!!c;'S;=`!'d<%lO!!c_!#YT&WSOz!#iz{!#{{;'S!#i;'S;=`!$j<%lO!#iZ!#lTOz!#iz{!#{{;'S!#i;'S;=`!$j<%lO!#iZ!$OVOz!#iz{!#{{!P!#i!P!Q!$e!Q;'S!#i;'S;=`!$j<%lO!#iZ!$jOQZZ!$mP;=`<%l!#i_!$sXOY!%`YZ!#TZr!%`rs!'jsz!%`z{!(Y{;'S!%`;'S;=`!)O<%lO!%`_!%cXOY!!cYZ!#TZr!!crs!$psz!!cz{!&O{;'S!!c;'S;=`!'d<%lO!!c_!&TZ&WSOY!!cYZ!#TZr!!crs!$psz!!cz{!&O{!P!!c!P!Q!&v!Q;'S!!c;'S;=`!'d<%lO!!c_!&}V&WSQZOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!'gP;=`<%l!!c_!'mXOY!%`YZ!#TZr!%`rs!#isz!%`z{!(Y{;'S!%`;'S;=`!)O<%lO!%`_!(]ZOY!!cYZ!#TZr!!crs!$psz!!cz{!&O{!P!!c!P!Q!&v!Q;'S!!c;'S;=`!'d<%lO!!c_!)RP;=`<%l!%`_!)]V&WSPZOY!)UYZ%lZr!)Urs!)rs;'S!)U;'S;=`!*x<%lO!)U_!)wVPZOY!*^YZ%lZr!*^rs!+Os;'S!*^;'S;=`!,R<%lO!*^_!*cVPZOY!)UYZ%lZr!)Urs!)rs;'S!)U;'S;=`!*x<%lO!)U_!*{P;=`<%l!)U_!+TVPZOY!*^YZ%lZr!*^rs!+js;'S!*^;'S;=`!,R<%lO!*^Z!+oSPZOY!+jZ;'S!+j;'S;=`!+{<%lO!+jZ!,OP;=`<%l!+j_!,UP;=`<%l!*^T!,`u&WS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!.s!P!Q%Q!Q![!0P![!d%Q!d!e!3Z!e!f%Q!f!gJT!g!hJq!h!iJT!i!n%Q!n!o!1u!o!q%Q!q!r!5X!r!z%Q!z!{!7P!{#R%Q#R#S!2c#S#U%Q#U#V!3Z#V#W%Q#W#XJT#X#YJq#Y#ZJT#Z#`%Q#`#a!1u#a#c%Q#c#d!5X#d#l%Q#l#m!7P#m;'S%Q;'S;=`&s<%lO%QT!.za&WS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hq![!f%Q!f!gJT!g!hJq!h!iJT!i#W%Q#W#XJT#X#YJq#Y#ZJT#Z;'S%Q;'S;=`&s<%lO%QT!0Wi&WS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!.s!P!Q%Q!Q![!0P![!f%Q!f!gJT!g!hJq!h!iJT!i!n%Q!n!o!1u!o#R%Q#R#S!2c#S#W%Q#W#XJT#X#YJq#Y#ZJT#Z#`%Q#`#a!1u#a;'S%Q;'S;=`&s<%lO%QT!1|V&WS_POY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT!2hZ&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!0P![#R%Q#R#S!2c#S;'S%Q;'S;=`&s<%lO%QT!3`Y&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q!R!4O!R!S!4O!S;'S%Q;'S;=`&s<%lO%QT!4V`&WS_POY%QYZ%lZr%Qrs%qs!Q%Q!Q!R!4O!R!S!4O!S!n%Q!n!o!1u!o#R%Q#R#S!3Z#S#`%Q#`#a!1u#a;'S%Q;'S;=`&s<%lO%QT!5^X&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q!Y!5y!Y;'S%Q;'S;=`&s<%lO%QT!6Q_&WS_POY%QYZ%lZr%Qrs%qs!Q%Q!Q!Y!5y!Y!n%Q!n!o!1u!o#R%Q#R#S!5X#S#`%Q#`#a!1u#a;'S%Q;'S;=`&s<%lO%QT!7U_&WSOY%QYZ%lZr%Qrs%qs!O%Q!O!P!8T!P!Q%Q!Q![!:c![!c%Q!c!i!:c!i#T%Q#T#Z!:c#Z;'S%Q;'S;=`&s<%lO%QT!8Y]&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!9R![!c%Q!c!i!9R!i#T%Q#T#Z!9R#Z;'S%Q;'S;=`&s<%lO%QT!9Wc&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!9R![!c%Q!c!i!9R!i!r%Q!r!sJq!s#R%Q#R#S!8T#S#T%Q#T#Z!9R#Z#d%Q#d#eJq#e;'S%Q;'S;=`&s<%lO%QT!:ji&WS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!<X!P!Q%Q!Q![!:c![!c%Q!c!i!:c!i!n%Q!n!o!1u!o!r%Q!r!sJq!s#R%Q#R#S!=c#S#T%Q#T#Z!:c#Z#`%Q#`#a!1u#a#d%Q#d#eJq#e;'S%Q;'S;=`&s<%lO%QT!<^a&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!9R![!c%Q!c!i!9R!i!r%Q!r!sJq!s#T%Q#T#Z!9R#Z#d%Q#d#eJq#e;'S%Q;'S;=`&s<%lO%QT!=h]&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!:c![!c%Q!c!i!:c!i#T%Q#T#Z!:c#Z;'S%Q;'S;=`&s<%lO%QV!>hX#oR&WSOY%QYZ%lZr%Qrs%qs![%Q![!]!?T!];'S%Q;'S;=`&s<%lO%QV!?[V&tR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV!?xV!PR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!@fY&]Z&WSOY%QYZ%lZr%Qrs%qs!^%Q!^!_!AU!_!`+p!`;'S%Q;'S;=`&s<%lO%QU!A]X#hQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QV!BPX!bR&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`;'S%Q;'S;=`&s<%lO%QV!BsY&[R&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`!a!Cc!a;'S%Q;'S;=`&s<%lO%QU!CjY#hQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`!a!AU!a;'S%Q;'S;=`&s<%lO%Q_!DcV&`X#nQ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!EPX%{Z&WSOY%QYZ%lZr%Qrs%qs#]%Q#]#^!El#^;'S%Q;'S;=`&s<%lO%QV!EqX&WSOY%QYZ%lZr%Qrs%qs#b%Q#b#c!F^#c;'S%Q;'S;=`&s<%lO%QV!FcX&WSOY%QYZ%lZr%Qrs%qs#h%Q#h#i!GO#i;'S%Q;'S;=`&s<%lO%QV!GTX&WSOY%QYZ%lZr%Qrs%qs#X%Q#X#Y!Gp#Y;'S%Q;'S;=`&s<%lO%QV!GuX&WSOY%QYZ%lZr%Qrs%qs#f%Q#f#g!Hb#g;'S%Q;'S;=`&s<%lO%QV!HgX&WSOY%QYZ%lZr%Qrs%qs#Y%Q#Y#Z!IS#Z;'S%Q;'S;=`&s<%lO%QV!IXX&WSOY%QYZ%lZr%Qrs%qs#T%Q#T#U!It#U;'S%Q;'S;=`&s<%lO%QV!IyX&WSOY%QYZ%lZr%Qrs%qs#V%Q#V#W!Jf#W;'S%Q;'S;=`&s<%lO%QV!JkX&WSOY%QYZ%lZr%Qrs%qs#X%Q#X#Y!KW#Y;'S%Q;'S;=`&s<%lO%QV!K_V&rR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!K{a&PZ&WSOY%QYZ%lZr%Qrs%qst%Qtu!Ktu!Q%Q!Q![!Kt![!c%Q!c!}!Kt!}#R%Q#R#S!Kt#S#T%Q#T#o!Kt#o;'S%Q;'S;=`&s<%lO%Q_!MXVuZ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV!MuVsR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QU!NcX#cQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QV# VV}R&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_# uZ&|X#cQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`#p%Q#p#q#!h#q;'S%Q;'S;=`&s<%lO%QU#!oV#dQ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV##]V|R&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT##yV#tP&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q",
  tokenizers: [0, 1, 2, 3],
  topRules: { Program: [0, 3] },
  dynamicPrecedences: { 27: 1, 230: -1, 241: -1 },
  specialized: [{ term: 229, get: (t) => PE[t] || -1 }],
  tokenPrec: 7067
});
var bE = Kt.define({
  name: "java",
  parser: yE.configure({
    props: [
      ci.add({
        IfStatement: gt({ except: /^\s*({|else\b)/ }),
        TryStatement: gt({ except: /^\s*({|catch|finally)\b/ }),
        LabeledStatement: Ep,
        SwitchBlock: (t) => {
          let e = t.textAfter, i = /^\s*\}/.test(e), n = /^\s*(case|default)\b/.test(e);
          return t.baseIndent + (i ? 0 : n ? 1 : 2) * t.unit;
        },
        Block: dO({ closing: "}" }),
        BlockComment: () => null,
        Statement: gt({ except: /^{/ })
      }),
      ui.add({
        ["Block SwitchBlock ClassBody ElementValueArrayInitializer ModuleBody EnumBody ConstructorBody InterfaceBody ArrayInitializer"]: Mn,
        BlockComment(t) {
          return { from: t.from + 2, to: t.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\})$/
  }
});
function vE() {
  return new li(bE);
}
var Xd = 1;
var XE = 2;
var xE = 3;
var wE = 4;
var TE = 5;
var kE = 35;
var _E = 36;
var WE = 37;
var YE = 11;
var RE = 13;
function ZE(t) {
  return t == 45 || t == 46 || t == 58 || t >= 65 && t <= 90 || t == 95 || t >= 97 && t <= 122 || t >= 161;
}
function UE(t) {
  return t == 9 || t == 10 || t == 13 || t == 32;
}
var qS = null;
var zS = null;
var CS = 0;
function xd(t, e) {
  let i = t.pos + e;
  if (zS == t && CS == i)
    return qS;
  for (; UE(t.peek(e)); )
    e++;
  let n = "";
  for (; ; ) {
    let O = t.peek(e);
    if (!ZE(O))
      break;
    n += String.fromCharCode(O), e++;
  }
  return zS = t, CS = i, qS = n || null;
}
function ES(t, e) {
  this.name = t, this.parent = e, this.hash = e ? e.hash : 0;
  for (let i = 0; i < t.length; i++)
    this.hash += (this.hash << 4) + t.charCodeAt(i) + (t.charCodeAt(i) << 8);
}
var VE = new lu({
  start: null,
  shift(t, e, i, n) {
    return e == Xd ? new ES(xd(n, 1) || "", t) : t;
  },
  reduce(t, e) {
    return e == YE && t ? t.parent : t;
  },
  reuse(t, e, i, n) {
    let O = e.type.id;
    return O == Xd || O == RE ? new ES(xd(n, 1) || "", t) : t;
  },
  hash(t) {
    return t ? t.hash : 0;
  },
  strict: false
});
var qE = new Ie((t, e) => {
  if (t.next == 60) {
    if (t.advance(), t.next == 47) {
      t.advance();
      let i = xd(t, 0);
      if (!i)
        return t.acceptToken(TE);
      if (e.context && i == e.context.name)
        return t.acceptToken(XE);
      for (let n = e.context; n; n = n.parent)
        if (n.name == i)
          return t.acceptToken(xE, -2);
      t.acceptToken(wE);
    } else if (t.next != 33 && t.next != 63)
      return t.acceptToken(Xd);
  }
}, { contextual: true });
function S$(t, e) {
  return new Ie((i) => {
    for (let n = 0, O = 0; ; O++) {
      if (i.next < 0) {
        O && i.acceptToken(t);
        break;
      }
      if (i.next == e.charCodeAt(n)) {
        if (n++, n == e.length) {
          O >= e.length && i.acceptToken(t, 1 - e.length);
          break;
        }
      } else
        n = i.next == e.charCodeAt(0) ? 1 : 0;
      i.advance();
    }
  });
}
var zE = S$(kE, "-->");
var CE = S$(_E, "?>");
var EE = S$(WE, "]]>");
var jE = ti({
  Text: f.content,
  "StartTag StartCloseTag EndTag SelfCloseEndTag": f.angleBracket,
  TagName: f.tagName,
  "MismatchedCloseTag/Tagname": [f.tagName, f.invalid],
  AttributeName: f.attributeName,
  AttributeValue: f.attributeValue,
  Is: f.definitionOperator,
  "EntityReference CharacterReference": f.character,
  Comment: f.blockComment,
  ProcessingInst: f.processingInstruction,
  DoctypeDecl: f.documentMeta,
  Cdata: f.special(f.string)
});
var IE = Jt.deserialize({
  version: 14,
  states: ",SOQOaOOOrOxO'#CfOzOpO'#CiO!tOaO'#CgOOOP'#Cg'#CgO!{OrO'#CrO#TOtO'#CsO#]OpO'#CtOOOP'#DS'#DSOOOP'#Cv'#CvQQOaOOOOOW'#Cw'#CwO#eOxO,59QOOOP,59Q,59QOOOO'#Cx'#CxO#mOpO,59TO#uO!bO,59TOOOP'#C{'#C{O$TOaO,59RO$[OpO'#CoOOOP,59R,59ROOOQ'#C|'#C|O$dOrO,59^OOOP,59^,59^OOOS'#C}'#C}O$lOtO,59_OOOP,59_,59_O$tOpO,59`O$|OpO,59`OOOP-E6t-E6tOOOW-E6u-E6uOOOP1G.l1G.lOOOO-E6v-E6vO%UO!bO1G.oO%UO!bO1G.oO%dOpO'#CkO%lO!bO'#CyO%zO!bO1G.oOOOP1G.o1G.oOOOP1G.w1G.wOOOP-E6y-E6yOOOP1G.m1G.mO&VOpO,59ZO&_OpO,59ZOOOQ-E6z-E6zOOOP1G.x1G.xOOOS-E6{-E6{OOOP1G.y1G.yO&gOpO1G.zO&gOpO1G.zOOOP1G.z1G.zO&oO!bO7+$ZO&}O!bO7+$ZOOOP7+$Z7+$ZOOOP7+$c7+$cO'YOpO,59VO'bOpO,59VO'jO!bO,59eOOOO-E6w-E6wO'xOpO1G.uO'xOpO1G.uOOOP1G.u1G.uO(QOpO7+$fOOOP7+$f7+$fO(YO!bO<<GuOOOP<<Gu<<GuOOOP<<G}<<G}O'bOpO1G.qO'bOpO1G.qO(eO#tO'#CnOOOO1G.q1G.qO(sOpO7+$aOOOP7+$a7+$aOOOP<<HQ<<HQOOOPAN=aAN=aOOOPAN=iAN=iO'bOpO7+$]OOOO7+$]7+$]OOOO'#Cz'#CzO({O#tO,59YOOOO,59Y,59YOOOP<<G{<<G{OOOO<<Gw<<GwOOOO-E6x-E6xOOOO1G.t1G.t",
  stateData: ")Z~OPQOSVOTWOVWOWWOXWOiXOxPO}TO!PUO~OuZOw]O~O^`Oy^O~OPQOQcOSVOTWOVWOWWOXWOxPO}TO!PUO~ORdO~P!SOseO|gO~OthO!OjO~O^lOy^O~OuZOwoO~O^qOy^O~O[vO`sOdwOy^O~ORyO~P!SO^{Oy^O~OseO|}O~OthO!O!PO~O^!QOy^O~O[!SOy^O~O[!VO`sOd!WOy^O~Oa!YOy^O~Oy^O[mX`mXdmX~O[!VO`sOd!WO~O^!]Oy^O~O[!_Oy^O~O[!aOy^O~O[!cO`sOd!dOy^O~O[!cO`sOd!dO~Oa!eOy^O~Oy^Oz!gO~Oy^O[ma`madma~O[!jOy^O~O[!kOy^O~O[!lO`sOd!mO~OW!pOX!pOz!rO{!pO~O[!sOy^O~OW!pOX!pOz!vO{!pO~O",
  goto: "%[wPPPPPPPPPPxxP!OP!UPP!_!iP!oxxxP!u!{#R$Z$j$p$v$|PPPP%SXWORYbXRORYb_t`qru!T!U!bQ!h!YS!o!e!fR!t!nQdRRybXSORYbQYORmYQ[PRn[Q_QQkVjp_krz!R!T!X!Z!^!`!f!i!nQr`QzcQ!RlQ!TqQ!XsQ!ZtQ!^{Q!`!QQ!f!YQ!i!]R!n!eQu`S!UqrU![u!U!bR!b!TQ!q!gR!u!qQbRRxbQfTR|fQiUR!OiSXOYTaRb",
  nodeNames: "⚠ StartTag StartCloseTag MissingCloseTag StartCloseTag StartCloseTag Document Text EntityReference CharacterReference Cdata Element EndTag OpenTag TagName Attribute AttributeName Is AttributeValue CloseTag SelfCloseEndTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag DoctypeDecl",
  maxTerm: 47,
  context: VE,
  nodeProps: [
    ["closedBy", 1, "SelfCloseEndTag EndTag", 13, "CloseTag MissingCloseTag"],
    ["openedBy", 12, "StartTag StartCloseTag", 19, "OpenTag", 20, "StartTag"]
  ],
  propSources: [jE],
  skippedNodes: [0],
  repeatNodeCount: 8,
  tokenData: "IX~R!XOX$nXY&kYZ&kZ]$n]^&k^p$npq&kqr$nrs'ssv$nvw(Zw}$n}!O*l!O!P$n!P!Q,{!Q![$n![!].e!]!^$n!^!_1v!_!`Cz!`!aDm!a!bE`!b!c$n!c!}.e!}#P$n#P#QFx#Q#R$n#R#S.e#S#T$n#T#o.e#o%W$n%W%o.e%o%p$n%p&a.e&a&b$n&b1p.e1p4U$n4U4d.e4d4e$n4e$IS.e$IS$I`$n$I`$Ib.e$Ib$Kh$n$Kh%#t.e%#t&/x$n&/x&Et.e&Et&FV$n&FV;'S.e;'S;:j1p;:j;=`&e<%l?&r$n?&r?Ah.e?Ah?BY$n?BY?Mn.e?MnO$nX$uWVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nP%dTVPOv%_w!^%_!_;'S%_;'S;=`%s<%lO%_P%vP;=`<%l%_W&OT{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yW&bP;=`<%l%yX&hP;=`<%l$n_&t_VP{WyUOX$nXY&kYZ&kZ]$n]^&k^p$npq&kqr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZ'zTzYVPOv%_w!^%_!_;'S%_;'S;=`%s<%lO%_~(^VOp(sqs(sst)ht!](s!^;'S(s;'S;=`)b<%lO(s~(vVOp(sqs(st!](s!]!^)]!^;'S(s;'S;=`)b<%lO(s~)bOW~~)eP;=`<%l(s~)kTOp)zq!])z!^;'S)z;'S;=`*f<%lO)z~)}UOp)zq!])z!]!^*a!^;'S)z;'S;=`*f<%lO)z~*fOX~~*iP;=`<%l)zZ*sYVP{WOr$nrs%_sv$nw}$n}!O+c!O!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZ+jYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!a,Y!a;'S$n;'S;=`&e<%lO$nZ,cW|QVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n]-SYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!a-r!a;'S$n;'S;=`&e<%lO$n]-{WdSVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n_.p!O`S^QVP{WOr$nrs%_sv$nw}$n}!O.e!O!P.e!P!Q$n!Q![.e![!].e!]!^$n!^!_%y!_!c$n!c!}.e!}#R$n#R#S.e#S#T$n#T#o.e#o$}$n$}%O.e%O%W$n%W%o.e%o%p$n%p&a.e&a&b$n&b1p.e1p4U.e4U4d.e4d4e$n4e$IS.e$IS$I`$n$I`$Ib.e$Ib$Je$n$Je$Jg.e$Jg$Kh$n$Kh%#t.e%#t&/x$n&/x&Et.e&Et&FV$n&FV;'S.e;'S;:j1p;:j;=`&e<%l?&r$n?&r?Ah.e?Ah?BY$n?BY?Mn.e?MnO$n_1sP;=`<%l.eX1{W{WOq%yqr2esv%yw!a%y!a!bCd!b;'S%y;'S;=`&_<%lO%yX2j]{WOr%ysv%yw}%y}!O3c!O!f%y!f!g4e!g!}%y!}#O9t#O#W%y#W#X@Q#X;'S%y;'S;=`&_<%lO%yX3hV{WOr%ysv%yw}%y}!O3}!O;'S%y;'S;=`&_<%lO%yX4UT}P{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yX4jV{WOr%ysv%yw!q%y!q!r5P!r;'S%y;'S;=`&_<%lO%yX5UV{WOr%ysv%yw!e%y!e!f5k!f;'S%y;'S;=`&_<%lO%yX5pV{WOr%ysv%yw!v%y!v!w6V!w;'S%y;'S;=`&_<%lO%yX6[V{WOr%ysv%yw!{%y!{!|6q!|;'S%y;'S;=`&_<%lO%yX6vV{WOr%ysv%yw!r%y!r!s7]!s;'S%y;'S;=`&_<%lO%yX7bV{WOr%ysv%yw!g%y!g!h7w!h;'S%y;'S;=`&_<%lO%yX7|X{WOr7wrs8isv7wvw8iw!`7w!`!a9W!a;'S7w;'S;=`9n<%lO7wP8lTO!`8i!`!a8{!a;'S8i;'S;=`9Q<%lO8iP9QOiPP9TP;=`<%l8iX9_TiP{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yX9qP;=`<%l7wX9yX{WOr%ysv%yw!e%y!e!f:f!f#V%y#V#W=t#W;'S%y;'S;=`&_<%lO%yX:kV{WOr%ysv%yw!f%y!f!g;Q!g;'S%y;'S;=`&_<%lO%yX;VV{WOr%ysv%yw!c%y!c!d;l!d;'S%y;'S;=`&_<%lO%yX;qV{WOr%ysv%yw!v%y!v!w<W!w;'S%y;'S;=`&_<%lO%yX<]V{WOr%ysv%yw!c%y!c!d<r!d;'S%y;'S;=`&_<%lO%yX<wV{WOr%ysv%yw!}%y!}#O=^#O;'S%y;'S;=`&_<%lO%yX=eT{WxPOr%ysv%yw;'S%y;'S;=`&_<%lO%yX=yV{WOr%ysv%yw#W%y#W#X>`#X;'S%y;'S;=`&_<%lO%yX>eV{WOr%ysv%yw#T%y#T#U>z#U;'S%y;'S;=`&_<%lO%yX?PV{WOr%ysv%yw#h%y#h#i?f#i;'S%y;'S;=`&_<%lO%yX?kV{WOr%ysv%yw#T%y#T#U<r#U;'S%y;'S;=`&_<%lO%yX@VV{WOr%ysv%yw#c%y#c#d@l#d;'S%y;'S;=`&_<%lO%yX@qV{WOr%ysv%yw#V%y#V#WAW#W;'S%y;'S;=`&_<%lO%yXA]V{WOr%ysv%yw#h%y#h#iAr#i;'S%y;'S;=`&_<%lO%yXAwV{WOr%ysv%yw#m%y#m#nB^#n;'S%y;'S;=`&_<%lO%yXBcV{WOr%ysv%yw#d%y#d#eBx#e;'S%y;'S;=`&_<%lO%yXB}V{WOr%ysv%yw#X%y#X#Y7w#Y;'S%y;'S;=`&_<%lO%yXCkT!PP{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yZDTWaQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n_DvW[UVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZEgYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!aFV!a;'S$n;'S;=`&e<%lO$nZF`W!OQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZGPYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_#P$n#P#QGo#Q;'S$n;'S;=`&e<%lO$nZGvYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!aHf!a;'S$n;'S;=`&e<%lO$nZHoWwQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n",
  tokenizers: [qE, zE, CE, EE, 0, 1, 2, 3],
  topRules: { Document: [0, 6] },
  tokenPrec: 0
});
function Vl(t, e) {
  let i = e && e.getChild("TagName");
  return i ? t.sliceString(i.from, i.to) : "";
}
function _f(t, e) {
  let i = e && e.firstChild;
  return !i || i.name != "OpenTag" ? "" : Vl(t, i);
}
function AE(t, e, i) {
  let n = e && e.getChildren("Attribute").find((r) => r.from <= i && r.to >= i), O = n && n.getChild("AttributeName");
  return O ? t.sliceString(O.from, O.to) : "";
}
function Wf(t) {
  for (let e = t && t.parent; e; e = e.parent)
    if (e.name == "Element")
      return e;
  return null;
}
function GE(t, e) {
  var i;
  let n = Ye(t).resolveInner(e, -1), O = null;
  for (let r = n; !O && r.parent; r = r.parent)
    (r.name == "OpenTag" || r.name == "CloseTag" || r.name == "SelfClosingTag" || r.name == "MismatchedCloseTag") && (O = r);
  if (O && (O.to > e || O.lastChild.type.isError)) {
    let r = O.parent;
    if (n.name == "TagName")
      return O.name == "CloseTag" || O.name == "MismatchedCloseTag" ? { type: "closeTag", from: n.from, context: r } : { type: "openTag", from: n.from, context: Wf(r) };
    if (n.name == "AttributeName")
      return { type: "attrName", from: n.from, context: O };
    if (n.name == "AttributeValue")
      return { type: "attrValue", from: n.from, context: O };
    let a = n == O || n.name == "Attribute" ? n.childBefore(e) : n;
    return (a == null ? void 0 : a.name) == "StartTag" ? { type: "openTag", from: e, context: Wf(r) } : (a == null ? void 0 : a.name) == "StartCloseTag" && a.to <= e ? { type: "closeTag", from: e, context: r } : (a == null ? void 0 : a.name) == "Is" ? { type: "attrValue", from: e, context: O } : a ? { type: "attrName", from: e, context: O } : null;
  } else if (n.name == "StartCloseTag")
    return { type: "closeTag", from: e, context: n.parent };
  for (; n.parent && n.to == e && !(!((i = n.lastChild) === null || i === void 0) && i.type.isError); )
    n = n.parent;
  return n.name == "Element" || n.name == "Text" || n.name == "Document" ? { type: "tag", from: e, context: n.name == "Element" ? n : Wf(n) } : null;
}
var LE = class {
  constructor(e, i, n) {
    this.attrs = i, this.attrValues = n, this.children = [], this.name = e.name, this.completion = Object.assign(Object.assign({ type: "type" }, e.completion || {}), { label: this.name }), this.openCompletion = Object.assign(Object.assign({}, this.completion), { label: "<" + this.name }), this.closeCompletion = Object.assign(Object.assign({}, this.completion), { label: "</" + this.name + ">", boost: 2 }), this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), { label: this.name + ">" }), this.text = e.textContent ? e.textContent.map((O) => ({ label: O, type: "text" })) : [];
  }
};
var Yf = /^[:\-\.\w\u00b7-\uffff]*$/;
function jS(t) {
  return Object.assign(Object.assign({ type: "property" }, t.completion || {}), { label: t.name });
}
function IS(t) {
  return typeof t == "string" ? { label: `"${t}"`, type: "constant" } : /^"/.test(t.label) ? t : Object.assign(Object.assign({}, t), { label: `"${t.label}"` });
}
function DE(t, e) {
  let i = [], n = [], O = /* @__PURE__ */ Object.create(null);
  for (let s of e) {
    let l = jS(s);
    i.push(l), s.global && n.push(l), s.values && (O[s.name] = s.values.map(IS));
  }
  let r = [], a = [], o = /* @__PURE__ */ Object.create(null);
  for (let s of t) {
    let l = n, c = O;
    s.attributes && (l = l.concat(s.attributes.map((h10) => typeof h10 == "string" ? i.find((d) => d.label == h10) || { label: h10, type: "property" } : (h10.values && (c == O && (c = Object.create(c)), c[h10.name] = h10.values.map(IS)), jS(h10)))));
    let u = new LE(s, l, c);
    o[u.name] = u, r.push(u), s.top && a.push(u);
  }
  a.length || (a = r);
  for (let s = 0; s < r.length; s++) {
    let l = t[s], c = r[s];
    if (l.children)
      for (let u of l.children)
        o[u] && c.children.push(o[u]);
    else
      c.children = r;
  }
  return (s) => {
    var l;
    let { doc: c } = s.state, u = GE(s.state, s.pos);
    if (!u || u.type == "tag" && !s.explicit)
      return null;
    let { type: h10, from: d, context: p } = u;
    if (h10 == "openTag") {
      let $ = a, g = _f(c, p);
      if (g) {
        let Q = o[g];
        $ = (Q == null ? void 0 : Q.children) || r;
      }
      return {
        from: d,
        options: $.map((Q) => Q.completion),
        validFor: Yf
      };
    } else if (h10 == "closeTag") {
      let $ = _f(c, p);
      return $ ? {
        from: d,
        to: s.pos + (c.sliceString(s.pos, s.pos + 1) == ">" ? 1 : 0),
        options: [((l = o[$]) === null || l === void 0 ? void 0 : l.closeNameCompletion) || { label: $ + ">", type: "type" }],
        validFor: Yf
      } : null;
    } else if (h10 == "attrName") {
      let $ = o[Vl(c, p)];
      return {
        from: d,
        options: ($ == null ? void 0 : $.attrs) || n,
        validFor: Yf
      };
    } else if (h10 == "attrValue") {
      let $ = AE(c, p, d);
      if (!$)
        return null;
      let g = o[Vl(c, p)], Q = ((g == null ? void 0 : g.attrValues) || O)[$];
      return !Q || !Q.length ? null : {
        from: d,
        to: s.pos + (c.sliceString(s.pos, s.pos + 1) == '"' ? 1 : 0),
        options: Q,
        validFor: /^"[^"]*"?$/
      };
    } else if (h10 == "tag") {
      let $ = _f(c, p), g = o[$], Q = [], m = p && p.lastChild;
      $ && (!m || m.name != "CloseTag" || Vl(c, m) != $) && Q.push(g ? g.closeCompletion : { label: "</" + $ + ">", type: "type", boost: 2 });
      let b = Q.concat(((g == null ? void 0 : g.children) || (p ? r : a)).map((P) => P.openCompletion));
      if (p && (g != null && g.text.length)) {
        let P = p.firstChild;
        P.to > s.pos - 20 && !/\S/.test(s.state.sliceDoc(P.to, s.pos)) && (b = b.concat(g.text));
      }
      return {
        from: d,
        options: b,
        validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/
      };
    } else
      return null;
  };
}
var AS = Kt.define({
  name: "xml",
  parser: IE.configure({
    props: [
      ci.add({
        Element(t) {
          let e = /^\s*<\//.test(t.textAfter);
          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(t) {
          return t.column(t.node.from) + t.unit;
        }
      }),
      ui.add({
        Element(t) {
          let e = t.firstChild, i = t.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: i.name == "CloseTag" ? i.from : t.to };
        }
      }),
      Ip.add({
        "OpenTag CloseTag": (t) => t.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/$/
  }
});
function ME(t = {}) {
  return new li(AS, AS.data.of({
    autocomplete: DE(t.elements || [], t.attributes || [])
  }));
}
var NE = ti({
  String: f.string,
  Number: f.number,
  "True False": f.bool,
  PropertyName: f.propertyName,
  Null: f.null,
  ",": f.separator,
  "[ ]": f.squareBracket,
  "{ }": f.brace
});
var BE = Jt.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
  stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
  goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "⚠ JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["openedBy", 7, "{", 12, "["],
    ["closedBy", 8, "}", 13, "]"]
  ],
  propSources: [NE],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(p~RaXY!WYZ!W]^!Wpq!Wrs!]|}$i}!O$n!Q!R$w!R![&V![!]&h!}#O&m#P#Q&r#Y#Z&w#b#c'f#h#i'}#o#p(f#q#r(k~!]Oc~~!`Upq!]qr!]rs!rs#O!]#O#P!w#P~!]~!wOe~~!zXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#g~#jR!Q![#s!c!i#s#T#Z#s~#vR!Q![$P!c!i$P#T#Z$P~$SR!Q![$]!c!i$]#T#Z$]~$`R!Q![!]!c!i!]#T#Z!]~$nOh~~$qQ!Q!R$w!R![&V~$|RT~!O!P%V!g!h%k#X#Y%k~%YP!Q![%]~%bRT~!Q![%]!g!h%k#X#Y%k~%nR{|%w}!O%w!Q![%}~%zP!Q![%}~&SPT~!Q![%}~&[ST~!O!P%V!Q![&V!g!h%k#X#Y%k~&mOg~~&rO]~~&wO[~~&zP#T#U&}~'QP#`#a'T~'WP#g#h'Z~'^P#X#Y'a~'fOR~~'iP#i#j'l~'oP#`#a'r~'uP#`#a'x~'}OS~~(QP#f#g(T~(WP#i#j(Z~(^P#X#Y(a~(fOQ~~(kOW~~(pOV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
});
var FE = Kt.define({
  name: "json",
  parser: BE.configure({
    props: [
      ci.add({
        Object: gt({ except: /^\s*\}/ }),
        Array: gt({ except: /^\s*\]/ })
      }),
      ui.add({
        "Object Array": Mn
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function HE() {
  return new li(FE);
}
var KE = { __proto__: null, anyref: 34, dataref: 34, eqref: 34, externref: 34, i31ref: 34, funcref: 34, i8: 34, i16: 34, i32: 34, i64: 34, f32: 34, f64: 34 };
var JE = Jt.deserialize({
  version: 14,
  states: "!^Q]QPOOOqQPO'#CbOOQO'#Cd'#CdOOQO'#Cl'#ClOOQO'#Ch'#ChQ]QPOOOOQO,58|,58|OxQPO,58|OOQO-E6f-E6fOOQO1G.h1G.h",
  stateData: "!P~O_OSPOSQOS~OTPOVROXROYROZROaQO~OSUO~P]OSXO~P]O",
  goto: "xaPPPPPPbPbPPPhPPPrXROPTVQTOQVPTWTVXSOPTV",
  nodeNames: "⚠ LineComment BlockComment Module ) ( App Identifier Type Keyword Number String",
  maxTerm: 17,
  nodeProps: [
    ["openedBy", 4, "("],
    ["closedBy", 5, ")"],
    ["group", -6, 6, 7, 8, 9, 10, 11, "Expression"]
  ],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 1,
  tokenData: "/Q~R^XY}YZ}]^}pq}rs!Stu!qxy&Vyz'S{|'X}!O'X!Q!R'b!R![)_!]!^,{#T#o-^~!SO_~~!VTOr!Srs!fs#O!S#O#P!k#P~!S~!kOZ~~!nPO~!S~!tiqr$cst$ctu$cuv$cvw$cwx$cz{$c{|$c}!O$c!O!P$c!P!Q$c!Q![$c![!]$c!^!_$c!_!`$c!`!a$c!a!b$c!b!c$c!c!}$c#Q#R$c#R#S$c#S#T$c#T#o$c#p#q$c#r#s$c~$hiV~qr$cst$ctu$cuv$cvw$cwx$cz{$c{|$c}!O$c!O!P$c!P!Q$c!Q![$c![!]$c!^!_$c!_!`$c!`!a$c!a!b$c!b!c$c!c!}$c#Q#R$c#R#S$c#S#T$c#T#o$c#p#q$c#r#s$c~&[PT~!]!^&_~&bRO!]&_!]!^&k!^~&_~&nTOy&_yz&}z!]&_!]!^&k!^~&_~'SOQ~~'XOS~~'[Q!Q!R'b!R![)_~'gUY~!O!P'y!Q![)_!g!h(j#R#S)s#X#Y(j#l#m)y~(ORY~!Q![(X!g!h(j#X#Y(j~(^SY~!Q![(X!g!h(j#R#S)X#X#Y(j~(mR{|(v}!O(v!Q![(|~(yP!Q![(|~)RQY~!Q![(|#R#S(v~)[P!Q![(X~)dTY~!O!P'y!Q![)_!g!h(j#R#S)s#X#Y(j~)vP!Q![)_~)|R!Q![*V!c!i*V#T#Z*V~*[VY~!O!P*q!Q![*V!c!i*V!r!s+n#R#S)y#T#Z*V#d#e+n~*vTY~!Q![+V!c!i+V!r!s+n#T#Z+V#d#e+n~+[UY~!Q![+V!c!i+V!r!s+n#R#S,o#T#Z+V#d#e+n~+qT{|,Q}!O,Q!Q![,^!c!i,^#T#Z,^~,TR!Q![,^!c!i,^#T#Z,^~,cSY~!Q![,^!c!i,^#R#S,Q#T#Z,^~,rR!Q![+V!c!i+V#T#Z+V~-OP!]!^-R~-WQP~OY-RZ~-R~-ciX~qr-^st-^tu-^uv-^vw-^wx-^z{-^{|-^}!O-^!O!P-^!P!Q-^!Q![-^![!]-^!^!_-^!_!`-^!`!a-^!a!b-^!b!c-^!c!}-^#Q#R-^#R#S-^#S#T-^#T#o-^#p#q-^#r#s-^",
  tokenizers: [0],
  topRules: { Module: [0, 3] },
  specialized: [{ term: 9, get: (t) => KE[t] || -1 }],
  tokenPrec: 0
});
var e6 = Kt.define({
  name: "wast",
  parser: JE.configure({
    props: [
      ci.add({
        App: dO({ closing: ")", align: false })
      }),
      ui.add({
        App: Mn,
        BlockComment(t) {
          return { from: t.from + 2, to: t.to - 2 };
        }
      }),
      ti({
        Keyword: f.keyword,
        Type: f.typeName,
        Number: f.number,
        String: f.string,
        Identifier: f.variableName,
        LineComment: f.lineComment,
        BlockComment: f.blockComment,
        "( )": f.paren
      })
    ]
  }),
  languageData: {
    commentTokens: { line: ";;", block: { open: "(;", close: ";)" } },
    closeBrackets: { brackets: ["(", '"'] }
  }
});
function t6() {
  return new li(e6);
}
function i6(t) {
  return new RegExp("^(?:" + t.join("|") + ")", "i");
}
function hu(t) {
  return new RegExp("^(?:" + t.join("|") + ")$", "i");
}
var n6 = hu([
  "_G",
  "_VERSION",
  "assert",
  "collectgarbage",
  "dofile",
  "error",
  "getfenv",
  "getmetatable",
  "ipairs",
  "load",
  "loadfile",
  "loadstring",
  "module",
  "next",
  "pairs",
  "pcall",
  "print",
  "rawequal",
  "rawget",
  "rawset",
  "require",
  "select",
  "setfenv",
  "setmetatable",
  "tonumber",
  "tostring",
  "type",
  "unpack",
  "xpcall",
  "coroutine.create",
  "coroutine.resume",
  "coroutine.running",
  "coroutine.status",
  "coroutine.wrap",
  "coroutine.yield",
  "debug.debug",
  "debug.getfenv",
  "debug.gethook",
  "debug.getinfo",
  "debug.getlocal",
  "debug.getmetatable",
  "debug.getregistry",
  "debug.getupvalue",
  "debug.setfenv",
  "debug.sethook",
  "debug.setlocal",
  "debug.setmetatable",
  "debug.setupvalue",
  "debug.traceback",
  "close",
  "flush",
  "lines",
  "read",
  "seek",
  "setvbuf",
  "write",
  "io.close",
  "io.flush",
  "io.input",
  "io.lines",
  "io.open",
  "io.output",
  "io.popen",
  "io.read",
  "io.stderr",
  "io.stdin",
  "io.stdout",
  "io.tmpfile",
  "io.type",
  "io.write",
  "math.abs",
  "math.acos",
  "math.asin",
  "math.atan",
  "math.atan2",
  "math.ceil",
  "math.cos",
  "math.cosh",
  "math.deg",
  "math.exp",
  "math.floor",
  "math.fmod",
  "math.frexp",
  "math.huge",
  "math.ldexp",
  "math.log",
  "math.log10",
  "math.max",
  "math.min",
  "math.modf",
  "math.pi",
  "math.pow",
  "math.rad",
  "math.random",
  "math.randomseed",
  "math.sin",
  "math.sinh",
  "math.sqrt",
  "math.tan",
  "math.tanh",
  "os.clock",
  "os.date",
  "os.difftime",
  "os.execute",
  "os.exit",
  "os.getenv",
  "os.remove",
  "os.rename",
  "os.setlocale",
  "os.time",
  "os.tmpname",
  "package.cpath",
  "package.loaded",
  "package.loaders",
  "package.loadlib",
  "package.path",
  "package.preload",
  "package.seeall",
  "string.byte",
  "string.char",
  "string.dump",
  "string.find",
  "string.format",
  "string.gmatch",
  "string.gsub",
  "string.len",
  "string.lower",
  "string.match",
  "string.rep",
  "string.reverse",
  "string.sub",
  "string.upper",
  "table.concat",
  "table.insert",
  "table.maxn",
  "table.remove",
  "table.sort"
]);
var O6 = hu([
  "and",
  "break",
  "elseif",
  "false",
  "nil",
  "not",
  "or",
  "return",
  "true",
  "function",
  "end",
  "if",
  "then",
  "else",
  "do",
  "while",
  "repeat",
  "until",
  "for",
  "in",
  "local"
]);
var r6 = hu(["function", "if", "repeat", "do", "\\(", "{"]);
var a6 = hu(["end", "until", "\\)", "}"]);
var o6 = i6(["end", "until", "\\)", "}", "else", "elseif"]);
function GS(t) {
  for (var e = 0; t.eat("="); )
    ++e;
  return t.eat("["), e;
}
function P$(t, e) {
  var i = t.next();
  return i == "-" && t.eat("-") ? t.eat("[") && t.eat("[") ? (e.cur = LS(GS(t), "comment"))(t, e) : (t.skipToEnd(), "comment") : i == '"' || i == "'" ? (e.cur = s6(i))(t, e) : i == "[" && /[\[=]/.test(t.peek()) ? (e.cur = LS(GS(t), "string"))(t, e) : /\d/.test(i) ? (t.eatWhile(/[\w.%]/), "number") : /[\w_]/.test(i) ? (t.eatWhile(/[\w\\\-_.]/), "variable") : null;
}
function LS(t, e) {
  return function(i, n) {
    for (var O = null, r; (r = i.next()) != null; )
      if (O == null)
        r == "]" && (O = 0);
      else if (r == "=")
        ++O;
      else if (r == "]" && O == t) {
        n.cur = P$;
        break;
      } else
        O = null;
    return e;
  };
}
function s6(t) {
  return function(e, i) {
    for (var n = false, O; (O = e.next()) != null && !(O == t && !n); )
      n = !n && O == "\\";
    return n || (i.cur = P$), "string";
  };
}
var l6 = {
  name: "lua",
  startState: function() {
    return { basecol: 0, indentDepth: 0, cur: P$ };
  },
  token: function(t, e) {
    if (t.eatSpace())
      return null;
    var i = e.cur(t, e), n = t.current();
    return i == "variable" && (O6.test(n) ? i = "keyword" : n6.test(n) && (i = "builtin")), i != "comment" && i != "string" && (r6.test(n) ? ++e.indentDepth : a6.test(n) && --e.indentDepth), i;
  },
  indent: function(t, e, i) {
    var n = o6.test(e);
    return t.basecol + i.unit * (t.indentDepth - (n ? 1 : 0));
  },
  languageData: {
    indentOnInput: /^\s*(?:end|until|else|\)|\})$/,
    commentTokens: { line: "--", block: { open: "--[[", close: "]]--" } }
  }
};
function y$(t) {
  for (var e = {}, i = 0, n = t.length; i < n; ++i)
    e[t[i]] = true;
  return e;
}
var ux = [
  "alias",
  "and",
  "BEGIN",
  "begin",
  "break",
  "case",
  "class",
  "def",
  "defined?",
  "do",
  "else",
  "elsif",
  "END",
  "end",
  "ensure",
  "false",
  "for",
  "if",
  "in",
  "module",
  "next",
  "not",
  "or",
  "redo",
  "rescue",
  "retry",
  "return",
  "self",
  "super",
  "then",
  "true",
  "undef",
  "unless",
  "until",
  "when",
  "while",
  "yield",
  "nil",
  "raise",
  "throw",
  "catch",
  "fail",
  "loop",
  "callcc",
  "caller",
  "lambda",
  "proc",
  "public",
  "protected",
  "private",
  "require",
  "load",
  "require_relative",
  "extend",
  "autoload",
  "__END__",
  "__FILE__",
  "__LINE__",
  "__dir__"
];
var c6 = y$(ux);
var u6 = y$([
  "def",
  "class",
  "case",
  "for",
  "while",
  "until",
  "module",
  "catch",
  "loop",
  "proc",
  "begin"
]);
var f6 = y$(["end", "until"]);
var DS = { "[": "]", "{": "}", "(": ")" };
var h6 = { "]": "[", "}": "{", ")": "(" };
var Bi;
function Xr(t, e, i) {
  return i.tokenize.push(t), t(e, i);
}
function yc(t, e) {
  if (t.sol() && t.match("=begin") && t.eol())
    return e.tokenize.push(Q6), "comment";
  if (t.eatSpace())
    return null;
  var i = t.next(), n;
  if (i == "`" || i == "'" || i == '"')
    return Xr(Ka(i, "string", i == '"' || i == "`"), t, e);
  if (i == "/")
    return d6(t) ? Xr(Ka(i, "string.special", true), t, e) : "operator";
  if (i == "%") {
    var O = "string", r = true;
    t.eat("s") ? O = "atom" : t.eat(/[WQ]/) ? O = "string" : t.eat(/[r]/) ? O = "string.special" : t.eat(/[wxq]/) && (O = "string", r = false);
    var a = t.eat(/[^\w\s=]/);
    return a ? (DS.propertyIsEnumerable(a) && (a = DS[a]), Xr(Ka(a, O, r, true), t, e)) : "operator";
  } else {
    if (i == "#")
      return t.skipToEnd(), "comment";
    if (i == "<" && (n = t.match(/^<([-~])[\`\"\']?([a-zA-Z_?]\w*)[\`\"\']?(?:;|$)/)))
      return Xr($6(n[2], n[1]), t, e);
    if (i == "0")
      return t.eat("x") ? t.eatWhile(/[\da-fA-F]/) : t.eat("b") ? t.eatWhile(/[01]/) : t.eatWhile(/[0-7]/), "number";
    if (/\d/.test(i))
      return t.match(/^[\d_]*(?:\.[\d_]+)?(?:[eE][+\-]?[\d_]+)?/), "number";
    if (i == "?") {
      for (; t.match(/^\\[CM]-/); )
        ;
      return t.eat("\\") ? t.eatWhile(/\w/) : t.next(), "string";
    } else {
      if (i == ":")
        return t.eat("'") ? Xr(Ka("'", "atom", false), t, e) : t.eat('"') ? Xr(Ka('"', "atom", true), t, e) : t.eat(/[\<\>]/) ? (t.eat(/[\<\>]/), "atom") : t.eat(/[\+\-\*\/\&\|\:\!]/) ? "atom" : t.eat(/[a-zA-Z$@_\xa1-\uffff]/) ? (t.eatWhile(/[\w$\xa1-\uffff]/), t.eat(/[\?\!\=]/), "atom") : "operator";
      if (i == "@" && t.match(/^@?[a-zA-Z_\xa1-\uffff]/))
        return t.eat("@"), t.eatWhile(/[\w\xa1-\uffff]/), "propertyName";
      if (i == "$")
        return t.eat(/[a-zA-Z_]/) ? t.eatWhile(/[\w]/) : t.eat(/\d/) ? t.eat(/\d/) : t.next(), "variableName.special";
      if (/[a-zA-Z_\xa1-\uffff]/.test(i))
        return t.eatWhile(/[\w\xa1-\uffff]/), t.eat(/[\?\!]/), t.eat(":") ? "atom" : "variable";
      if (i == "|" && (e.varList || e.lastTok == "{" || e.lastTok == "do"))
        return Bi = "|", null;
      if (/[\(\)\[\]{}\\;]/.test(i))
        return Bi = i, null;
      if (i == "-" && t.eat(">"))
        return "operator";
      if (/[=+\-\/*:\.^%<>~|]/.test(i)) {
        var o = t.eatWhile(/[=+\-\/*:\.^%<>~|]/);
        return i == "." && !o && (Bi = "."), "operator";
      } else
        return null;
    }
  }
}
function d6(t) {
  for (var e = t.pos, i = 0, n, O = false, r = false; (n = t.next()) != null; )
    if (r)
      r = false;
    else {
      if ("[{(".indexOf(n) > -1)
        i++;
      else if ("]})".indexOf(n) > -1) {
        if (i--, i < 0)
          break;
      } else if (n == "/" && i == 0) {
        O = true;
        break;
      }
      r = n == "\\";
    }
  return t.backUp(t.pos - e), O;
}
function wd(t) {
  return t || (t = 1), function(e, i) {
    if (e.peek() == "}") {
      if (t == 1)
        return i.tokenize.pop(), i.tokenize[i.tokenize.length - 1](e, i);
      i.tokenize[i.tokenize.length - 1] = wd(t - 1);
    } else
      e.peek() == "{" && (i.tokenize[i.tokenize.length - 1] = wd(t + 1));
    return yc(e, i);
  };
}
function p6() {
  var t = false;
  return function(e, i) {
    return t ? (i.tokenize.pop(), i.tokenize[i.tokenize.length - 1](e, i)) : (t = true, yc(e, i));
  };
}
function Ka(t, e, i, n) {
  return function(O, r) {
    var a = false, o;
    for (r.context.type === "read-quoted-paused" && (r.context = r.context.prev, O.eat("}")); (o = O.next()) != null; ) {
      if (o == t && (n || !a)) {
        r.tokenize.pop();
        break;
      }
      if (i && o == "#" && !a) {
        if (O.eat("{")) {
          t == "}" && (r.context = { prev: r.context, type: "read-quoted-paused" }), r.tokenize.push(wd());
          break;
        } else if (/[@\$]/.test(O.peek())) {
          r.tokenize.push(p6());
          break;
        }
      }
      a = !a && o == "\\";
    }
    return e;
  };
}
function $6(t, e) {
  return function(i, n) {
    return e && i.eatSpace(), i.match(t) ? n.tokenize.pop() : i.skipToEnd(), "string";
  };
}
function Q6(t, e) {
  return t.sol() && t.match("=end") && t.eol() && e.tokenize.pop(), t.skipToEnd(), "comment";
}
var g6 = {
  name: "ruby",
  startState: function(t) {
    return {
      tokenize: [yc],
      indented: 0,
      context: { type: "top", indented: -t },
      continuedLine: false,
      lastTok: null,
      varList: false
    };
  },
  token: function(t, e) {
    Bi = null, t.sol() && (e.indented = t.indentation());
    var i = e.tokenize[e.tokenize.length - 1](t, e), n, O = Bi;
    if (i == "variable") {
      var r = t.current();
      i = e.lastTok == "." ? "property" : c6.propertyIsEnumerable(t.current()) ? "keyword" : /^[A-Z]/.test(r) ? "tag" : e.lastTok == "def" || e.lastTok == "class" || e.varList ? "def" : "variable", i == "keyword" && (O = r, u6.propertyIsEnumerable(r) ? n = "indent" : f6.propertyIsEnumerable(r) ? n = "dedent" : ((r == "if" || r == "unless") && t.column() == t.indentation() || r == "do" && e.context.indented < e.indented) && (n = "indent"));
    }
    return (Bi || i && i != "comment") && (e.lastTok = O), Bi == "|" && (e.varList = !e.varList), n == "indent" || /[\(\[\{]/.test(Bi) ? e.context = { prev: e.context, type: Bi || i, indented: e.indented } : (n == "dedent" || /[\)\]\}]/.test(Bi)) && e.context.prev && (e.context = e.context.prev), t.eol() && (e.continuedLine = Bi == "\\" || i == "operator"), i;
  },
  indent: function(t, e, i) {
    if (t.tokenize[t.tokenize.length - 1] != yc)
      return null;
    var n = e && e.charAt(0), O = t.context, r = O.type == h6[n] || O.type == "keyword" && /^(?:end|until|else|elsif|when|rescue)\b/.test(e);
    return O.indented + (r ? 0 : i.unit) + (t.continuedLine ? i.unit : 0);
  },
  languageData: {
    indentOnInput: /^\s*(?:end|rescue|elsif|else|\})$/,
    commentTokens: { line: "#" },
    autocomplete: ux
  }
};
function b$(t, e, i, n, O, r) {
  this.indented = t, this.column = e, this.type = i, this.info = n, this.align = O, this.prev = r;
}
function ul(t, e, i, n) {
  var O = t.indented;
  return t.context && t.context.type == "statement" && i != "statement" && (O = t.context.indented), t.context = new b$(O, e, i, n, null, t.context);
}
function Ja(t) {
  var e = t.context.type;
  return (e == ")" || e == "]" || e == "}") && (t.indented = t.context.indented), t.context = t.context.prev;
}
function MS(t, e, i) {
  if (e.prevToken == "variable" || e.prevToken == "type" || /\S(?:[^- ]>|[*\]])\s*$|\*$/.test(t.string.slice(0, i)) || e.typeAtEndOfLine && t.column() == t.indentation())
    return true;
}
function NS(t) {
  for (; ; ) {
    if (!t || t.type == "top")
      return true;
    if (t.type == "}" && t.prev.info != "namespace")
      return false;
    t = t.prev;
  }
}
function vi(t) {
  var e = t.statementIndentUnit, i = t.dontAlignCalls, n = t.keywords || {}, O = t.types || {}, r = t.builtin || {}, a = t.blockKeywords || {}, o = t.defKeywords || {}, s = t.atoms || {}, l = t.hooks || {}, c = t.multiLineStrings, u = t.indentStatements !== false, h10 = t.indentSwitch !== false, d = t.namespaceSeparator, p = t.isPunctuationChar || /[\[\]{}\(\),;\:\.]/, $ = t.numberStart || /[\d\.]/, g = t.number || /^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i, Q = t.isOperatorChar || /[+\-*&%=<>!?|\/]/, m = t.isIdentifierChar || /[\w\$_\xa1-\uffff]/, b = t.isReservedIdentifier || false, P, S;
  function y(x, k) {
    var Y = x.next();
    if (l[Y]) {
      var Z = l[Y](x, k);
      if (Z !== false)
        return Z;
    }
    if (Y == '"' || Y == "'")
      return k.tokenize = v(Y), k.tokenize(x, k);
    if ($.test(Y)) {
      if (x.backUp(1), x.match(g))
        return "number";
      x.next();
    }
    if (p.test(Y))
      return P = Y, null;
    if (Y == "/") {
      if (x.eat("*"))
        return k.tokenize = T, T(x, k);
      if (x.eat("/"))
        return x.skipToEnd(), "comment";
    }
    if (Q.test(Y)) {
      for (; !x.match(/^\/[\/*]/, false) && x.eat(Q); )
        ;
      return "operator";
    }
    if (x.eatWhile(m), d)
      for (; x.match(d); )
        x.eatWhile(m);
    var L = x.current();
    return Yn(n, L) ? (Yn(a, L) && (P = "newstatement"), Yn(o, L) && (S = true), "keyword") : Yn(O, L) ? "type" : Yn(r, L) || b && b(L) ? (Yn(a, L) && (P = "newstatement"), "builtin") : Yn(s, L) ? "atom" : "variable";
  }
  function v(x) {
    return function(k, Y) {
      for (var Z = false, L, ae = false; (L = k.next()) != null; ) {
        if (L == x && !Z) {
          ae = true;
          break;
        }
        Z = !Z && L == "\\";
      }
      return (ae || !(Z || c)) && (Y.tokenize = null), "string";
    };
  }
  function T(x, k) {
    for (var Y = false, Z; Z = x.next(); ) {
      if (Z == "/" && Y) {
        k.tokenize = null;
        break;
      }
      Y = Z == "*";
    }
    return "comment";
  }
  function _(x, k) {
    t.typeFirstDefinitions && x.eol() && NS(k.context) && (k.typeAtEndOfLine = MS(x, k, x.pos));
  }
  return {
    name: t.name,
    startState: function(x) {
      return {
        tokenize: null,
        context: new b$(-x, 0, "top", null, false),
        indented: 0,
        startOfLine: true,
        prevToken: null
      };
    },
    token: function(x, k) {
      var Y = k.context;
      if (x.sol() && (Y.align == null && (Y.align = false), k.indented = x.indentation(), k.startOfLine = true), x.eatSpace())
        return _(x, k), null;
      P = S = null;
      var Z = (k.tokenize || y)(x, k);
      if (Z == "comment" || Z == "meta")
        return Z;
      if (Y.align == null && (Y.align = true), P == ";" || P == ":" || P == "," && x.match(/^\s*(?:\/\/.*)?$/, false))
        for (; k.context.type == "statement"; )
          Ja(k);
      else if (P == "{")
        ul(k, x.column(), "}");
      else if (P == "[")
        ul(k, x.column(), "]");
      else if (P == "(")
        ul(k, x.column(), ")");
      else if (P == "}") {
        for (; Y.type == "statement"; )
          Y = Ja(k);
        for (Y.type == "}" && (Y = Ja(k)); Y.type == "statement"; )
          Y = Ja(k);
      } else
        P == Y.type ? Ja(k) : u && ((Y.type == "}" || Y.type == "top") && P != ";" || Y.type == "statement" && P == "newstatement") && ul(k, x.column(), "statement", x.current());
      if (Z == "variable" && (k.prevToken == "def" || t.typeFirstDefinitions && MS(x, k, x.start) && NS(k.context) && x.match(/^\s*\(/, false)) && (Z = "def"), l.token) {
        var L = l.token(x, k, Z);
        L !== void 0 && (Z = L);
      }
      return Z == "def" && t.styleDefs === false && (Z = "variable"), k.startOfLine = false, k.prevToken = S ? "def" : Z || P, _(x, k), Z;
    },
    indent: function(x, k, Y) {
      if (x.tokenize != y && x.tokenize != null || x.typeAtEndOfLine)
        return null;
      var Z = x.context, L = k && k.charAt(0), ae = L == Z.type;
      if (Z.type == "statement" && L == "}" && (Z = Z.prev), t.dontIndentStatements)
        for (; Z.type == "statement" && t.dontIndentStatements.test(Z.info); )
          Z = Z.prev;
      if (l.indent) {
        var Oe = l.indent(x, Z, k, Y.unit);
        if (typeof Oe == "number")
          return Oe;
      }
      var C = Z.prev && Z.prev.info == "switch";
      if (t.allmanIndentation && /[{(]/.test(L)) {
        for (; Z.type != "top" && Z.type != "}"; )
          Z = Z.prev;
        return Z.indented;
      }
      return Z.type == "statement" ? Z.indented + (L == "{" ? 0 : e || Y.unit) : Z.align && (!i || Z.type != ")") ? Z.column + (ae ? 0 : 1) : Z.type == ")" && !ae ? Z.indented + (e || Y.unit) : Z.indented + (ae ? 0 : Y.unit) + (!ae && C && !/^(?:case|default)\b/.test(k) ? Y.unit : 0);
    },
    languageData: {
      indentOnInput: h10 ? /^\s*(?:case .*?:|default:|\{\}?|\})$/ : /^\s*[{}]$/,
      commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
      autocomplete: Object.keys(n).concat(Object.keys(O)).concat(Object.keys(r)).concat(Object.keys(s)),
      ...t.languageData
    }
  };
}
function te(t) {
  for (var e = {}, i = t.split(" "), n = 0; n < i.length; ++n)
    e[i[n]] = true;
  return e;
}
function Yn(t, e) {
  return typeof t == "function" ? t(e) : t.propertyIsEnumerable(e);
}
var ws = "auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile inline restrict asm fortran";
var fx = "alignas alignof and and_eq audit axiom bitand bitor catch class compl concept constexpr const_cast decltype delete dynamic_cast explicit export final friend import module mutable namespace new noexcept not not_eq operator or or_eq override private protected public reinterpret_cast requires static_assert static_cast template this thread_local throw try typeid typename using virtual xor xor_eq";
var hx = "bycopy byref in inout oneway out self super atomic nonatomic retain copy readwrite readonly strong weak assign typeof nullable nonnull null_resettable _cmd @interface @implementation @end @protocol @encode @property @synthesize @dynamic @class @public @package @private @protected @required @optional @try @catch @finally @import @selector @encode @defs @synchronized @autoreleasepool @compatibility_alias @available";
var dx = "FOUNDATION_EXPORT FOUNDATION_EXTERN NS_INLINE NS_FORMAT_FUNCTION  NS_RETURNS_RETAINEDNS_ERROR_ENUM NS_RETURNS_NOT_RETAINED NS_RETURNS_INNER_POINTER NS_DESIGNATED_INITIALIZER NS_ENUM NS_OPTIONS NS_REQUIRES_NIL_TERMINATION NS_ASSUME_NONNULL_BEGIN NS_ASSUME_NONNULL_END NS_SWIFT_NAME NS_REFINED_FOR_SWIFT";
var m6 = te("int long char short double float unsigned signed void bool");
var S6 = te("SEL instancetype id Class Protocol BOOL");
function Ts(t) {
  return Yn(m6, t) || /.+_t$/.test(t);
}
function px(t) {
  return Ts(t) || Yn(S6, t);
}
var ks = "case do else for if switch while struct enum union";
var du = "struct enum union";
function kO(t, e) {
  if (!e.startOfLine)
    return false;
  for (var i, n = null; i = t.peek(); ) {
    if (i == "\\" && t.match(/^.$/)) {
      n = kO;
      break;
    } else if (i == "/" && t.match(/^\/[\/\*]/, false))
      break;
    t.next();
  }
  return e.tokenize = n, "meta";
}
function pu(t, e) {
  return e.prevToken == "type" ? "type" : false;
}
function $u(t) {
  return !t || t.length < 2 || t[0] != "_" ? false : t[1] == "_" || t[1] !== t[1].toLowerCase();
}
function at(t) {
  return t.eatWhile(/[\w\.']/), "number";
}
function fO(t, e) {
  if (t.backUp(1), t.match(/^(?:R|u8R|uR|UR|LR)/)) {
    var i = t.match(/^"([^\s\\()]{0,16})\(/);
    return i ? (e.cpp11RawStringDelim = i[1], e.tokenize = FS, FS(t, e)) : false;
  }
  return t.match(/^(?:u8|u|U|L)/) ? t.match(
    /^["']/,
    /* eat */
    false
  ) ? "string" : false : (t.next(), false);
}
function $x(t) {
  var e = /(\w+)::~?(\w+)$/.exec(t);
  return e && e[1] == e[2];
}
function BS(t, e) {
  for (var i; (i = t.next()) != null; )
    if (i == '"' && !t.eat('"')) {
      e.tokenize = null;
      break;
    }
  return "string";
}
function FS(t, e) {
  var i = e.cpp11RawStringDelim.replace(/[^\w\s]/g, "\\$&"), n = t.match(new RegExp(".*?\\)" + i + '"'));
  return n ? e.tokenize = null : t.skipToEnd(), "string";
}
var P6 = vi({
  name: "c",
  keywords: te(ws),
  types: Ts,
  blockKeywords: te(ks),
  defKeywords: te(du),
  typeFirstDefinitions: true,
  atoms: te("NULL true false"),
  isReservedIdentifier: $u,
  hooks: {
    "#": kO,
    "*": pu
  }
});
vi({
  name: "cpp",
  keywords: te(ws + " " + fx),
  types: Ts,
  blockKeywords: te(ks + " class try catch"),
  defKeywords: te(du + " class namespace"),
  typeFirstDefinitions: true,
  atoms: te("true false NULL nullptr"),
  dontIndentStatements: /^template$/,
  isIdentifierChar: /[\w\$_~\xa1-\uffff]/,
  isReservedIdentifier: $u,
  hooks: {
    "#": kO,
    "*": pu,
    u: fO,
    U: fO,
    L: fO,
    R: fO,
    0: at,
    1: at,
    2: at,
    3: at,
    4: at,
    5: at,
    6: at,
    7: at,
    8: at,
    9: at,
    token: function(t, e, i) {
      if (i == "variable" && t.peek() == "(" && (e.prevToken == ";" || e.prevToken == null || e.prevToken == "}") && $x(t.current()))
        return "def";
    }
  },
  namespaceSeparator: "::"
});
vi({
  name: "java",
  keywords: te("abstract assert break case catch class const continue default do else enum extends final finally for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),
  types: te("var byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),
  blockKeywords: te("catch class do else finally for if switch try while"),
  defKeywords: te("class interface enum @interface"),
  typeFirstDefinitions: true,
  atoms: te("true false null"),
  number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
  hooks: {
    "@": function(t) {
      return t.match("interface", false) ? false : (t.eatWhile(/[\w\$_]/), "meta");
    },
    '"': function(t, e) {
      return t.match(/""$/) ? (e.tokenize = Qx, e.tokenize(t, e)) : false;
    }
  }
});
var y6 = vi({
  name: "csharp",
  keywords: te("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),
  types: te("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),
  blockKeywords: te("catch class do else finally for foreach if struct switch try while"),
  defKeywords: te("class interface namespace struct var"),
  typeFirstDefinitions: true,
  atoms: te("true false null"),
  hooks: {
    "@": function(t, e) {
      return t.eat('"') ? (e.tokenize = BS, BS(t, e)) : (t.eatWhile(/[\w\$_]/), "meta");
    }
  }
});
function Qx(t, e) {
  for (var i = false; !t.eol(); ) {
    if (!i && t.match('"""')) {
      e.tokenize = null;
      break;
    }
    i = t.next() == "\\" && !i;
  }
  return "string";
}
function ls(t) {
  return function(e, i) {
    for (var n; n = e.next(); )
      if (n == "*" && e.eat("/"))
        if (t == 1) {
          i.tokenize = null;
          break;
        } else
          return i.tokenize = ls(t - 1), i.tokenize(e, i);
      else if (n == "/" && e.eat("*"))
        return i.tokenize = ls(t + 1), i.tokenize(e, i);
    return "comment";
  };
}
var b6 = vi({
  name: "scala",
  keywords: te(
    /* scala */
    "abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"
  ),
  types: te(
    "AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"
  ),
  multiLineStrings: true,
  blockKeywords: te("catch class enum do else finally for forSome if match switch try while"),
  defKeywords: te("class enum def object package trait type val var"),
  atoms: te("true false null"),
  indentStatements: false,
  indentSwitch: false,
  isOperatorChar: /[+\-*&%=<>!?|\/#:@]/,
  hooks: {
    "@": function(t) {
      return t.eatWhile(/[\w\$_]/), "meta";
    },
    '"': function(t, e) {
      return t.match('""') ? (e.tokenize = Qx, e.tokenize(t, e)) : false;
    },
    "'": function(t) {
      return t.eatWhile(/[\w\$_\xa1-\uffff]/), "atom";
    },
    "=": function(t, e) {
      var i = e.context;
      return i.type == "}" && i.align && t.eat(">") ? (e.context = new b$(i.indented, i.column, i.type, i.info, null, i.prev), "operator") : false;
    },
    "/": function(t, e) {
      return t.eat("*") ? (e.tokenize = ls(1), e.tokenize(t, e)) : false;
    }
  },
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', '"""'] }
  }
});
function v6(t) {
  return function(e, i) {
    for (var n = false, O, r = false; !e.eol(); ) {
      if (!t && !n && e.match('"')) {
        r = true;
        break;
      }
      if (t && e.match('"""')) {
        r = true;
        break;
      }
      O = e.next(), !n && O == "$" && e.match("{") && e.skipTo("}"), n = !n && O == "\\" && !t;
    }
    return (r || !t) && (i.tokenize = null), "string";
  };
}
var X6 = vi({
  name: "kotlin",
  keywords: te(
    /*keywords*/
    "package as typealias class interface this super val operator var fun for is in This throw return annotation break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend actual expect setparam"
  ),
  types: te(
    /* package java.lang */
    "Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void Annotation Any BooleanArray ByteArray Char CharArray DeprecationLevel DoubleArray Enum FloatArray Function Int IntArray Lazy LazyThreadSafetyMode LongArray Nothing ShortArray Unit"
  ),
  intendSwitch: false,
  indentStatements: false,
  multiLineStrings: true,
  number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+(\.\d+)?|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
  blockKeywords: te("catch class do else finally for if where try while enum"),
  defKeywords: te("class val var object interface fun"),
  atoms: te("true false null this"),
  hooks: {
    "@": function(t) {
      return t.eatWhile(/[\w\$_]/), "meta";
    },
    "*": function(t, e) {
      return e.prevToken == "." ? "variable" : "operator";
    },
    '"': function(t, e) {
      return e.tokenize = v6(t.match('""')), e.tokenize(t, e);
    },
    "/": function(t, e) {
      return t.eat("*") ? (e.tokenize = ls(1), e.tokenize(t, e)) : false;
    },
    indent: function(t, e, i, n) {
      var O = i && i.charAt(0);
      if ((t.prevToken == "}" || t.prevToken == ")") && i == "")
        return t.indented;
      if (t.prevToken == "operator" && i != "}" && t.context.type != "}" || t.prevToken == "variable" && O == "." || (t.prevToken == "}" || t.prevToken == ")") && O == ".")
        return n * 2 + e.indented;
      if (e.align && e.type == "}")
        return e.indented + (t.context.type == (i || "").charAt(0) ? 0 : n);
    }
  },
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', '"""'] }
  }
});
vi({
  name: "shader",
  keywords: te("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),
  types: te("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),
  blockKeywords: te("for while do if else struct"),
  builtin: te("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),
  atoms: te("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TextureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),
  indentSwitch: false,
  hooks: { "#": kO }
});
vi({
  name: "nesc",
  keywords: te(ws + " as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),
  types: Ts,
  blockKeywords: te(ks),
  atoms: te("null true false"),
  hooks: { "#": kO }
});
var x6 = vi({
  name: "objectivec",
  keywords: te(ws + " " + hx),
  types: px,
  builtin: te(dx),
  blockKeywords: te(ks + " @synthesize @try @catch @finally @autoreleasepool @synchronized"),
  defKeywords: te(du + " @interface @implementation @protocol @class"),
  dontIndentStatements: /^@.*$/,
  typeFirstDefinitions: true,
  atoms: te("YES NO NULL Nil nil true false nullptr"),
  isReservedIdentifier: $u,
  hooks: {
    "#": kO,
    "*": pu
  }
});
vi({
  name: "objectivecpp",
  keywords: te(ws + " " + hx + " " + fx),
  types: px,
  builtin: te(dx),
  blockKeywords: te(ks + " @synthesize @try @catch @finally @autoreleasepool @synchronized class try catch"),
  defKeywords: te(du + " @interface @implementation @protocol @class class namespace"),
  dontIndentStatements: /^@.*$|^template$/,
  typeFirstDefinitions: true,
  atoms: te("YES NO NULL Nil nil true false nullptr"),
  isReservedIdentifier: $u,
  hooks: {
    "#": kO,
    "*": pu,
    u: fO,
    U: fO,
    L: fO,
    R: fO,
    0: at,
    1: at,
    2: at,
    3: at,
    4: at,
    5: at,
    6: at,
    7: at,
    8: at,
    9: at,
    token: function(t, e, i) {
      if (i == "variable" && t.peek() == "(" && (e.prevToken == ";" || e.prevToken == null || e.prevToken == "}") && $x(t.current()))
        return "def";
    }
  },
  namespaceSeparator: "::"
});
vi({
  name: "squirrel",
  keywords: te("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),
  types: Ts,
  blockKeywords: te("case catch class else for foreach if switch try while"),
  defKeywords: te("function local class"),
  typeFirstDefinitions: true,
  atoms: te("true false null"),
  hooks: { "#": kO }
});
var ql = null;
function gx(t) {
  return function(e, i) {
    for (var n = false, O, r = false; !e.eol(); ) {
      if (!n && e.match('"') && (t == "single" || e.match('""'))) {
        r = true;
        break;
      }
      if (!n && e.match("``")) {
        ql = gx(t), r = true;
        break;
      }
      O = e.next(), n = t == "single" && !n && O == "\\";
    }
    return r && (i.tokenize = null), "string";
  };
}
vi({
  name: "ceylon",
  keywords: te("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),
  types: function(t) {
    var e = t.charAt(0);
    return e === e.toUpperCase() && e !== e.toLowerCase();
  },
  blockKeywords: te("case catch class dynamic else finally for function if interface module new object switch try while"),
  defKeywords: te("class dynamic function interface module object package value"),
  builtin: te("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),
  isPunctuationChar: /[\[\]{}\(\),;\:\.`]/,
  isOperatorChar: /[+\-*&%=<>!?|^~:\/]/,
  numberStart: /[\d#$]/,
  number: /^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,
  multiLineStrings: true,
  typeFirstDefinitions: true,
  atoms: te("true false null larger smaller equal empty finished"),
  indentSwitch: false,
  styleDefs: false,
  hooks: {
    "@": function(t) {
      return t.eatWhile(/[\w\$_]/), "meta";
    },
    '"': function(t, e) {
      return e.tokenize = gx(t.match('""') ? "triple" : "single"), e.tokenize(t, e);
    },
    "`": function(t, e) {
      return !ql || !t.match("`") ? false : (e.tokenize = ql, ql = null, e.tokenize(t, e));
    },
    "'": function(t) {
      return t.eatWhile(/[\w\$_\xa1-\uffff]/), "atom";
    },
    token: function(t, e, i) {
      if ((i == "variable" || i == "type") && e.prevToken == ".")
        return "variableName.special";
    }
  },
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', '"""'] }
  }
});
function w6(t) {
  (t.interpolationStack || (t.interpolationStack = [])).push(t.tokenize);
}
function mx(t) {
  return (t.interpolationStack || (t.interpolationStack = [])).pop();
}
function T6(t) {
  return t.interpolationStack ? t.interpolationStack.length : 0;
}
function Rf(t, e, i, n) {
  var O = false;
  if (e.eat(t))
    if (e.eat(t))
      O = true;
    else
      return "string";
  function r(a, o) {
    for (var s = false; !a.eol(); ) {
      if (!n && !s && a.peek() == "$")
        return w6(o), o.tokenize = k6, "string";
      var l = a.next();
      if (l == t && !s && (!O || a.match(t + t))) {
        o.tokenize = null;
        break;
      }
      s = !n && !s && l == "\\";
    }
    return "string";
  }
  return i.tokenize = r, r(e, i);
}
function k6(t, e) {
  return t.eat("$"), t.eat("{") ? e.tokenize = null : e.tokenize = _6, null;
}
function _6(t, e) {
  return t.eatWhile(/[\w_]/), e.tokenize = mx(e), "variable";
}
var W6 = vi({
  name: "dart",
  keywords: te("this super static final const abstract class extends external factory implements mixin get native set typedef with enum throw rethrow assert break case continue default in return new deferred async await covariant try catch finally do else for if switch while import library export part of show hide is as extension on yield late required"),
  blockKeywords: te("try catch finally do else for if switch while"),
  builtin: te("void bool num int double dynamic var String Null Never"),
  atoms: te("true false null"),
  hooks: {
    "@": function(t) {
      return t.eatWhile(/[\w\$_\.]/), "meta";
    },
    // custom string handling to deal with triple-quoted strings and string interpolation
    "'": function(t, e) {
      return Rf("'", t, e, false);
    },
    '"': function(t, e) {
      return Rf('"', t, e, false);
    },
    r: function(t, e) {
      var i = t.peek();
      return i == "'" || i == '"' ? Rf(t.next(), t, e, true) : false;
    },
    "}": function(t, e) {
      return T6(e) > 0 ? (e.tokenize = mx(e), null) : false;
    },
    "/": function(t, e) {
      return t.eat("*") ? (e.tokenize = ls(1), e.tokenize(t, e)) : false;
    },
    token: function(t, e, i) {
      if (i == "variable") {
        var n = RegExp("^[_$]*[A-Z][a-zA-Z0-9_$]*$", "g");
        if (n.test(t.current()))
          return "type";
      }
    }
  }
});
var Y6 = {
  break: true,
  case: true,
  chan: true,
  const: true,
  continue: true,
  default: true,
  defer: true,
  else: true,
  fallthrough: true,
  for: true,
  func: true,
  go: true,
  goto: true,
  if: true,
  import: true,
  interface: true,
  map: true,
  package: true,
  range: true,
  return: true,
  select: true,
  struct: true,
  switch: true,
  type: true,
  var: true,
  bool: true,
  byte: true,
  complex64: true,
  complex128: true,
  float32: true,
  float64: true,
  int8: true,
  int16: true,
  int32: true,
  int64: true,
  string: true,
  uint8: true,
  uint16: true,
  uint32: true,
  uint64: true,
  int: true,
  uint: true,
  uintptr: true,
  error: true,
  rune: true,
  any: true,
  comparable: true
};
var R6 = {
  true: true,
  false: true,
  iota: true,
  nil: true,
  append: true,
  cap: true,
  close: true,
  complex: true,
  copy: true,
  delete: true,
  imag: true,
  len: true,
  make: true,
  new: true,
  panic: true,
  print: true,
  println: true,
  real: true,
  recover: true
};
var HS = /[+\-*&^%:=<>!|\/]/;
var Rn;
function bc(t, e) {
  var i = t.next();
  if (i == '"' || i == "'" || i == "`")
    return e.tokenize = Z6(i), e.tokenize(t, e);
  if (/[\d\.]/.test(i))
    return i == "." ? t.match(/^[0-9]+([eE][\-+]?[0-9]+)?/) : i == "0" ? t.match(/^[xX][0-9a-fA-F]+/) || t.match(/^0[0-7]+/) : t.match(/^[0-9]*\.?[0-9]*([eE][\-+]?[0-9]+)?/), "number";
  if (/[\[\]{}\(\),;\:\.]/.test(i))
    return Rn = i, null;
  if (i == "/") {
    if (t.eat("*"))
      return e.tokenize = KS, KS(t, e);
    if (t.eat("/"))
      return t.skipToEnd(), "comment";
  }
  if (HS.test(i))
    return t.eatWhile(HS), "operator";
  t.eatWhile(/[\w\$_\xa1-\uffff]/);
  var n = t.current();
  return Y6.propertyIsEnumerable(n) ? ((n == "case" || n == "default") && (Rn = "case"), "keyword") : R6.propertyIsEnumerable(n) ? "atom" : "variable";
}
function Z6(t) {
  return function(e, i) {
    for (var n = false, O, r = false; (O = e.next()) != null; ) {
      if (O == t && !n) {
        r = true;
        break;
      }
      n = !n && t != "`" && O == "\\";
    }
    return (r || !(n || t == "`")) && (i.tokenize = bc), "string";
  };
}
function KS(t, e) {
  for (var i = false, n; n = t.next(); ) {
    if (n == "/" && i) {
      e.tokenize = bc;
      break;
    }
    i = n == "*";
  }
  return "comment";
}
function Sx(t, e, i, n, O) {
  this.indented = t, this.column = e, this.type = i, this.align = n, this.prev = O;
}
function Zf(t, e, i) {
  return t.context = new Sx(t.indented, e, i, null, t.context);
}
function JS(t) {
  if (t.context.prev) {
    var e = t.context.type;
    return (e == ")" || e == "]" || e == "}") && (t.indented = t.context.indented), t.context = t.context.prev;
  }
}
var U6 = {
  name: "go",
  startState: function(t) {
    return {
      tokenize: null,
      context: new Sx(-t, 0, "top", false),
      indented: 0,
      startOfLine: true
    };
  },
  token: function(t, e) {
    var i = e.context;
    if (t.sol() && (i.align == null && (i.align = false), e.indented = t.indentation(), e.startOfLine = true, i.type == "case" && (i.type = "}")), t.eatSpace())
      return null;
    Rn = null;
    var n = (e.tokenize || bc)(t, e);
    return n == "comment" || (i.align == null && (i.align = true), Rn == "{" ? Zf(e, t.column(), "}") : Rn == "[" ? Zf(e, t.column(), "]") : Rn == "(" ? Zf(e, t.column(), ")") : Rn == "case" ? i.type = "case" : (Rn == "}" && i.type == "}" || Rn == i.type) && JS(e), e.startOfLine = false), n;
  },
  indent: function(t, e, i) {
    if (t.tokenize != bc && t.tokenize != null)
      return null;
    var n = t.context, O = e && e.charAt(0);
    if (n.type == "case" && /^(?:case|default)\b/.test(e))
      return t.context.type = "}", n.indented;
    var r = O == n.type;
    return n.align ? n.column + (r ? 0 : 1) : n.indented + (r ? 0 : i.unit);
  },
  languageData: {
    indentOnInput: /^\s([{}]|case |default\s*:)$/,
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } }
  }
};
function Qu(t) {
  for (var e = {}, i = 0; i < t.length; i++)
    e[t[i]] = true;
  return e;
}
var V6 = Qu([
  "_",
  "var",
  "let",
  "actor",
  "class",
  "enum",
  "extension",
  "import",
  "protocol",
  "struct",
  "func",
  "typealias",
  "associatedtype",
  "open",
  "public",
  "internal",
  "fileprivate",
  "private",
  "deinit",
  "init",
  "new",
  "override",
  "self",
  "subscript",
  "super",
  "convenience",
  "dynamic",
  "final",
  "indirect",
  "lazy",
  "required",
  "static",
  "unowned",
  "unowned(safe)",
  "unowned(unsafe)",
  "weak",
  "as",
  "is",
  "break",
  "case",
  "continue",
  "default",
  "else",
  "fallthrough",
  "for",
  "guard",
  "if",
  "in",
  "repeat",
  "switch",
  "where",
  "while",
  "defer",
  "return",
  "inout",
  "mutating",
  "nonmutating",
  "isolated",
  "nonisolated",
  "catch",
  "do",
  "rethrows",
  "throw",
  "throws",
  "async",
  "await",
  "try",
  "didSet",
  "get",
  "set",
  "willSet",
  "assignment",
  "associativity",
  "infix",
  "left",
  "none",
  "operator",
  "postfix",
  "precedence",
  "precedencegroup",
  "prefix",
  "right",
  "Any",
  "AnyObject",
  "Type",
  "dynamicType",
  "Self",
  "Protocol",
  "__COLUMN__",
  "__FILE__",
  "__FUNCTION__",
  "__LINE__"
]);
var q6 = Qu(["var", "let", "actor", "class", "enum", "extension", "import", "protocol", "struct", "func", "typealias", "associatedtype", "for"]);
var z6 = Qu(["true", "false", "nil", "self", "super", "_"]);
var C6 = Qu([
  "Array",
  "Bool",
  "Character",
  "Dictionary",
  "Double",
  "Float",
  "Int",
  "Int8",
  "Int16",
  "Int32",
  "Int64",
  "Never",
  "Optional",
  "Set",
  "String",
  "UInt8",
  "UInt16",
  "UInt32",
  "UInt64",
  "Void"
]);
var E6 = "+-/*%=|&<>~^?!";
var j6 = ":;,.(){}[]";
var I6 = /^\-?0b[01][01_]*/;
var A6 = /^\-?0o[0-7][0-7_]*/;
var G6 = /^\-?0x[\dA-Fa-f][\dA-Fa-f_]*(?:(?:\.[\dA-Fa-f][\dA-Fa-f_]*)?[Pp]\-?\d[\d_]*)?/;
var L6 = /^\-?\d[\d_]*(?:\.\d[\d_]*)?(?:[Ee]\-?\d[\d_]*)?/;
var D6 = /^\$\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\1/;
var M6 = /^\.(?:\$\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\1)/;
var N6 = /^\#[A-Za-z]+/;
var B6 = /^@(?:\$\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\1)/;
function Px(t, e, i) {
  if (t.sol() && (e.indented = t.indentation()), t.eatSpace())
    return null;
  var n = t.peek();
  if (n == "/") {
    if (t.match("//"))
      return t.skipToEnd(), "comment";
    if (t.match("/*"))
      return e.tokenize.push(Td), Td(t, e);
  }
  if (t.match(N6))
    return "builtin";
  if (t.match(B6))
    return "attribute";
  if (t.match(I6) || t.match(A6) || t.match(G6) || t.match(L6))
    return "number";
  if (t.match(M6))
    return "property";
  if (E6.indexOf(n) > -1)
    return t.next(), "operator";
  if (j6.indexOf(n) > -1)
    return t.next(), t.match(".."), "punctuation";
  var O;
  if (O = t.match(/("""|"|')/)) {
    var r = H6.bind(null, O[0]);
    return e.tokenize.push(r), r(t, e);
  }
  if (t.match(D6)) {
    var a = t.current();
    return C6.hasOwnProperty(a) ? "type" : z6.hasOwnProperty(a) ? "atom" : V6.hasOwnProperty(a) ? (q6.hasOwnProperty(a) && (e.prev = "define"), "keyword") : i == "define" ? "def" : "variable";
  }
  return t.next(), null;
}
function F6() {
  var t = 0;
  return function(e, i, n) {
    var O = Px(e, i, n);
    if (O == "punctuation") {
      if (e.current() == "(")
        ++t;
      else if (e.current() == ")") {
        if (t == 0)
          return e.backUp(1), i.tokenize.pop(), i.tokenize[i.tokenize.length - 1](e, i);
        --t;
      }
    }
    return O;
  };
}
function H6(t, e, i) {
  for (var n = t.length == 1, O, r = false; O = e.peek(); )
    if (r) {
      if (e.next(), O == "(")
        return i.tokenize.push(F6()), "string";
      r = false;
    } else {
      if (e.match(t))
        return i.tokenize.pop(), "string";
      e.next(), r = O == "\\";
    }
  return n && i.tokenize.pop(), "string";
}
function Td(t, e) {
  for (var i; i = t.next(); )
    if (i === "/" && t.eat("*"))
      e.tokenize.push(Td);
    else if (i === "*" && t.eat("/")) {
      e.tokenize.pop();
      break;
    }
  return "comment";
}
function K6(t, e, i) {
  this.prev = t, this.align = e, this.indented = i;
}
function J6(t, e) {
  var i = e.match(/^\s*($|\/[\/\*]|[)}\]])/, false) ? null : e.column() + 1;
  t.context = new K6(t.context, i, t.indented);
}
function ej(t) {
  t.context && (t.indented = t.context.indented, t.context = t.context.prev);
}
var tj = {
  name: "swift",
  startState: function() {
    return {
      prev: null,
      context: null,
      indented: 0,
      tokenize: []
    };
  },
  token: function(t, e) {
    var i = e.prev;
    e.prev = null;
    var n = e.tokenize[e.tokenize.length - 1] || Px, O = n(t, e, i);
    if (!O || O == "comment" ? e.prev = i : e.prev || (e.prev = O), O == "punctuation") {
      var r = /[\(\[\{]|([\]\)\}])/.exec(t.current());
      r && (r[1] ? ej : J6)(e, t);
    }
    return O;
  },
  indent: function(t, e, i) {
    var n = t.context;
    if (!n)
      return 0;
    var O = /^[\]\}\)]/.test(e);
    return n.align != null ? n.align - (O ? 1 : 0) : n.indented + (O ? 0 : i.unit);
  },
  languageData: {
    indentOnInput: /^\s*[\)\}\]]$/,
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }
  }
};
function eo(t, e, i) {
  return e(i), i(t, e);
}
var ij = /[a-z]/;
var nj = /[A-Z]/;
var eP = /[a-zA-Z0-9_]/;
var fl = /[0-9]/;
var Oj = /[0-9A-Fa-f]/;
var tP = /[-&*+.\\/<>=?^|:]/;
var rj = /[(),[\]{}]/;
var aj = /[ \v\f]/;
function Gn() {
  return function(t, e) {
    if (t.eatWhile(aj))
      return null;
    var i = t.next();
    if (rj.test(i))
      return i === "{" && t.eat("-") ? eo(t, e, yx(1)) : i === "[" && t.match("glsl|") ? eo(t, e, cj) : "builtin";
    if (i === "'")
      return eo(t, e, lj);
    if (i === '"')
      return t.eat('"') ? t.eat('"') ? eo(t, e, oj) : "string" : eo(t, e, sj);
    if (nj.test(i))
      return t.eatWhile(eP), "type";
    if (ij.test(i)) {
      var n = t.pos === 1;
      return t.eatWhile(eP), n ? "def" : "variable";
    }
    if (fl.test(i)) {
      if (i === "0") {
        if (t.eat(/[xX]/))
          return t.eatWhile(Oj), "number";
      } else
        t.eatWhile(fl);
      return t.eat(".") && t.eatWhile(fl), t.eat(/[eE]/) && (t.eat(/[-+]/), t.eatWhile(fl)), "number";
    }
    return tP.test(i) ? i === "-" && t.eat("-") ? (t.skipToEnd(), "comment") : (t.eatWhile(tP), "keyword") : i === "_" ? "keyword" : "error";
  };
}
function yx(t) {
  return t == 0 ? Gn() : function(e, i) {
    for (; !e.eol(); ) {
      var n = e.next();
      if (n == "{" && e.eat("-"))
        ++t;
      else if (n == "-" && e.eat("}") && (--t, t === 0))
        return i(Gn()), "comment";
    }
    return i(yx(t)), "comment";
  };
}
function oj(t, e) {
  for (; !t.eol(); ) {
    var i = t.next();
    if (i === '"' && t.eat('"') && t.eat('"'))
      return e(Gn()), "string";
  }
  return "string";
}
function sj(t, e) {
  for (; t.skipTo('\\"'); )
    t.next(), t.next();
  return t.skipTo('"') ? (t.next(), e(Gn()), "string") : (t.skipToEnd(), e(Gn()), "error");
}
function lj(t, e) {
  for (; t.skipTo("\\'"); )
    t.next(), t.next();
  return t.skipTo("'") ? (t.next(), e(Gn()), "string") : (t.skipToEnd(), e(Gn()), "error");
}
function cj(t, e) {
  for (; !t.eol(); ) {
    var i = t.next();
    if (i === "|" && t.eat("]"))
      return e(Gn()), "string";
  }
  return "string";
}
var uj = {
  case: 1,
  of: 1,
  as: 1,
  if: 1,
  then: 1,
  else: 1,
  let: 1,
  in: 1,
  type: 1,
  alias: 1,
  module: 1,
  where: 1,
  import: 1,
  exposing: 1,
  port: 1
};
var fj = {
  name: "elm",
  startState: function() {
    return { f: Gn() };
  },
  copyState: function(t) {
    return { f: t.f };
  },
  token: function(t, e) {
    var i = e.f(t, function(O) {
      e.f = O;
    }), n = t.current();
    return uj.hasOwnProperty(n) ? "keyword" : i;
  },
  languageData: {
    commentTokens: { line: "--" }
  }
};
function kd(t, e, i) {
  return e(i), i(t, e);
}
var hj = /[a-z_]/;
var dj = /[A-Z]/;
var Uf = /\d/;
var pj = /[0-9A-Fa-f]/;
var $j = /[0-7]/;
var iP = /[a-z_A-Z0-9'\xa1-\uffff]/;
var Vf = /[-!#$%&*+.\/<=>?@\\^|~:]/;
var Qj = /[(),;[\]`{}]/;
var bx = /[ \t\v\f]/;
function sa(t, e) {
  if (t.eatWhile(bx))
    return null;
  var i = t.next();
  if (Qj.test(i)) {
    if (i == "{" && t.eat("-")) {
      var n = "comment";
      return t.eat("#") && (n = "meta"), kd(t, e, vx(n, 1));
    }
    return null;
  }
  if (i == "'")
    return t.eat("\\"), t.next(), t.eat("'") ? "string" : "error";
  if (i == '"')
    return kd(t, e, Xx);
  if (dj.test(i))
    return t.eatWhile(iP), t.eat(".") ? "qualifier" : "type";
  if (hj.test(i))
    return t.eatWhile(iP), "variable";
  if (Uf.test(i)) {
    if (i == "0") {
      if (t.eat(/[xX]/))
        return t.eatWhile(pj), "integer";
      if (t.eat(/[oO]/))
        return t.eatWhile($j), "number";
    }
    t.eatWhile(Uf);
    var n = "number";
    return t.match(/^\.\d+/) && (n = "number"), t.eat(/[eE]/) && (n = "number", t.eat(/[-+]/), t.eatWhile(Uf)), n;
  }
  return i == "." && t.eat(".") ? "keyword" : Vf.test(i) ? i == "-" && t.eat(/-/) && (t.eatWhile(/-/), !t.eat(Vf)) ? (t.skipToEnd(), "comment") : (t.eatWhile(Vf), "variable") : "error";
}
function vx(t, e) {
  return e == 0 ? sa : function(i, n) {
    for (var O = e; !i.eol(); ) {
      var r = i.next();
      if (r == "{" && i.eat("-"))
        ++O;
      else if (r == "-" && i.eat("}") && (--O, O == 0))
        return n(sa), t;
    }
    return n(vx(t, O)), t;
  };
}
function Xx(t, e) {
  for (; !t.eol(); ) {
    var i = t.next();
    if (i == '"')
      return e(sa), "string";
    if (i == "\\") {
      if (t.eol() || t.eat(bx))
        return e(gj), "string";
      t.eat("&") || t.next();
    }
  }
  return e(sa), "error";
}
function gj(t, e) {
  return t.eat("\\") ? kd(t, e, Xx) : (t.next(), e(sa), "error");
}
var nP = function() {
  var t = {};
  function e(i) {
    return function() {
      for (var n = 0; n < arguments.length; n++)
        t[arguments[n]] = i;
    };
  }
  return e("keyword")(
    "case",
    "class",
    "data",
    "default",
    "deriving",
    "do",
    "else",
    "foreign",
    "if",
    "import",
    "in",
    "infix",
    "infixl",
    "infixr",
    "instance",
    "let",
    "module",
    "newtype",
    "of",
    "then",
    "type",
    "where",
    "_"
  ), e("keyword")(
    "..",
    ":",
    "::",
    "=",
    "\\",
    "<-",
    "->",
    "@",
    "~",
    "=>"
  ), e("builtin")(
    "!!",
    "$!",
    "$",
    "&&",
    "+",
    "++",
    "-",
    ".",
    "/",
    "/=",
    "<",
    "<*",
    "<=",
    "<$>",
    "<*>",
    "=<<",
    "==",
    ">",
    ">=",
    ">>",
    ">>=",
    "^",
    "^^",
    "||",
    "*",
    "*>",
    "**"
  ), e("builtin")(
    "Applicative",
    "Bool",
    "Bounded",
    "Char",
    "Double",
    "EQ",
    "Either",
    "Enum",
    "Eq",
    "False",
    "FilePath",
    "Float",
    "Floating",
    "Fractional",
    "Functor",
    "GT",
    "IO",
    "IOError",
    "Int",
    "Integer",
    "Integral",
    "Just",
    "LT",
    "Left",
    "Maybe",
    "Monad",
    "Nothing",
    "Num",
    "Ord",
    "Ordering",
    "Rational",
    "Read",
    "ReadS",
    "Real",
    "RealFloat",
    "RealFrac",
    "Right",
    "Show",
    "ShowS",
    "String",
    "True"
  ), e("builtin")(
    "abs",
    "acos",
    "acosh",
    "all",
    "and",
    "any",
    "appendFile",
    "asTypeOf",
    "asin",
    "asinh",
    "atan",
    "atan2",
    "atanh",
    "break",
    "catch",
    "ceiling",
    "compare",
    "concat",
    "concatMap",
    "const",
    "cos",
    "cosh",
    "curry",
    "cycle",
    "decodeFloat",
    "div",
    "divMod",
    "drop",
    "dropWhile",
    "either",
    "elem",
    "encodeFloat",
    "enumFrom",
    "enumFromThen",
    "enumFromThenTo",
    "enumFromTo",
    "error",
    "even",
    "exp",
    "exponent",
    "fail",
    "filter",
    "flip",
    "floatDigits",
    "floatRadix",
    "floatRange",
    "floor",
    "fmap",
    "foldl",
    "foldl1",
    "foldr",
    "foldr1",
    "fromEnum",
    "fromInteger",
    "fromIntegral",
    "fromRational",
    "fst",
    "gcd",
    "getChar",
    "getContents",
    "getLine",
    "head",
    "id",
    "init",
    "interact",
    "ioError",
    "isDenormalized",
    "isIEEE",
    "isInfinite",
    "isNaN",
    "isNegativeZero",
    "iterate",
    "last",
    "lcm",
    "length",
    "lex",
    "lines",
    "log",
    "logBase",
    "lookup",
    "map",
    "mapM",
    "mapM_",
    "max",
    "maxBound",
    "maximum",
    "maybe",
    "min",
    "minBound",
    "minimum",
    "mod",
    "negate",
    "not",
    "notElem",
    "null",
    "odd",
    "or",
    "otherwise",
    "pi",
    "pred",
    "print",
    "product",
    "properFraction",
    "pure",
    "putChar",
    "putStr",
    "putStrLn",
    "quot",
    "quotRem",
    "read",
    "readFile",
    "readIO",
    "readList",
    "readLn",
    "readParen",
    "reads",
    "readsPrec",
    "realToFrac",
    "recip",
    "rem",
    "repeat",
    "replicate",
    "return",
    "reverse",
    "round",
    "scaleFloat",
    "scanl",
    "scanl1",
    "scanr",
    "scanr1",
    "seq",
    "sequence",
    "sequence_",
    "show",
    "showChar",
    "showList",
    "showParen",
    "showString",
    "shows",
    "showsPrec",
    "significand",
    "signum",
    "sin",
    "sinh",
    "snd",
    "span",
    "splitAt",
    "sqrt",
    "subtract",
    "succ",
    "sum",
    "tail",
    "take",
    "takeWhile",
    "tan",
    "tanh",
    "toEnum",
    "toInteger",
    "toRational",
    "truncate",
    "uncurry",
    "undefined",
    "unlines",
    "until",
    "unwords",
    "unzip",
    "unzip3",
    "userError",
    "words",
    "writeFile",
    "zip",
    "zip3",
    "zipWith",
    "zipWith3"
  ), t;
}();
var mj = {
  name: "haskell",
  startState: function() {
    return { f: sa };
  },
  copyState: function(t) {
    return { f: t.f };
  },
  token: function(t, e) {
    var i = e.f(t, function(O) {
      e.f = O;
    }), n = t.current();
    return nP.hasOwnProperty(n) ? nP[n] : i;
  },
  languageData: {
    commentTokens: { line: "--", block: { open: "{-", close: "-}" } }
  }
};
var Sj = ["true", "false", "on", "off", "yes", "no"];
var Pj = new RegExp("\\b((" + Sj.join(")|(") + "))$", "i");
var yj = {
  name: "yaml",
  token: function(t, e) {
    var i = t.peek(), n = e.escaped;
    if (e.escaped = false, i == "#" && (t.pos == 0 || /\s/.test(t.string.charAt(t.pos - 1))))
      return t.skipToEnd(), "comment";
    if (t.match(/^('([^']|\\.)*'?|"([^"]|\\.)*"?)/))
      return "string";
    if (e.literal && t.indentation() > e.keyCol)
      return t.skipToEnd(), "string";
    if (e.literal && (e.literal = false), t.sol()) {
      if (e.keyCol = 0, e.pair = false, e.pairStart = false, t.match("---") || t.match("..."))
        return "def";
      if (t.match(/^\s*-\s+/))
        return "meta";
    }
    if (t.match(/^(\{|\}|\[|\])/))
      return i == "{" ? e.inlinePairs++ : i == "}" ? e.inlinePairs-- : i == "[" ? e.inlineList++ : e.inlineList--, "meta";
    if (e.inlineList > 0 && !n && i == ",")
      return t.next(), "meta";
    if (e.inlinePairs > 0 && !n && i == ",")
      return e.keyCol = 0, e.pair = false, e.pairStart = false, t.next(), "meta";
    if (e.pairStart) {
      if (t.match(/^\s*(\||\>)\s*/))
        return e.literal = true, "meta";
      if (t.match(/^\s*(\&|\*)[a-z0-9\._-]+\b/i))
        return "variable";
      if (e.inlinePairs == 0 && t.match(/^\s*-?[0-9\.\,]+\s?$/) || e.inlinePairs > 0 && t.match(/^\s*-?[0-9\.\,]+\s?(?=(,|}))/))
        return "number";
      if (t.match(Pj))
        return "keyword";
    }
    return !e.pair && t.match(/^\s*(?:[,\[\]{}&*!|>'"%@`][^\s'":]|[^,\[\]{}#&*!|>'"%@`])[^#]*?(?=\s*:($|\s))/) ? (e.pair = true, e.keyCol = t.indentation(), "atom") : e.pair && t.match(/^:\s*/) ? (e.pairStart = true, "meta") : (e.pairStart = false, e.escaped = i == "\\", t.next(), null);
  },
  startState: function() {
    return {
      pair: false,
      pairStart: false,
      keyCol: 0,
      inlinePairs: 0,
      inlineList: 0,
      literal: false,
      escaped: false
    };
  },
  languageData: {
    commentTokens: { line: "#" }
  }
};
var _d = {};
function v$(t, e) {
  for (var i = 0; i < e.length; i++)
    _d[e[i]] = t;
}
var xx = ["true", "false"];
var wx = [
  "if",
  "then",
  "do",
  "else",
  "elif",
  "while",
  "until",
  "for",
  "in",
  "esac",
  "fi",
  "fin",
  "fil",
  "done",
  "exit",
  "set",
  "unset",
  "export",
  "function"
];
var Tx = [
  "ab",
  "awk",
  "bash",
  "beep",
  "cat",
  "cc",
  "cd",
  "chown",
  "chmod",
  "chroot",
  "clear",
  "cp",
  "curl",
  "cut",
  "diff",
  "echo",
  "find",
  "gawk",
  "gcc",
  "get",
  "git",
  "grep",
  "hg",
  "kill",
  "killall",
  "ln",
  "ls",
  "make",
  "mkdir",
  "openssl",
  "mv",
  "nc",
  "nl",
  "node",
  "npm",
  "ping",
  "ps",
  "restart",
  "rm",
  "rmdir",
  "sed",
  "service",
  "sh",
  "shopt",
  "shred",
  "source",
  "sort",
  "sleep",
  "ssh",
  "start",
  "stop",
  "su",
  "sudo",
  "svn",
  "tee",
  "telnet",
  "top",
  "touch",
  "vi",
  "vim",
  "wall",
  "wc",
  "wget",
  "who",
  "write",
  "yes",
  "zsh"
];
v$("atom", xx);
v$("keyword", wx);
v$("builtin", Tx);
function bj(t, e) {
  if (t.eatSpace())
    return null;
  var i = t.sol(), n = t.next();
  if (n === "\\")
    return t.next(), null;
  if (n === "'" || n === '"' || n === "`")
    return e.tokens.unshift(gu(n, n === "`" ? "quote" : "string")), la(t, e);
  if (n === "#")
    return i && t.eat("!") ? (t.skipToEnd(), "meta") : (t.skipToEnd(), "comment");
  if (n === "$")
    return e.tokens.unshift(kx), la(t, e);
  if (n === "+" || n === "=")
    return "operator";
  if (n === "-")
    return t.eat("-"), t.eatWhile(/\w/), "attribute";
  if (n == "<") {
    if (t.match("<<"))
      return "operator";
    var O = t.match(/^<-?\s*['"]?([^'"]*)['"]?/);
    if (O)
      return e.tokens.unshift(Xj(O[1])), "string.special";
  }
  if (/\d/.test(n) && (t.eatWhile(/\d/), t.eol() || !/\w/.test(t.peek())))
    return "number";
  t.eatWhile(/[\w-]/);
  var r = t.current();
  return t.peek() === "=" && /\w+/.test(r) ? "def" : _d.hasOwnProperty(r) ? _d[r] : null;
}
function gu(t, e) {
  var i = t == "(" ? ")" : t == "{" ? "}" : t;
  return function(n, O) {
    for (var r, a = false; (r = n.next()) != null; ) {
      if (r === i && !a) {
        O.tokens.shift();
        break;
      } else if (r === "$" && !a && t !== "'" && n.peek() != i) {
        a = true, n.backUp(1), O.tokens.unshift(kx);
        break;
      } else {
        if (!a && t !== i && r === t)
          return O.tokens.unshift(gu(t, e)), la(n, O);
        if (!a && /['"]/.test(r) && !/['"]/.test(t)) {
          O.tokens.unshift(vj(r, "string")), n.backUp(1);
          break;
        }
      }
      a = !a && r === "\\";
    }
    return e;
  };
}
function vj(t, e) {
  return function(i, n) {
    return n.tokens[0] = gu(t, e), i.next(), la(i, n);
  };
}
var kx = function(t, e) {
  e.tokens.length > 1 && t.eat("$");
  var i = t.next();
  return /['"({]/.test(i) ? (e.tokens[0] = gu(i, i == "(" ? "quote" : i == "{" ? "def" : "string"), la(t, e)) : (/\d/.test(i) || t.eatWhile(/\w/), e.tokens.shift(), "def");
};
function Xj(t) {
  return function(e, i) {
    return e.sol() && e.string == t && i.tokens.shift(), e.skipToEnd(), "string.special";
  };
}
function la(t, e) {
  return (e.tokens[0] || bj)(t, e);
}
var xj = {
  name: "shell",
  startState: function() {
    return { tokens: [] };
  },
  token: function(t, e) {
    return la(t, e);
  },
  languageData: {
    autocomplete: xx.concat(wx, Tx),
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "#" }
  }
};
function mu(t) {
  for (var e = {}, i = 0; i < t.length; ++i)
    e[t[i]] = true;
  return e;
}
var _x = ["NULL", "NA", "Inf", "NaN", "NA_integer_", "NA_real_", "NA_complex_", "NA_character_", "TRUE", "FALSE"];
var Wx = ["list", "quote", "bquote", "eval", "return", "call", "parse", "deparse"];
var Yx = ["if", "else", "repeat", "while", "function", "for", "in", "next", "break"];
var wj = ["if", "else", "repeat", "while", "function", "for"];
var Tj = mu(_x);
var kj = mu(Wx);
var _j = mu(Yx);
var Wj = mu(wj);
var OP = /[+\-*\/^<>=!&|~$:]/;
var Fi;
function Wd(t, e) {
  Fi = null;
  var i = t.next();
  if (i == "#")
    return t.skipToEnd(), "comment";
  if (i == "0" && t.eat("x"))
    return t.eatWhile(/[\da-f]/i), "number";
  if (i == "." && t.eat(/\d/))
    return t.match(/\d*(?:e[+\-]?\d+)?/), "number";
  if (/\d/.test(i))
    return t.match(/\d*(?:\.\d+)?(?:e[+\-]\d+)?L?/), "number";
  if (i == "'" || i == '"')
    return e.tokenize = Yj(i), "string";
  if (i == "`")
    return t.match(/[^`]+`/), "string.special";
  if (i == "." && t.match(/.(?:[.]|\d+)/))
    return "keyword";
  if (/[a-zA-Z\.]/.test(i)) {
    t.eatWhile(/[\w\.]/);
    var n = t.current();
    return Tj.propertyIsEnumerable(n) ? "atom" : _j.propertyIsEnumerable(n) ? (Wj.propertyIsEnumerable(n) && !t.match(/\s*if(\s+|$)/, false) && (Fi = "block"), "keyword") : kj.propertyIsEnumerable(n) ? "builtin" : "variable";
  } else
    return i == "%" ? (t.skipTo("%") && t.next(), "variableName.special") : i == "<" && t.eat("-") || i == "<" && t.match("<-") || i == "-" && t.match(/>>?/) || i == "=" && e.ctx.argList ? "operator" : OP.test(i) ? (i == "$" || t.eatWhile(OP), "operator") : /[\(\){}\[\];]/.test(i) ? (Fi = i, i == ";" ? "punctuation" : null) : null;
}
function Yj(t) {
  return function(e, i) {
    if (e.eat("\\")) {
      var n = e.next();
      return n == "x" ? e.match(/^[a-f0-9]{2}/i) : (n == "u" || n == "U") && e.eat("{") && e.skipTo("}") ? e.next() : n == "u" ? e.match(/^[a-f0-9]{4}/i) : n == "U" ? e.match(/^[a-f0-9]{8}/i) : /[0-7]/.test(n) && e.match(/^[0-7]{1,2}/), "string.special";
    } else {
      for (var O; (O = e.next()) != null; ) {
        if (O == t) {
          i.tokenize = Wd;
          break;
        }
        if (O == "\\") {
          e.backUp(1);
          break;
        }
      }
      return "string";
    }
  };
}
var rP = 1;
var qf = 2;
var zf = 4;
function hl(t, e, i) {
  t.ctx = {
    type: e,
    indent: t.indent,
    flags: 0,
    column: i.column(),
    prev: t.ctx
  };
}
function aP(t, e) {
  var i = t.ctx;
  t.ctx = {
    type: i.type,
    indent: i.indent,
    flags: i.flags | e,
    column: i.column,
    prev: i.prev
  };
}
function Cf(t) {
  t.indent = t.ctx.indent, t.ctx = t.ctx.prev;
}
var Rj = {
  name: "r",
  startState: function(t) {
    return {
      tokenize: Wd,
      ctx: {
        type: "top",
        indent: -t,
        flags: qf
      },
      indent: 0,
      afterIdent: false
    };
  },
  token: function(t, e) {
    if (t.sol() && (e.ctx.flags & 3 || (e.ctx.flags |= qf), e.ctx.flags & zf && Cf(e), e.indent = t.indentation()), t.eatSpace())
      return null;
    var i = e.tokenize(t, e);
    return i != "comment" && !(e.ctx.flags & qf) && aP(e, rP), (Fi == ";" || Fi == "{" || Fi == "}") && e.ctx.type == "block" && Cf(e), Fi == "{" ? hl(e, "}", t) : Fi == "(" ? (hl(e, ")", t), e.afterIdent && (e.ctx.argList = true)) : Fi == "[" ? hl(e, "]", t) : Fi == "block" ? hl(e, "block", t) : Fi == e.ctx.type ? Cf(e) : e.ctx.type == "block" && i != "comment" && aP(e, zf), e.afterIdent = i == "variable" || i == "keyword", i;
  },
  indent: function(t, e, i) {
    if (t.tokenize != Wd)
      return 0;
    var n = e && e.charAt(0), O = t.ctx, r = n == O.type;
    return O.flags & zf && (O = O.prev), O.type == "block" ? O.indent + (n == "{" ? 0 : i.unit) : O.flags & rP ? O.column + (r ? 0 : 1) : O.indent + (r ? 0 : i.unit);
  },
  languageData: {
    wordChars: ".",
    commentTokens: { line: "#" },
    autocomplete: _x.concat(Wx, Yx)
  }
};
var Zj = {
  name: "toml",
  startState: function() {
    return {
      inString: false,
      stringType: "",
      lhs: true,
      inArray: 0
    };
  },
  token: function(t, e) {
    if (!e.inString && (t.peek() == '"' || t.peek() == "'") && (e.stringType = t.peek(), t.next(), e.inString = true), t.sol() && e.inArray === 0 && (e.lhs = true), e.inString) {
      for (; e.inString && !t.eol(); )
        t.peek() === e.stringType ? (t.next(), e.inString = false) : t.peek() === "\\" ? (t.next(), t.next()) : t.match(/^.[^\\\"\']*/);
      return e.lhs ? "property" : "string";
    } else {
      if (e.inArray && t.peek() === "]")
        return t.next(), e.inArray--, "bracket";
      if (e.lhs && t.peek() === "[" && t.skipTo("]"))
        return t.next(), t.peek() === "]" && t.next(), "atom";
      if (t.peek() === "#")
        return t.skipToEnd(), "comment";
      if (t.eatSpace())
        return null;
      if (e.lhs && t.eatWhile(function(i) {
        return i != "=" && i != " ";
      }))
        return "property";
      if (e.lhs && t.peek() === "=")
        return t.next(), e.lhs = false, null;
      if (!e.lhs && t.match(/^\d\d\d\d[\d\-\:\.T]*Z/))
        return "atom";
      if (!e.lhs && (t.match("true") || t.match("false")))
        return "atom";
      if (!e.lhs && t.peek() === "[")
        return e.inArray++, t.next(), "bracket";
      if (!e.lhs && t.match(/^\-?\d+(?:\.\d+)?/))
        return "number";
      t.eatSpace() || t.next();
    }
    return null;
  },
  languageData: {
    commentTokens: { line: "#" }
  }
};
var Uj = {
  name: "properties",
  token: function(t, e) {
    var i = t.sol() || e.afterSection, n = t.eol();
    if (e.afterSection = false, i && (e.nextMultiline ? (e.inMultiline = true, e.nextMultiline = false) : e.position = "def"), n && !e.nextMultiline && (e.inMultiline = false, e.position = "def"), i)
      for (; t.eatSpace(); )
        ;
    var O = t.next();
    return i && (O === "#" || O === "!" || O === ";") ? (e.position = "comment", t.skipToEnd(), "comment") : i && O === "[" ? (e.afterSection = true, t.skipTo("]"), t.eat("]"), "header") : O === "=" || O === ":" ? (e.position = "quote", null) : (O === "\\" && e.position === "quote" && t.eol() && (e.nextMultiline = true), e.position);
  },
  startState: function() {
    return {
      position: "def",
      // Current position, "def", "quote" or "comment"
      nextMultiline: false,
      // Is the next line multiline value
      inMultiline: false,
      // Is the current line a multiline value
      afterSection: false
      // Did we just open a section
    };
  }
};
function Za(t, e) {
  return new RegExp((e ? "" : "^") + "(?:" + t.join("|") + ")" + (e ? "$" : "\\b"));
}
function Jn(t, e, i) {
  return i.tokenize.push(t), t(e, i);
}
var Yd = /^(?:[-+/%|&^]|\*\*?|[<>]{2})/;
var Rd = /^(?:[=!]~|===|<=>|[<>=!]=?|[|&]{2}|~)/;
var Rx = /^(?:\[\][?=]?)/;
var Vj = /^(?:\.(?:\.{2})?|->|[?:])/;
var Wo = /^[a-z_\u009F-\uFFFF][a-zA-Z0-9_\u009F-\uFFFF]*/;
var zl = /^[A-Z_\u009F-\uFFFF][a-zA-Z0-9_\u009F-\uFFFF]*/;
var qj = Za([
  "abstract",
  "alias",
  "as",
  "asm",
  "begin",
  "break",
  "case",
  "class",
  "def",
  "do",
  "else",
  "elsif",
  "end",
  "ensure",
  "enum",
  "extend",
  "for",
  "fun",
  "if",
  "include",
  "instance_sizeof",
  "lib",
  "macro",
  "module",
  "next",
  "of",
  "out",
  "pointerof",
  "private",
  "protected",
  "rescue",
  "return",
  "require",
  "select",
  "sizeof",
  "struct",
  "super",
  "then",
  "type",
  "typeof",
  "uninitialized",
  "union",
  "unless",
  "until",
  "when",
  "while",
  "with",
  "yield",
  "__DIR__",
  "__END_LINE__",
  "__FILE__",
  "__LINE__"
]);
var zj = Za(["true", "false", "nil", "self"]);
var Cj = [
  "def",
  "fun",
  "macro",
  "class",
  "module",
  "struct",
  "lib",
  "enum",
  "union",
  "do",
  "for"
];
var Ej = Za(Cj);
var jj = ["if", "unless", "case", "while", "until", "begin", "then"];
var Ij = Za(jj);
var Zx = ["end", "else", "elsif", "rescue", "ensure"];
var Aj = Za(Zx);
var Ux = ["\\)", "\\}", "\\]"];
var Gj = new RegExp("^(?:" + Ux.join("|") + ")$");
var oP = {
  def: sP,
  fun: sP,
  macro: Lj,
  class: xr,
  module: xr,
  struct: xr,
  lib: xr,
  enum: xr,
  union: xr
};
var Ef = { "[": "]", "{": "}", "(": ")", "<": ">" };
function X$(t, e) {
  if (t.eatSpace())
    return null;
  if (e.lastToken != "\\" && t.match("{%", false))
    return Jn(nr("%", "%"), t, e);
  if (e.lastToken != "\\" && t.match("{{", false))
    return Jn(nr("{", "}"), t, e);
  if (t.peek() == "#")
    return t.skipToEnd(), "comment";
  var i;
  if (t.match(Wo))
    return t.eat(/[?!]/), i = t.current(), t.eat(":") ? "atom" : e.lastToken == "." ? "property" : qj.test(i) ? (Ej.test(i) ? !(i == "fun" && e.blocks.indexOf("lib") >= 0) && !(i == "def" && e.lastToken == "abstract") && (e.blocks.push(i), e.currentIndent += 1) : (e.lastStyle == "operator" || !e.lastStyle) && Ij.test(i) ? (e.blocks.push(i), e.currentIndent += 1) : i == "end" && (e.blocks.pop(), e.currentIndent -= 1), oP.hasOwnProperty(i) && e.tokenize.push(oP[i]), "keyword") : zj.test(i) ? "atom" : "variable";
  if (t.eat("@"))
    return t.peek() == "[" ? Jn(cs("[", "]", "meta"), t, e) : (t.eat("@"), t.match(Wo) || t.match(zl), "propertyName");
  if (t.match(zl))
    return "tag";
  if (t.eat(":"))
    return t.eat('"') ? Jn(jf('"', "atom", false), t, e) : t.match(Wo) || t.match(zl) || t.match(Yd) || t.match(Rd) || t.match(Rx) ? "atom" : (t.eat(":"), "operator");
  if (t.eat('"'))
    return Jn(jf('"', "string", true), t, e);
  if (t.peek() == "%") {
    var n = "string", O = true, r;
    if (t.match("%r"))
      n = "string.special", r = t.next();
    else if (t.match("%w"))
      O = false, r = t.next();
    else if (t.match("%q"))
      O = false, r = t.next();
    else if (r = t.match(/^%([^\w\s=])/))
      r = r[1];
    else {
      if (t.match(/^%[a-zA-Z_\u009F-\uFFFF][\w\u009F-\uFFFF]*/))
        return "meta";
      if (t.eat("%"))
        return "operator";
    }
    return Ef.hasOwnProperty(r) && (r = Ef[r]), Jn(jf(r, n, O), t, e);
  }
  return (i = t.match(/^<<-('?)([A-Z]\w*)\1/)) ? Jn(Dj(i[2], !i[1]), t, e) : t.eat("'") ? (t.match(/^(?:[^']|\\(?:[befnrtv0'"]|[0-7]{3}|u(?:[0-9a-fA-F]{4}|\{[0-9a-fA-F]{1,6}\})))/), t.eat("'"), "atom") : t.eat("0") ? (t.eat("x") ? t.match(/^[0-9a-fA-F_]+/) : t.eat("o") ? t.match(/^[0-7_]+/) : t.eat("b") && t.match(/^[01_]+/), "number") : t.eat(/^\d/) ? (t.match(/^[\d_]*(?:\.[\d_]+)?(?:[eE][+-]?\d+)?/), "number") : t.match(Yd) ? (t.eat("="), "operator") : t.match(Rd) || t.match(Vj) ? "operator" : (i = t.match(/[({[]/, false)) ? (i = i[0], Jn(cs(i, Ef[i], null), t, e)) : t.eat("\\") ? (t.next(), "meta") : (t.next(), null);
}
function cs(t, e, i, n) {
  return function(O, r) {
    if (!n && O.match(t))
      return r.tokenize[r.tokenize.length - 1] = cs(t, e, i, true), r.currentIndent += 1, i;
    var a = X$(O, r);
    return O.current() === e && (r.tokenize.pop(), r.currentIndent -= 1, a = i), a;
  };
}
function nr(t, e, i) {
  return function(n, O) {
    return !i && n.match("{" + t) ? (O.currentIndent += 1, O.tokenize[O.tokenize.length - 1] = nr(t, e, true), "meta") : n.match(e + "}") ? (O.currentIndent -= 1, O.tokenize.pop(), "meta") : X$(n, O);
  };
}
function Lj(t, e) {
  if (t.eatSpace())
    return null;
  var i;
  if (i = t.match(Wo)) {
    if (i == "def")
      return "keyword";
    t.eat(/[?!]/);
  }
  return e.tokenize.pop(), "def";
}
function sP(t, e) {
  return t.eatSpace() ? null : (t.match(Wo) ? t.eat(/[!?]/) : t.match(Yd) || t.match(Rd) || t.match(Rx), e.tokenize.pop(), "def");
}
function xr(t, e) {
  return t.eatSpace() ? null : (t.match(zl), e.tokenize.pop(), "def");
}
function jf(t, e, i) {
  return function(n, O) {
    for (var r = false; n.peek(); )
      if (r)
        n.next(), r = false;
      else {
        if (n.match("{%", false))
          return O.tokenize.push(nr("%", "%")), e;
        if (n.match("{{", false))
          return O.tokenize.push(nr("{", "}")), e;
        if (i && n.match("#{", false))
          return O.tokenize.push(cs("#{", "}", "meta")), e;
        var a = n.next();
        if (a == t)
          return O.tokenize.pop(), e;
        r = i && a == "\\";
      }
    return e;
  };
}
function Dj(t, e) {
  return function(i, n) {
    if (i.sol() && (i.eatSpace(), i.match(t)))
      return n.tokenize.pop(), "string";
    for (var O = false; i.peek(); )
      if (O)
        i.next(), O = false;
      else {
        if (i.match("{%", false))
          return n.tokenize.push(nr("%", "%")), "string";
        if (i.match("{{", false))
          return n.tokenize.push(nr("{", "}")), "string";
        if (e && i.match("#{", false))
          return n.tokenize.push(cs("#{", "}", "meta")), "string";
        O = e && i.next() == "\\";
      }
    return "string";
  };
}
var Mj = {
  name: "crystal",
  startState: function() {
    return {
      tokenize: [X$],
      currentIndent: 0,
      lastToken: null,
      lastStyle: null,
      blocks: []
    };
  },
  token: function(t, e) {
    var i = e.tokenize[e.tokenize.length - 1](t, e), n = t.current();
    return i && i != "comment" && (e.lastToken = n, e.lastStyle = i), i;
  },
  indent: function(t, e, i) {
    return e = e.replace(/^\s*(?:\{%)?\s*|\s*(?:%\})?\s*$/g, ""), Aj.test(e) || Gj.test(e) ? i.unit * (t.currentIndent - 1) : i.unit * t.currentIndent;
  },
  languageData: {
    indentOnInput: Za(Ux.concat(Zx), true),
    commentTokens: { line: "#" }
  }
};
function mt() {
  return mt = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var i = arguments[e];
      for (var n in i)
        Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n]);
    }
    return t;
  }, mt.apply(this, arguments);
}
var zt = (t) => {
  var {
    theme: e,
    settings: i = {},
    styles: n = []
  } = t, O = {
    ".cm-gutters": {}
  }, r = {};
  i.background && (r.backgroundColor = i.background), i.foreground && (r.color = i.foreground), (i.background || i.foreground) && (O["&"] = r), i.fontFamily && (O["&.cm-editor .cm-scroller"] = {
    fontFamily: i.fontFamily
  }), i.gutterBackground && (O[".cm-gutters"].backgroundColor = i.gutterBackground), i.gutterForeground && (O[".cm-gutters"].color = i.gutterForeground), i.gutterBorder && (O[".cm-gutters"].borderRightColor = i.gutterBorder), i.caret && (O[".cm-content"] = {
    caretColor: i.caret
  }, O[".cm-cursor, .cm-dropCursor"] = {
    borderLeftColor: i.caret
  });
  var a = {};
  i.gutterActiveForeground && (a.color = i.gutterActiveForeground), i.lineHighlight && (O[".cm-activeLine"] = {
    backgroundColor: i.lineHighlight
  }, a.backgroundColor = i.lineHighlight), O[".cm-activeLineGutter"] = a, i.selection && (O["&.cm-focused .cm-selectionBackground, & .cm-selectionLayer .cm-selectionBackground, .cm-content ::selection"] = {
    backgroundColor: i.selection
  }), i.selectionMatch && (O["& .cm-selectionMatch"] = {
    backgroundColor: i.selectionMatch
  });
  var o = B.theme(O, {
    dark: e === "dark"
  }), s = Wa.define(n), l = [o, jp(s)];
  return l;
};
var Nj = {
  background: "#0f0f0f",
  foreground: "#defdef",
  caret: "#00FF00",
  selection: "#515151",
  selectionMatch: "#515151",
  gutterBackground: "#555",
  gutterForeground: "#FFFFFF",
  lineHighlight: "#314151"
};
var Bj = (t) => {
  var {
    theme: e = "dark",
    settings: i = {},
    styles: n = []
  } = t || {};
  return zt({
    theme: e,
    settings: mt({}, Nj, i),
    styles: [
      {
        tag: f.keyword,
        color: "darkgoldenrod",
        fontWeight: "bold"
      },
      {
        tag: f.atom,
        color: "#77F"
      },
      {
        tag: f.comment,
        color: "#7a7b7c",
        fontStyle: "italic"
      },
      {
        tag: f.number,
        color: "violet"
      },
      {
        tag: f.definition(f.variableName),
        color: "#fffabc"
      },
      {
        tag: f.variableName,
        color: "#abcdef"
      },
      {
        tag: f.function(f.variableName),
        color: "#fffabc"
      },
      {
        tag: f.typeName,
        color: "#FFDD44"
      },
      {
        tag: f.tagName,
        color: "#def"
      },
      {
        tag: f.string,
        color: "#2b4"
      },
      {
        tag: f.meta,
        color: "#C9F"
      },
      // { tag: t.qualifier, color: '#FFF700' },
      // { tag: t.builtin, color: '#30aabc' },
      {
        tag: f.bracket,
        color: "#8a8a8a"
      },
      {
        tag: f.attributeName,
        color: "#DDFF00"
      },
      {
        tag: f.heading,
        color: "aquamarine",
        fontWeight: "bold"
      },
      {
        tag: f.link,
        color: "blueviolet",
        fontWeight: "bold"
      },
      ...n
    ]
  });
};
var Fj = Bj();
var Hj = {
  background: "#282b2e",
  foreground: "#a9b7c6",
  caret: "#00FF00",
  selection: "#343739",
  selectionMatch: "#343739",
  lineHighlight: "#343739"
};
var Kj = (t) => {
  var {
    theme: e = "dark",
    settings: i = {},
    styles: n = []
  } = t || {};
  return zt({
    theme: e,
    settings: mt({}, Hj, i),
    styles: [{
      tag: [f.keyword, f.deleted, f.className],
      color: "#cc7832"
    }, {
      tag: [f.number, f.literal, f.derefOperator],
      color: "#6897bb"
    }, {
      tag: [f.link, f.variableName],
      color: "#629755"
    }, {
      tag: [f.comment, f.quote],
      color: "grey"
    }, {
      tag: [f.meta, f.documentMeta],
      color: "#bbb529"
    }, {
      tag: [f.string, f.propertyName, f.attributeValue],
      color: "#6a8759"
    }, {
      tag: [f.heading, f.typeName],
      color: "#ffc66d"
    }, {
      tag: [f.attributeName],
      color: "#a9b7c6"
    }, {
      tag: [f.emphasis],
      fontStyle: "italic"
    }, ...n]
  });
};
var Jj = Kj();
var e8 = {
  background: "#272C35",
  foreground: "#9d9b97",
  caret: "#797977",
  selection: "#ffffff30",
  selectionMatch: "#2B323D",
  gutterBackground: "#272C35",
  gutterForeground: "#465063",
  gutterBorder: "transparent",
  lineHighlight: "#2B323D"
};
var t8 = (t) => {
  var {
    theme: e = "dark",
    settings: i = {},
    styles: n = []
  } = t || {};
  return zt({
    theme: e,
    settings: mt({}, e8, i),
    styles: [{
      tag: [f.function(f.variableName), f.function(f.propertyName), f.url, f.processingInstruction],
      color: "hsl(207, 82%, 66%)"
    }, {
      tag: [f.tagName, f.heading],
      color: "#e06c75"
    }, {
      tag: f.comment,
      color: "#54636D"
    }, {
      tag: [f.propertyName],
      color: "hsl(220, 14%, 71%)"
    }, {
      tag: [f.attributeName, f.number],
      color: "hsl( 29, 54%, 61%)"
    }, {
      tag: f.className,
      color: "hsl( 39, 67%, 69%)"
    }, {
      tag: f.keyword,
      color: "hsl(286, 60%, 67%)"
    }, {
      tag: [f.string, f.regexp, f.special(f.propertyName)],
      color: "#98c379"
    }, ...n]
  });
};
var i8 = t8();
var n8 = {
  background: "#FFFFFF",
  foreground: "#000000",
  caret: "#FBAC52",
  selection: "#FFD420",
  selectionMatch: "#FFD420",
  gutterBackground: "#f5f5f5",
  gutterForeground: "#4D4D4C",
  gutterBorder: "transparent",
  lineHighlight: "#00000012"
};
var O8 = (t) => {
  var {
    theme: e = "light",
    settings: i = {},
    styles: n = []
  } = t || {};
  return zt({
    theme: e,
    settings: mt({}, n8, i),
    styles: [{
      tag: [f.meta, f.comment],
      color: "#804000"
    }, {
      tag: [f.keyword, f.strong],
      color: "#0000FF"
    }, {
      tag: [f.number],
      color: "#FF0080"
    }, {
      tag: [f.string],
      color: "#FF0080"
    }, {
      tag: [f.variableName],
      color: "#006600"
    }, {
      tag: [f.escape],
      color: "#33CC33"
    }, {
      tag: [f.tagName],
      color: "#1C02FF"
    }, {
      tag: [f.heading],
      color: "#0C07FF"
    }, {
      tag: [f.quote],
      color: "#000000"
    }, {
      tag: [f.list],
      color: "#B90690"
    }, {
      tag: [f.documentMeta],
      color: "#888888"
    }, {
      tag: [f.function(f.variableName)],
      color: "#0000A2"
    }, {
      tag: [f.definition(f.typeName), f.typeName],
      color: "#6D79DE"
    }, ...n]
  });
};
var r8 = O8();
var a8 = {
  background: "#28211c",
  foreground: "#9d9b97",
  caret: "#797977",
  selection: "#36312e",
  selectionMatch: "#4f382b",
  gutterBackground: "#28211c",
  gutterForeground: "#666666",
  lineHighlight: "rgba(255, 255, 255, 0.1)"
};
var o8 = (t) => {
  var {
    theme: e = "dark",
    settings: i = {},
    styles: n = []
  } = t || {};
  return zt({
    theme: e,
    settings: mt({}, a8, i),
    styles: [{
      tag: [f.atom, f.number, f.link, f.bool],
      color: "#9b859d"
    }, {
      tag: f.comment,
      color: "#937121"
    }, {
      tag: [f.keyword, f.tagName],
      color: "#cf6a4c"
    }, {
      tag: f.string,
      color: "#f9ee98"
    }, {
      tag: f.bracket,
      color: "#9d9b97"
    }, {
      tag: [f.variableName],
      color: "#5ea6ea"
    }, {
      tag: f.definition(f.variableName),
      color: "#cf7d34"
    }, {
      tag: [f.function(f.variableName), f.className],
      color: "#cf7d34"
    }, {
      tag: [f.propertyName, f.attributeName],
      color: "#54be0d"
    }, ...n]
  });
};
var s8 = o8();
var l8 = {
  background: "#2B2B2B",
  foreground: "#f8f8f2",
  caret: "#FFFFFF",
  selection: "rgba(255, 255, 255, 0.1)",
  selectionMatch: "rgba(255, 255, 255, 0.2)",
  gutterBackground: "rgba(255, 255, 255, 0.1)",
  gutterForeground: "#999",
  gutterBorder: "transparent",
  lineHighlight: "rgba(255, 255, 255, 0.1)"
};
var c8 = (t) => {
  var {
    theme: e = "dark",
    settings: i = {},
    styles: n = []
  } = t || {};
  return zt({
    theme: e,
    settings: mt({}, l8, i),
    styles: [{
      tag: [f.atom, f.number],
      color: "#bd93f9"
    }, {
      tag: [f.comment],
      color: "#61A151"
    }, {
      tag: [f.string],
      color: "#6A8759"
    }, {
      tag: [f.variableName, f.operator],
      color: "#A9B7C6"
    }, {
      tag: [f.meta, f.className],
      color: "#A9B7C6"
    }, {
      tag: [f.propertyName],
      color: "#FFC66D"
    }, {
      tag: [f.keyword],
      color: "#CC7832"
    }, {
      tag: [f.tagName],
      color: "#ff79c6"
    }, {
      tag: [f.typeName],
      color: "#ffb86c"
    }, ...n]
  });
};
var u8 = c8();
var f8 = {
  background: "#282a36",
  foreground: "#f8f8f2",
  caret: "#f8f8f0",
  selection: "rgba(255, 255, 255, 0.1)",
  selectionMatch: "rgba(255, 255, 255, 0.2)",
  gutterBackground: "#282a36",
  gutterForeground: "#6D8A88",
  gutterBorder: "transparent",
  lineHighlight: "rgba(255, 255, 255, 0.1)"
};
var h8 = (t) => {
  var {
    theme: e = "dark",
    settings: i = {},
    styles: n = []
  } = t || {};
  return zt({
    theme: e,
    settings: mt({}, f8, i),
    styles: [{
      tag: f.comment,
      color: "#6272a4"
    }, {
      tag: f.string,
      color: "#f1fa8c"
    }, {
      tag: f.atom,
      color: "#bd93f9"
    }, {
      tag: f.meta,
      color: "#f8f8f2"
    }, {
      tag: [f.keyword, f.operator, f.tagName],
      color: "#ff79c6"
    }, {
      tag: [f.function(f.propertyName), f.propertyName],
      color: "#66d9ef"
    }, {
      tag: [f.definition(f.variableName), f.function(f.variableName), f.className, f.attributeName],
      color: "#50fa7b"
    }, {
      tag: f.atom,
      color: "#bd93f9"
    }, ...n]
  });
};
var d8 = h8();
var p8 = {
  background: "#faf8f5",
  foreground: "#b29762",
  caret: "#93abdc",
  selection: "#e3dcce",
  selectionMatch: "#e3dcce",
  gutterBackground: "#faf8f5",
  gutterForeground: "#cdc4b1",
  gutterBorder: "transparent",
  lineHighlight: "#EFEFEF"
};
var $8 = (t) => {
  var {
    theme: e = "light",
    settings: i = {},
    styles: n = []
  } = t || {};
  return zt({
    theme: e,
    settings: mt({}, p8, i),
    styles: [{
      tag: [f.comment, f.bracket],
      color: "#b6ad9a"
    }, {
      tag: [f.atom, f.number, f.keyword, f.link, f.attributeName, f.quote],
      color: "#063289"
    }, {
      tag: [f.emphasis, f.heading, f.tagName, f.propertyName, f.variableName],
      color: "#2d2006"
    }, {
      tag: [f.typeName, f.url, f.string],
      color: "#896724"
    }, {
      tag: [f.operator, f.string],
      color: "#1659df"
    }, {
      tag: [f.propertyName],
      color: "#b29762"
    }, {
      tag: [f.unit, f.punctuation],
      color: "#063289"
    }, ...n]
  });
};
var Q8 = $8();
var g8 = {
  background: "#2a2734",
  foreground: "#6c6783",
  caret: "#ffad5c",
  selection: "rgba(255, 255, 255, 0.1)",
  gutterBackground: "#2a2734",
  gutterForeground: "#545167",
  lineHighlight: "#36334280"
};
var m8 = (t) => {
  var {
    theme: e = "dark",
    settings: i = {},
    styles: n = []
  } = t || {};
  return zt({
    theme: e,
    settings: mt({}, g8, i),
    styles: [{
      tag: [f.comment, f.bracket],
      color: "#6c6783"
    }, {
      tag: [f.atom, f.number, f.keyword, f.link, f.attributeName, f.quote],
      color: "#ffcc99"
    }, {
      tag: [f.emphasis, f.heading, f.tagName, f.propertyName, f.className, f.variableName],
      color: "#eeebff"
    }, {
      tag: [f.typeName, f.url],
      color: "#7a63ee"
    }, {
      tag: f.operator,
      color: "#ffad5c"
    }, {
      tag: f.string,
      color: "#ffb870"
    }, {
      tag: [f.propertyName],
      color: "#9a86fd"
    }, {
      tag: [f.unit, f.punctuation],
      color: "#e09142"
    }, ...n]
  });
};
var S8 = m8();
var P8 = {
  background: "#fff",
  foreground: "#000",
  caret: "#FFFFFF",
  selection: "#d7d4f0",
  selectionMatch: "#d7d4f0",
  gutterBackground: "#f7f7f7",
  gutterForeground: "#999",
  lineHighlight: "#e8f2ff",
  gutterBorder: "transparent"
};
var y8 = (t) => {
  var {
    theme: e = "light",
    settings: i = {},
    styles: n = []
  } = t || {};
  return zt({
    theme: e,
    settings: mt({}, P8, i),
    styles: [{
      tag: [f.comment],
      color: "#3F7F5F"
    }, {
      tag: [f.documentMeta],
      color: "#FF1717"
    }, {
      tag: f.keyword,
      color: "#7F0055",
      fontWeight: "bold"
    }, {
      tag: f.atom,
      color: "#00f"
    }, {
      tag: f.number,
      color: "#164"
    }, {
      tag: f.propertyName,
      color: "#164"
    }, {
      tag: [f.variableName, f.definition(f.variableName)],
      color: "#0000C0"
    }, {
      tag: f.function(f.variableName),
      color: "#0000C0"
    }, {
      tag: f.string,
      color: "#2A00FF"
    }, {
      tag: f.operator,
      color: "black"
    }, {
      tag: f.tagName,
      color: "#170"
    }, {
      tag: f.attributeName,
      color: "#00c"
    }, {
      tag: f.link,
      color: "#219"
    }, ...n]
  });
};
var b8 = y8();
var v8 = {
  background: "#fff",
  foreground: "#24292e",
  selection: "#BBDFFF",
  selectionMatch: "#BBDFFF",
  gutterBackground: "#fff",
  gutterForeground: "#6e7781"
};
var X8 = (t) => {
  var {
    theme: e = "light",
    settings: i = {},
    styles: n = []
  } = t || {};
  return zt({
    theme: e,
    settings: mt({}, v8, i),
    styles: [{
      tag: [f.standard(f.tagName), f.tagName],
      color: "#116329"
    }, {
      tag: [f.comment, f.bracket],
      color: "#6a737d"
    }, {
      tag: [f.className, f.propertyName],
      color: "#6f42c1"
    }, {
      tag: [f.variableName, f.attributeName, f.number, f.operator],
      color: "#005cc5"
    }, {
      tag: [f.keyword, f.typeName, f.typeOperator, f.typeName],
      color: "#d73a49"
    }, {
      tag: [f.string, f.meta, f.regexp],
      color: "#032f62"
    }, {
      tag: [f.name, f.quote],
      color: "#22863a"
    }, {
      tag: [f.heading],
      color: "#24292e",
      fontWeight: "bold"
    }, {
      tag: [f.emphasis],
      color: "#24292e",
      fontStyle: "italic"
    }, {
      tag: [f.deleted],
      color: "#b31d28",
      backgroundColor: "ffeef0"
    }, {
      tag: [f.atom, f.bool, f.special(f.variableName)],
      color: "#e36209"
    }, {
      tag: [f.url, f.escape, f.regexp, f.link],
      color: "#032f62"
    }, {
      tag: f.link,
      textDecoration: "underline"
    }, {
      tag: f.strikethrough,
      textDecoration: "line-through"
    }, {
      tag: f.invalid,
      color: "#cb2431"
    }, ...n]
  });
};
var x8 = X8();
var w8 = {
  background: "#0d1117",
  foreground: "#c9d1d9",
  caret: "#c9d1d9",
  selection: "#003d73",
  selectionMatch: "#003d73",
  lineHighlight: "#36334280"
};
var T8 = (t) => {
  var {
    theme: e = "dark",
    settings: i = {},
    styles: n = []
  } = t || {};
  return zt({
    theme: e,
    settings: mt({}, w8, i),
    styles: [{
      tag: [f.standard(f.tagName), f.tagName],
      color: "#7ee787"
    }, {
      tag: [f.comment, f.bracket],
      color: "#8b949e"
    }, {
      tag: [f.className, f.propertyName],
      color: "#d2a8ff"
    }, {
      tag: [f.variableName, f.attributeName, f.number, f.operator],
      color: "#79c0ff"
    }, {
      tag: [f.keyword, f.typeName, f.typeOperator, f.typeName],
      color: "#ff7b72"
    }, {
      tag: [f.string, f.meta, f.regexp],
      color: "#a5d6ff"
    }, {
      tag: [f.name, f.quote],
      color: "#7ee787"
    }, {
      tag: [f.heading],
      color: "#d2a8ff",
      fontWeight: "bold"
    }, {
      tag: [f.emphasis],
      color: "#d2a8ff",
      fontStyle: "italic"
    }, {
      tag: [f.deleted],
      color: "#ffdcd7",
      backgroundColor: "ffeef0"
    }, {
      tag: [f.atom, f.bool, f.special(f.variableName)],
      color: "#ffab70"
    }, {
      tag: f.link,
      textDecoration: "underline"
    }, {
      tag: f.strikethrough,
      textDecoration: "line-through"
    }, {
      tag: f.invalid,
      color: "#f97583"
    }, ...n]
  });
};
var k8 = T8();
var _8 = {
  background: "#272822",
  foreground: "#FFFFFF",
  caret: "#FFFFFF",
  selection: "#49483E",
  selectionMatch: "#49483E",
  gutterBackground: "#272822",
  gutterForeground: "#FFFFFF70",
  lineHighlight: "#00000059"
};
var W8 = (t) => {
  var {
    theme: e = "dark",
    settings: i = {},
    styles: n = []
  } = t || {};
  return zt({
    theme: e,
    settings: mt({}, _8, i),
    styles: [
      {
        tag: [f.comment, f.documentMeta],
        color: "#8292a2"
      },
      {
        tag: [f.number, f.bool, f.null, f.atom],
        color: "#ae81ff"
      },
      {
        tag: [f.attributeValue, f.className, f.name],
        color: "#e6db74"
      },
      {
        tag: [f.propertyName, f.attributeName],
        color: "#a6e22e"
      },
      {
        tag: [f.variableName],
        color: "#9effff"
      },
      {
        tag: [f.squareBracket],
        color: "#bababa"
      },
      {
        tag: [f.string, f.special(f.brace)],
        color: "#e6db74"
      },
      {
        tag: [f.regexp, f.className, f.typeName, f.definition(f.typeName)],
        color: "#66d9ef"
      },
      {
        tag: [f.definition(f.variableName), f.definition(f.propertyName), f.function(f.variableName)],
        color: "#fd971f"
      },
      // { tag: t.keyword, color: '#f92672' },
      {
        tag: [f.keyword, f.definitionKeyword, f.modifier, f.tagName, f.angleBracket],
        color: "#f92672"
      },
      ...n
    ]
  });
};
var Y8 = W8();
var R8 = "#e5c07b";
var lP = "#e06c75";
var Z8 = "#56b6c2";
var U8 = "#ffffff";
var Cl = "#abb2bf";
var Zd = "#7d8799";
var V8 = "#61afef";
var q8 = "#98c379";
var cP = "#d19a66";
var z8 = "#c678dd";
var C8 = "#21252b";
var uP = "#2c313a";
var fP = "#282c34";
var If = "#353a42";
var E8 = "#3E4451";
var hP = "#528bff";
var j8 = B.theme({
  "&": {
    color: Cl,
    backgroundColor: fP
  },
  ".cm-content": {
    caretColor: hP
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: hP },
  "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: E8 },
  ".cm-panels": { backgroundColor: C8, color: Cl },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: fP,
    color: Zd,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: uP
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: If
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: If,
    borderBottomColor: If
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: uP,
      color: Cl
    }
  }
}, { dark: true });
var I8 = Wa.define([
  {
    tag: f.keyword,
    color: z8
  },
  {
    tag: [f.name, f.deleted, f.character, f.propertyName, f.macroName],
    color: lP
  },
  {
    tag: [f.function(f.variableName), f.labelName],
    color: V8
  },
  {
    tag: [f.color, f.constant(f.name), f.standard(f.name)],
    color: cP
  },
  {
    tag: [f.definition(f.name), f.separator],
    color: Cl
  },
  {
    tag: [f.typeName, f.className, f.number, f.changed, f.annotation, f.modifier, f.self, f.namespace],
    color: R8
  },
  {
    tag: [f.operator, f.operatorKeyword, f.url, f.escape, f.regexp, f.link, f.special(f.string)],
    color: Z8
  },
  {
    tag: [f.meta, f.comment],
    color: Zd
  },
  {
    tag: f.strong,
    fontWeight: "bold"
  },
  {
    tag: f.emphasis,
    fontStyle: "italic"
  },
  {
    tag: f.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: f.link,
    color: Zd,
    textDecoration: "underline"
  },
  {
    tag: f.heading,
    fontWeight: "bold",
    color: lP
  },
  {
    tag: [f.atom, f.bool, f.special(f.variableName)],
    color: cP
  },
  {
    tag: [f.processingInstruction, f.string, f.inserted],
    color: q8
  },
  {
    tag: f.invalid,
    color: U8
  }
]);
var A8 = [j8, jp(I8)];
var G8 = {
  background: "#303841",
  foreground: "#FFFFFF",
  caret: "#FBAC52",
  selection: "#4C5964",
  selectionMatch: "#3A546E",
  gutterBackground: "#303841",
  gutterForeground: "#FFFFFF70",
  lineHighlight: "#00000059"
};
function L8(t) {
  var {
    theme: e = "dark",
    settings: i = {},
    styles: n = []
  } = t || {};
  return zt({
    theme: e,
    settings: mt({}, G8, i),
    styles: [
      {
        tag: [f.meta, f.comment],
        color: "#A2A9B5"
      },
      {
        tag: [f.attributeName, f.keyword],
        color: "#B78FBA"
      },
      {
        tag: f.function(f.variableName),
        color: "#5AB0B0"
      },
      {
        tag: [f.string, f.regexp, f.attributeValue],
        color: "#99C592"
      },
      {
        tag: f.operator,
        color: "#f47954"
      },
      // { tag: t.moduleKeyword, color: 'red' },
      {
        tag: [f.tagName, f.modifier],
        color: "#E35F63"
      },
      {
        tag: [f.number, f.definition(f.tagName), f.className, f.definition(f.variableName)],
        color: "#fbac52"
      },
      {
        tag: [f.atom, f.bool, f.special(f.variableName)],
        color: "#E35F63"
      },
      {
        tag: f.variableName,
        color: "#539ac4"
      },
      {
        tag: [f.propertyName, f.typeName],
        color: "#629ccd"
      },
      {
        tag: f.propertyName,
        color: "#36b7b5"
      },
      ...n
    ]
  });
}
var D8 = L8();
var M8 = {
  background: "#fff",
  foreground: "#3D3D3D",
  selection: "#BBDFFF",
  selectionMatch: "#BBDFFF",
  gutterBackground: "#fff",
  gutterForeground: "#AFAFAF",
  lineHighlight: "#EDF4FF"
};
function N8(t) {
  var {
    theme: e = "light",
    settings: i = {},
    styles: n = []
  } = t || {};
  return zt({
    theme: e,
    settings: mt({}, M8, i),
    styles: [{
      tag: [f.comment, f.quote],
      color: "#707F8D"
    }, {
      tag: [f.typeName, f.typeOperator],
      color: "#aa0d91"
    }, {
      tag: [f.keyword],
      color: "#aa0d91",
      fontWeight: "bold"
    }, {
      tag: [f.string, f.meta],
      color: "#D23423"
    }, {
      tag: [f.name],
      color: "#032f62"
    }, {
      tag: [f.typeName],
      color: "#522BB2"
    }, {
      tag: [f.variableName],
      color: "#23575C"
    }, {
      tag: [f.definition(f.variableName)],
      color: "#327A9E"
    }, {
      tag: [f.regexp, f.link],
      color: "#0e0eff"
    }, ...n]
  });
}
var B8 = N8();
var F8 = {
  background: "#292A30",
  foreground: "#CECFD0",
  caret: "#fff",
  selection: "#727377",
  selectionMatch: "#727377",
  lineHighlight: "#2F3239"
};
var H8 = (t) => {
  var {
    theme: e = "dark",
    settings: i = {},
    styles: n = []
  } = t || {};
  return zt({
    theme: e,
    settings: mt({}, F8, i),
    styles: [{
      tag: [f.comment, f.quote],
      color: "#7F8C98"
    }, {
      tag: [f.keyword],
      color: "#FF7AB2",
      fontWeight: "bold"
    }, {
      tag: [f.string, f.meta],
      color: "#FF8170"
    }, {
      tag: [f.typeName],
      color: "#DABAFF"
    }, {
      tag: [f.definition(f.variableName)],
      color: "#6BDFFF"
    }, {
      tag: [f.name],
      color: "#6BAA9F"
    }, {
      tag: [f.variableName],
      color: "#ACF2E4"
    }, {
      tag: [f.regexp, f.link],
      color: "#FF8170"
    }, ...n]
  });
};
var K8 = H8();
var J8 = {
  HTML: u$(),
  PYTHON: zq(),
  RUST: rz(),
  C: Ot.define(P6),
  CPP: Tz(),
  CSHARP: Ot.define(y6),
  CRYSTAL: Ot.define(Mj),
  OBJECTIVE_C: Ot.define(x6),
  KOTLIN: Ot.define(X6),
  DART: Ot.define(W6),
  PHP: KC(),
  PROPERTIES: Ot.define(Uj),
  JAVASCRIPT: go(),
  TYPESCRIPT: go({ typescript: true }),
  JSX: go({ jsx: true }),
  TSX: go({ typescript: true, jsx: true }),
  SQL: z4(),
  SHELL: Ot.define(xj),
  SCALA: Ot.define(b6),
  MARKDOWN: mE(),
  JAVA: vE(),
  XML: ME(),
  CSS: uX(),
  JSON: HE(),
  WEB_ASSEMBLY: t6(),
  LUA: Ot.define(l6),
  RUBY: Ot.define(g6),
  R: Ot.define(Rj),
  GO: Ot.define(U6),
  SWIFT: Ot.define(tj),
  ELM: Ot.define(fj),
  HASKELL: Ot.define(mj),
  YAML: Ot.define(yj),
  TOML: Ot.define(Zj)
};
var e9 = {
  ANDROID_STUDIO: Jj,
  ABCDEF: Fj,
  ATOMONE: i8,
  BBEDIT: r8,
  BESPIN: s8,
  DARCULA: u8,
  DRACULA: d8,
  DUOTONE_LIGHT: Q8,
  DUOTONE_DARK: S8,
  ECLIPSE: b8,
  GITHUB_LIGHT: x8,
  GITHUB_DARK: k8,
  ONE_DARK: A8,
  OKAIDIA: Y8,
  SUBLIME: D8,
  X_CODE_LIGHT: B8,
  X_CODE_DARK: K8
};
var t9 = {
  name: "HCodeEditor"
};
var i9 = defineComponent({
  ...t9,
  props: {
    modelValue: null,
    lang: { default: "JAVASCRIPT" },
    theme: null,
    placeholder: null,
    autofocus: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false },
    copyable: { type: Boolean },
    copyBtnPosition: null,
    hiddenGutter: { type: Boolean },
    isFocus: { type: Boolean },
    errorLine: null
  },
  emits: ["update:modelValue", "update:isFocus"],
  setup(t, { emit: e }) {
    const i = t, n = B.theme({
      "& .cm-scroller": {
        fontFamily: "var(--code-font-family)",
        "& .cm-gutters": {
          display: i.hiddenGutter ? "none" : null
        }
      },
      "&.cm-editor.cm-focused": {
        outline: "none"
      }
    }), O = ref(), r = ref(false);
    onMounted(async () => {
      r.value = await window.$he3.getTheme(), window.$he3.subscribeThemeChange((h10) => {
        r.value = h10;
      });
    }), watch(
      [() => i.lang, () => i.theme, () => r],
      ([h10, d, p]) => {
        O.value = [
          J8[h10],
          e9[d ?? (p ? "GITHUB_DARK" : "GITHUB_LIGHT")],
          n
        ];
      },
      {
        immediate: true
      }
    );
    const a = ref(), o = (h10) => {
      var d;
      h10 === 0 ? (d = a.value.querySelector(".error-line")) == null || d.classList.remove("error-line") : a.value.querySelectorAll(".cm-line")[h10 - 1].classList.add("error-line");
    }, s = () => {
      i.isFocus !== void 0 && e("update:isFocus", true);
    }, l = () => {
      i.isFocus !== void 0 && e("update:isFocus", false);
    }, c = () => {
      i.errorLine && o(i.errorLine);
    }, u = (h10) => {
      e("update:modelValue", h10);
    };
    return (h10, d) => (openBlock(), createElementBlock("div", {
      ref_key: "codeRef",
      ref: a,
      class: "code-editor-wrapper"
    }, [
      createVNode(unref(nU), {
        "model-value": i.modelValue,
        placeholder: i == null ? void 0 : i.placeholder,
        "indent-with-tab": true,
        "tab-size": 2,
        extensions: O.value,
        style: {
          width: "100%",
          height: "100%"
        },
        class: "code",
        autofocus: i.autofocus,
        disabled: i.disabled,
        onChange: u,
        onFocus: s,
        onBlur: l,
        onUpdate: c
      }, null, 8, ["model-value", "placeholder", "extensions", "autofocus", "disabled"])
    ], 512));
  }
});
var Vx = ei(i9, [["__scopeId", "data-v-39fb03b1"]]);
var ca = Be(Vx);
var n9 = {
  name: "HCodeResult"
};
var O9 = defineComponent({
  ...n9,
  props: {
    code: null,
    lang: null
  },
  setup(t) {
    const e = t;
    useCssVars((r) => ({
      "6dc8a138": unref(O)
    }));
    const i = ref(e.code), n = ref(false);
    onMounted(async () => {
      n.value = await window.$he3.getTheme(), window.$he3.subscribeThemeChange((r) => {
        n.value = r;
      });
    }), watch(
      () => e.code,
      (r) => {
        i.value = r;
      }
    );
    const O = computed(() => n.value ? "rgb(13, 17, 23)" : "#fff");
    return (r, a) => (openBlock(), createBlock(Vx, {
      "model-value": e.code,
      lang: e.lang,
      "hidden-gutter": "",
      disabled: "",
      copyable: "",
      class: "code-result"
    }, null, 8, ["model-value", "lang"]));
  }
});
var r9 = ei(O9, [["__scopeId", "data-v-83f77ac1"]]);
var qx = Be(r9);
var a9 = { class: "highlight-box" };
var o9 = ["innerHTML"];
var s9 = ["placeholder", "onKeyup"];
var l9 = ["innerHTML"];
var c9 = ["placeholder"];
var u9 = {
  name: "HHighlightInput"
};
var f9 = defineComponent({
  ...u9,
  props: {
    highlightText: null,
    highlightTextColor: { default: "var(--default-font-color)" },
    highlightColor: { default: "var(--hight-background)" },
    modelValue: null,
    placeholder: { default: "请输入" },
    type: { default: "textarea" },
    maxHeight: { default: "220px" },
    title: { default: "Input content:" },
    regexModifier: { default: "g" }
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const i = t;
    useCssVars((d) => ({
      e074f754: i.maxHeight,
      "2c41b944": i.highlightColor,
      bda840d2: i.highlightTextColor
    }));
    const n = ref(i.modelValue), O = ref(), r = ref(), a = ref();
    watch(n, () => {
      e("update:modelValue", n.value);
    }), onBeforeMount(() => {
      n.value = i.modelValue.replace(/(^\s*)|(\s*$)/g, "").replace(/<br \/>|<br\/>|<br>/g, `
`);
    }), onMounted(() => {
      c();
    });
    function o(d) {
      if ((!d || !i.highlightText || i.highlightText.length === 0) && i.type !== "textarea")
        return d;
      let p = s(d);
      if (i.highlightText.filter(($) => ~d.indexOf($)).length) {
        let $ = "", g = null;
        i.highlightText.forEach((Q) => {
          $ = u(Q), g = new RegExp($, i.regexModifier), p = p.replace(g, `<span>${Q}</span>`);
        });
      }
      if (i.type === "textarea") {
        p = p.replace(/\n/g, "<br/>").replace(/\s/g, "&nbsp;");
        const $ = r.value;
        $ && $.scrollHeight > i.maxHeight && (p = p + "<br/>");
      }
      return p;
    }
    const s = (d) => d ? d.replace(/[<">']/g, (p) => ({
      "<": "&lt;",
      '"': "&quot;",
      ">": "&gt;",
      "'": "&#39;"
    })[p]) : "";
    function l() {
      r.value.scrollHeight > i.maxHeight && a.value.scrollHeight !== r.value.scrollHeight && (a.value.style.height = `${r.value.scrollHeight}px`), r.value.scrollTop !== O.value.scrollTop && (O.value.scrollTop = r.value.scrollTop);
    }
    function c() {
      i.type !== "input" && nextTick(() => {
        h10("add");
      });
    }
    function u(d) {
      const p = [
        "(",
        ")",
        "[",
        "]",
        "{",
        "}",
        "^",
        "$",
        "|",
        "?",
        "*",
        "+",
        "."
      ];
      let $ = d.replace(new RegExp("\\\\", "g"), "\\\\");
      return p.forEach(function(g) {
        let Q = new RegExp("\\" + g, "g");
        $ = $.replace(Q, "\\" + g);
      }), $;
    }
    function h10(d) {
      if (r.value) {
        let p = /Firefox/i.test(navigator.userAgent) ? "DOMMouseScroll" : "mousewheel";
        r.value[`${d}EventListener`](p, l), r.value[`${d}EventListener`]("scroll", l);
      }
    }
    return onBeforeUnmount(() => {
      h10("remove");
    }), (d, p) => {
      const $ = resolveComponent("HIcon");
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("p", null, toDisplayString(i.title), 1),
        createVNode($, { "data-icon": "material-symbols:360" }),
        createBaseVNode("div", a9, [
          t.type === "textarea" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            n.value ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref_key: "textareaOuter",
              ref: O,
              class: "textarea-outer",
              style: normalizeStyle({ height: t.maxHeight })
            }, [
              createBaseVNode("div", {
                ref_key: "outerInner",
                ref: a,
                class: "outer-inner",
                innerHTML: o(n.value)
              }, null, 8, o9)
            ], 4)) : createCommentVNode("", true),
            withDirectives(createBaseVNode("textarea", {
              ref_key: "textareaBox",
              ref: r,
              "onUpdate:modelValue": p[0] || (p[0] = (g) => n.value = g),
              style: normalizeStyle({ height: t.maxHeight }),
              placeholder: t.placeholder,
              spellcheck: false,
              onKeyup: withKeys(l, ["enter"])
            }, `\r
        `, 44, s9), [
              [vModelText, n.value]
            ])
          ], 64)) : createCommentVNode("", true),
          t.type === "input" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            n.value ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "input-outer",
              innerHTML: o(n.value)
            }, null, 8, l9)) : createCommentVNode("", true),
            withDirectives(createBaseVNode("input", {
              "onUpdate:modelValue": p[1] || (p[1] = (g) => n.value = g),
              type: "text",
              placeholder: t.placeholder
            }, null, 8, c9), [
              [vModelText, n.value]
            ])
          ], 64)) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});
var h9 = Be(f9);
var d9 = {
  name: "HContentSaveButton",
  components: { HIcon: Bt }
};
var p9 = defineComponent({
  ...d9,
  props: {
    title: null,
    type: { default: "primary" },
    size: { default: "small" },
    saveText: null,
    icon: { type: Boolean },
    fileType: null,
    url: null
  },
  setup(t) {
    const e = t;
    function i() {
      if (e.saveText) {
        const n = new Blob([e.saveText], e == null ? void 0 : e.fileType), O = URL.createObjectURL(n);
        window.$he3.downloadByUrl(O);
        return;
      }
      if (e.url) {
        window.$he3.downloadByUrl(e.url);
        return;
      }
    }
    return (n, O) => {
      const r = resolveComponent("a-button");
      return openBlock(), createBlock(r, {
        type: t.type ?? "primary",
        size: t.size,
        onClick: i
      }, createSlots({
        default: withCtx(() => [
          createTextVNode(toDisplayString(t.title || n.$t("btnWithFun.saveAsFile")) + " ", 1)
        ]),
        _: 2
      }, [
        e.icon ? {
          name: "icon",
          fn: withCtx(() => [
            createVNode(unref(Bt), { icon: "ant-design:download-outlined" })
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["type", "size"]);
    };
  }
});
var $9 = {
  name: "HFileUploadButton"
};
var Q9 = defineComponent({
  ...$9,
  props: {
    title: null,
    type: { default: "primary" },
    size: { default: "small" },
    accept: null,
    icon: { type: Boolean },
    handleFileSelected: null
  },
  setup(t) {
    const e = t;
    function i(n) {
      return e.handleFileSelected(n), false;
    }
    return (n, O) => {
      const r = resolveComponent("a-button"), a = resolveComponent("a-upload");
      return openBlock(), createBlock(a, {
        class: "TransForm-left-content-btn",
        "before-upload": i,
        "max-count": 1,
        "show-upload-list": false,
        accept: t.accept
      }, {
        default: withCtx(() => [
          createVNode(r, {
            type: t.type,
            size: t.size
          }, createSlots({
            default: withCtx(() => [
              createTextVNode(toDisplayString(t.title || n.$t("btnWithFun.select")) + " ", 1)
            ]),
            _: 2
          }, [
            e.icon ? {
              name: "icon",
              fn: withCtx(() => [
                createVNode(unref(Bt), { icon: "ant-design:upload-outlined" })
              ]),
              key: "0"
            } : void 0
          ]), 1032, ["type", "size"])
        ]),
        _: 1
      }, 8, ["accept"]);
    };
  }
});
var yO = typeof window < "u";
var Si;
var Or;
if (true) {
  const t = yO && window.performance;
  t && t.mark && t.measure && t.clearMarks && t.clearMeasures && (Si = (e) => t.mark(e), Or = (e, i, n) => {
    t.measure(e, i, n), t.clearMarks(i), t.clearMarks(n);
  });
}
var g9 = /\{([0-9a-zA-Z]+)\}/g;
function Su(t, ...e) {
  return e.length === 1 && Ze(e[0]) && (e = e[0]), (!e || !e.hasOwnProperty) && (e = {}), t.replace(g9, (i, n) => e.hasOwnProperty(n) ? e[n] : "");
}
var m9 = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol";
var Nn = (t) => m9 ? Symbol(t) : t;
var S9 = (t, e, i) => P9({ l: t, k: e, s: i });
var P9 = (t) => JSON.stringify(t).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
var Yt = (t) => typeof t == "number" && isFinite(t);
var y9 = (t) => w$(t) === "[object Date]";
var ua = (t) => w$(t) === "[object RegExp]";
var Pu = (t) => be(t) && Object.keys(t).length === 0;
function _s(t, e) {
  typeof console < "u" && (console.warn("[intlify] " + t), e && console.warn(e.stack));
}
var kt = Object.assign;
var dP;
var Yo = () => dP || (dP = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function pP(t) {
  return t.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
var b9 = Object.prototype.hasOwnProperty;
function x$(t, e) {
  return b9.call(t, e);
}
var tt = Array.isArray;
var ut = (t) => typeof t == "function";
var F = (t) => typeof t == "string";
var Ce = (t) => typeof t == "boolean";
var Ze = (t) => (
  // eslint-disable-line
  t !== null && typeof t == "object"
);
var zx = Object.prototype.toString;
var w$ = (t) => zx.call(t);
var be = (t) => w$(t) === "[object Object]";
var v9 = (t) => t == null ? "" : tt(t) || be(t) && t.toString === zx ? JSON.stringify(t, null, 2) : String(t);
var $P = 2;
function X9(t, e = 0, i = t.length) {
  const n = t.split(/\r?\n/);
  let O = 0;
  const r = [];
  for (let a = 0; a < n.length; a++)
    if (O += n[a].length + 1, O >= e) {
      for (let o = a - $P; o <= a + $P || i > O; o++) {
        if (o < 0 || o >= n.length)
          continue;
        const s = o + 1;
        r.push(`${s}${" ".repeat(3 - String(s).length)}|  ${n[o]}`);
        const l = n[o].length;
        if (o === a) {
          const c = e - (O - l) + 1, u = Math.max(1, i > O ? l - c : i - e);
          r.push("   |  " + " ".repeat(c) + "^".repeat(u));
        } else if (o > a) {
          if (i > O) {
            const c = Math.max(Math.min(i - O, l), 1);
            r.push("   |  " + "^".repeat(c));
          }
          O += l + 1;
        }
      }
      break;
    }
  return r.join(`
`);
}
function x9() {
  const t = /* @__PURE__ */ new Map();
  return {
    events: t,
    on(i, n) {
      const O = t.get(i);
      O && O.push(n) || t.set(i, [n]);
    },
    off(i, n) {
      const O = t.get(i);
      O && O.splice(O.indexOf(n) >>> 0, 1);
    },
    emit(i, n) {
      (t.get(i) || []).slice().map((O) => O(n)), (t.get("*") || []).slice().map((O) => O(i, n));
    }
  };
}
var ce = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // Special value for higher-order compilers to pick up the last code
  // to avoid collision of error codes. This should always be kept as the last
  // item.
  __EXTEND_POINT__: 15
};
var w9 = {
  // tokenizer error messages
  [ce.EXPECTED_TOKEN]: "Expected token: '{0}'",
  [ce.INVALID_TOKEN_IN_PLACEHOLDER]: "Invalid token in placeholder: '{0}'",
  [ce.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: "Unterminated single quote in placeholder",
  [ce.UNKNOWN_ESCAPE_SEQUENCE]: "Unknown escape sequence: \\{0}",
  [ce.INVALID_UNICODE_ESCAPE_SEQUENCE]: "Invalid unicode escape sequence: {0}",
  [ce.UNBALANCED_CLOSING_BRACE]: "Unbalanced closing brace",
  [ce.UNTERMINATED_CLOSING_BRACE]: "Unterminated closing brace",
  [ce.EMPTY_PLACEHOLDER]: "Empty placeholder",
  [ce.NOT_ALLOW_NEST_PLACEHOLDER]: "Not allowed nest placeholder",
  [ce.INVALID_LINKED_FORMAT]: "Invalid linked format",
  // parser error messages
  [ce.MUST_HAVE_MESSAGES_IN_PLURAL]: "Plural must have messages",
  [ce.UNEXPECTED_EMPTY_LINKED_MODIFIER]: "Unexpected empty linked modifier",
  [ce.UNEXPECTED_EMPTY_LINKED_KEY]: "Unexpected empty linked key",
  [ce.UNEXPECTED_LEXICAL_ANALYSIS]: "Unexpected lexical analysis in token: '{0}'"
};
function yu(t, e, i = {}) {
  const { domain: n, messages: O, args: r } = i, a = true ? Su((O || w9)[t] || "", ...r || []) : t, o = new SyntaxError(String(a));
  return o.code = t, e && (o.location = e), o.domain = n, o;
}
function T9(t) {
  throw t;
}
function k9(t, e, i) {
  return { line: t, column: e, offset: i };
}
function Ud(t, e, i) {
  const n = { start: t, end: e };
  return i != null && (n.source = i), n;
}
var Tn = " ";
var _9 = "\r";
var At = `
`;
var W9 = String.fromCharCode(8232);
var Y9 = String.fromCharCode(8233);
function R9(t) {
  const e = t;
  let i = 0, n = 1, O = 1, r = 0;
  const a = (v) => e[v] === _9 && e[v + 1] === At, o = (v) => e[v] === At, s = (v) => e[v] === Y9, l = (v) => e[v] === W9, c = (v) => a(v) || o(v) || s(v) || l(v), u = () => i, h10 = () => n, d = () => O, p = () => r, $ = (v) => a(v) || s(v) || l(v) ? At : e[v], g = () => $(i), Q = () => $(i + r);
  function m() {
    return r = 0, c(i) && (n++, O = 0), a(i) && i++, i++, O++, e[i];
  }
  function b() {
    return a(i + r) && r++, r++, e[i + r];
  }
  function P() {
    i = 0, n = 1, O = 1, r = 0;
  }
  function S(v = 0) {
    r = v;
  }
  function y() {
    const v = i + r;
    for (; v !== i; )
      m();
    r = 0;
  }
  return {
    index: u,
    line: h10,
    column: d,
    peekOffset: p,
    charAt: $,
    currentChar: g,
    currentPeek: Q,
    next: m,
    peek: b,
    reset: P,
    resetPeek: S,
    skipToPeek: y
  };
}
var eO = void 0;
var QP = "'";
var Z9 = "tokenizer";
function U9(t, e = {}) {
  const i = e.location !== false, n = R9(t), O = () => n.index(), r = () => k9(n.line(), n.column(), n.index()), a = r(), o = O(), s = {
    currentType: 14,
    offset: o,
    startLoc: a,
    endLoc: a,
    lastType: 14,
    lastOffset: o,
    lastStartLoc: a,
    lastEndLoc: a,
    braceNest: 0,
    inLinked: false,
    text: ""
  }, l = () => s, { onError: c } = e;
  function u(w, X, W, ...D) {
    const le = l();
    if (X.column += W, X.offset += W, c) {
      const we = Ud(le.startLoc, X), xi = yu(w, we, {
        domain: Z9,
        args: D
      });
      c(xi);
    }
  }
  function h10(w, X, W) {
    w.endLoc = r(), w.currentType = X;
    const D = { type: X };
    return i && (D.loc = Ud(w.startLoc, w.endLoc)), W != null && (D.value = W), D;
  }
  const d = (w) => h10(
    w,
    14
    /* EOF */
  );
  function p(w, X) {
    return w.currentChar() === X ? (w.next(), X) : (u(ce.EXPECTED_TOKEN, r(), 0, X), "");
  }
  function $(w) {
    let X = "";
    for (; w.currentPeek() === Tn || w.currentPeek() === At; )
      X += w.currentPeek(), w.peek();
    return X;
  }
  function g(w) {
    const X = $(w);
    return w.skipToPeek(), X;
  }
  function Q(w) {
    if (w === eO)
      return false;
    const X = w.charCodeAt(0);
    return X >= 97 && X <= 122 || // a-z
    X >= 65 && X <= 90 || // A-Z
    X === 95;
  }
  function m(w) {
    if (w === eO)
      return false;
    const X = w.charCodeAt(0);
    return X >= 48 && X <= 57;
  }
  function b(w, X) {
    const { currentType: W } = X;
    if (W !== 2)
      return false;
    $(w);
    const D = Q(w.currentPeek());
    return w.resetPeek(), D;
  }
  function P(w, X) {
    const { currentType: W } = X;
    if (W !== 2)
      return false;
    $(w);
    const D = w.currentPeek() === "-" ? w.peek() : w.currentPeek(), le = m(D);
    return w.resetPeek(), le;
  }
  function S(w, X) {
    const { currentType: W } = X;
    if (W !== 2)
      return false;
    $(w);
    const D = w.currentPeek() === QP;
    return w.resetPeek(), D;
  }
  function y(w, X) {
    const { currentType: W } = X;
    if (W !== 8)
      return false;
    $(w);
    const D = w.currentPeek() === ".";
    return w.resetPeek(), D;
  }
  function v(w, X) {
    const { currentType: W } = X;
    if (W !== 9)
      return false;
    $(w);
    const D = Q(w.currentPeek());
    return w.resetPeek(), D;
  }
  function T(w, X) {
    const { currentType: W } = X;
    if (!(W === 8 || W === 12))
      return false;
    $(w);
    const D = w.currentPeek() === ":";
    return w.resetPeek(), D;
  }
  function _(w, X) {
    const { currentType: W } = X;
    if (W !== 10)
      return false;
    const D = () => {
      const we = w.currentPeek();
      return we === "{" ? Q(w.peek()) : we === "@" || we === "%" || we === "|" || we === ":" || we === "." || we === Tn || !we ? false : we === At ? (w.peek(), D()) : Q(we);
    }, le = D();
    return w.resetPeek(), le;
  }
  function x(w) {
    $(w);
    const X = w.currentPeek() === "|";
    return w.resetPeek(), X;
  }
  function k(w) {
    const X = $(w), W = w.currentPeek() === "%" && w.peek() === "{";
    return w.resetPeek(), {
      isModulo: W,
      hasSpace: X.length > 0
    };
  }
  function Y(w, X = true) {
    const W = (le = false, we = "", xi = false) => {
      const Pt = w.currentPeek();
      return Pt === "{" ? we === "%" ? false : le : Pt === "@" || !Pt ? we === "%" ? true : le : Pt === "%" ? (w.peek(), W(le, "%", true)) : Pt === "|" ? we === "%" || xi ? true : !(we === Tn || we === At) : Pt === Tn ? (w.peek(), W(true, Tn, xi)) : Pt === At ? (w.peek(), W(true, At, xi)) : true;
    }, D = W();
    return X && w.resetPeek(), D;
  }
  function Z(w, X) {
    const W = w.currentChar();
    return W === eO ? eO : X(W) ? (w.next(), W) : null;
  }
  function L(w) {
    return Z(w, (W) => {
      const D = W.charCodeAt(0);
      return D >= 97 && D <= 122 || // a-z
      D >= 65 && D <= 90 || // A-Z
      D >= 48 && D <= 57 || // 0-9
      D === 95 || // _
      D === 36;
    });
  }
  function ae(w) {
    return Z(w, (W) => {
      const D = W.charCodeAt(0);
      return D >= 48 && D <= 57;
    });
  }
  function Oe(w) {
    return Z(w, (W) => {
      const D = W.charCodeAt(0);
      return D >= 48 && D <= 57 || // 0-9
      D >= 65 && D <= 70 || // A-F
      D >= 97 && D <= 102;
    });
  }
  function C(w) {
    let X = "", W = "";
    for (; X = ae(w); )
      W += X;
    return W;
  }
  function M(w) {
    g(w);
    const X = w.currentChar();
    return X !== "%" && u(ce.EXPECTED_TOKEN, r(), 0, X), w.next(), "%";
  }
  function H(w) {
    let X = "";
    for (; ; ) {
      const W = w.currentChar();
      if (W === "{" || W === "}" || W === "@" || W === "|" || !W)
        break;
      if (W === "%")
        if (Y(w))
          X += W, w.next();
        else
          break;
      else if (W === Tn || W === At)
        if (Y(w))
          X += W, w.next();
        else {
          if (x(w))
            break;
          X += W, w.next();
        }
      else
        X += W, w.next();
    }
    return X;
  }
  function xe(w) {
    g(w);
    let X = "", W = "";
    for (; X = L(w); )
      W += X;
    return w.currentChar() === eO && u(ce.UNTERMINATED_CLOSING_BRACE, r(), 0), W;
  }
  function Fe(w) {
    g(w);
    let X = "";
    return w.currentChar() === "-" ? (w.next(), X += `-${C(w)}`) : X += C(w), w.currentChar() === eO && u(ce.UNTERMINATED_CLOSING_BRACE, r(), 0), X;
  }
  function nt(w) {
    g(w), p(w, "'");
    let X = "", W = "";
    const D = (we) => we !== QP && we !== At;
    for (; X = Z(w, D); )
      X === "\\" ? W += Et(w) : W += X;
    const le = w.currentChar();
    return le === At || le === eO ? (u(ce.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, r(), 0), le === At && (w.next(), p(w, "'")), W) : (p(w, "'"), W);
  }
  function Et(w) {
    const X = w.currentChar();
    switch (X) {
      case "\\":
      case "'":
        return w.next(), `\\${X}`;
      case "u":
        return jt(w, X, 4);
      case "U":
        return jt(w, X, 6);
      default:
        return u(ce.UNKNOWN_ESCAPE_SEQUENCE, r(), 0, X), "";
    }
  }
  function jt(w, X, W) {
    p(w, X);
    let D = "";
    for (let le = 0; le < W; le++) {
      const we = Oe(w);
      if (!we) {
        u(ce.INVALID_UNICODE_ESCAPE_SEQUENCE, r(), 0, `\\${X}${D}${w.currentChar()}`);
        break;
      }
      D += we;
    }
    return `\\${X}${D}`;
  }
  function ii(w) {
    g(w);
    let X = "", W = "";
    const D = (le) => le !== "{" && le !== "}" && le !== Tn && le !== At;
    for (; X = Z(w, D); )
      W += X;
    return W;
  }
  function Ai(w) {
    let X = "", W = "";
    for (; X = L(w); )
      W += X;
    return W;
  }
  function on(w) {
    const X = (W = false, D) => {
      const le = w.currentChar();
      return le === "{" || le === "%" || le === "@" || le === "|" || !le || le === Tn ? D : le === At ? (D += le, w.next(), X(W, D)) : (D += le, w.next(), X(true, D));
    };
    return X(false, "");
  }
  function It(w) {
    g(w);
    const X = p(
      w,
      "|"
      /* Pipe */
    );
    return g(w), X;
  }
  function Gi(w, X) {
    let W = null;
    switch (w.currentChar()) {
      case "{":
        return X.braceNest >= 1 && u(ce.NOT_ALLOW_NEST_PLACEHOLDER, r(), 0), w.next(), W = h10(
          X,
          2,
          "{"
          /* BraceLeft */
        ), g(w), X.braceNest++, W;
      case "}":
        return X.braceNest > 0 && X.currentType === 2 && u(ce.EMPTY_PLACEHOLDER, r(), 0), w.next(), W = h10(
          X,
          3,
          "}"
          /* BraceRight */
        ), X.braceNest--, X.braceNest > 0 && g(w), X.inLinked && X.braceNest === 0 && (X.inLinked = false), W;
      case "@":
        return X.braceNest > 0 && u(ce.UNTERMINATED_CLOSING_BRACE, r(), 0), W = sn(w, X) || d(X), X.braceNest = 0, W;
      default:
        let le = true, we = true, xi = true;
        if (x(w))
          return X.braceNest > 0 && u(ce.UNTERMINATED_CLOSING_BRACE, r(), 0), W = h10(X, 1, It(w)), X.braceNest = 0, X.inLinked = false, W;
        if (X.braceNest > 0 && (X.currentType === 5 || X.currentType === 6 || X.currentType === 7))
          return u(ce.UNTERMINATED_CLOSING_BRACE, r(), 0), X.braceNest = 0, Li(w, X);
        if (le = b(w, X))
          return W = h10(X, 5, xe(w)), g(w), W;
        if (we = P(w, X))
          return W = h10(X, 6, Fe(w)), g(w), W;
        if (xi = S(w, X))
          return W = h10(X, 7, nt(w)), g(w), W;
        if (!le && !we && !xi)
          return W = h10(X, 13, ii(w)), u(ce.INVALID_TOKEN_IN_PLACEHOLDER, r(), 0, W.value), g(w), W;
        break;
    }
    return W;
  }
  function sn(w, X) {
    const { currentType: W } = X;
    let D = null;
    const le = w.currentChar();
    switch ((W === 8 || W === 9 || W === 12 || W === 10) && (le === At || le === Tn) && u(ce.INVALID_LINKED_FORMAT, r(), 0), le) {
      case "@":
        return w.next(), D = h10(
          X,
          8,
          "@"
          /* LinkedAlias */
        ), X.inLinked = true, D;
      case ".":
        return g(w), w.next(), h10(
          X,
          9,
          "."
          /* LinkedDot */
        );
      case ":":
        return g(w), w.next(), h10(
          X,
          10,
          ":"
          /* LinkedDelimiter */
        );
      default:
        return x(w) ? (D = h10(X, 1, It(w)), X.braceNest = 0, X.inLinked = false, D) : y(w, X) || T(w, X) ? (g(w), sn(w, X)) : v(w, X) ? (g(w), h10(X, 12, Ai(w))) : _(w, X) ? (g(w), le === "{" ? Gi(w, X) || D : h10(X, 11, on(w))) : (W === 8 && u(ce.INVALID_LINKED_FORMAT, r(), 0), X.braceNest = 0, X.inLinked = false, Li(w, X));
    }
  }
  function Li(w, X) {
    let W = {
      type: 14
      /* EOF */
    };
    if (X.braceNest > 0)
      return Gi(w, X) || d(X);
    if (X.inLinked)
      return sn(w, X) || d(X);
    switch (w.currentChar()) {
      case "{":
        return Gi(w, X) || d(X);
      case "}":
        return u(ce.UNBALANCED_CLOSING_BRACE, r(), 0), w.next(), h10(
          X,
          3,
          "}"
          /* BraceRight */
        );
      case "@":
        return sn(w, X) || d(X);
      default:
        if (x(w))
          return W = h10(X, 1, It(w)), X.braceNest = 0, X.inLinked = false, W;
        const { isModulo: le, hasSpace: we } = k(w);
        if (le)
          return we ? h10(X, 0, H(w)) : h10(X, 4, M(w));
        if (Y(w))
          return h10(X, 0, H(w));
        break;
    }
    return W;
  }
  function YO() {
    const { currentType: w, offset: X, startLoc: W, endLoc: D } = s;
    return s.lastType = w, s.lastOffset = X, s.lastStartLoc = W, s.lastEndLoc = D, s.offset = O(), s.startLoc = r(), n.currentChar() === eO ? h10(
      s,
      14
      /* EOF */
    ) : Li(n, s);
  }
  return {
    nextToken: YO,
    currentOffset: O,
    currentPosition: r,
    context: l
  };
}
var V9 = "parser";
var q9 = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function z9(t, e, i) {
  switch (t) {
    case "\\\\":
      return "\\";
    case "\\'":
      return "'";
    default: {
      const n = parseInt(e || i, 16);
      return n <= 55295 || n >= 57344 ? String.fromCodePoint(n) : "�";
    }
  }
}
function C9(t = {}) {
  const e = t.location !== false, { onError: i } = t;
  function n(Q, m, b, P, ...S) {
    const y = Q.currentPosition();
    if (y.offset += P, y.column += P, i) {
      const v = Ud(b, y), T = yu(m, v, {
        domain: V9,
        args: S
      });
      i(T);
    }
  }
  function O(Q, m, b) {
    const P = {
      type: Q,
      start: m,
      end: m
    };
    return e && (P.loc = { start: b, end: b }), P;
  }
  function r(Q, m, b, P) {
    Q.end = m, P && (Q.type = P), e && Q.loc && (Q.loc.end = b);
  }
  function a(Q, m) {
    const b = Q.context(), P = O(3, b.offset, b.startLoc);
    return P.value = m, r(P, Q.currentOffset(), Q.currentPosition()), P;
  }
  function o(Q, m) {
    const b = Q.context(), { lastOffset: P, lastStartLoc: S } = b, y = O(5, P, S);
    return y.index = parseInt(m, 10), Q.nextToken(), r(y, Q.currentOffset(), Q.currentPosition()), y;
  }
  function s(Q, m) {
    const b = Q.context(), { lastOffset: P, lastStartLoc: S } = b, y = O(4, P, S);
    return y.key = m, Q.nextToken(), r(y, Q.currentOffset(), Q.currentPosition()), y;
  }
  function l(Q, m) {
    const b = Q.context(), { lastOffset: P, lastStartLoc: S } = b, y = O(9, P, S);
    return y.value = m.replace(q9, z9), Q.nextToken(), r(y, Q.currentOffset(), Q.currentPosition()), y;
  }
  function c(Q) {
    const m = Q.nextToken(), b = Q.context(), { lastOffset: P, lastStartLoc: S } = b, y = O(8, P, S);
    return m.type !== 12 ? (n(Q, ce.UNEXPECTED_EMPTY_LINKED_MODIFIER, b.lastStartLoc, 0), y.value = "", r(y, P, S), {
      nextConsumeToken: m,
      node: y
    }) : (m.value == null && n(Q, ce.UNEXPECTED_LEXICAL_ANALYSIS, b.lastStartLoc, 0, fn(m)), y.value = m.value || "", r(y, Q.currentOffset(), Q.currentPosition()), {
      node: y
    });
  }
  function u(Q, m) {
    const b = Q.context(), P = O(7, b.offset, b.startLoc);
    return P.value = m, r(P, Q.currentOffset(), Q.currentPosition()), P;
  }
  function h10(Q) {
    const m = Q.context(), b = O(6, m.offset, m.startLoc);
    let P = Q.nextToken();
    if (P.type === 9) {
      const S = c(Q);
      b.modifier = S.node, P = S.nextConsumeToken || Q.nextToken();
    }
    switch (P.type !== 10 && n(Q, ce.UNEXPECTED_LEXICAL_ANALYSIS, m.lastStartLoc, 0, fn(P)), P = Q.nextToken(), P.type === 2 && (P = Q.nextToken()), P.type) {
      case 11:
        P.value == null && n(Q, ce.UNEXPECTED_LEXICAL_ANALYSIS, m.lastStartLoc, 0, fn(P)), b.key = u(Q, P.value || "");
        break;
      case 5:
        P.value == null && n(Q, ce.UNEXPECTED_LEXICAL_ANALYSIS, m.lastStartLoc, 0, fn(P)), b.key = s(Q, P.value || "");
        break;
      case 6:
        P.value == null && n(Q, ce.UNEXPECTED_LEXICAL_ANALYSIS, m.lastStartLoc, 0, fn(P)), b.key = o(Q, P.value || "");
        break;
      case 7:
        P.value == null && n(Q, ce.UNEXPECTED_LEXICAL_ANALYSIS, m.lastStartLoc, 0, fn(P)), b.key = l(Q, P.value || "");
        break;
      default:
        n(Q, ce.UNEXPECTED_EMPTY_LINKED_KEY, m.lastStartLoc, 0);
        const S = Q.context(), y = O(7, S.offset, S.startLoc);
        return y.value = "", r(y, S.offset, S.startLoc), b.key = y, r(b, S.offset, S.startLoc), {
          nextConsumeToken: P,
          node: b
        };
    }
    return r(b, Q.currentOffset(), Q.currentPosition()), {
      node: b
    };
  }
  function d(Q) {
    const m = Q.context(), b = m.currentType === 1 ? Q.currentOffset() : m.offset, P = m.currentType === 1 ? m.endLoc : m.startLoc, S = O(2, b, P);
    S.items = [];
    let y = null;
    do {
      const _ = y || Q.nextToken();
      switch (y = null, _.type) {
        case 0:
          _.value == null && n(Q, ce.UNEXPECTED_LEXICAL_ANALYSIS, m.lastStartLoc, 0, fn(_)), S.items.push(a(Q, _.value || ""));
          break;
        case 6:
          _.value == null && n(Q, ce.UNEXPECTED_LEXICAL_ANALYSIS, m.lastStartLoc, 0, fn(_)), S.items.push(o(Q, _.value || ""));
          break;
        case 5:
          _.value == null && n(Q, ce.UNEXPECTED_LEXICAL_ANALYSIS, m.lastStartLoc, 0, fn(_)), S.items.push(s(Q, _.value || ""));
          break;
        case 7:
          _.value == null && n(Q, ce.UNEXPECTED_LEXICAL_ANALYSIS, m.lastStartLoc, 0, fn(_)), S.items.push(l(Q, _.value || ""));
          break;
        case 8:
          const x = h10(Q);
          S.items.push(x.node), y = x.nextConsumeToken || null;
          break;
      }
    } while (m.currentType !== 14 && m.currentType !== 1);
    const v = m.currentType === 1 ? m.lastOffset : Q.currentOffset(), T = m.currentType === 1 ? m.lastEndLoc : Q.currentPosition();
    return r(S, v, T), S;
  }
  function p(Q, m, b, P) {
    const S = Q.context();
    let y = P.items.length === 0;
    const v = O(1, m, b);
    v.cases = [], v.cases.push(P);
    do {
      const T = d(Q);
      y || (y = T.items.length === 0), v.cases.push(T);
    } while (S.currentType !== 14);
    return y && n(Q, ce.MUST_HAVE_MESSAGES_IN_PLURAL, b, 0), r(v, Q.currentOffset(), Q.currentPosition()), v;
  }
  function $(Q) {
    const m = Q.context(), { offset: b, startLoc: P } = m, S = d(Q);
    return m.currentType === 14 ? S : p(Q, b, P, S);
  }
  function g(Q) {
    const m = U9(Q, kt({}, t)), b = m.context(), P = O(0, b.offset, b.startLoc);
    return e && P.loc && (P.loc.source = Q), P.body = $(m), b.currentType !== 14 && n(m, ce.UNEXPECTED_LEXICAL_ANALYSIS, b.lastStartLoc, 0, Q[b.offset] || ""), r(P, m.currentOffset(), m.currentPosition()), P;
  }
  return { parse: g };
}
function fn(t) {
  if (t.type === 14)
    return "EOF";
  const e = (t.value || "").replace(/\r?\n/gu, "\\n");
  return e.length > 10 ? e.slice(0, 9) + "…" : e;
}
function E9(t, e = {}) {
  const i = {
    ast: t,
    helpers: /* @__PURE__ */ new Set()
  };
  return { context: () => i, helper: (r) => (i.helpers.add(r), r) };
}
function gP(t, e) {
  for (let i = 0; i < t.length; i++)
    T$(t[i], e);
}
function T$(t, e) {
  switch (t.type) {
    case 1:
      gP(t.cases, e), e.helper(
        "plural"
        /* PLURAL */
      );
      break;
    case 2:
      gP(t.items, e);
      break;
    case 6:
      T$(t.key, e), e.helper(
        "linked"
        /* LINKED */
      ), e.helper(
        "type"
        /* TYPE */
      );
      break;
    case 5:
      e.helper(
        "interpolate"
        /* INTERPOLATE */
      ), e.helper(
        "list"
        /* LIST */
      );
      break;
    case 4:
      e.helper(
        "interpolate"
        /* INTERPOLATE */
      ), e.helper(
        "named"
        /* NAMED */
      );
      break;
  }
}
function j9(t, e = {}) {
  const i = E9(t);
  i.helper(
    "normalize"
    /* NORMALIZE */
  ), t.body && T$(t.body, i);
  const n = i.context();
  t.helpers = Array.from(n.helpers);
}
function I9(t, e) {
  const { sourceMap: i, filename: n, breakLineCode: O, needIndent: r } = e, a = {
    source: t.loc.source,
    filename: n,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode: O,
    needIndent: r,
    indentLevel: 0
  }, o = () => a;
  function s($, g) {
    a.code += $;
  }
  function l($, g = true) {
    const Q = g ? O : "";
    s(r ? Q + "  ".repeat($) : Q);
  }
  function c($ = true) {
    const g = ++a.indentLevel;
    $ && l(g);
  }
  function u($ = true) {
    const g = --a.indentLevel;
    $ && l(g);
  }
  function h10() {
    l(a.indentLevel);
  }
  return {
    context: o,
    push: s,
    indent: c,
    deindent: u,
    newline: h10,
    helper: ($) => `_${$}`,
    needIndent: () => a.needIndent
  };
}
function A9(t, e) {
  const { helper: i } = t;
  t.push(`${i(
    "linked"
    /* LINKED */
  )}(`), fa(t, e.key), e.modifier ? (t.push(", "), fa(t, e.modifier), t.push(", _type")) : t.push(", undefined, _type"), t.push(")");
}
function G9(t, e) {
  const { helper: i, needIndent: n } = t;
  t.push(`${i(
    "normalize"
    /* NORMALIZE */
  )}([`), t.indent(n());
  const O = e.items.length;
  for (let r = 0; r < O && (fa(t, e.items[r]), r !== O - 1); r++)
    t.push(", ");
  t.deindent(n()), t.push("])");
}
function L9(t, e) {
  const { helper: i, needIndent: n } = t;
  if (e.cases.length > 1) {
    t.push(`${i(
      "plural"
      /* PLURAL */
    )}([`), t.indent(n());
    const O = e.cases.length;
    for (let r = 0; r < O && (fa(t, e.cases[r]), r !== O - 1); r++)
      t.push(", ");
    t.deindent(n()), t.push("])");
  }
}
function D9(t, e) {
  e.body ? fa(t, e.body) : t.push("null");
}
function fa(t, e) {
  const { helper: i } = t;
  switch (e.type) {
    case 0:
      D9(t, e);
      break;
    case 1:
      L9(t, e);
      break;
    case 2:
      G9(t, e);
      break;
    case 6:
      A9(t, e);
      break;
    case 8:
      t.push(JSON.stringify(e.value), e);
      break;
    case 7:
      t.push(JSON.stringify(e.value), e);
      break;
    case 5:
      t.push(`${i(
        "interpolate"
        /* INTERPOLATE */
      )}(${i(
        "list"
        /* LIST */
      )}(${e.index}))`, e);
      break;
    case 4:
      t.push(`${i(
        "interpolate"
        /* INTERPOLATE */
      )}(${i(
        "named"
        /* NAMED */
      )}(${JSON.stringify(e.key)}))`, e);
      break;
    case 9:
      t.push(JSON.stringify(e.value), e);
      break;
    case 3:
      t.push(JSON.stringify(e.value), e);
      break;
    default:
      if (true)
        throw new Error(`unhandled codegen node type: ${e.type}`);
  }
}
var M9 = (t, e = {}) => {
  const i = F(e.mode) ? e.mode : "normal", n = F(e.filename) ? e.filename : "message.intl", O = !!e.sourceMap, r = e.breakLineCode != null ? e.breakLineCode : i === "arrow" ? ";" : `
`, a = e.needIndent ? e.needIndent : i !== "arrow", o = t.helpers || [], s = I9(t, {
    mode: i,
    filename: n,
    sourceMap: O,
    breakLineCode: r,
    needIndent: a
  });
  s.push(i === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), s.indent(a), o.length > 0 && (s.push(`const { ${o.map((u) => `${u}: _${u}`).join(", ")} } = ctx`), s.newline()), s.push("return "), fa(s, t), s.deindent(a), s.push("}");
  const { code: l, map: c } = s.context();
  return {
    ast: t,
    code: l,
    map: c ? c.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function N9(t, e = {}) {
  const i = kt({}, e), O = C9(i).parse(t);
  return j9(O, i), M9(O, i);
}
var Cx = {
  I18nInit: "i18n:init",
  FunctionTranslate: "function:translate"
};
var _O = [];
_O[
  0
  /* BEFORE_PATH */
] = {
  w: [
    0
    /* BEFORE_PATH */
  ],
  i: [
    3,
    0
    /* APPEND */
  ],
  [
    "["
    /* LEFT_BRACKET */
  ]: [
    4
    /* IN_SUB_PATH */
  ],
  o: [
    7
    /* AFTER_PATH */
  ]
};
_O[
  1
  /* IN_PATH */
] = {
  w: [
    1
    /* IN_PATH */
  ],
  [
    "."
    /* DOT */
  ]: [
    2
    /* BEFORE_IDENT */
  ],
  [
    "["
    /* LEFT_BRACKET */
  ]: [
    4
    /* IN_SUB_PATH */
  ],
  o: [
    7
    /* AFTER_PATH */
  ]
};
_O[
  2
  /* BEFORE_IDENT */
] = {
  w: [
    2
    /* BEFORE_IDENT */
  ],
  i: [
    3,
    0
    /* APPEND */
  ],
  [
    0
    /* ZERO */
  ]: [
    3,
    0
    /* APPEND */
  ]
};
_O[
  3
  /* IN_IDENT */
] = {
  i: [
    3,
    0
    /* APPEND */
  ],
  [
    0
    /* ZERO */
  ]: [
    3,
    0
    /* APPEND */
  ],
  w: [
    1,
    1
    /* PUSH */
  ],
  [
    "."
    /* DOT */
  ]: [
    2,
    1
    /* PUSH */
  ],
  [
    "["
    /* LEFT_BRACKET */
  ]: [
    4,
    1
    /* PUSH */
  ],
  o: [
    7,
    1
    /* PUSH */
  ]
};
_O[
  4
  /* IN_SUB_PATH */
] = {
  [
    "'"
    /* SINGLE_QUOTE */
  ]: [
    5,
    0
    /* APPEND */
  ],
  [
    '"'
    /* DOUBLE_QUOTE */
  ]: [
    6,
    0
    /* APPEND */
  ],
  [
    "["
    /* LEFT_BRACKET */
  ]: [
    4,
    2
    /* INC_SUB_PATH_DEPTH */
  ],
  [
    "]"
    /* RIGHT_BRACKET */
  ]: [
    1,
    3
    /* PUSH_SUB_PATH */
  ],
  o: 8,
  l: [
    4,
    0
    /* APPEND */
  ]
};
_O[
  5
  /* IN_SINGLE_QUOTE */
] = {
  [
    "'"
    /* SINGLE_QUOTE */
  ]: [
    4,
    0
    /* APPEND */
  ],
  o: 8,
  l: [
    5,
    0
    /* APPEND */
  ]
};
_O[
  6
  /* IN_DOUBLE_QUOTE */
] = {
  [
    '"'
    /* DOUBLE_QUOTE */
  ]: [
    4,
    0
    /* APPEND */
  ],
  o: 8,
  l: [
    6,
    0
    /* APPEND */
  ]
};
var B9 = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function F9(t) {
  return B9.test(t);
}
function H9(t) {
  const e = t.charCodeAt(0), i = t.charCodeAt(t.length - 1);
  return e === i && (e === 34 || e === 39) ? t.slice(1, -1) : t;
}
function K9(t) {
  if (t == null)
    return "o";
  switch (t.charCodeAt(0)) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return t;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function J9(t) {
  const e = t.trim();
  return t.charAt(0) === "0" && isNaN(parseInt(t)) ? false : F9(e) ? H9(e) : "*" + e;
}
function e3(t) {
  const e = [];
  let i = -1, n = 0, O = 0, r, a, o, s, l, c, u;
  const h10 = [];
  h10[
    0
    /* APPEND */
  ] = () => {
    a === void 0 ? a = o : a += o;
  }, h10[
    1
    /* PUSH */
  ] = () => {
    a !== void 0 && (e.push(a), a = void 0);
  }, h10[
    2
    /* INC_SUB_PATH_DEPTH */
  ] = () => {
    h10[
      0
      /* APPEND */
    ](), O++;
  }, h10[
    3
    /* PUSH_SUB_PATH */
  ] = () => {
    if (O > 0)
      O--, n = 4, h10[
        0
        /* APPEND */
      ]();
    else {
      if (O = 0, a === void 0 || (a = J9(a), a === false))
        return false;
      h10[
        1
        /* PUSH */
      ]();
    }
  };
  function d() {
    const p = t[i + 1];
    if (n === 5 && p === "'" || n === 6 && p === '"')
      return i++, o = "\\" + p, h10[
        0
        /* APPEND */
      ](), true;
  }
  for (; n !== null; )
    if (i++, r = t[i], !(r === "\\" && d())) {
      if (s = K9(r), u = _O[n], l = u[s] || u.l || 8, l === 8 || (n = l[0], l[1] !== void 0 && (c = h10[l[1]], c && (o = r, c() === false))))
        return;
      if (n === 7)
        return e;
    }
}
var mP = /* @__PURE__ */ new Map();
function t3(t, e) {
  return Ze(t) ? t[e] : null;
}
function i3(t, e) {
  if (!Ze(t))
    return null;
  let i = mP.get(e);
  if (i || (i = e3(e), i && mP.set(e, i)), !i)
    return null;
  const n = i.length;
  let O = t, r = 0;
  for (; r < n; ) {
    const a = O[i[r]];
    if (a === void 0)
      return null;
    O = a, r++;
  }
  return O;
}
var n3 = (t) => t;
var O3 = (t) => "";
var r3 = "text";
var a3 = (t) => t.length === 0 ? "" : t.join("");
var o3 = v9;
function SP(t, e) {
  return t = Math.abs(t), e === 2 ? t ? t > 1 ? 1 : 0 : 1 : t ? Math.min(t, 2) : 0;
}
function s3(t) {
  const e = Yt(t.pluralIndex) ? t.pluralIndex : -1;
  return t.named && (Yt(t.named.count) || Yt(t.named.n)) ? Yt(t.named.count) ? t.named.count : Yt(t.named.n) ? t.named.n : e : e;
}
function l3(t, e) {
  e.count || (e.count = t), e.n || (e.n = t);
}
function c3(t = {}) {
  const e = t.locale, i = s3(t), n = Ze(t.pluralRules) && F(e) && ut(t.pluralRules[e]) ? t.pluralRules[e] : SP, O = Ze(t.pluralRules) && F(e) && ut(t.pluralRules[e]) ? SP : void 0, r = (Q) => Q[n(i, Q.length, O)], a = t.list || [], o = (Q) => a[Q], s = t.named || {};
  Yt(t.pluralIndex) && l3(i, s);
  const l = (Q) => s[Q];
  function c(Q) {
    const m = ut(t.messages) ? t.messages(Q) : Ze(t.messages) ? t.messages[Q] : false;
    return m || (t.parent ? t.parent.message(Q) : O3);
  }
  const u = (Q) => t.modifiers ? t.modifiers[Q] : n3, h10 = be(t.processor) && ut(t.processor.normalize) ? t.processor.normalize : a3, d = be(t.processor) && ut(t.processor.interpolate) ? t.processor.interpolate : o3, p = be(t.processor) && F(t.processor.type) ? t.processor.type : r3, g = {
    list: o,
    named: l,
    plural: r,
    linked: (Q, ...m) => {
      const [b, P] = m;
      let S = "text", y = "";
      m.length === 1 ? Ze(b) ? (y = b.modifier || y, S = b.type || S) : F(b) && (y = b || y) : m.length === 2 && (F(b) && (y = b || y), F(P) && (S = P || S));
      let v = c(Q)(g);
      return S === "vnode" && tt(v) && y && (v = v[0]), y ? u(y)(v, S) : v;
    },
    message: c,
    type: p,
    interpolate: d,
    normalize: h10
  };
  return g;
}
var us = null;
function u3(t) {
  us = t;
}
function f3(t, e, i) {
  us && us.emit(Cx.I18nInit, {
    timestamp: Date.now(),
    i18n: t,
    version: e,
    meta: i
  });
}
var h3 = d3(Cx.FunctionTranslate);
function d3(t) {
  return (e) => us && us.emit(t, e);
}
var $i = {
  NOT_FOUND_KEY: 1,
  FALLBACK_TO_TRANSLATE: 2,
  CANNOT_FORMAT_NUMBER: 3,
  FALLBACK_TO_NUMBER_FORMAT: 4,
  CANNOT_FORMAT_DATE: 5,
  FALLBACK_TO_DATE_FORMAT: 6,
  __EXTEND_POINT__: 7
};
var p3 = {
  [$i.NOT_FOUND_KEY]: "Not found '{key}' key in '{locale}' locale messages.",
  [$i.FALLBACK_TO_TRANSLATE]: "Fall back to translate '{key}' key with '{target}' locale.",
  [$i.CANNOT_FORMAT_NUMBER]: "Cannot format a number value due to not supported Intl.NumberFormat.",
  [$i.FALLBACK_TO_NUMBER_FORMAT]: "Fall back to number format '{key}' key with '{target}' locale.",
  [$i.CANNOT_FORMAT_DATE]: "Cannot format a date value due to not supported Intl.DateTimeFormat.",
  [$i.FALLBACK_TO_DATE_FORMAT]: "Fall back to datetime format '{key}' key with '{target}' locale."
};
function ha(t, ...e) {
  return Su(p3[t], ...e);
}
function $3(t, e, i) {
  return [.../* @__PURE__ */ new Set([
    i,
    ...tt(e) ? e : Ze(e) ? Object.keys(e) : F(e) ? [e] : [i]
  ])];
}
function Ex(t, e, i) {
  const n = F(i) ? i : vu, O = t;
  O.__localeChainCache || (O.__localeChainCache = /* @__PURE__ */ new Map());
  let r = O.__localeChainCache.get(n);
  if (!r) {
    r = [];
    let a = [i];
    for (; tt(a); )
      a = PP(r, a, e);
    const o = tt(e) || !be(e) ? e : e.default ? e.default : null;
    a = F(o) ? [o] : o, tt(a) && PP(r, a, false), O.__localeChainCache.set(n, r);
  }
  return r;
}
function PP(t, e, i) {
  let n = true;
  for (let O = 0; O < e.length && Ce(n); O++) {
    const r = e[O];
    F(r) && (n = Q3(t, e[O], i));
  }
  return n;
}
function Q3(t, e, i) {
  let n;
  const O = e.split("-");
  do {
    const r = O.join("-");
    n = g3(t, r, i), O.splice(-1, 1);
  } while (O.length && n === true);
  return n;
}
function g3(t, e, i) {
  let n = false;
  if (!t.includes(e) && (n = true, e)) {
    n = e[e.length - 1] !== "!";
    const O = e.replace(/!/g, "");
    t.push(O), (tt(i) || be(i)) && i[O] && (n = i[O]);
  }
  return n;
}
var m3 = "9.2.2";
var bu = -1;
var vu = "en-US";
var vc = "";
var yP = (t) => `${t.charAt(0).toLocaleUpperCase()}${t.substr(1)}`;
function S3() {
  return {
    upper: (t, e) => e === "text" && F(t) ? t.toUpperCase() : e === "vnode" && Ze(t) && "__v_isVNode" in t ? t.children.toUpperCase() : t,
    lower: (t, e) => e === "text" && F(t) ? t.toLowerCase() : e === "vnode" && Ze(t) && "__v_isVNode" in t ? t.children.toLowerCase() : t,
    capitalize: (t, e) => e === "text" && F(t) ? yP(t) : e === "vnode" && Ze(t) && "__v_isVNode" in t ? yP(t.children) : t
  };
}
var jx;
function P3(t) {
  jx = t;
}
var Ix;
function y3(t) {
  Ix = t;
}
var Ax;
function b3(t) {
  Ax = t;
}
var Gx = null;
var bP = (t) => {
  Gx = t;
};
var v3 = () => Gx;
var Lx = null;
var vP = (t) => {
  Lx = t;
};
var X3 = () => Lx;
var XP = 0;
function x3(t = {}) {
  const e = F(t.version) ? t.version : m3, i = F(t.locale) ? t.locale : vu, n = tt(t.fallbackLocale) || be(t.fallbackLocale) || F(t.fallbackLocale) || t.fallbackLocale === false ? t.fallbackLocale : i, O = be(t.messages) ? t.messages : { [i]: {} }, r = be(t.datetimeFormats) ? t.datetimeFormats : { [i]: {} }, a = be(t.numberFormats) ? t.numberFormats : { [i]: {} }, o = kt({}, t.modifiers || {}, S3()), s = t.pluralRules || {}, l = ut(t.missing) ? t.missing : null, c = Ce(t.missingWarn) || ua(t.missingWarn) ? t.missingWarn : true, u = Ce(t.fallbackWarn) || ua(t.fallbackWarn) ? t.fallbackWarn : true, h10 = !!t.fallbackFormat, d = !!t.unresolving, p = ut(t.postTranslation) ? t.postTranslation : null, $ = be(t.processor) ? t.processor : null, g = Ce(t.warnHtmlMessage) ? t.warnHtmlMessage : true, Q = !!t.escapeParameter, m = ut(t.messageCompiler) ? t.messageCompiler : jx, b = ut(t.messageResolver) ? t.messageResolver : Ix || t3, P = ut(t.localeFallbacker) ? t.localeFallbacker : Ax || $3, S = Ze(t.fallbackContext) ? t.fallbackContext : void 0, y = ut(t.onWarn) ? t.onWarn : _s, v = t, T = Ze(v.__datetimeFormatters) ? v.__datetimeFormatters : /* @__PURE__ */ new Map(), _ = Ze(v.__numberFormatters) ? v.__numberFormatters : /* @__PURE__ */ new Map(), x = Ze(v.__meta) ? v.__meta : {};
  XP++;
  const k = {
    version: e,
    cid: XP,
    locale: i,
    fallbackLocale: n,
    messages: O,
    modifiers: o,
    pluralRules: s,
    missing: l,
    missingWarn: c,
    fallbackWarn: u,
    fallbackFormat: h10,
    unresolving: d,
    postTranslation: p,
    processor: $,
    warnHtmlMessage: g,
    escapeParameter: Q,
    messageCompiler: m,
    messageResolver: b,
    localeFallbacker: P,
    fallbackContext: S,
    onWarn: y,
    __meta: x
  };
  return k.datetimeFormats = r, k.numberFormats = a, k.__datetimeFormatters = T, k.__numberFormatters = _, k.__v_emitter = v.__v_emitter != null ? v.__v_emitter : void 0, f3(k, e, x), k;
}
function Xu(t, e) {
  return t instanceof RegExp ? t.test(e) : t;
}
function Dx(t, e) {
  return t instanceof RegExp ? t.test(e) : t;
}
function k$(t, e, i, n, O) {
  const { missing: r, onWarn: a } = t;
  if (true) {
    const o = t.__v_emitter;
    o && o.emit("missing", {
      locale: i,
      key: e,
      type: O,
      groupId: `${O}:${e}`
    });
  }
  if (r !== null) {
    const o = r(t, i, e, O);
    return F(o) ? o : e;
  } else
    return Dx(n, e) && a(ha($i.NOT_FOUND_KEY, { key: e, locale: i })), e;
}
function to(t, e, i) {
  const n = t;
  n.__localeChainCache = /* @__PURE__ */ new Map(), t.localeFallbacker(t, i, e);
}
var w3 = /<\/?[\w\s="/.':;#-\/]+>/;
var T3 = "Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.";
function k3(t, e) {
  (Ce(e.warnHtmlMessage) ? e.warnHtmlMessage : true) && w3.test(t) && _s(Su(T3, { source: t }));
}
var _3 = (t) => t;
var xP = /* @__PURE__ */ Object.create(null);
function W3(t, e = {}) {
  {
    k3(t, e);
    const n = (e.onCacheKey || _3)(t), O = xP[n];
    if (O)
      return O;
    let r = false;
    const a = e.onError || T9;
    e.onError = (l) => {
      r = true, a(l);
    };
    const { code: o } = N9(t, e), s = new Function(`return ${o}`)();
    return r ? s : xP[n] = s;
  }
}
var Mx = ce.__EXTEND_POINT__;
var Af = () => ++Mx;
var qn = {
  INVALID_ARGUMENT: Mx,
  INVALID_DATE_ARGUMENT: Af(),
  INVALID_ISO_DATE_ARGUMENT: Af(),
  __EXTEND_POINT__: Af()
  // 18
};
function Ar(t) {
  return yu(t, null, true ? { messages: Y3 } : void 0);
}
var Y3 = {
  [qn.INVALID_ARGUMENT]: "Invalid arguments",
  [qn.INVALID_DATE_ARGUMENT]: "The date provided is an invalid Date object.Make sure your Date represents a valid date.",
  [qn.INVALID_ISO_DATE_ARGUMENT]: "The argument provided is not a valid ISO date string"
};
var wP = () => "";
var dn = (t) => ut(t);
function TP(t, ...e) {
  const { fallbackFormat: i, postTranslation: n, unresolving: O, messageCompiler: r, fallbackLocale: a, messages: o } = t, [s, l] = Vd(...e), c = Ce(l.missingWarn) ? l.missingWarn : t.missingWarn, u = Ce(l.fallbackWarn) ? l.fallbackWarn : t.fallbackWarn, h10 = Ce(l.escapeParameter) ? l.escapeParameter : t.escapeParameter, d = !!l.resolvedMessage, p = F(l.default) || Ce(l.default) ? Ce(l.default) ? r ? s : () => s : l.default : i ? r ? s : () => s : "", $ = i || p !== "", g = F(l.locale) ? l.locale : t.locale;
  h10 && R3(l);
  let [Q, m, b] = d ? [
    s,
    g,
    o[g] || {}
  ] : Nx(t, s, g, a, u, c), P = Q, S = s;
  if (!d && !(F(P) || dn(P)) && $ && (P = p, S = P), !d && (!(F(P) || dn(P)) || !F(m)))
    return O ? bu : s;
  if (F(P) && t.messageCompiler == null)
    return _s(`The message format compilation is not supported in this build. Because message compiler isn't included. You need to pre-compilation all message format. So translate function return '${s}'.`), s;
  let y = false;
  const v = () => {
    y = true;
  }, T = dn(P) ? P : Bx(t, s, m, P, S, v);
  if (y)
    return P;
  const _ = V3(t, m, b, l), x = c3(_), k = Z3(t, T, x), Y = n ? n(k, s) : k;
  if (true) {
    const Z = {
      timestamp: Date.now(),
      key: F(s) ? s : dn(P) ? P.key : "",
      locale: m || (dn(P) ? P.locale : ""),
      format: F(P) ? P : dn(P) ? P.source : "",
      message: Y
    };
    Z.meta = kt({}, t.__meta, v3() || {}), h3(Z);
  }
  return Y;
}
function R3(t) {
  tt(t.list) ? t.list = t.list.map((e) => F(e) ? pP(e) : e) : Ze(t.named) && Object.keys(t.named).forEach((e) => {
    F(t.named[e]) && (t.named[e] = pP(t.named[e]));
  });
}
function Nx(t, e, i, n, O, r) {
  const { messages: a, onWarn: o, messageResolver: s, localeFallbacker: l } = t, c = l(t, n, i);
  let u = {}, h10, d = null, p = i, $ = null;
  const g = "translate";
  for (let Q = 0; Q < c.length; Q++) {
    if (h10 = $ = c[Q], i !== h10 && Xu(O, e) && o(ha($i.FALLBACK_TO_TRANSLATE, {
      key: e,
      target: h10
    })), i !== h10) {
      const y = t.__v_emitter;
      y && y.emit("fallback", {
        type: g,
        key: e,
        from: p,
        to: $,
        groupId: `${g}:${e}`
      });
    }
    u = a[h10] || {};
    let m = null, b, P;
    if (yO && (m = window.performance.now(), b = "intlify-message-resolve-start", P = "intlify-message-resolve-end", Si && Si(b)), (d = s(u, e)) === null && (d = u[e]), yO) {
      const y = window.performance.now(), v = t.__v_emitter;
      v && m && d && v.emit("message-resolve", {
        type: "message-resolve",
        key: e,
        message: d,
        time: y - m,
        groupId: `${g}:${e}`
      }), b && P && Si && Or && (Si(P), Or("intlify message resolve", b, P));
    }
    if (F(d) || ut(d))
      break;
    const S = k$(
      t,
      // eslint-disable-line @typescript-eslint/no-explicit-any
      e,
      h10,
      r,
      g
    );
    S !== e && (d = S), p = $;
  }
  return [d, h10, u];
}
function Bx(t, e, i, n, O, r) {
  const { messageCompiler: a, warnHtmlMessage: o } = t;
  if (dn(n)) {
    const h10 = n;
    return h10.locale = h10.locale || i, h10.key = h10.key || e, h10;
  }
  if (a == null) {
    const h10 = () => n;
    return h10.locale = i, h10.key = e, h10;
  }
  let s = null, l, c;
  yO && (s = window.performance.now(), l = "intlify-message-compilation-start", c = "intlify-message-compilation-end", Si && Si(l));
  const u = a(n, U3(t, i, O, n, o, r));
  if (yO) {
    const h10 = window.performance.now(), d = t.__v_emitter;
    d && s && d.emit("message-compilation", {
      type: "message-compilation",
      message: n,
      time: h10 - s,
      groupId: `translate:${e}`
    }), l && c && Si && Or && (Si(c), Or("intlify message compilation", l, c));
  }
  return u.locale = i, u.key = e, u.source = n, u;
}
function Z3(t, e, i) {
  let n = null, O, r;
  yO && (n = window.performance.now(), O = "intlify-message-evaluation-start", r = "intlify-message-evaluation-end", Si && Si(O));
  const a = e(i);
  if (yO) {
    const o = window.performance.now(), s = t.__v_emitter;
    s && n && s.emit("message-evaluation", {
      type: "message-evaluation",
      value: a,
      time: o - n,
      groupId: `translate:${e.key}`
    }), O && r && Si && Or && (Si(r), Or("intlify message evaluation", O, r));
  }
  return a;
}
function Vd(...t) {
  const [e, i, n] = t, O = {};
  if (!F(e) && !Yt(e) && !dn(e))
    throw Ar(qn.INVALID_ARGUMENT);
  const r = Yt(e) ? String(e) : (dn(e), e);
  return Yt(i) ? O.plural = i : F(i) ? O.default = i : be(i) && !Pu(i) ? O.named = i : tt(i) && (O.list = i), Yt(n) ? O.plural = n : F(n) ? O.default = n : be(n) && kt(O, n), [r, O];
}
function U3(t, e, i, n, O, r) {
  return {
    warnHtmlMessage: O,
    onError: (a) => {
      if (r && r(a), true) {
        const o = `Message compilation error: ${a.message}`, s = a.location && X9(n, a.location.start.offset, a.location.end.offset), l = t.__v_emitter;
        l && l.emit("compile-error", {
          message: n,
          error: a.message,
          start: a.location && a.location.start.offset,
          end: a.location && a.location.end.offset,
          groupId: `translate:${i}`
        }), console.error(s ? `${o}
${s}` : o);
      } else
        throw a;
    },
    onCacheKey: (a) => S9(e, i, a)
  };
}
function V3(t, e, i, n) {
  const { modifiers: O, pluralRules: r, messageResolver: a, fallbackLocale: o, fallbackWarn: s, missingWarn: l, fallbackContext: c } = t, h10 = {
    locale: e,
    modifiers: O,
    pluralRules: r,
    messages: (d) => {
      let p = a(i, d);
      if (p == null && c) {
        const [, , $] = Nx(c, d, e, o, s, l);
        p = a($, d);
      }
      if (F(p)) {
        let $ = false;
        const Q = Bx(t, d, e, p, d, () => {
          $ = true;
        });
        return $ ? wP : Q;
      } else
        return dn(p) ? p : wP;
    }
  };
  return t.processor && (h10.processor = t.processor), n.list && (h10.list = n.list), n.named && (h10.named = n.named), Yt(n.plural) && (h10.pluralIndex = n.plural), h10;
}
var kP = typeof Intl < "u";
var Fx = {
  dateTimeFormat: kP && typeof Intl.DateTimeFormat < "u",
  numberFormat: kP && typeof Intl.NumberFormat < "u"
};
function _P(t, ...e) {
  const { datetimeFormats: i, unresolving: n, fallbackLocale: O, onWarn: r, localeFallbacker: a } = t, { __datetimeFormatters: o } = t;
  if (!Fx.dateTimeFormat)
    return r(ha($i.CANNOT_FORMAT_DATE)), vc;
  const [s, l, c, u] = qd(...e), h10 = Ce(c.missingWarn) ? c.missingWarn : t.missingWarn, d = Ce(c.fallbackWarn) ? c.fallbackWarn : t.fallbackWarn, p = !!c.part, $ = F(c.locale) ? c.locale : t.locale, g = a(
    t,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    O,
    $
  );
  if (!F(s) || s === "")
    return new Intl.DateTimeFormat($, u).format(l);
  let Q = {}, m, b = null, P = $, S = null;
  const y = "datetime format";
  for (let _ = 0; _ < g.length; _++) {
    if (m = S = g[_], $ !== m && Xu(d, s) && r(ha($i.FALLBACK_TO_DATE_FORMAT, {
      key: s,
      target: m
    })), $ !== m) {
      const x = t.__v_emitter;
      x && x.emit("fallback", {
        type: y,
        key: s,
        from: P,
        to: S,
        groupId: `${y}:${s}`
      });
    }
    if (Q = i[m] || {}, b = Q[s], be(b))
      break;
    k$(t, s, m, h10, y), P = S;
  }
  if (!be(b) || !F(m))
    return n ? bu : s;
  let v = `${m}__${s}`;
  Pu(u) || (v = `${v}__${JSON.stringify(u)}`);
  let T = o.get(v);
  return T || (T = new Intl.DateTimeFormat(m, kt({}, b, u)), o.set(v, T)), p ? T.formatToParts(l) : T.format(l);
}
var Hx = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function qd(...t) {
  const [e, i, n, O] = t, r = {};
  let a = {}, o;
  if (F(e)) {
    const s = e.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!s)
      throw Ar(qn.INVALID_ISO_DATE_ARGUMENT);
    const l = s[3] ? s[3].trim().startsWith("T") ? `${s[1].trim()}${s[3].trim()}` : `${s[1].trim()}T${s[3].trim()}` : s[1].trim();
    o = new Date(l);
    try {
      o.toISOString();
    } catch {
      throw Ar(qn.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (y9(e)) {
    if (isNaN(e.getTime()))
      throw Ar(qn.INVALID_DATE_ARGUMENT);
    o = e;
  } else if (Yt(e))
    o = e;
  else
    throw Ar(qn.INVALID_ARGUMENT);
  return F(i) ? r.key = i : be(i) && Object.keys(i).forEach((s) => {
    Hx.includes(s) ? a[s] = i[s] : r[s] = i[s];
  }), F(n) ? r.locale = n : be(n) && (a = n), be(O) && (a = O), [r.key || "", o, r, a];
}
function WP(t, e, i) {
  const n = t;
  for (const O in i) {
    const r = `${e}__${O}`;
    n.__datetimeFormatters.has(r) && n.__datetimeFormatters.delete(r);
  }
}
function YP(t, ...e) {
  const { numberFormats: i, unresolving: n, fallbackLocale: O, onWarn: r, localeFallbacker: a } = t, { __numberFormatters: o } = t;
  if (!Fx.numberFormat)
    return r(ha($i.CANNOT_FORMAT_NUMBER)), vc;
  const [s, l, c, u] = zd(...e), h10 = Ce(c.missingWarn) ? c.missingWarn : t.missingWarn, d = Ce(c.fallbackWarn) ? c.fallbackWarn : t.fallbackWarn, p = !!c.part, $ = F(c.locale) ? c.locale : t.locale, g = a(
    t,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    O,
    $
  );
  if (!F(s) || s === "")
    return new Intl.NumberFormat($, u).format(l);
  let Q = {}, m, b = null, P = $, S = null;
  const y = "number format";
  for (let _ = 0; _ < g.length; _++) {
    if (m = S = g[_], $ !== m && Xu(d, s) && r(ha($i.FALLBACK_TO_NUMBER_FORMAT, {
      key: s,
      target: m
    })), $ !== m) {
      const x = t.__v_emitter;
      x && x.emit("fallback", {
        type: y,
        key: s,
        from: P,
        to: S,
        groupId: `${y}:${s}`
      });
    }
    if (Q = i[m] || {}, b = Q[s], be(b))
      break;
    k$(t, s, m, h10, y), P = S;
  }
  if (!be(b) || !F(m))
    return n ? bu : s;
  let v = `${m}__${s}`;
  Pu(u) || (v = `${v}__${JSON.stringify(u)}`);
  let T = o.get(v);
  return T || (T = new Intl.NumberFormat(m, kt({}, b, u)), o.set(v, T)), p ? T.formatToParts(l) : T.format(l);
}
var Kx = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function zd(...t) {
  const [e, i, n, O] = t, r = {};
  let a = {};
  if (!Yt(e))
    throw Ar(qn.INVALID_ARGUMENT);
  const o = e;
  return F(i) ? r.key = i : be(i) && Object.keys(i).forEach((s) => {
    Kx.includes(s) ? a[s] = i[s] : r[s] = i[s];
  }), F(n) ? r.locale = n : be(n) && (a = n), be(O) && (a = O), [r.key || "", o, r, a];
}
function RP(t, e, i) {
  const n = t;
  for (const O in i) {
    const r = `${e}__${O}`;
    n.__numberFormatters.has(r) && n.__numberFormatters.delete(r);
  }
}
typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Yo().__INTLIFY_PROD_DEVTOOLS__ = false);
var q3 = "9.2.2";
function z3() {
  let t = false;
  typeof __VUE_I18N_FULL_INSTALL__ != "boolean" && (t = true, Yo().__VUE_I18N_FULL_INSTALL__ = true), typeof __VUE_I18N_LEGACY_API__ != "boolean" && (t = true, Yo().__VUE_I18N_LEGACY_API__ = true), typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Yo().__INTLIFY_PROD_DEVTOOLS__ = false), t && console.warn("You are running the esm-bundler build of vue-i18n. It is recommended to configure your bundler to explicitly replace feature flag globals with boolean literals to get proper tree-shaking in the final bundle.");
}
var Jx = $i.__EXTEND_POINT__;
var wr = () => ++Jx;
var Zn = {
  FALLBACK_TO_ROOT: Jx,
  NOT_SUPPORTED_PRESERVE: wr(),
  NOT_SUPPORTED_FORMATTER: wr(),
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: wr(),
  NOT_SUPPORTED_GET_CHOICE_INDEX: wr(),
  COMPONENT_NAME_LEGACY_COMPATIBLE: wr(),
  NOT_FOUND_PARENT_SCOPE: wr()
  // 13
};
var C3 = {
  [Zn.FALLBACK_TO_ROOT]: "Fall back to {type} '{key}' with root locale.",
  [Zn.NOT_SUPPORTED_PRESERVE]: "Not supported 'preserve'.",
  [Zn.NOT_SUPPORTED_FORMATTER]: "Not supported 'formatter'.",
  [Zn.NOT_SUPPORTED_PRESERVE_DIRECTIVE]: "Not supported 'preserveDirectiveContent'.",
  [Zn.NOT_SUPPORTED_GET_CHOICE_INDEX]: "Not supported 'getChoiceIndex'.",
  [Zn.COMPONENT_NAME_LEGACY_COMPATIBLE]: "Component name legacy compatible: '{name}' -> 'i18n'",
  [Zn.NOT_FOUND_PARENT_SCOPE]: "Not found parent scope. use the global scope."
};
function ew(t, ...e) {
  return Su(C3[t], ...e);
}
var tw = ce.__EXTEND_POINT__;
var ni = () => ++tw;
var Ae = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: tw,
  // legacy module errors
  INVALID_ARGUMENT: ni(),
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: ni(),
  NOT_INSLALLED: ni(),
  NOT_AVAILABLE_IN_LEGACY_MODE: ni(),
  // directive module errors
  REQUIRED_VALUE: ni(),
  INVALID_VALUE: ni(),
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: ni(),
  NOT_INSLALLED_WITH_PROVIDE: ni(),
  // unexpected error
  UNEXPECTED_ERROR: ni(),
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: ni(),
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: ni(),
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: ni(),
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: ni(),
  // for enhancement
  __EXTEND_POINT__: ni()
  // 29
};
function jn(t, ...e) {
  return yu(t, null, true ? { messages: E3, args: e } : void 0);
}
var E3 = {
  [Ae.UNEXPECTED_RETURN_TYPE]: "Unexpected return type in composer",
  [Ae.INVALID_ARGUMENT]: "Invalid argument",
  [Ae.MUST_BE_CALL_SETUP_TOP]: "Must be called at the top of a `setup` function",
  [Ae.NOT_INSLALLED]: "Need to install with `app.use` function",
  [Ae.UNEXPECTED_ERROR]: "Unexpected error",
  [Ae.NOT_AVAILABLE_IN_LEGACY_MODE]: "Not available in legacy mode",
  [Ae.REQUIRED_VALUE]: "Required in value: {0}",
  [Ae.INVALID_VALUE]: "Invalid value",
  [Ae.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: "Cannot setup vue-devtools plugin",
  [Ae.NOT_INSLALLED_WITH_PROVIDE]: "Need to install with `provide` function",
  [Ae.NOT_COMPATIBLE_LEGACY_VUE_I18N]: "Not compatible legacy VueI18n.",
  [Ae.BRIDGE_SUPPORT_VUE_2_ONLY]: "vue-i18n-bridge support Vue 2.x only",
  [Ae.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION]: "Must define ‘i18n’ option or custom block in Composition API with using local scope in Legacy API mode",
  [Ae.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: "Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly"
};
var Cd = Nn("__transrateVNode");
var Ed = Nn("__datetimeParts");
var jd = Nn("__numberParts");
var Id = Nn("__enableEmitter");
var Ad = Nn("__disableEmitter");
var j3 = Nn("__setPluralRules");
Nn("__intlifyMeta");
var iw = Nn("__injectWithOption");
function Gd(t) {
  if (!Ze(t))
    return t;
  for (const e in t)
    if (x$(t, e))
      if (!e.includes("."))
        Ze(t[e]) && Gd(t[e]);
      else {
        const i = e.split("."), n = i.length - 1;
        let O = t;
        for (let r = 0; r < n; r++)
          i[r] in O || (O[i[r]] = {}), O = O[i[r]];
        O[i[n]] = t[e], delete t[e], Ze(O[i[n]]) && Gd(O[i[n]]);
      }
  return t;
}
function _$(t, e) {
  const { messages: i, __i18n: n, messageResolver: O, flatJson: r } = e, a = be(i) ? i : tt(n) ? {} : { [t]: {} };
  if (tt(n) && n.forEach((o) => {
    if ("locale" in o && "resource" in o) {
      const { locale: s, resource: l } = o;
      s ? (a[s] = a[s] || {}, Ro(l, a[s])) : Ro(l, a);
    } else
      F(o) && Ro(JSON.parse(o), a);
  }), O == null && r)
    for (const o in a)
      x$(a, o) && Gd(a[o]);
  return a;
}
var dl = (t) => !Ze(t) || tt(t);
function Ro(t, e) {
  if (dl(t) || dl(e))
    throw jn(Ae.INVALID_VALUE);
  for (const i in t)
    x$(t, i) && (dl(t[i]) || dl(e[i]) ? e[i] = t[i] : Ro(t[i], e[i]));
}
function nw(t) {
  return t.type;
}
function I3(t, e, i) {
  let n = Ze(e.messages) ? e.messages : {};
  "__i18nGlobal" in i && (n = _$(t.locale.value, {
    messages: n,
    __i18n: i.__i18nGlobal
  }));
  const O = Object.keys(n);
  O.length && O.forEach((r) => {
    t.mergeLocaleMessage(r, n[r]);
  });
  {
    if (Ze(e.datetimeFormats)) {
      const r = Object.keys(e.datetimeFormats);
      r.length && r.forEach((a) => {
        t.mergeDateTimeFormat(a, e.datetimeFormats[a]);
      });
    }
    if (Ze(e.numberFormats)) {
      const r = Object.keys(e.numberFormats);
      r.length && r.forEach((a) => {
        t.mergeNumberFormat(a, e.numberFormats[a]);
      });
    }
  }
}
function ZP(t) {
  return createVNode(Text, null, t, 0);
}
var UP = "__INTLIFY_META__";
var VP = 0;
function qP(t) {
  return (e, i, n, O) => t(i, n, getCurrentInstance() || void 0, O);
}
var A3 = () => {
  const t = getCurrentInstance();
  let e = null;
  return t && (e = nw(t)[UP]) ? { [UP]: e } : null;
};
function G3(t = {}, e) {
  const { __root: i } = t, n = i === void 0;
  let O = Ce(t.inheritLocale) ? t.inheritLocale : true;
  const r = ref(
    // prettier-ignore
    i && O ? i.locale.value : F(t.locale) ? t.locale : vu
  ), a = ref(
    // prettier-ignore
    i && O ? i.fallbackLocale.value : F(t.fallbackLocale) || tt(t.fallbackLocale) || be(t.fallbackLocale) || t.fallbackLocale === false ? t.fallbackLocale : r.value
  ), o = ref(_$(r.value, t)), s = ref(be(t.datetimeFormats) ? t.datetimeFormats : { [r.value]: {} }), l = ref(be(t.numberFormats) ? t.numberFormats : { [r.value]: {} });
  let c = i ? i.missingWarn : Ce(t.missingWarn) || ua(t.missingWarn) ? t.missingWarn : true, u = i ? i.fallbackWarn : Ce(t.fallbackWarn) || ua(t.fallbackWarn) ? t.fallbackWarn : true, h10 = i ? i.fallbackRoot : Ce(t.fallbackRoot) ? t.fallbackRoot : true, d = !!t.fallbackFormat, p = ut(t.missing) ? t.missing : null, $ = ut(t.missing) ? qP(t.missing) : null, g = ut(t.postTranslation) ? t.postTranslation : null, Q = i ? i.warnHtmlMessage : Ce(t.warnHtmlMessage) ? t.warnHtmlMessage : true, m = !!t.escapeParameter;
  const b = i ? i.modifiers : be(t.modifiers) ? t.modifiers : {};
  let P = t.pluralRules || i && i.pluralRules, S;
  S = (() => {
    n && vP(null);
    const U = {
      version: q3,
      locale: r.value,
      fallbackLocale: a.value,
      messages: o.value,
      modifiers: b,
      pluralRules: P,
      missing: $ === null ? void 0 : $,
      missingWarn: c,
      fallbackWarn: u,
      fallbackFormat: d,
      unresolving: true,
      postTranslation: g === null ? void 0 : g,
      warnHtmlMessage: Q,
      escapeParameter: m,
      messageResolver: t.messageResolver,
      __meta: { framework: "vue" }
    };
    U.datetimeFormats = s.value, U.numberFormats = l.value, U.__datetimeFormatters = be(S) ? S.__datetimeFormatters : void 0, U.__numberFormatters = be(S) ? S.__numberFormatters : void 0, U.__v_emitter = be(S) ? S.__v_emitter : void 0;
    const z = x3(U);
    return n && vP(z), z;
  })(), to(S, r.value, a.value);
  function v() {
    return [
      r.value,
      a.value,
      o.value,
      s.value,
      l.value
    ];
  }
  const T = computed({
    get: () => r.value,
    set: (U) => {
      r.value = U, S.locale = r.value;
    }
  }), _ = computed({
    get: () => a.value,
    set: (U) => {
      a.value = U, S.fallbackLocale = a.value, to(S, r.value, U);
    }
  }), x = computed(() => o.value), k = computed(() => s.value), Y = computed(() => l.value);
  function Z() {
    return ut(g) ? g : null;
  }
  function L(U) {
    g = U, S.postTranslation = U;
  }
  function ae() {
    return p;
  }
  function Oe(U) {
    U !== null && ($ = qP(U)), p = U, S.missing = $;
  }
  function C(U, z) {
    return U !== "translate" || !z.resolvedMessage;
  }
  const M = (U, z, yt, $t, Pr, RO) => {
    v();
    let yr;
    if (true)
      try {
        bP(A3()), n || (S.fallbackContext = i ? X3() : void 0), yr = U(S);
      } finally {
        bP(null), n || (S.fallbackContext = void 0);
      }
    else
      yr = U(S);
    if (Yt(yr) && yr === bu) {
      const [ZO, WT] = z();
      if (i && F(ZO) && C(yt, WT) && (h10 && (Xu(u, ZO) || Dx(c, ZO)) && _s(ew(Zn.FALLBACK_TO_ROOT, {
        key: ZO,
        type: yt
      })), true)) {
        const { __v_emitter: mQ } = S;
        mQ && h10 && mQ.emit("fallback", {
          type: yt,
          key: ZO,
          to: "global",
          groupId: `${yt}:${ZO}`
        });
      }
      return i && h10 ? $t(i) : Pr(ZO);
    } else {
      if (RO(yr))
        return yr;
      throw jn(Ae.UNEXPECTED_RETURN_TYPE);
    }
  };
  function H(...U) {
    return M((z) => Reflect.apply(TP, null, [z, ...U]), () => Vd(...U), "translate", (z) => Reflect.apply(z.t, z, [...U]), (z) => z, (z) => F(z));
  }
  function xe(...U) {
    const [z, yt, $t] = U;
    if ($t && !Ze($t))
      throw jn(Ae.INVALID_ARGUMENT);
    return H(z, yt, kt({ resolvedMessage: true }, $t || {}));
  }
  function Fe(...U) {
    return M((z) => Reflect.apply(_P, null, [z, ...U]), () => qd(...U), "datetime format", (z) => Reflect.apply(z.d, z, [...U]), () => vc, (z) => F(z));
  }
  function nt(...U) {
    return M((z) => Reflect.apply(YP, null, [z, ...U]), () => zd(...U), "number format", (z) => Reflect.apply(z.n, z, [...U]), () => vc, (z) => F(z));
  }
  function Et(U) {
    return U.map((z) => F(z) || Yt(z) || Ce(z) ? ZP(String(z)) : z);
  }
  const ii = {
    normalize: Et,
    interpolate: (U) => U,
    type: "vnode"
  };
  function Ai(...U) {
    return M(
      (z) => {
        let yt;
        const $t = z;
        try {
          $t.processor = ii, yt = Reflect.apply(TP, null, [$t, ...U]);
        } finally {
          $t.processor = null;
        }
        return yt;
      },
      () => Vd(...U),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (z) => z[Cd](...U),
      (z) => [ZP(z)],
      (z) => tt(z)
    );
  }
  function on(...U) {
    return M(
      (z) => Reflect.apply(YP, null, [z, ...U]),
      () => zd(...U),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (z) => z[jd](...U),
      () => [],
      (z) => F(z) || tt(z)
    );
  }
  function It(...U) {
    return M(
      (z) => Reflect.apply(_P, null, [z, ...U]),
      () => qd(...U),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (z) => z[Ed](...U),
      () => [],
      (z) => F(z) || tt(z)
    );
  }
  function Gi(U) {
    P = U, S.pluralRules = P;
  }
  function sn(U, z) {
    const yt = F(z) ? z : r.value, $t = w(yt);
    return S.messageResolver($t, U) !== null;
  }
  function Li(U) {
    let z = null;
    const yt = Ex(S, a.value, r.value);
    for (let $t = 0; $t < yt.length; $t++) {
      const Pr = o.value[yt[$t]] || {}, RO = S.messageResolver(Pr, U);
      if (RO != null) {
        z = RO;
        break;
      }
    }
    return z;
  }
  function YO(U) {
    const z = Li(U);
    return z ?? (i ? i.tm(U) || {} : {});
  }
  function w(U) {
    return o.value[U] || {};
  }
  function X(U, z) {
    o.value[U] = z, S.messages = o.value;
  }
  function W(U, z) {
    o.value[U] = o.value[U] || {}, Ro(z, o.value[U]), S.messages = o.value;
  }
  function D(U) {
    return s.value[U] || {};
  }
  function le(U, z) {
    s.value[U] = z, S.datetimeFormats = s.value, WP(S, U, z);
  }
  function we(U, z) {
    s.value[U] = kt(s.value[U] || {}, z), S.datetimeFormats = s.value, WP(S, U, z);
  }
  function xi(U) {
    return l.value[U] || {};
  }
  function Pt(U, z) {
    l.value[U] = z, S.numberFormats = l.value, RP(S, U, z);
  }
  function Sr(U, z) {
    l.value[U] = kt(l.value[U] || {}, z), S.numberFormats = l.value, RP(S, U, z);
  }
  VP++, i && yO && (watch(i.locale, (U) => {
    O && (r.value = U, S.locale = U, to(S, r.value, a.value));
  }), watch(i.fallbackLocale, (U) => {
    O && (a.value = U, S.fallbackLocale = U, to(S, r.value, a.value));
  }));
  const De = {
    id: VP,
    locale: T,
    fallbackLocale: _,
    get inheritLocale() {
      return O;
    },
    set inheritLocale(U) {
      O = U, U && i && (r.value = i.locale.value, a.value = i.fallbackLocale.value, to(S, r.value, a.value));
    },
    get availableLocales() {
      return Object.keys(o.value).sort();
    },
    messages: x,
    get modifiers() {
      return b;
    },
    get pluralRules() {
      return P || {};
    },
    get isGlobal() {
      return n;
    },
    get missingWarn() {
      return c;
    },
    set missingWarn(U) {
      c = U, S.missingWarn = c;
    },
    get fallbackWarn() {
      return u;
    },
    set fallbackWarn(U) {
      u = U, S.fallbackWarn = u;
    },
    get fallbackRoot() {
      return h10;
    },
    set fallbackRoot(U) {
      h10 = U;
    },
    get fallbackFormat() {
      return d;
    },
    set fallbackFormat(U) {
      d = U, S.fallbackFormat = d;
    },
    get warnHtmlMessage() {
      return Q;
    },
    set warnHtmlMessage(U) {
      Q = U, S.warnHtmlMessage = U;
    },
    get escapeParameter() {
      return m;
    },
    set escapeParameter(U) {
      m = U, S.escapeParameter = U;
    },
    t: H,
    getLocaleMessage: w,
    setLocaleMessage: X,
    mergeLocaleMessage: W,
    getPostTranslationHandler: Z,
    setPostTranslationHandler: L,
    getMissingHandler: ae,
    setMissingHandler: Oe,
    [j3]: Gi
  };
  return De.datetimeFormats = k, De.numberFormats = Y, De.rt = xe, De.te = sn, De.tm = YO, De.d = Fe, De.n = nt, De.getDateTimeFormat = D, De.setDateTimeFormat = le, De.mergeDateTimeFormat = we, De.getNumberFormat = xi, De.setNumberFormat = Pt, De.mergeNumberFormat = Sr, De[iw] = t.__injectWithOption, De[Cd] = Ai, De[Ed] = It, De[jd] = on, De[Id] = (U) => {
    S.__v_emitter = U;
  }, De[Ad] = () => {
    S.__v_emitter = void 0;
  }, De;
}
var W$ = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (t) => t === "parent" || t === "global",
    default: "parent"
    /* ComponetI18nScope */
  },
  i18n: {
    type: Object
  }
};
kt({
  keypath: {
    type: String,
    required: true
  },
  plural: {
    type: [Number, String],
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    validator: (t) => Yt(t) || !isNaN(t)
  }
}, W$);
kt({
  value: {
    type: Number,
    required: true
  },
  format: {
    type: [String, Object]
  }
}, W$);
kt({
  value: {
    type: [Number, Date],
    required: true
  },
  format: {
    type: [String, Object]
  }
}, W$);
function zP(t, e) {
}
var M3 = Nn("global-vue-i18n");
function hr(t = {}) {
  const e = getCurrentInstance();
  if (e == null)
    throw jn(Ae.MUST_BE_CALL_SETUP_TOP);
  if (!e.isCE && e.appContext.app != null && !e.appContext.app.__VUE_I18N_SYMBOL__)
    throw jn(Ae.NOT_INSLALLED);
  const i = N3(e), n = F3(i), O = nw(e), r = B3(t, O);
  if (__VUE_I18N_LEGACY_API__ && i.mode === "legacy" && !t.__useComponent) {
    if (!i.allowComposition)
      throw jn(Ae.NOT_AVAILABLE_IN_LEGACY_MODE);
    return J3(e, r, n, t);
  }
  if (r === "global")
    return I3(n, t, O), n;
  if (r === "parent") {
    let s = H3(i, e, t.__useComponent);
    return s == null && (_s(ew(Zn.NOT_FOUND_PARENT_SCOPE)), s = n), s;
  }
  const a = i;
  let o = a.__getInstance(e);
  if (o == null) {
    const s = kt({}, t);
    "__i18n" in O && (s.__i18n = O.__i18n), n && (s.__root = n), o = G3(s), K3(a, e, o), a.__setInstance(e, o);
  }
  return o;
}
function N3(t) {
  {
    const e = inject(t.isCE ? M3 : t.appContext.app.__VUE_I18N_SYMBOL__);
    if (!e)
      throw jn(t.isCE ? Ae.NOT_INSLALLED_WITH_PROVIDE : Ae.UNEXPECTED_ERROR);
    return e;
  }
}
function B3(t, e) {
  return Pu(t) ? "__i18n" in e ? "local" : "global" : t.useScope ? t.useScope : "local";
}
function F3(t) {
  return t.mode === "composition" ? t.global : t.global.__composer;
}
function H3(t, e, i = false) {
  let n = null;
  const O = e.root;
  let r = e.parent;
  for (; r != null; ) {
    const a = t;
    if (t.mode === "composition")
      n = a.__getInstance(r);
    else if (__VUE_I18N_LEGACY_API__) {
      const o = a.__getInstance(r);
      o != null && (n = o.__composer, i && n && !n[iw] && (n = null));
    }
    if (n != null || O === r)
      break;
    r = r.parent;
  }
  return n;
}
function K3(t, e, i) {
  let n = null;
  onMounted(() => {
    if (e.vnode.el) {
      e.vnode.el.__VUE_I18N__ = i, n = x9();
      const O = i;
      O[Id] && O[Id](n), n.on("*", zP);
    }
  }, e), onUnmounted(() => {
    if (e.vnode.el && e.vnode.el.__VUE_I18N__) {
      n && n.off("*", zP);
      const O = i;
      O[Ad] && O[Ad](), delete e.vnode.el.__VUE_I18N__;
    }
    t.__deleteInstance(e);
  }, e);
}
function J3(t, e, i, n = {}) {
  const O = e === "local", r = shallowRef(null);
  if (O && t.proxy && !(t.proxy.$options.i18n || t.proxy.$options.__i18n))
    throw jn(Ae.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
  const a = Ce(n.inheritLocale) ? n.inheritLocale : true, o = ref(
    // prettier-ignore
    O && a ? i.locale.value : F(n.locale) ? n.locale : vu
  ), s = ref(
    // prettier-ignore
    O && a ? i.fallbackLocale.value : F(n.fallbackLocale) || tt(n.fallbackLocale) || be(n.fallbackLocale) || n.fallbackLocale === false ? n.fallbackLocale : o.value
  ), l = ref(_$(o.value, n)), c = ref(be(n.datetimeFormats) ? n.datetimeFormats : { [o.value]: {} }), u = ref(be(n.numberFormats) ? n.numberFormats : { [o.value]: {} }), h10 = O ? i.missingWarn : Ce(n.missingWarn) || ua(n.missingWarn) ? n.missingWarn : true, d = O ? i.fallbackWarn : Ce(n.fallbackWarn) || ua(n.fallbackWarn) ? n.fallbackWarn : true, p = O ? i.fallbackRoot : Ce(n.fallbackRoot) ? n.fallbackRoot : true, $ = !!n.fallbackFormat, g = ut(n.missing) ? n.missing : null, Q = ut(n.postTranslation) ? n.postTranslation : null, m = O ? i.warnHtmlMessage : Ce(n.warnHtmlMessage) ? n.warnHtmlMessage : true, b = !!n.escapeParameter, P = O ? i.modifiers : be(n.modifiers) ? n.modifiers : {}, S = n.pluralRules || O && i.pluralRules;
  function y() {
    return [
      o.value,
      s.value,
      l.value,
      c.value,
      u.value
    ];
  }
  const v = computed({
    get: () => r.value ? r.value.locale.value : o.value,
    set: (X) => {
      r.value && (r.value.locale.value = X), o.value = X;
    }
  }), T = computed({
    get: () => r.value ? r.value.fallbackLocale.value : s.value,
    set: (X) => {
      r.value && (r.value.fallbackLocale.value = X), s.value = X;
    }
  }), _ = computed(() => r.value ? r.value.messages.value : l.value), x = computed(() => c.value), k = computed(() => u.value);
  function Y() {
    return r.value ? r.value.getPostTranslationHandler() : Q;
  }
  function Z(X) {
    r.value && r.value.setPostTranslationHandler(X);
  }
  function L() {
    return r.value ? r.value.getMissingHandler() : g;
  }
  function ae(X) {
    r.value && r.value.setMissingHandler(X);
  }
  function Oe(X) {
    return y(), X();
  }
  function C(...X) {
    return r.value ? Oe(() => Reflect.apply(r.value.t, null, [...X])) : Oe(() => "");
  }
  function M(...X) {
    return r.value ? Reflect.apply(r.value.rt, null, [...X]) : "";
  }
  function H(...X) {
    return r.value ? Oe(() => Reflect.apply(r.value.d, null, [...X])) : Oe(() => "");
  }
  function xe(...X) {
    return r.value ? Oe(() => Reflect.apply(r.value.n, null, [...X])) : Oe(() => "");
  }
  function Fe(X) {
    return r.value ? r.value.tm(X) : {};
  }
  function nt(X, W) {
    return r.value ? r.value.te(X, W) : false;
  }
  function Et(X) {
    return r.value ? r.value.getLocaleMessage(X) : {};
  }
  function jt(X, W) {
    r.value && (r.value.setLocaleMessage(X, W), l.value[X] = W);
  }
  function ii(X, W) {
    r.value && r.value.mergeLocaleMessage(X, W);
  }
  function Ai(X) {
    return r.value ? r.value.getDateTimeFormat(X) : {};
  }
  function on(X, W) {
    r.value && (r.value.setDateTimeFormat(X, W), c.value[X] = W);
  }
  function It(X, W) {
    r.value && r.value.mergeDateTimeFormat(X, W);
  }
  function Gi(X) {
    return r.value ? r.value.getNumberFormat(X) : {};
  }
  function sn(X, W) {
    r.value && (r.value.setNumberFormat(X, W), u.value[X] = W);
  }
  function Li(X, W) {
    r.value && r.value.mergeNumberFormat(X, W);
  }
  const YO = {
    get id() {
      return r.value ? r.value.id : -1;
    },
    locale: v,
    fallbackLocale: T,
    messages: _,
    datetimeFormats: x,
    numberFormats: k,
    get inheritLocale() {
      return r.value ? r.value.inheritLocale : a;
    },
    set inheritLocale(X) {
      r.value && (r.value.inheritLocale = X);
    },
    get availableLocales() {
      return r.value ? r.value.availableLocales : Object.keys(l.value);
    },
    get modifiers() {
      return r.value ? r.value.modifiers : P;
    },
    get pluralRules() {
      return r.value ? r.value.pluralRules : S;
    },
    get isGlobal() {
      return r.value ? r.value.isGlobal : false;
    },
    get missingWarn() {
      return r.value ? r.value.missingWarn : h10;
    },
    set missingWarn(X) {
      r.value && (r.value.missingWarn = X);
    },
    get fallbackWarn() {
      return r.value ? r.value.fallbackWarn : d;
    },
    set fallbackWarn(X) {
      r.value && (r.value.missingWarn = X);
    },
    get fallbackRoot() {
      return r.value ? r.value.fallbackRoot : p;
    },
    set fallbackRoot(X) {
      r.value && (r.value.fallbackRoot = X);
    },
    get fallbackFormat() {
      return r.value ? r.value.fallbackFormat : $;
    },
    set fallbackFormat(X) {
      r.value && (r.value.fallbackFormat = X);
    },
    get warnHtmlMessage() {
      return r.value ? r.value.warnHtmlMessage : m;
    },
    set warnHtmlMessage(X) {
      r.value && (r.value.warnHtmlMessage = X);
    },
    get escapeParameter() {
      return r.value ? r.value.escapeParameter : b;
    },
    set escapeParameter(X) {
      r.value && (r.value.escapeParameter = X);
    },
    t: C,
    getPostTranslationHandler: Y,
    setPostTranslationHandler: Z,
    getMissingHandler: L,
    setMissingHandler: ae,
    rt: M,
    d: H,
    n: xe,
    tm: Fe,
    te: nt,
    getLocaleMessage: Et,
    setLocaleMessage: jt,
    mergeLocaleMessage: ii,
    getDateTimeFormat: Ai,
    setDateTimeFormat: on,
    mergeDateTimeFormat: It,
    getNumberFormat: Gi,
    setNumberFormat: sn,
    mergeNumberFormat: Li
  };
  function w(X) {
    X.locale.value = o.value, X.fallbackLocale.value = s.value, Object.keys(l.value).forEach((W) => {
      X.mergeLocaleMessage(W, l.value[W]);
    }), Object.keys(c.value).forEach((W) => {
      X.mergeDateTimeFormat(W, c.value[W]);
    }), Object.keys(u.value).forEach((W) => {
      X.mergeNumberFormat(W, u.value[W]);
    }), X.escapeParameter = b, X.fallbackFormat = $, X.fallbackRoot = p, X.fallbackWarn = d, X.missingWarn = h10, X.warnHtmlMessage = m;
  }
  return onBeforeMount(() => {
    if (t.proxy == null || t.proxy.$i18n == null)
      throw jn(Ae.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
    const X = r.value = t.proxy.$i18n.__composer;
    e === "global" ? (o.value = X.locale.value, s.value = X.fallbackLocale.value, l.value = X.messages.value, c.value = X.datetimeFormats.value, u.value = X.numberFormats.value) : O && w(X);
  }), YO;
}
P3(W3);
y3(i3);
b3(Ex);
z3();
if (true) {
  const t = Yo();
  t.__INTLIFY__ = true, u3(t.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
var CP;
var xu = typeof window < "u";
var e7 = (t) => typeof t == "function";
var t7 = (t) => typeof t == "string";
var da = () => {
};
var i7 = xu && ((CP = window == null ? void 0 : window.navigator) == null ? void 0 : CP.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function bO(t) {
  return typeof t == "function" ? t() : unref(t);
}
function Y$(t, e) {
  function i(...n) {
    return new Promise((O, r) => {
      Promise.resolve(t(() => e.apply(this, n), { fn: e, thisArg: this, args: n })).then(O).catch(r);
    });
  }
  return i;
}
var aw = (t) => t();
function n7(t, e = {}) {
  let i, n, O = da;
  const r = (o) => {
    clearTimeout(o), O(), O = da;
  };
  return (o) => {
    const s = bO(t), l = bO(e.maxWait);
    return i && r(i), s <= 0 || l !== void 0 && l <= 0 ? (n && (r(n), n = null), Promise.resolve(o())) : new Promise((c, u) => {
      O = e.rejectOnCancel ? u : c, l && !n && (n = setTimeout(() => {
        i && r(i), n = null, c(o());
      }, l)), i = setTimeout(() => {
        n && r(n), n = null, c(o());
      }, s);
    });
  };
}
function O7(t, e = true, i = true, n = false) {
  let O = 0, r, a = true, o = da, s;
  const l = () => {
    r && (clearTimeout(r), r = void 0, o(), o = da);
  };
  return (u) => {
    const h10 = bO(t), d = Date.now() - O, p = () => s = u();
    return l(), h10 <= 0 ? (O = Date.now(), p()) : (d > h10 && (i || !a) ? (O = Date.now(), p()) : e && (s = new Promise(($, g) => {
      o = n ? g : $, r = setTimeout(() => {
        O = Date.now(), a = true, $(p()), l();
      }, Math.max(0, h10 - d));
    })), !i && !r && (r = setTimeout(() => a = true, h10)), a = false, s);
  };
}
function r7(t = aw) {
  const e = ref(true);
  function i() {
    e.value = false;
  }
  function n() {
    e.value = true;
  }
  const O = (...r) => {
    e.value && t(...r);
  };
  return { isActive: readonly(e), pause: i, resume: n, eventFilter: O };
}
function a7(t) {
  return t;
}
function R$(t) {
  return getCurrentScope() ? (onScopeDispose(t), true) : false;
}
function rr(t, e = 200, i = {}) {
  return Y$(n7(e, i), t);
}
function o7(t, e = 200, i = false, n = true, O = false) {
  return Y$(O7(e, i, n, O), t);
}
function dr(t, e = true) {
  getCurrentInstance() ? onMounted(t) : e ? t() : nextTick(t);
}
function s7(t, e, i = {}) {
  const {
    immediate: n = true
  } = i, O = ref(false);
  let r = null;
  function a() {
    r && (clearTimeout(r), r = null);
  }
  function o() {
    O.value = false, a();
  }
  function s(...l) {
    a(), O.value = true, r = setTimeout(() => {
      O.value = false, r = null, t(...l);
    }, bO(e));
  }
  return n && (O.value = true, xu && s()), R$(o), {
    isPending: readonly(O),
    start: s,
    stop: o
  };
}
var EP = Object.getOwnPropertySymbols;
var l7 = Object.prototype.hasOwnProperty;
var c7 = Object.prototype.propertyIsEnumerable;
var u7 = (t, e) => {
  var i = {};
  for (var n in t)
    l7.call(t, n) && e.indexOf(n) < 0 && (i[n] = t[n]);
  if (t != null && EP)
    for (var n of EP(t))
      e.indexOf(n) < 0 && c7.call(t, n) && (i[n] = t[n]);
  return i;
};
function f7(t, e, i = {}) {
  const n = i, {
    eventFilter: O = aw
  } = n, r = u7(n, [
    "eventFilter"
  ]);
  return watch(t, Y$(O, e), r);
}
var h7 = Object.defineProperty;
var d7 = Object.defineProperties;
var p7 = Object.getOwnPropertyDescriptors;
var Xc = Object.getOwnPropertySymbols;
var ow = Object.prototype.hasOwnProperty;
var sw = Object.prototype.propertyIsEnumerable;
var jP = (t, e, i) => e in t ? h7(t, e, { enumerable: true, configurable: true, writable: true, value: i }) : t[e] = i;
var $7 = (t, e) => {
  for (var i in e || (e = {}))
    ow.call(e, i) && jP(t, i, e[i]);
  if (Xc)
    for (var i of Xc(e))
      sw.call(e, i) && jP(t, i, e[i]);
  return t;
};
var Q7 = (t, e) => d7(t, p7(e));
var g7 = (t, e) => {
  var i = {};
  for (var n in t)
    ow.call(t, n) && e.indexOf(n) < 0 && (i[n] = t[n]);
  if (t != null && Xc)
    for (var n of Xc(t))
      e.indexOf(n) < 0 && sw.call(t, n) && (i[n] = t[n]);
  return i;
};
function m7(t, e, i = {}) {
  const n = i, {
    eventFilter: O
  } = n, r = g7(n, [
    "eventFilter"
  ]), { eventFilter: a, pause: o, resume: s, isActive: l } = r7(O);
  return { stop: f7(t, e, Q7($7({}, r), {
    eventFilter: a
  })), pause: o, resume: s, isActive: l };
}
function Rt(t, e, i) {
  return watch(t, (n, O, r) => {
    n && e(n, O, r);
  }, i);
}
function zn(t) {
  var e;
  const i = bO(t);
  return (e = i == null ? void 0 : i.$el) != null ? e : i;
}
var ar = xu ? window : void 0;
var S7 = xu ? window.navigator : void 0;
function BO(...t) {
  let e, i, n, O;
  if (t7(t[0]) || Array.isArray(t[0]) ? ([i, n, O] = t, e = ar) : [e, i, n, O] = t, !e)
    return da;
  Array.isArray(i) || (i = [i]), Array.isArray(n) || (n = [n]);
  const r = [], a = () => {
    r.forEach((c) => c()), r.length = 0;
  }, o = (c, u, h10, d) => (c.addEventListener(u, h10, d), () => c.removeEventListener(u, h10, d)), s = watch(() => [zn(e), bO(O)], ([c, u]) => {
    a(), c && r.push(...i.flatMap((h10) => n.map((d) => o(c, h10, d, u))));
  }, { immediate: true, flush: "post" }), l = () => {
    s(), a();
  };
  return R$(l), l;
}
var IP = false;
function P7(t, e, i = {}) {
  const { window: n = ar, ignore: O = [], capture: r = true, detectIframe: a = false } = i;
  if (!n)
    return;
  i7 && !IP && (IP = true, Array.from(n.document.body.children).forEach((h10) => h10.addEventListener("click", da)));
  let o = true;
  const s = (h10) => O.some((d) => {
    if (typeof d == "string")
      return Array.from(n.document.querySelectorAll(d)).some((p) => p === h10.target || h10.composedPath().includes(p));
    {
      const p = zn(d);
      return p && (h10.target === p || h10.composedPath().includes(p));
    }
  }), c = [
    BO(n, "click", (h10) => {
      const d = zn(t);
      if (!(!d || d === h10.target || h10.composedPath().includes(d))) {
        if (h10.detail === 0 && (o = !s(h10)), !o) {
          o = true;
          return;
        }
        e(h10);
      }
    }, { passive: true, capture: r }),
    BO(n, "pointerdown", (h10) => {
      const d = zn(t);
      d && (o = !h10.composedPath().includes(d) && !s(h10));
    }, { passive: true }),
    a && BO(n, "blur", (h10) => {
      var d;
      const p = zn(t);
      ((d = n.document.activeElement) == null ? void 0 : d.tagName) === "IFRAME" && !(p != null && p.contains(n.document.activeElement)) && e(h10);
    })
  ].filter(Boolean);
  return () => c.forEach((h10) => h10());
}
function Z$(t, e = false) {
  const i = ref(), n = () => i.value = Boolean(t());
  return n(), dr(n, e), i;
}
function y7(t = {}) {
  const {
    navigator: e = S7,
    read: i = false,
    source: n,
    copiedDuring: O = 1500,
    legacy: r = false
  } = t, a = ["copy", "cut"], o = Z$(() => e && "clipboard" in e), s = computed(() => o.value || r), l = ref(""), c = ref(false), u = s7(() => c.value = false, O);
  function h10() {
    o.value ? e.clipboard.readText().then((g) => {
      l.value = g;
    }) : l.value = $();
  }
  if (s.value && i)
    for (const g of a)
      BO(g, h10);
  async function d(g = bO(n)) {
    s.value && g != null && (o.value ? await e.clipboard.writeText(g) : p(g), l.value = g, c.value = true, u.start());
  }
  function p(g) {
    const Q = document.createElement("textarea");
    Q.value = g ?? "", Q.style.position = "absolute", Q.style.opacity = "0", document.body.appendChild(Q), Q.select(), document.execCommand("copy"), Q.remove();
  }
  function $() {
    var g, Q, m;
    return (m = (Q = (g = document == null ? void 0 : document.getSelection) == null ? void 0 : g.call(document)) == null ? void 0 : Q.toString()) != null ? m : "";
  }
  return {
    isSupported: s,
    text: l,
    copied: c,
    copy: d
  };
}
var Ld = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var Dd = "__vueuse_ssr_handlers__";
Ld[Dd] = Ld[Dd] || {};
var b7 = Ld[Dd];
function v7(t, e) {
  return b7[t] || e;
}
function X7(t) {
  return t == null ? "any" : t instanceof Set ? "set" : t instanceof Map ? "map" : t instanceof Date ? "date" : typeof t == "boolean" ? "boolean" : typeof t == "string" ? "string" : typeof t == "object" ? "object" : Number.isNaN(t) ? "any" : "number";
}
var x7 = Object.defineProperty;
var AP = Object.getOwnPropertySymbols;
var w7 = Object.prototype.hasOwnProperty;
var T7 = Object.prototype.propertyIsEnumerable;
var GP = (t, e, i) => e in t ? x7(t, e, { enumerable: true, configurable: true, writable: true, value: i }) : t[e] = i;
var LP = (t, e) => {
  for (var i in e || (e = {}))
    w7.call(e, i) && GP(t, i, e[i]);
  if (AP)
    for (var i of AP(e))
      T7.call(e, i) && GP(t, i, e[i]);
  return t;
};
var k7 = {
  boolean: {
    read: (t) => t === "true",
    write: (t) => String(t)
  },
  object: {
    read: (t) => JSON.parse(t),
    write: (t) => JSON.stringify(t)
  },
  number: {
    read: (t) => Number.parseFloat(t),
    write: (t) => String(t)
  },
  any: {
    read: (t) => t,
    write: (t) => String(t)
  },
  string: {
    read: (t) => t,
    write: (t) => String(t)
  },
  map: {
    read: (t) => new Map(JSON.parse(t)),
    write: (t) => JSON.stringify(Array.from(t.entries()))
  },
  set: {
    read: (t) => new Set(JSON.parse(t)),
    write: (t) => JSON.stringify(Array.from(t))
  },
  date: {
    read: (t) => new Date(t),
    write: (t) => t.toISOString()
  }
};
var DP = "vueuse-storage";
function _7(t, e, i, n = {}) {
  var O;
  const {
    flush: r = "pre",
    deep: a = true,
    listenToStorageChanges: o = true,
    writeDefaults: s = true,
    mergeDefaults: l = false,
    shallow: c,
    window: u = ar,
    eventFilter: h10,
    onError: d = (T) => {
      console.error(T);
    }
  } = n, p = (c ? shallowRef : ref)(e);
  if (!i)
    try {
      i = v7("getDefaultStorage", () => {
        var T;
        return (T = ar) == null ? void 0 : T.localStorage;
      })();
    } catch (T) {
      d(T);
    }
  if (!i)
    return p;
  const $ = bO(e), g = X7($), Q = (O = n.serializer) != null ? O : k7[g], { pause: m, resume: b } = m7(p, () => P(p.value), { flush: r, deep: a, eventFilter: h10 });
  return u && o && (BO(u, "storage", v), BO(u, DP, y)), v(), p;
  function P(T) {
    try {
      if (T == null)
        i.removeItem(t);
      else {
        const _ = Q.write(T), x = i.getItem(t);
        x !== _ && (i.setItem(t, _), u && u.dispatchEvent(new CustomEvent(DP, {
          detail: {
            key: t,
            oldValue: x,
            newValue: _,
            storageArea: i
          }
        })));
      }
    } catch (_) {
      d(_);
    }
  }
  function S(T) {
    const _ = T ? T.newValue : i.getItem(t);
    if (_ == null)
      return s && $ !== null && i.setItem(t, Q.write($)), $;
    if (!T && l) {
      const x = Q.read(_);
      return e7(l) ? l(x, $) : g === "object" && !Array.isArray(x) ? LP(LP({}, $), x) : x;
    } else
      return typeof _ != "string" ? _ : Q.read(_);
  }
  function y(T) {
    v(T.detail);
  }
  function v(T) {
    if (!(T && T.storageArea !== i)) {
      if (T && T.key == null) {
        p.value = $;
        return;
      }
      if (!(T && T.key !== t)) {
        m();
        try {
          p.value = S(T);
        } catch (_) {
          d(_);
        } finally {
          T ? nextTick(b) : b();
        }
      }
    }
  }
}
var MP = Object.getOwnPropertySymbols;
var W7 = Object.prototype.hasOwnProperty;
var Y7 = Object.prototype.propertyIsEnumerable;
var R7 = (t, e) => {
  var i = {};
  for (var n in t)
    W7.call(t, n) && e.indexOf(n) < 0 && (i[n] = t[n]);
  if (t != null && MP)
    for (var n of MP(t))
      e.indexOf(n) < 0 && Y7.call(t, n) && (i[n] = t[n]);
  return i;
};
function Z7(t, e, i = {}) {
  const n = i, { window: O = ar } = n, r = R7(n, ["window"]);
  let a;
  const o = Z$(() => O && "ResizeObserver" in O), s = () => {
    a && (a.disconnect(), a = void 0);
  }, l = watch(() => zn(t), (u) => {
    s(), o.value && O && u && (a = new ResizeObserver(e), a.observe(u, r));
  }, { immediate: true, flush: "post" }), c = () => {
    s(), l();
  };
  return R$(c), {
    isSupported: o,
    stop: c
  };
}
function NP(t, e = { width: 0, height: 0 }, i = {}) {
  const { window: n = ar, box: O = "content-box" } = i, r = computed(() => {
    var s, l;
    return (l = (s = zn(t)) == null ? void 0 : s.namespaceURI) == null ? void 0 : l.includes("svg");
  }), a = ref(e.width), o = ref(e.height);
  return Z7(t, ([s]) => {
    const l = O === "border-box" ? s.borderBoxSize : O === "content-box" ? s.contentBoxSize : s.devicePixelContentBoxSize;
    if (n && r.value) {
      const c = zn(t);
      if (c) {
        const u = n.getComputedStyle(c);
        a.value = parseFloat(u.width), o.value = parseFloat(u.height);
      }
    } else if (l) {
      const c = Array.isArray(l) ? l : [l];
      a.value = c.reduce((u, { inlineSize: h10 }) => u + h10, 0), o.value = c.reduce((u, { blockSize: h10 }) => u + h10, 0);
    } else
      a.value = s.contentRect.width, o.value = s.contentRect.height;
  }, i), watch(() => zn(t), (s) => {
    a.value = s ? e.width : 0, o.value = s ? e.height : 0;
  }), {
    width: a,
    height: o
  };
}
function U7(t = {}) {
  const { initialValue: e = "" } = t, i = Z$(() => typeof window < "u" && "EyeDropper" in window), n = ref(e);
  async function O(r) {
    if (!i.value)
      return;
    const o = await new window.EyeDropper().open(r);
    return n.value = o.sRGBHex, o;
  }
  return { isSupported: i, sRGBHex: n, open: O };
}
function U$(t, e, i = {}) {
  const { window: n = ar } = i;
  return _7(t, e, n == null ? void 0 : n.localStorage, i);
}
var BP;
(function(t) {
  t.UP = "UP", t.RIGHT = "RIGHT", t.DOWN = "DOWN", t.LEFT = "LEFT", t.NONE = "NONE";
})(BP || (BP = {}));
var V7 = Object.defineProperty;
var FP = Object.getOwnPropertySymbols;
var q7 = Object.prototype.hasOwnProperty;
var z7 = Object.prototype.propertyIsEnumerable;
var HP = (t, e, i) => e in t ? V7(t, e, { enumerable: true, configurable: true, writable: true, value: i }) : t[e] = i;
var C7 = (t, e) => {
  for (var i in e || (e = {}))
    q7.call(e, i) && HP(t, i, e[i]);
  if (FP)
    for (var i of FP(e))
      z7.call(e, i) && HP(t, i, e[i]);
  return t;
};
var E7 = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
C7({
  linear: a7
}, E7);
var j7 = {
  name: "HTextCopyButton"
};
var I7 = defineComponent({
  ...j7,
  props: {
    copyContent: null,
    title: null,
    type: { default: "primary" },
    size: { default: "small" },
    icon: { type: Boolean },
    successText: null,
    disabled: { type: Boolean, default: false }
  },
  emits: ["afterCopy"],
  setup(t, { emit: e }) {
    const i = t, { t: n } = hr(), { copy: O } = y7();
    function r() {
      O(i.copyContent), window.$he3.message.success(i.successText || n("common.copySuccess")), e("afterCopy");
    }
    return (a, o) => {
      const s = resolveComponent("HIcon"), l = resolveComponent("a-button");
      return openBlock(), createBlock(l, {
        class: "TransForm-right-content-btn",
        type: t.type,
        size: t.size,
        disabled: t.disabled,
        onClick: r
      }, createSlots({
        default: withCtx(() => [
          createTextVNode(" " + toDisplayString(t.title || unref(n)("common.copy")) + " ", 1),
          renderSlot(a.$slots, "default")
        ]),
        _: 2
      }, [
        i.icon ? {
          name: "icon",
          fn: withCtx(() => [
            createVNode(s, { icon: "ant-design:copy-outlined" })
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["type", "size", "disabled"]);
    };
  }
});
var V$ = Be(p9);
var lw = Be(Q9);
var pa = Be(I7);
function A7() {
  return navigator.userAgent.toLowerCase().includes("mac");
}
function cw() {
  return navigator.userAgent.toLowerCase().includes("windows");
}
var Xe = function() {
  return Xe = Object.assign || function(t) {
    for (var e, i = 1, n = arguments.length; i < n; i++)
      for (var O in e = arguments[i])
        Object.prototype.hasOwnProperty.call(e, O) && (t[O] = e[O]);
    return t;
  }, Xe.apply(this, arguments);
};
function KP(t, e, i) {
  if (i || arguments.length === 2)
    for (var n, O = 0, r = e.length; O < r; O++)
      !n && O in e || (n || (n = Array.prototype.slice.call(e, 0, O)), n[O] = e[O]);
  return t.concat(n || Array.prototype.slice.call(e));
}
var pe;
var aO;
var Oi;
var xc;
(function(t) {
  t.HEX = "HEX", t.RGB = "RGB", t.HSL = "HSL", t.CMYK = "CMYK";
})(pe || (pe = {})), function(t) {
  t.ANALOGOUS = "ANALOGOUS", t.COMPLEMENTARY = "COMPLEMENTARY", t.SPLIT_COMPLEMENTARY = "SPLIT_COMPLEMENTARY", t.TRIADIC = "TRIADIC", t.TETRADIC = "TETRADIC", t.SQUARE = "SQUARE";
}(aO || (aO = {})), function(t) {
  t.ADDITIVE = "ADDITIVE", t.SUBTRACTIVE = "SUBTRACTIVE";
}(Oi || (Oi = {})), function(t) {
  t.black = "#000000", t.silver = "#C0C0C0", t.gray = "#808080", t.white = "#FFFFFF", t.maroon = "#800000", t.red = "#FF0000", t.purple = "#800080", t.fuchsia = "#FF00FF", t.green = "#008000", t.lime = "#00FF00", t.olive = "#808000", t.yellow = "#FFFF00", t.navy = "#000080", t.blue = "#0000FF", t.teal = "#008080", t.aqua = "#00FFFF", t.orange = "#FFA500", t.aliceblue = "#F0F8FF", t.antiquewhite = "#FAEBD7", t.aquamarine = "#7FFFD4", t.azure = "#F0FFFF", t.beige = "#F5F5DC", t.bisque = "#FFE4C4", t.blanchedalmond = "#FFEBCD", t.blueviolet = "#8A2BE2", t.brown = "#A52A2A", t.burlywood = "#DEB887", t.cadetblue = "#5F9EA0", t.chartreuse = "#7FFF00", t.chocolate = "#D2691E", t.coral = "#FF7F50", t.cornflowerblue = "#6495ED", t.cornsilk = "#FFF8DC", t.crimson = "#DC143C", t.cyan = "#00FFFF", t.darkblue = "#00008B", t.darkcyan = "#008B8B", t.darkgoldenrod = "#B8860B", t.darkgray = "#A9A9A9", t.darkgreen = "#006400", t.darkgrey = "#A9A9A9", t.darkkhaki = "#BDB76B", t.darkmagenta = "#8B008B", t.darkolivegreen = "#556B2F", t.darkorange = "#FF8C00", t.darkorchid = "#9932CC", t.darkred = "#8B0000", t.darksalmon = "#E9967A", t.darkseagreen = "#8FBC8F", t.darkslateblue = "#483D8B", t.darkslategray = "#2F4F4F", t.darkslategrey = "#2F4F4F", t.darkturquoise = "#00CED1", t.darkviolet = "#9400D3", t.deeppink = "#FF1493", t.deepskyblue = "#00BFFF", t.dimgray = "#696969", t.dimgrey = "#696969", t.dodgerblue = "#1E90FF", t.firebrick = "#B22222", t.floralwhite = "#FFFAF0", t.forestgreen = "#228B22", t.gainsboro = "#DCDCDC", t.ghostwhite = "#F8F8FF", t.gold = "#FFD700", t.goldenrod = "#DAA520", t.greenyellow = "#ADFF2F", t.grey = "#808080", t.honeydew = "#F0FFF0", t.hotpink = "#FF69B4", t.indianred = "#CD5C5C", t.indigo = "#4B0082", t.ivory = "#FFFFF0", t.khaki = "#F0E68C", t.lavender = "#E6E6FA", t.lavenderblush = "#FFF0F5", t.lawngreen = "#7CFC00", t.lemonchiffon = "#FFFACD", t.lightblue = "#ADD8E6", t.lightcoral = "#F08080", t.lightcyan = "#E0FFFF", t.lightgoldenrodyellow = "#FAFAD2", t.lightgray = "#D3D3D3", t.lightgreen = "#90EE90", t.lightgrey = "#D3D3D3", t.lightpink = "#FFB6C1", t.lightsalmon = "#FFA07A", t.lightseagreen = "#20B2AA", t.lightskyblue = "#87CEFA", t.lightslategray = "#778899", t.lightslategrey = "#778899", t.lightsteelblue = "#B0C4DE", t.lightyellow = "#FFFFE0", t.limegreen = "#32CD32", t.linen = "#FAF0E6", t.magenta = "#FF00FF", t.mediumaquamarine = "#66CDAA", t.mediumblue = "#0000CD", t.mediumorchid = "#BA55D3", t.mediumpurple = "#9370DB", t.mediumseagreen = "#3CB371", t.mediumslateblue = "#7B68EE", t.mediumspringgreen = "#00FA9A", t.mediumturquoise = "#48D1CC", t.mediumvioletred = "#C71585", t.midnightblue = "#191970", t.mintcream = "#F5FFFA", t.mistyrose = "#FFE4E1", t.moccasin = "#FFE4B5", t.navajowhite = "#FFDEAD", t.oldlace = "#FDF5E6", t.olivedrab = "#6B8E23", t.orangered = "#FF4500", t.orchid = "#DA70D6", t.palegoldenrod = "#EEE8AA", t.palegreen = "#98FB98", t.paleturquoise = "#AFEEEE", t.palevioletred = "#DB7093", t.papayawhip = "#FFEFD5", t.peachpuff = "#FFDAB9", t.peru = "#CD853F", t.pink = "#FFC0CB", t.plum = "#DDA0DD", t.powderblue = "#B0E0E6", t.rosybrown = "#BC8F8F", t.royalblue = "#4169E1", t.saddlebrown = "#8B4513", t.salmon = "#FA8072", t.sandybrown = "#F4A460", t.seagreen = "#2E8B57", t.seashell = "#FFF5EE", t.sienna = "#A0522D", t.skyblue = "#87CEEB", t.slateblue = "#6A5ACD", t.slategray = "#708090", t.slategrey = "#708090", t.snow = "#FFFAFA", t.springgreen = "#00FF7F", t.steelblue = "#4682B4", t.tan = "#D2B48C", t.thistle = "#D8BFD8", t.tomato = "#FF6347", t.turquoise = "#40E0D0", t.violet = "#EE82EE", t.wheat = "#F5DEB3", t.whitesmoke = "#F5F5F5", t.yellowgreen = "#9ACD32", t.rebeccapurple = "#663399";
}(xc || (xc = {}));
var io;
var no;
var Oo;
var ro;
var kn;
var qO;
var zO;
var uw = Object.keys(xc);
var mo = ((io = {})[pe.HEX] = /^#(?:([a-f\d])([a-f\d])([a-f\d])([a-f\d])?|([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?)$/i, io[pe.RGB] = /^rgba?\s*\(\s*(?:((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)(?:\s*,\s*((?:\d*\.)?\d+))?|((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)(?:\s*\/\s*((?:\d*\.)?\d+%?))?)\s*\)$/, io[pe.HSL] = /^hsla?\s*\(\s*(?:(-?(?:\d*\.)?\d+(?:deg|grad|rad|turn)?)\s*,\s*((?:\d*\.)?\d+)%\s*,\s*((?:\d*\.)?\d+)%(?:\s*,\s*((?:\d*\.)?\d+))?|(-?(?:\d*\.)?\d+(?:deg|grad|rad|turn)?)\s*((?:\d*\.)?\d+)%\s*((?:\d*\.)?\d+)%(?:\s*\/\s*((?:\d*\.)?\d+%?))?)\s*\)$/, io[pe.CMYK] = /^(?:device-cmyk|cmyk)\s*\(\s*(?:((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)(?:\s*,\s*((?:\d*\.)?\d+))?|((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)(?:\s*\/\s*((?:\d*\.)?\d+%?))?)\s*\)$/, io);
var G7 = /^(-?(?:\d*\.)?\d+)((?:deg|grad|rad|turn)?)$/;
var Ln = /^(\d+(?:\.\d+)?|\.\d+)%$/;
var Md = /^0x([a-f\d]{1,2})$/i;
var L7 = "The provided string color doesn't have a correct format";
var D7 = "The provided color object doesn't have the proper keys or format";
var Gf = function(t, e, i) {
  return i < 0 && (i += 6), i >= 6 && (i -= 6), i < 1 ? Math.round(255 * ((e - t) * i + t)) : i < 3 ? Math.round(255 * e) : i < 4 ? Math.round(255 * ((e - t) * (4 - i) + t)) : Math.round(255 * t);
};
var vt = function(t, e, i) {
  e /= 100;
  var n = (i /= 100) <= 0.5 ? i * (e + 1) : i + e - i * e, O = 2 * i - n;
  return { r: Gf(O, n, (t /= 60) + 2), g: Gf(O, n, t), b: Gf(O, n, t - 2) };
};
var q$ = function(t, e, i, n) {
  return n = 1 - n, { r: Math.round(255 * (1 - t) * n), g: Math.round(255 * (1 - e) * n), b: Math.round(255 * (1 - i) * n) };
};
var Nd = function(t, e, i) {
  t /= 255, e /= 255, i /= 255;
  var n = 1 - Math.max(t, e, i), O = 1 - n, r = (O - t) / O, a = (O - e) / O, o = (O - i) / O;
  return { c: Math.round(100 * r), m: Math.round(100 * a), y: Math.round(100 * o), k: Math.round(100 * n) };
};
var $a = function(t, e, i, n) {
  n === void 0 && (n = 1), t /= 255, e /= 255, i /= 255, n = Math.min(n, 1);
  var O = Math.max(t, e, i), r = Math.min(t, e, i), a = O - r, o = 0, s = 0, l = (O + r) / 2;
  if (a === 0)
    o = 0, s = 0;
  else {
    switch (O) {
      case t:
        o = (e - i) / a % 6;
        break;
      case e:
        o = (i - t) / a + 2;
        break;
      case i:
        o = (t - e) / a + 4;
    }
    (o = Math.round(60 * o)) < 0 && (o += 360), s = a / (1 - Math.abs(2 * l - 1));
  }
  return { h: o, s: Math.round(100 * s), l: Math.round(100 * l), a: n };
};
var JP = function(t, e) {
  if (t < 0 && (t += 360), t > 360 && (t -= 360), t === 360 || t === 0)
    return t;
  var i = [[0, 120], [120, 180], [180, 240], [240, 360]], n = [[0, 60], [60, 120], [120, 240], [240, 360]], O = e ? n : i, r = 0, a = 0, o = 0, s = 0;
  return (e ? i : n).find(function(l, c) {
    return t >= l[0] && t < l[1] && (r = l[0], a = l[1], o = O[c][0], s = O[c][1], true);
  }), o + (s - o) / (a - r) * (t - r);
};
var ot = function(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
};
var wc = function(t) {
  return Ln.test("".concat(t)) ? +"".concat(t).replace(Ln, "$1") : Math.min(+t, 100);
};
var pl = function(t) {
  return t.length === 1 && (t += t), parseInt(t, 16);
};
var $l = function(t) {
  var e = de(t).toString(16).toUpperCase();
  return e.length === 1 ? "0x0".concat(e) : "0x".concat(e);
};
var Ql = function(t) {
  var e = de(t).toString(16).toUpperCase();
  return e.length === 1 && (e = "0".concat(e)), e;
};
var MO = function(t, e) {
  return e === void 0 && (e = false), !e && Ln.test(t) ? Math.min(255 * +t.replace(Ln, "$1") / 100, 255) : Md.test(t) ? t.length === 3 ? e ? parseInt(t + t.slice(-1)) / 255 : parseInt(t + t.slice(-1)) : e ? de(t, 6) / 255 : de(t, 6) : Math.min(+t, e ? 1 : 255);
};
var hO = function(t) {
  return Math.min(Ln.test(t) ? +t.replace(Ln, "$1") / 100 : +t, 1);
};
var fw = function(t) {
  return t.sort().join("").toUpperCase();
};
var de = function(t, e) {
  e === void 0 && (e = 0);
  var i = Math.pow(10, e);
  return Math.round(+t * i) / i;
};
var Mi = function(t, e, i) {
  return Math.max(e, Math.min(t, i));
};
var $e = ((no = {})[pe.HEX] = function(t) {
  return "#".concat(Ql(t.r)).concat(Ql(t.g)).concat(Ql(t.b)).concat(ot(t, "a") && Ql(t.a) || "");
}, no[pe.RGB] = function(t) {
  return "rgb".concat(ot(t, "a") ? "a" : "", "(").concat(de(t.r), ",").concat(de(t.g), ",").concat(de(t.b)).concat(ot(t, "a") && ",".concat(de(t.a, 2)) || "", ")");
}, no[pe.HSL] = function(t) {
  return "hsl".concat(ot(t, "a") ? "a" : "", "(").concat(de(t.h), ",").concat(de(t.s), "%,").concat(de(t.l), "%").concat(ot(t, "a") && ",".concat(de(t.a, 2)) || "", ")");
}, no[pe.CMYK] = function(t) {
  return "cmyk(".concat(de(t.c), "%,").concat(de(t.m), "%,").concat(de(t.y), "%,").concat(de(t.k), "%").concat(ot(t, "a") && ",".concat(de(t.a, 2)) || "", ")");
}, no);
var fs = function(t) {
  if (typeof t == "string") {
    var e = t.match(G7), i = +e[1];
    switch (e[2]) {
      case "rad":
        t = Math.round(180 * i / Math.PI);
        break;
      case "turn":
        t = Math.round(360 * i);
        break;
      default:
        t = i;
    }
  }
  return (t > 360 || t < 0) && (t -= 360 * Math.floor(t / 360)), t;
};
var Lt = function(t) {
  return typeof t == "string" && (t = Ln.test(t) ? +t.replace(Ln, "$1") / 100 : +t), isNaN(+t) || t > 1 ? 1 : de(t, 6);
};
var Ua = function(t, e, i) {
  return e.reduce(function(n, O) {
    return KP(KP([], n, true), [Xe(Xe({}, t), { h: i === Oi.ADDITIVE ? fs(t.h + O) : fs(JP(JP(t.h, false) + O, true)) })], false);
  }, [Xe({}, t)]);
};
var M7 = function(t, e) {
  return Ua(t, [30, -30], e);
};
var N7 = function(t, e) {
  return Ua(t, [180], e);
};
var B7 = function(t, e) {
  return Ua(t, [150, -150], e);
};
var F7 = function(t, e) {
  return Ua(t, [120, -120], e);
};
var H7 = function(t, e) {
  return Ua(t, [60, -120, 180], e);
};
var K7 = function(t, e) {
  return Ua(t, [90, -90, 180], e);
};
var ey = Object.entries(pe).reduce(function(t, e) {
  var i = e[0], n = e[1];
  if (i !== pe.HEX) {
    var O = fw(i.split(""));
    t[O] = n, t["A" + O] = n;
  }
  return t;
}, {});
var wi = function(t) {
  return typeof t == "string" ? function(e) {
    var i;
    if (Object.keys(pe).some(function(n) {
      if (mo[n].test(e))
        return i = n, true;
    }), !i && ~uw.indexOf(e) && (i = pe.HEX), !i)
      throw new Error(L7);
    return i;
  }(t) : function(e) {
    var i, n = false, O = fw(Object.keys(e));
    if (ey[O] && (i = ey[O]), i && i === pe.RGB) {
      var r = Object.entries(e).some(function(o) {
        return !Md.test("".concat(o[1]));
      }), a = Object.entries(e).some(function(o) {
        return !(Ln.test("".concat(o[1])) || !Md.test("".concat(o[1])) && !isNaN(+o[1]) && +o[1] <= 255);
      });
      r && a && (n = true), r || (i = pe.HEX);
    }
    if (!i || n)
      throw new Error(D7);
    return i;
  }(t);
};
var J7 = ((Oo = {})[pe.HEX] = function(t) {
  var e = (~uw.indexOf(t) ? xc[t] : t).match(mo.HEX), i = { r: pl(e[1] || e[5]), g: pl(e[2] || e[6]), b: pl(e[3] || e[7]) }, n = e[4] || e[8];
  return n !== void 0 && (i.a = pl(n) / 255), i;
}, Oo[pe.RGB] = function(t) {
  var e = t.match(mo.RGB), i = MO(e[1] || e[5]), n = MO(e[2] || e[6]), O = MO(e[3] || e[7]), r = e[4] || e[8], a = { r: Math.min(i, 255), g: Math.min(n, 255), b: Math.min(O, 255) };
  return r !== void 0 && (a.a = Lt(r)), a;
}, Oo[pe.HSL] = function(t) {
  var e = t.match(mo.HSL), i = fs(e[1] || e[5]), n = wc(e[2] || e[6]), O = wc(e[3] || e[7]), r = e[4] || e[8], a = vt(i, n, O);
  return r !== void 0 && (a.a = Lt(r)), a;
}, Oo[pe.CMYK] = function(t) {
  var e = t.match(mo.CMYK), i = hO(e[1] || e[6]), n = hO(e[2] || e[7]), O = hO(e[3] || e[8]), r = hO(e[4] || e[9]), a = e[5] || e[10], o = q$(i, n, O, r);
  return a !== void 0 && (o.a = Lt(a)), o;
}, Oo);
var eI = ((ro = {})[pe.HEX] = function(t) {
  var e = { r: MO("".concat(t.r)), g: MO("".concat(t.g)), b: MO("".concat(t.b)) };
  return ot(t, "a") && (e.a = Math.min(MO("".concat(t.a), true), 1)), e;
}, ro[pe.RGB] = function(t) {
  return this.HEX(t);
}, ro[pe.HSL] = function(t) {
  var e = wc("".concat(t.s)), i = wc("".concat(t.l)), n = vt(fs(t.h), e, i);
  return ot(t, "a") && (n.a = Lt(t.a)), n;
}, ro[pe.CMYK] = function(t) {
  var e = hO("".concat(t.c)), i = hO("".concat(t.m)), n = hO("".concat(t.y)), O = hO("".concat(t.k)), r = q$(e, i, n, O);
  return ot(t, "a") && (r.a = Lt(t.a)), r;
}, ro);
var or = function(t, e) {
  return e === void 0 && (e = wi(t)), typeof t == "string" ? J7[e](t) : eI[e](t);
};
var Pe = ((kn = {})[pe.HEX] = function(t) {
  return { r: $l(t.r), g: $l(t.g), b: $l(t.b) };
}, kn.HEXA = function(t) {
  var e = Pe.HEX(t);
  return e.a = ot(t, "a") ? $l(255 * t.a) : "0xFF", e;
}, kn[pe.RGB] = function(t) {
  return ot(t, "a") && delete t.a, t;
}, kn.RGBA = function(t) {
  return t.a = ot(t, "a") ? de(t.a, 2) : 1, t;
}, kn[pe.HSL] = function(t) {
  var e = $a(t.r, t.g, t.b);
  return delete e.a, e;
}, kn.HSLA = function(t) {
  var e = Pe.HSL(t);
  return e.a = ot(t, "a") ? de(t.a, 2) : 1, e;
}, kn[pe.CMYK] = function(t) {
  return Nd(t.r, t.g, t.b);
}, kn.CMYKA = function(t) {
  var e = Nd(t.r, t.g, t.b);
  return e.a = ot(t, "a") ? de(t.a, 2) : 1, e;
}, kn);
var ty = function(t, e, i) {
  var n = wi(t), O = typeof t == "string", r = or(t, n), a = typeof t == "string" && ot(r, "a") || typeof t != "string" && ot(t, "a"), o = $a(r.r, r.g, r.b, r.a);
  a || delete o.a;
  var s = i ? o.l / (e + 1) : (100 - o.l) / (e + 1), l = Array(e).fill(null).map(function(c, u) {
    return Xe(Xe({}, o), { l: o.l + s * (u + 1) * (1 - 2 * +i) });
  });
  switch (n) {
    case pe.HEX:
    default:
      return l.map(function(c) {
        var u = vt(c.h, c.s, c.l);
        return a && (u.a = c.a), O ? a ? $e.HEX(Xe(Xe({}, u), { a: de(255 * u.a, 6) })) : $e.HEX(u) : a ? Pe.HEXA(u) : Pe.HEX(u);
      });
    case pe.RGB:
      return l.map(function(c) {
        var u = vt(c.h, c.s, c.l);
        return a && (u.a = c.a), O ? $e.RGB(u) : a ? Pe.RGBA(u) : Pe.RGB(u);
      });
    case pe.HSL:
      return l.map(function(c) {
        return O ? $e.HSL(c) : a ? Pe.HSLA(Xe(Xe({}, vt(c.h, c.s, c.l)), { a: c.a })) : Pe.HSL(vt(c.h, c.s, c.l));
      });
  }
};
var Tr = ((qO = { buildHarmony: function(t, e, i) {
  var n = wi(t), O = or(t, n), r = $a(O.r, O.g, O.b, O.a), a = typeof t == "string" && ot(O, "a") || typeof t != "string" && ot(t, "a"), o = typeof t == "string";
  switch (n) {
    case pe.HEX:
    default:
      return a ? this.HEXA(r, e, i, o) : this.HEX(r, e, i, o);
    case pe.HSL:
      return a ? this.HSLA(r, e, i, o) : this.HSL(r, e, i, o);
    case pe.RGB:
      return a ? this.RGBA(r, e, i, o) : this.RGB(r, e, i, o);
  }
} })[pe.HEX] = function(t, e, i, n) {
  return e(t, i).map(function(O) {
    return n ? $e.HEX(vt(O.h, O.s, O.l)) : Pe.HEX(vt(O.h, O.s, O.l));
  });
}, qO.HEXA = function(t, e, i, n) {
  return e(t, i).map(function(O) {
    return n ? $e.HEX(Xe(Xe({}, vt(O.h, O.s, O.l)), { a: 255 * Lt(O.a) })) : Pe.HEXA(Xe(Xe({}, vt(O.h, O.s, O.l)), { a: Lt(O.a) }));
  });
}, qO[pe.RGB] = function(t, e, i, n) {
  return e(t, i).map(function(O) {
    return n ? $e.RGB(vt(O.h, O.s, O.l)) : Pe.RGB(vt(O.h, O.s, O.l));
  });
}, qO.RGBA = function(t, e, i, n) {
  return e(t, i).map(function(O) {
    return n ? $e.RGB(Xe(Xe({}, vt(O.h, O.s, O.l)), { a: Lt(O.a) })) : Pe.RGBA(Xe(Xe({}, vt(O.h, O.s, O.l)), { a: Lt(O.a) }));
  });
}, qO[pe.HSL] = function(t, e, i, n) {
  return e(t, i).map(function(O) {
    return n ? $e.HSL({ h: O.h, s: O.s, l: O.l }) : Pe.HSL(vt(O.h, O.s, O.l));
  });
}, qO.HSLA = function(t, e, i, n) {
  return e(t, i).map(function(O) {
    return n ? $e.HSL(Xe(Xe({}, O), { a: Lt(O.a) })) : Pe.HSLA(Xe(Xe({}, vt(O.h, O.s, O.l)), { a: Lt(O.a) }));
  });
}, qO);
var kr = ((zO = { mix: function(t, e) {
  var i, n, O, r, a, o, s, l, c, u, h10, d, p, $, g, Q = t.map(function(S) {
    var y = wi(S);
    return or(S, y);
  }), m = e === Oi.SUBTRACTIVE ? Q.map(function(S) {
    var y, v, T, _, x, k, Y, Z, L, ae, Oe, C, M, H, xe = (y = S.r, v = S.g, T = S.b, _ = Math.min(y, v, T), x = Math.min(255 - y, 255 - v, 255 - T), k = y - _, Y = v - _, Z = T - _, L = Math.min(k, Y), ae = k - L, Oe = (Y + L) / 2, C = (Z + Y - L) / 2, M = Math.max(ae, Oe, C) / Math.max(k, Y, Z), H = isNaN(M) || M === 1 / 0 || M <= 0 ? 1 : M, { r: ae / H + x, y: Oe / H + x, b: C / H + x });
    return ot(S, "a") && (xe.a = S.a), xe;
  }) : null;
  function b(S) {
    var y = e === Oi.ADDITIVE ? { r: 0, g: 0, b: 0, a: 0 } : { r: 0, y: 0, b: 0, a: 0 };
    return S.reduce(function(v, T) {
      var _ = ot(T, "a") ? T.a : 1, x = { r: Math.min(v.r + T.r * _, 255), b: Math.min(v.b + T.b * _, 255), a: 1 - (1 - _) * (1 - v.a) }, k = "g" in v ? v.g : v.y, Y = "g" in T ? T.g : T.y;
      return Xe(Xe({}, x), e === Oi.ADDITIVE ? { g: Math.min(k + Y * _, 255) } : { y: Math.min(k + Y * _, 255) });
    }, y);
  }
  if (e === Oi.ADDITIVE)
    i = b(Q);
  else {
    var P = b(m);
    n = P.r, O = P.y, r = P.b, a = Math.min(n, O, r), o = Math.min(255 - n, 255 - O, 255 - r), s = n - a, l = O - a, c = r - a, u = Math.min(l, c), h10 = s + l - u, d = l + u, p = 2 * (c - u), $ = Math.max(h10, d, p) / Math.max(s, l, c), g = isNaN($) || $ === 1 / 0 || $ <= 0 ? 1 : $, (i = { r: h10 / g + o, g: d / g + o, b: p / g + o }).a = P.a;
  }
  return { r: de(i.r, 2), g: de(i.g, 2), b: de(i.b, 2), a: Mi(i.a, 0, 1) };
} })[pe.HEX] = function(t, e, i) {
  var n = this.mix(t, e);
  return delete n.a, i ? $e.HEX(n) : Pe.HEX(n);
}, zO.HEXA = function(t, e, i) {
  var n = this.mix(t, e);
  return n.a = i ? 255 * Lt(n.a) : Lt(n.a), i ? $e.HEX(n) : Pe.HEXA(n);
}, zO[pe.RGB] = function(t, e, i) {
  var n = this.mix(t, e);
  return delete n.a, i ? $e.RGB(n) : Pe.RGB(n);
}, zO.RGBA = function(t, e, i) {
  var n = this.mix(t, e);
  return i ? $e.RGB(n) : Pe.RGBA(n);
}, zO[pe.HSL] = function(t, e, i) {
  var n = this.mix(t, e), O = $a(n.r, n.g, n.b);
  return delete n.a, delete O.a, i ? $e.HSL(O) : Pe.HSL(n);
}, zO.HSLA = function(t, e, i) {
  var n = this.mix(t, e), O = $a(n.r, n.g, n.b, n.a);
  return i ? $e.HSL(O) : Pe.HSLA(n);
}, zO);
var tO = function(t, e, i, n, O) {
  var r = n(or(t, e));
  return i ? O(r) : r;
};
var _r = function(t, e, i, n, O, r) {
  i < 1 && (i = 5);
  var a = function(o, s, l) {
    var c = l - 1, u = (s.r - o.r) / c, h10 = (s.g - o.g) / c, d = (s.b - o.b) / c, p = Lt(o.a), $ = (Lt(s.a) - p) / c;
    return Array(l).fill(null).map(function(g, Q) {
      return Q === 0 ? o : Q === c ? s : { r: de(o.r + u * Q), g: de(o.g + h10 * Q), b: de(o.b + d * Q), a: de(p + $ * Q, 2) };
    });
  }(or(t), or(e), i);
  return a.map(function(o) {
    var s = O(o);
    return n ? r(s) : s;
  });
};
var hw = function() {
  function t(e) {
    this.rgb = or(e), this.updateHSL(), this.updateCMYK();
  }
  return t.prototype.updateRGB = function() {
    this.rgb = Xe(Xe({}, vt(this.hsl.h, this.hsl.s, this.hsl.l)), { a: this.hsl.a });
  }, t.prototype.updateRGBFromCMYK = function() {
    this.rgb = Xe(Xe({}, q$(this.cmyk.c, this.cmyk.m, this.cmyk.y, this.cmyk.k)), { a: this.rgb.a });
  }, t.prototype.updateHSL = function() {
    this.hsl = $a(this.rgb.r, this.rgb.g, this.rgb.b, this.rgb.a);
  }, t.prototype.updateCMYK = function() {
    this.cmyk = Nd(this.rgb.r, this.rgb.g, this.rgb.b);
  }, t.prototype.updateRGBAndCMYK = function() {
    return this.updateRGB(), this.updateCMYK(), this;
  }, t.prototype.updateHSLAndCMYK = function() {
    return this.updateHSL(), this.updateCMYK(), this;
  }, t.prototype.updateRGBAndHSL = function() {
    return this.updateRGBFromCMYK(), this.updateHSL(), this;
  }, t.prototype.setH = function(e) {
    return this.hsl.h = fs(e), this.updateRGBAndCMYK();
  }, t.prototype.setS = function(e) {
    return this.hsl.s = Mi(e, 0, 100), this.updateRGBAndCMYK();
  }, t.prototype.setL = function(e) {
    return this.hsl.l = Mi(e, 0, 100), this.updateRGBAndCMYK();
  }, t.prototype.setR = function(e) {
    return this.rgb.r = Mi(e, 0, 255), this.updateHSLAndCMYK();
  }, t.prototype.setG = function(e) {
    return this.rgb.g = Mi(e, 0, 255), this.updateHSLAndCMYK();
  }, t.prototype.setB = function(e) {
    return this.rgb.b = Mi(e, 0, 255), this.updateHSLAndCMYK();
  }, t.prototype.setA = function(e) {
    return this.hsl.a = this.rgb.a = Mi(e, 0, 1), this;
  }, t.prototype.setC = function(e) {
    return this.cmyk.c = Mi(e, 0, 100), this.updateRGBAndHSL();
  }, t.prototype.setM = function(e) {
    return this.cmyk.m = Mi(e, 0, 100), this.updateRGBAndHSL();
  }, t.prototype.setY = function(e) {
    return this.cmyk.y = Mi(e, 0, 100), this.updateRGBAndHSL();
  }, t.prototype.setK = function(e) {
    return this.cmyk.k = Mi(e, 0, 100), this.updateRGBAndHSL();
  }, Object.defineProperty(t.prototype, "H", { get: function() {
    return de(this.hsl.h);
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "S", { get: function() {
    return de(this.hsl.s);
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "L", { get: function() {
    return de(this.hsl.l);
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "R", { get: function() {
    return de(this.rgb.r);
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "G", { get: function() {
    return de(this.rgb.g);
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "B", { get: function() {
    return de(this.rgb.b);
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "A", { get: function() {
    return de(this.hsl.a, 2);
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "C", { get: function() {
    return de(this.cmyk.c);
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "M", { get: function() {
    return de(this.cmyk.m);
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "Y", { get: function() {
    return de(this.cmyk.y);
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "K", { get: function() {
    return de(this.cmyk.k);
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "HEXObject", { get: function() {
    return Pe.HEX(this.rgb);
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "HEXAObject", { get: function() {
    return Pe.HEXA(this.rgb);
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "RGBObject", { get: function() {
    return { r: this.R, g: this.G, b: this.B };
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "RGBAObject", { get: function() {
    return Xe(Xe({}, this.RGBObject), { a: this.hsl.a });
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "HSLObject", { get: function() {
    return { h: this.H, s: this.S, l: this.L };
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "HSLAObject", { get: function() {
    return Xe(Xe({}, this.HSLObject), { a: this.hsl.a });
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "CMYKObject", { get: function() {
    return { c: this.C, m: this.M, y: this.Y, k: this.K };
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "CMYKAObject", { get: function() {
    return { c: this.C, m: this.M, y: this.Y, k: this.K, a: this.hsl.a };
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "HEX", { get: function() {
    var e = this.rgb, i = { r: e.r, g: e.g, b: e.b };
    return $e.HEX(i);
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "HEXA", { get: function() {
    var e = this.rgb, i = { r: e.r, g: e.g, b: e.b, a: 255 * this.hsl.a };
    return $e.HEX(i);
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "RGB", { get: function() {
    var e = this.rgb, i = { r: e.r, g: e.g, b: e.b };
    return $e.RGB(i);
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "RGBA", { get: function() {
    var e = this.rgb, i = { r: e.r, g: e.g, b: e.b, a: this.hsl.a };
    return $e.RGB(i);
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "HSL", { get: function() {
    var e = this.hsl, i = { h: e.h, s: e.s, l: e.l };
    return $e.HSL(i);
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "HSLA", { get: function() {
    return $e.HSL(this.hsl);
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "CMYK", { get: function() {
    return $e.CMYK(this.cmyk);
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "CMYKA", { get: function() {
    return $e.CMYK(Xe(Xe({}, this.cmyk), { a: this.hsl.a }));
  }, enumerable: false, configurable: true }), t.toHEX = function(e, i) {
    i === void 0 && (i = true);
    var n = wi(e);
    return tO(e, n, i, Pe.HEX, $e.HEX);
  }, t.toHEXA = function(e, i) {
    i === void 0 && (i = true);
    var n = wi(e);
    return tO(e, n, i, Pe.HEXA, $e.HEX);
  }, t.toRGB = function(e, i) {
    i === void 0 && (i = true);
    var n = wi(e);
    return tO(e, n, i, Pe.RGB, $e.RGB);
  }, t.toRGBA = function(e, i) {
    i === void 0 && (i = true);
    var n = wi(e);
    return tO(e, n, i, Pe.RGBA, $e.RGB);
  }, t.toHSL = function(e, i) {
    i === void 0 && (i = true);
    var n = wi(e);
    return tO(e, n, i, Pe.HSL, $e.HSL);
  }, t.toHSLA = function(e, i) {
    i === void 0 && (i = true);
    var n = wi(e);
    return tO(e, n, i, Pe.HSLA, $e.HSL);
  }, t.toCMYK = function(e, i) {
    i === void 0 && (i = true);
    var n = wi(e);
    return tO(e, n, i, Pe.CMYK, $e.CMYK);
  }, t.toCMYKA = function(e, i) {
    i === void 0 && (i = true);
    var n = wi(e);
    return tO(e, n, i, Pe.CMYKA, $e.CMYK);
  }, t.getBlendHEX = function(e, i, n, O) {
    return n === void 0 && (n = 5), O === void 0 && (O = true), _r(e, i, n, O, Pe.HEX, $e.HEX);
  }, t.getBlendHEXA = function(e, i, n, O) {
    return n === void 0 && (n = 5), O === void 0 && (O = true), _r(e, i, n, O, Pe.HEXA, $e.HEX);
  }, t.getBlendRGB = function(e, i, n, O) {
    return n === void 0 && (n = 5), O === void 0 && (O = true), _r(e, i, n, O, Pe.RGB, $e.RGB);
  }, t.getBlendRGBA = function(e, i, n, O) {
    return n === void 0 && (n = 5), O === void 0 && (O = true), _r(e, i, n, O, Pe.RGBA, $e.RGB);
  }, t.getBlendHSL = function(e, i, n, O) {
    return n === void 0 && (n = 5), O === void 0 && (O = true), _r(e, i, n, O, Pe.HSL, $e.HSL);
  }, t.getBlendHSLA = function(e, i, n, O) {
    return n === void 0 && (n = 5), O === void 0 && (O = true), _r(e, i, n, O, Pe.HSLA, $e.HSL);
  }, t.getMixHEX = function(e, i, n) {
    return i === void 0 && (i = Oi.ADDITIVE), n === void 0 && (n = true), kr.HEX(e, i, n);
  }, t.getMixHEXA = function(e, i, n) {
    return i === void 0 && (i = Oi.ADDITIVE), n === void 0 && (n = true), kr.HEXA(e, i, n);
  }, t.getMixRGB = function(e, i, n) {
    return i === void 0 && (i = Oi.ADDITIVE), n === void 0 && (n = true), kr.RGB(e, i, n);
  }, t.getMixRGBA = function(e, i, n) {
    return i === void 0 && (i = Oi.ADDITIVE), n === void 0 && (n = true), kr.RGBA(e, i, n);
  }, t.getMixHSL = function(e, i, n) {
    return i === void 0 && (i = Oi.ADDITIVE), n === void 0 && (n = true), kr.HSL(e, i, n);
  }, t.getMixHSLA = function(e, i, n) {
    return i === void 0 && (i = Oi.ADDITIVE), n === void 0 && (n = true), kr.HSLA(e, i, n);
  }, t.getShades = function(e, i) {
    return ty(e, i, true);
  }, t.getTints = function(e, i) {
    return ty(e, i, false);
  }, t.getHarmony = function(e, i, n) {
    switch (i === void 0 && (i = aO.COMPLEMENTARY), n === void 0 && (n = Oi.ADDITIVE), i) {
      case aO.ANALOGOUS:
        return Tr.buildHarmony(e, M7, n);
      case aO.SPLIT_COMPLEMENTARY:
        return Tr.buildHarmony(e, B7, n);
      case aO.TRIADIC:
        return Tr.buildHarmony(e, F7, n);
      case aO.TETRADIC:
        return Tr.buildHarmony(e, H7, n);
      case aO.SQUARE:
        return Tr.buildHarmony(e, K7, n);
      default:
        return Tr.buildHarmony(e, N7, n);
    }
  }, t;
}();
var tI = function(t) {
  var e = {};
  function i(n) {
    if (e[n])
      return e[n].exports;
    var O = e[n] = { i: n, l: false, exports: {} };
    return t[n].call(O.exports, O, O.exports, i), O.l = true, O.exports;
  }
  return i.m = t, i.c = e, i.d = function(n, O, r) {
    i.o(n, O) || Object.defineProperty(n, O, { enumerable: true, get: r });
  }, i.r = function(n) {
    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n, "__esModule", { value: true });
  }, i.t = function(n, O) {
    if (1 & O && (n = i(n)), 8 & O || 4 & O && typeof n == "object" && n && n.__esModule)
      return n;
    var r = /* @__PURE__ */ Object.create(null);
    if (i.r(r), Object.defineProperty(r, "default", { enumerable: true, value: n }), 2 & O && typeof n != "string")
      for (var a in n)
        i.d(r, a, function(o) {
          return n[o];
        }.bind(null, a));
    return r;
  }, i.n = function(n) {
    var O = n && n.__esModule ? function() {
      return n.default;
    } : function() {
      return n;
    };
    return i.d(O, "a", O), O;
  }, i.o = function(n, O) {
    return Object.prototype.hasOwnProperty.call(n, O);
  }, i.p = "", i(i.s = 0);
}([function(t, e, i) {
  i.r(e), i.d(e, "validateHTMLColorName", function() {
    return a;
  }), i.d(e, "validateHTMLColorSpecialName", function() {
    return o;
  }), i.d(e, "validateHTMLColorHex", function() {
    return s;
  }), i.d(e, "validateHTMLColorRgb", function() {
    return $;
  }), i.d(e, "validateHTMLColorHsl", function() {
    return g;
  }), i.d(e, "validateHTMLColorHwb", function() {
    return Q;
  }), i.d(e, "validateHTMLColorLab", function() {
    return m;
  }), i.d(e, "validateHTMLColorLch", function() {
    return b;
  }), i.d(e, "validateHTMLColor", function() {
    return P;
  });
  const n = (S) => S && typeof S == "string", O = ["AliceBlue", "AntiqueWhite", "Aqua", "Aquamarine", "Azure", "Beige", "Bisque", "Black", "BlanchedAlmond", "Blue", "BlueViolet", "Brown", "BurlyWood", "CadetBlue", "Chartreuse", "Chocolate", "Coral", "CornflowerBlue", "Cornsilk", "Crimson", "Cyan", "DarkBlue", "DarkCyan", "DarkGoldenrod", "DarkGray", "DarkGrey", "DarkGreen", "DarkKhaki", "DarkMagenta", "DarkOliveGreen", "DarkOrange", "DarkOrchid", "DarkRed", "DarkSalmon", "DarkSeaGreen", "DarkSlateBlue", "DarkSlateGray", "DarkSlateGrey", "DarkTurquoise", "DarkViolet", "DeepPink", "DeepSkyBlue", "DimGray", "DimGrey", "DodgerBlue", "FireBrick", "FloralWhite", "ForestGreen", "Fuchsia", "Gainsboro", "GhostWhite", "Gold", "Goldenrod", "Gray", "Grey", "Green", "GreenYellow", "HoneyDew", "HotPink", "IndianRed", "Indigo", "Ivory", "Khaki", "Lavender", "LavenderBlush", "LawnGreen", "LemonChiffon", "LightBlue", "LightCoral", "LightCyan", "LightGoldenrodYellow", "LightGray", "LightGrey", "LightGreen", "LightPink", "LightSalmon", "LightSalmon", "LightSeaGreen", "LightSkyBlue", "LightSlateGray", "LightSlateGrey", "LightSteelBlue", "LightYellow", "Lime", "LimeGreen", "Linen", "Magenta", "Maroon", "MediumAquamarine", "MediumBlue", "MediumOrchid", "MediumPurple", "MediumSeaGreen", "MediumSlateBlue", "MediumSlateBlue", "MediumSpringGreen", "MediumTurquoise", "MediumVioletRed", "MidnightBlue", "MintCream", "MistyRose", "Moccasin", "NavajoWhite", "Navy", "OldLace", "Olive", "OliveDrab", "Orange", "OrangeRed", "Orchid", "PaleGoldenrod", "PaleGreen", "PaleTurquoise", "PaleVioletRed", "PapayaWhip", "PeachPuff", "Peru", "Pink", "Plum", "PowderBlue", "Purple", "RebeccaPurple", "Red", "RosyBrown", "RoyalBlue", "SaddleBrown", "Salmon", "SandyBrown", "SeaGreen", "SeaShell", "Sienna", "Silver", "SkyBlue", "SlateBlue", "SlateGray", "SlateGrey", "Snow", "SpringGreen", "SteelBlue", "Tan", "Teal", "Thistle", "Tomato", "Turquoise", "Violet", "Wheat", "White", "WhiteSmoke", "Yellow", "YellowGreen"], r = ["currentColor", "inherit", "transparent"], a = (S) => {
    let y = false;
    return n(S) && O.map((v) => (S.toLowerCase() === v.toLowerCase() && (y = true), null)), y;
  }, o = (S) => {
    let y = false;
    return n(S) && r.map((v) => (S.toLowerCase() === v.toLowerCase() && (y = true), null)), y;
  }, s = (S) => n(S) ? S && /^#([\da-f]{3}){1,2}$|^#([\da-f]{4}){1,2}$/i.test(S) : false, l = "(([\\d]{0,5})((\\.([\\d]{1,5}))?))", c = `(${l}%)`, u = "(([0-9]|[1-9][0-9]|100)%)", h10 = `(${u}|(0?((\\.([\\d]{1,5}))?))|1)`, d = `([\\s]{0,5})\\)?)(([\\s]{0,5})(\\/?)([\\s]{1,5})${`(((${u}))|(0?((\\.([\\d]{1,5}))?))|1))?`}([\\s]{0,5})\\)`, p = "(-?(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9]|3[0-5][0-9])((\\.([\\d]{1,5}))?)|360)(deg)?)", $ = (S) => {
    if (n(S)) {
      const y = "([\\s]{0,5})([\\d]{1,5})%?([\\s]{0,5}),?", v = "((([\\s]{0,5}),?([\\s]{0,5}))|(([\\s]{1,5})))", T = new RegExp(`^(rgb)a?\\(${`${y}${v}`}${`${y}${v}`}${`${y}${v}`}((\\/?([\\s]{0,5})(0?\\.?([\\d]{1,5})%?([\\s]{0,5}))?|1|0))?\\)$`);
      return S && T.test(S);
    }
    return false;
  }, g = (S) => {
    if (n(S)) {
      const y = new RegExp(`^(hsl)a?\\((([\\s]{0,5})(${p}|(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9]|3[0-9][0-9]|400)grad)|((([0-5])?\\.([\\d]{1,5})|6\\.([0-9]|1[0-9]|2[0-8])|[0-6])rad)|((0?((\\.([\\d]{1,5}))?)|1)turn))((([\\s]{0,5}),([\\s]{0,5}))|(([\\s]{1,5}))))(([\\s]{0,5})(0|${u})((([\\s]{0,5}),([\\s]{0,5}))|(([\\s]{1,5}))))(([\\s]{0,5})(0|${u})([\\s]{0,5})\\)?)(([\\s]{0,5})(\\/?|,?)([\\s]{0,5})(((${u}))|(0?((\\.([\\d]{1,5}))?))|1))?\\)$`);
      return S && y.test(S);
    }
    return false;
  }, Q = (S) => {
    if (n(S)) {
      const y = new RegExp(`^(hwb\\(([\\s]{0,5})${p}([\\s]{1,5}))((0|${u})([\\s]{1,5}))((0|${u})${d}$`);
      return S && y.test(S);
    }
    return false;
  }, m = (S) => {
    if (n(S)) {
      const y = "(-?(([0-9]|[1-9][0-9]|1[0-5][0-9])((\\.([\\d]{1,5}))?)?|160))", v = new RegExp(`^(lab\\(([\\s]{0,5})${c}([\\s]{1,5})${y}([\\s]{1,5})${y}${d}$`);
      return S && v.test(S);
    }
    return false;
  }, b = (S) => {
    if (n(S)) {
      const y = "((([0-9]|[1-9][0-9])?((\\.([\\d]{1,5}))?)|100)(%)?)", v = "" + l, T = `((${p})|(0|${h10})|(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9]|3[0-5][0-9])((\\.([\\d]{1,5}))?)|360))`, _ = `(\\/([\\s]{0,5})${h10})`, x = new RegExp(`^lch\\(${`(([\\s]{0,5})${y}([\\s]{1,5})${v}([\\s]{1,5})${T}([\\s]{0,5})(${_})?)`}\\)$`);
      return S && x.test(S);
    }
    return false;
  }, P = (S) => !!(S && s(S) || $(S) || g(S) || Q(S) || m(S) || b(S));
  e.default = (S) => !!(S && s(S) || a(S) || o(S) || $(S) || g(S) || Q(S) || m(S) || b(S));
}]);
function iy(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function iI(t) {
  var e, i;
  return iy(t) === false ? false : (e = t.constructor, e === void 0 ? true : (i = e.prototype, !(iy(i) === false || i.hasOwnProperty("isPrototypeOf") === false)));
}
function Zo() {
  return Zo = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var i = arguments[e];
      for (var n in i)
        Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n]);
    }
    return t;
  }, Zo.apply(this, arguments);
}
function dw(t, e) {
  if (t == null)
    return {};
  var i, n, O = {}, r = Object.keys(t);
  for (n = 0; n < r.length; n++)
    e.indexOf(i = r[n]) >= 0 || (O[i] = t[i]);
  return O;
}
var Bd = { silent: false, logLevel: "warn" };
var nI = ["validator"];
var pw = Object.prototype;
var $w = pw.toString;
var OI = pw.hasOwnProperty;
var Qw = /^\s*function (\w+)/;
function ny(t) {
  var e;
  const i = (e = t == null ? void 0 : t.type) !== null && e !== void 0 ? e : t;
  if (i) {
    const n = i.toString().match(Qw);
    return n ? n[1] : "";
  }
  return "";
}
var sr = iI;
var gw = (t) => t;
var Tt = gw;
Tt = typeof console < "u" ? function(e, i = Bd.logLevel) {
  Bd.silent === false && console[i](`[VueTypes warn]: ${e}`);
} : gw;
var Qa = (t, e) => OI.call(t, e);
var rI = Number.isInteger || function(t) {
  return typeof t == "number" && isFinite(t) && Math.floor(t) === t;
};
var ga = Array.isArray || function(t) {
  return $w.call(t) === "[object Array]";
};
var ma = (t) => $w.call(t) === "[object Function]";
var Tc = (t) => sr(t) && Qa(t, "_vueTypes_name");
var mw = (t) => sr(t) && (Qa(t, "type") || ["_vueTypes_name", "validator", "default", "required"].some((e) => Qa(t, e)));
function z$(t, e) {
  return Object.defineProperty(t.bind(e), "__original", { value: t });
}
function pr(t, e, i = false) {
  let n, O = true, r = "";
  n = sr(t) ? t : { type: t };
  const a = Tc(n) ? n._vueTypes_name + " - " : "";
  if (mw(n) && n.type !== null) {
    if (n.type === void 0 || n.type === true || !n.required && e === void 0)
      return O;
    ga(n.type) ? (O = n.type.some((o) => pr(o, e, true) === true), r = n.type.map((o) => ny(o)).join(" or ")) : (r = ny(n), O = r === "Array" ? ga(e) : r === "Object" ? sr(e) : r === "String" || r === "Number" || r === "Boolean" || r === "Function" ? function(o) {
      if (o == null)
        return "";
      const s = o.constructor.toString().match(Qw);
      return s ? s[1] : "";
    }(e) === r : e instanceof n.type);
  }
  if (!O) {
    const o = `${a}value "${e}" should be of type "${r}"`;
    return i === false ? (Tt(o), false) : o;
  }
  if (Qa(n, "validator") && ma(n.validator)) {
    const o = Tt, s = [];
    if (Tt = (l) => {
      s.push(l);
    }, O = n.validator(e), Tt = o, !O) {
      const l = (s.length > 1 ? "* " : "") + s.join(`
* `);
      return s.length = 0, i === false ? (Tt(l), O) : l;
    }
  }
  return O;
}
function yi(t, e) {
  const i = Object.defineProperties(e, { _vueTypes_name: { value: t, writable: true }, isRequired: { get() {
    return this.required = true, this;
  } }, def: { value(O) {
    return O === void 0 ? (Qa(this, "default") && delete this.default, this) : ma(O) || pr(this, O, true) === true ? (this.default = ga(O) ? () => [...O] : sr(O) ? () => Object.assign({}, O) : O, this) : (Tt(`${this._vueTypes_name} - invalid default value: "${O}"`), this);
  } } }), { validator: n } = i;
  return ma(n) && (i.validator = z$(n, i)), i;
}
function Pn(t, e) {
  const i = yi(t, e);
  return Object.defineProperty(i, "validate", { value(n) {
    return ma(this.validator) && Tt(`${this._vueTypes_name} - calling .validate() will overwrite the current custom validator function. Validator info:
${JSON.stringify(this)}`), this.validator = z$(n, this), this;
  } });
}
function Oy(t, e, i) {
  const n = function(s) {
    const l = {};
    return Object.getOwnPropertyNames(s).forEach((c) => {
      l[c] = Object.getOwnPropertyDescriptor(s, c);
    }), Object.defineProperties({}, l);
  }(e);
  if (n._vueTypes_name = t, !sr(i))
    return n;
  const { validator: O } = i, r = dw(i, nI);
  if (ma(O)) {
    let { validator: s } = n;
    s && (s = (o = (a = s).__original) !== null && o !== void 0 ? o : a), n.validator = z$(s ? function(l) {
      return s.call(this, l) && O.call(this, l);
    } : O, n);
  }
  var a, o;
  return Object.assign(n, r);
}
function wu(t) {
  return t.replace(/^(?!\s*$)/gm, "  ");
}
var aI = () => Pn("any", {});
var oI = () => Pn("function", { type: Function });
var sI = () => Pn("boolean", { type: Boolean });
var lI = () => Pn("string", { type: String });
var cI = () => Pn("number", { type: Number });
var uI = () => Pn("array", { type: Array });
var fI = () => Pn("object", { type: Object });
var hI = () => yi("integer", { type: Number, validator: (t) => rI(t) });
var dI = () => yi("symbol", { validator: (t) => typeof t == "symbol" });
function pI(t, e = "custom validation failed") {
  if (typeof t != "function")
    throw new TypeError("[VueTypes error]: You must provide a function as argument");
  return yi(t.name || "<<anonymous function>>", { type: null, validator(i) {
    const n = t(i);
    return n || Tt(`${this._vueTypes_name} - ${e}`), n;
  } });
}
function $I(t) {
  if (!ga(t))
    throw new TypeError("[VueTypes error]: You must provide an array as argument.");
  const e = `oneOf - value should be one of "${t.join('", "')}".`, i = t.reduce((n, O) => {
    if (O != null) {
      const r = O.constructor;
      n.indexOf(r) === -1 && n.push(r);
    }
    return n;
  }, []);
  return yi("oneOf", { type: i.length > 0 ? i : void 0, validator(n) {
    const O = t.indexOf(n) !== -1;
    return O || Tt(e), O;
  } });
}
function QI(t) {
  if (!ga(t))
    throw new TypeError("[VueTypes error]: You must provide an array as argument");
  let e = false, i = [];
  for (let O = 0; O < t.length; O += 1) {
    const r = t[O];
    if (mw(r)) {
      if (Tc(r) && r._vueTypes_name === "oneOf" && r.type) {
        i = i.concat(r.type);
        continue;
      }
      if (ma(r.validator) && (e = true), r.type === true || !r.type) {
        Tt('oneOfType - invalid usage of "true" or "null" as types.');
        continue;
      }
      i = i.concat(r.type);
    } else
      i.push(r);
  }
  i = i.filter((O, r) => i.indexOf(O) === r);
  const n = i.length > 0 ? i : null;
  return yi("oneOfType", e ? { type: n, validator(O) {
    const r = [], a = t.some((o) => {
      const s = pr(Tc(o) && o._vueTypes_name === "oneOf" ? o.type || null : o, O, true);
      return typeof s == "string" && r.push(s), s === true;
    });
    return a || Tt(`oneOfType - provided value does not match any of the ${r.length} passed-in validators:
${wu(r.join(`
`))}`), a;
  } } : { type: n });
}
function gI(t) {
  return yi("arrayOf", { type: Array, validator(e) {
    let i = "";
    const n = e.every((O) => (i = pr(t, O, true), i === true));
    return n || Tt(`arrayOf - value validation error:
${wu(i)}`), n;
  } });
}
function mI(t) {
  return yi("instanceOf", { type: t });
}
function SI(t) {
  return yi("objectOf", { type: Object, validator(e) {
    let i = "";
    const n = Object.keys(e).every((O) => (i = pr(t, e[O], true), i === true));
    return n || Tt(`objectOf - value validation error:
${wu(i)}`), n;
  } });
}
function PI(t) {
  const e = Object.keys(t), i = e.filter((O) => {
    var r;
    return !((r = t[O]) === null || r === void 0 || !r.required);
  }), n = yi("shape", { type: Object, validator(O) {
    if (!sr(O))
      return false;
    const r = Object.keys(O);
    if (i.length > 0 && i.some((a) => r.indexOf(a) === -1)) {
      const a = i.filter((o) => r.indexOf(o) === -1);
      return Tt(a.length === 1 ? `shape - required property "${a[0]}" is not defined.` : `shape - required properties "${a.join('", "')}" are not defined.`), false;
    }
    return r.every((a) => {
      if (e.indexOf(a) === -1)
        return this._vueTypes_isLoose === true || (Tt(`shape - shape definition does not include a "${a}" property. Allowed keys: "${e.join('", "')}".`), false);
      const o = pr(t[a], O[a], true);
      return typeof o == "string" && Tt(`shape - "${a}" property validation error:
 ${wu(o)}`), o === true;
    });
  } });
  return Object.defineProperty(n, "_vueTypes_isLoose", { writable: true, value: false }), Object.defineProperty(n, "loose", { get() {
    return this._vueTypes_isLoose = true, this;
  } }), n;
}
var yI = ["name", "validate", "getter"];
var bI = (() => {
  var t;
  return (t = class {
    static get any() {
      return aI();
    }
    static get func() {
      return oI().def(this.defaults.func);
    }
    static get bool() {
      return sI().def(this.defaults.bool);
    }
    static get string() {
      return lI().def(this.defaults.string);
    }
    static get number() {
      return cI().def(this.defaults.number);
    }
    static get array() {
      return uI().def(this.defaults.array);
    }
    static get object() {
      return fI().def(this.defaults.object);
    }
    static get integer() {
      return hI().def(this.defaults.integer);
    }
    static get symbol() {
      return dI();
    }
    static get nullable() {
      return { type: null };
    }
    static extend(e) {
      if (ga(e))
        return e.forEach((s) => this.extend(s)), this;
      const { name: i, validate: n = false, getter: O = false } = e, r = dw(e, yI);
      if (Qa(this, i))
        throw new TypeError(`[VueTypes error]: Type "${i}" already defined`);
      const { type: a } = r;
      if (Tc(a))
        return delete r.type, Object.defineProperty(this, i, O ? { get: () => Oy(i, a, r) } : { value(...s) {
          const l = Oy(i, a, r);
          return l.validator && (l.validator = l.validator.bind(l, ...s)), l;
        } });
      let o;
      return o = O ? { get() {
        const s = Object.assign({}, r);
        return n ? Pn(i, s) : yi(i, s);
      }, enumerable: true } : { value(...s) {
        const l = Object.assign({}, r);
        let c;
        return c = n ? Pn(i, l) : yi(i, l), l.validator && (c.validator = l.validator.bind(c, ...s)), c;
      }, enumerable: true }, Object.defineProperty(this, i, o);
    }
  }).defaults = {}, t.sensibleDefaults = void 0, t.config = Bd, t.custom = pI, t.oneOf = $I, t.instanceOf = mI, t.oneOfType = QI, t.arrayOf = gI, t.objectOf = SI, t.shape = PI, t.utils = { validate: (e, i) => pr(i, e, true) === true, toType: (e, i, n = false) => n ? Pn(e, i) : yi(e, i) }, t;
})();
function vI(t = { func: () => {
}, bool: true, string: "", number: 0, array: () => [], object: () => ({}), integer: 0 }) {
  var e;
  return (e = class extends bI {
    static get sensibleDefaults() {
      return Zo({}, this.defaults);
    }
    static set sensibleDefaults(i) {
      this.defaults = i !== false ? Zo({}, i !== true ? i : t) : {};
    }
  }).defaults = Zo({}, t), e;
}
var he = class extends vI() {
};
function kc(t) {
  return kc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, kc(t);
}
var XI = /^\s+/;
var xI = /\s+$/;
function A(t, e) {
  if (t = t || "", e = e || {}, t instanceof A)
    return t;
  if (!(this instanceof A))
    return new A(t, e);
  var i = wI(t);
  this._originalInput = t, this._r = i.r, this._g = i.g, this._b = i.b, this._a = i.a, this._roundA = Math.round(100 * this._a) / 100, this._format = e.format || i.format, this._gradientType = e.gradientType, this._r < 1 && (this._r = Math.round(this._r)), this._g < 1 && (this._g = Math.round(this._g)), this._b < 1 && (this._b = Math.round(this._b)), this._ok = i.ok;
}
A.prototype = {
  isDark: function() {
    return this.getBrightness() < 128;
  },
  isLight: function() {
    return !this.isDark();
  },
  isValid: function() {
    return this._ok;
  },
  getOriginalInput: function() {
    return this._originalInput;
  },
  getFormat: function() {
    return this._format;
  },
  getAlpha: function() {
    return this._a;
  },
  getBrightness: function() {
    var e = this.toRgb();
    return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3;
  },
  getLuminance: function() {
    var e = this.toRgb(), i, n, O, r, a, o;
    return i = e.r / 255, n = e.g / 255, O = e.b / 255, i <= 0.03928 ? r = i / 12.92 : r = Math.pow((i + 0.055) / 1.055, 2.4), n <= 0.03928 ? a = n / 12.92 : a = Math.pow((n + 0.055) / 1.055, 2.4), O <= 0.03928 ? o = O / 12.92 : o = Math.pow((O + 0.055) / 1.055, 2.4), 0.2126 * r + 0.7152 * a + 0.0722 * o;
  },
  setAlpha: function(e) {
    return this._a = Sw(e), this._roundA = Math.round(100 * this._a) / 100, this;
  },
  toHsv: function() {
    var e = ay(this._r, this._g, this._b);
    return {
      h: e.h * 360,
      s: e.s,
      v: e.v,
      a: this._a
    };
  },
  toHsvString: function() {
    var e = ay(this._r, this._g, this._b), i = Math.round(e.h * 360), n = Math.round(e.s * 100), O = Math.round(e.v * 100);
    return this._a == 1 ? "hsv(" + i + ", " + n + "%, " + O + "%)" : "hsva(" + i + ", " + n + "%, " + O + "%, " + this._roundA + ")";
  },
  toHsl: function() {
    var e = ry(this._r, this._g, this._b);
    return {
      h: e.h * 360,
      s: e.s,
      l: e.l,
      a: this._a
    };
  },
  toHslString: function() {
    var e = ry(this._r, this._g, this._b), i = Math.round(e.h * 360), n = Math.round(e.s * 100), O = Math.round(e.l * 100);
    return this._a == 1 ? "hsl(" + i + ", " + n + "%, " + O + "%)" : "hsla(" + i + ", " + n + "%, " + O + "%, " + this._roundA + ")";
  },
  toHex: function(e) {
    return oy(this._r, this._g, this._b, e);
  },
  toHexString: function(e) {
    return "#" + this.toHex(e);
  },
  toHex8: function(e) {
    return WI(this._r, this._g, this._b, this._a, e);
  },
  toHex8String: function(e) {
    return "#" + this.toHex8(e);
  },
  toRgb: function() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function() {
    return {
      r: Math.round(Ge(this._r, 255) * 100) + "%",
      g: Math.round(Ge(this._g, 255) * 100) + "%",
      b: Math.round(Ge(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function() {
    return this._a == 1 ? "rgb(" + Math.round(Ge(this._r, 255) * 100) + "%, " + Math.round(Ge(this._g, 255) * 100) + "%, " + Math.round(Ge(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(Ge(this._r, 255) * 100) + "%, " + Math.round(Ge(this._g, 255) * 100) + "%, " + Math.round(Ge(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function() {
    return this._a === 0 ? "transparent" : this._a < 1 ? false : AI[oy(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function(e) {
    var i = "#" + sy(this._r, this._g, this._b, this._a), n = i, O = this._gradientType ? "GradientType = 1, " : "";
    if (e) {
      var r = A(e);
      n = "#" + sy(r._r, r._g, r._b, r._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + O + "startColorstr=" + i + ",endColorstr=" + n + ")";
  },
  toString: function(e) {
    var i = !!e;
    e = e || this._format;
    var n = false, O = this._a < 1 && this._a >= 0, r = !i && O && (e === "hex" || e === "hex6" || e === "hex3" || e === "hex4" || e === "hex8" || e === "name");
    return r ? e === "name" && this._a === 0 ? this.toName() : this.toRgbString() : (e === "rgb" && (n = this.toRgbString()), e === "prgb" && (n = this.toPercentageRgbString()), (e === "hex" || e === "hex6") && (n = this.toHexString()), e === "hex3" && (n = this.toHexString(true)), e === "hex4" && (n = this.toHex8String(true)), e === "hex8" && (n = this.toHex8String()), e === "name" && (n = this.toName()), e === "hsl" && (n = this.toHslString()), e === "hsv" && (n = this.toHsvString()), n || this.toHexString());
  },
  clone: function() {
    return A(this.toString());
  },
  _applyModification: function(e, i) {
    var n = e.apply(null, [this].concat([].slice.call(i)));
    return this._r = n._r, this._g = n._g, this._b = n._b, this.setAlpha(n._a), this;
  },
  lighten: function() {
    return this._applyModification(UI, arguments);
  },
  brighten: function() {
    return this._applyModification(VI, arguments);
  },
  darken: function() {
    return this._applyModification(qI, arguments);
  },
  desaturate: function() {
    return this._applyModification(YI, arguments);
  },
  saturate: function() {
    return this._applyModification(RI, arguments);
  },
  greyscale: function() {
    return this._applyModification(ZI, arguments);
  },
  spin: function() {
    return this._applyModification(zI, arguments);
  },
  _applyCombination: function(e, i) {
    return e.apply(null, [this].concat([].slice.call(i)));
  },
  analogous: function() {
    return this._applyCombination(jI, arguments);
  },
  complement: function() {
    return this._applyCombination(CI, arguments);
  },
  monochromatic: function() {
    return this._applyCombination(II, arguments);
  },
  splitcomplement: function() {
    return this._applyCombination(EI, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function() {
    return this._applyCombination(ly, [3]);
  },
  tetrad: function() {
    return this._applyCombination(ly, [4]);
  }
};
A.fromRatio = function(t, e) {
  if (kc(t) == "object") {
    var i = {};
    for (var n in t)
      t.hasOwnProperty(n) && (n === "a" ? i[n] = t[n] : i[n] = So(t[n]));
    t = i;
  }
  return A(t, e);
};
function wI(t) {
  var e = {
    r: 0,
    g: 0,
    b: 0
  }, i = 1, n = null, O = null, r = null, a = false, o = false;
  return typeof t == "string" && (t = MI(t)), kc(t) == "object" && (_n(t.r) && _n(t.g) && _n(t.b) ? (e = TI(t.r, t.g, t.b), a = true, o = String(t.r).substr(-1) === "%" ? "prgb" : "rgb") : _n(t.h) && _n(t.s) && _n(t.v) ? (n = So(t.s), O = So(t.v), e = _I(t.h, n, O), a = true, o = "hsv") : _n(t.h) && _n(t.s) && _n(t.l) && (n = So(t.s), r = So(t.l), e = kI(t.h, n, r), a = true, o = "hsl"), t.hasOwnProperty("a") && (i = t.a)), i = Sw(i), {
    ok: a,
    format: t.format || o,
    r: Math.min(255, Math.max(e.r, 0)),
    g: Math.min(255, Math.max(e.g, 0)),
    b: Math.min(255, Math.max(e.b, 0)),
    a: i
  };
}
function TI(t, e, i) {
  return {
    r: Ge(t, 255) * 255,
    g: Ge(e, 255) * 255,
    b: Ge(i, 255) * 255
  };
}
function ry(t, e, i) {
  t = Ge(t, 255), e = Ge(e, 255), i = Ge(i, 255);
  var n = Math.max(t, e, i), O = Math.min(t, e, i), r, a, o = (n + O) / 2;
  if (n == O)
    r = a = 0;
  else {
    var s = n - O;
    switch (a = o > 0.5 ? s / (2 - n - O) : s / (n + O), n) {
      case t:
        r = (e - i) / s + (e < i ? 6 : 0);
        break;
      case e:
        r = (i - t) / s + 2;
        break;
      case i:
        r = (t - e) / s + 4;
        break;
    }
    r /= 6;
  }
  return {
    h: r,
    s: a,
    l: o
  };
}
function kI(t, e, i) {
  var n, O, r;
  t = Ge(t, 360), e = Ge(e, 100), i = Ge(i, 100);
  function a(l, c, u) {
    return u < 0 && (u += 1), u > 1 && (u -= 1), u < 1 / 6 ? l + (c - l) * 6 * u : u < 1 / 2 ? c : u < 2 / 3 ? l + (c - l) * (2 / 3 - u) * 6 : l;
  }
  if (e === 0)
    n = O = r = i;
  else {
    var o = i < 0.5 ? i * (1 + e) : i + e - i * e, s = 2 * i - o;
    n = a(s, o, t + 1 / 3), O = a(s, o, t), r = a(s, o, t - 1 / 3);
  }
  return {
    r: n * 255,
    g: O * 255,
    b: r * 255
  };
}
function ay(t, e, i) {
  t = Ge(t, 255), e = Ge(e, 255), i = Ge(i, 255);
  var n = Math.max(t, e, i), O = Math.min(t, e, i), r, a, o = n, s = n - O;
  if (a = n === 0 ? 0 : s / n, n == O)
    r = 0;
  else {
    switch (n) {
      case t:
        r = (e - i) / s + (e < i ? 6 : 0);
        break;
      case e:
        r = (i - t) / s + 2;
        break;
      case i:
        r = (t - e) / s + 4;
        break;
    }
    r /= 6;
  }
  return {
    h: r,
    s: a,
    v: o
  };
}
function _I(t, e, i) {
  t = Ge(t, 360) * 6, e = Ge(e, 100), i = Ge(i, 100);
  var n = Math.floor(t), O = t - n, r = i * (1 - e), a = i * (1 - O * e), o = i * (1 - (1 - O) * e), s = n % 6, l = [i, a, r, r, o, i][s], c = [o, i, i, a, r, r][s], u = [r, r, o, i, i, a][s];
  return {
    r: l * 255,
    g: c * 255,
    b: u * 255
  };
}
function oy(t, e, i, n) {
  var O = [Ji(Math.round(t).toString(16)), Ji(Math.round(e).toString(16)), Ji(Math.round(i).toString(16))];
  return n && O[0].charAt(0) == O[0].charAt(1) && O[1].charAt(0) == O[1].charAt(1) && O[2].charAt(0) == O[2].charAt(1) ? O[0].charAt(0) + O[1].charAt(0) + O[2].charAt(0) : O.join("");
}
function WI(t, e, i, n, O) {
  var r = [Ji(Math.round(t).toString(16)), Ji(Math.round(e).toString(16)), Ji(Math.round(i).toString(16)), Ji(Pw(n))];
  return O && r[0].charAt(0) == r[0].charAt(1) && r[1].charAt(0) == r[1].charAt(1) && r[2].charAt(0) == r[2].charAt(1) && r[3].charAt(0) == r[3].charAt(1) ? r[0].charAt(0) + r[1].charAt(0) + r[2].charAt(0) + r[3].charAt(0) : r.join("");
}
function sy(t, e, i, n) {
  var O = [Ji(Pw(n)), Ji(Math.round(t).toString(16)), Ji(Math.round(e).toString(16)), Ji(Math.round(i).toString(16))];
  return O.join("");
}
A.equals = function(t, e) {
  return !t || !e ? false : A(t).toRgbString() == A(e).toRgbString();
};
A.random = function() {
  return A.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function YI(t, e) {
  e = e === 0 ? 0 : e || 10;
  var i = A(t).toHsl();
  return i.s -= e / 100, i.s = Tu(i.s), A(i);
}
function RI(t, e) {
  e = e === 0 ? 0 : e || 10;
  var i = A(t).toHsl();
  return i.s += e / 100, i.s = Tu(i.s), A(i);
}
function ZI(t) {
  return A(t).desaturate(100);
}
function UI(t, e) {
  e = e === 0 ? 0 : e || 10;
  var i = A(t).toHsl();
  return i.l += e / 100, i.l = Tu(i.l), A(i);
}
function VI(t, e) {
  e = e === 0 ? 0 : e || 10;
  var i = A(t).toRgb();
  return i.r = Math.max(0, Math.min(255, i.r - Math.round(255 * -(e / 100)))), i.g = Math.max(0, Math.min(255, i.g - Math.round(255 * -(e / 100)))), i.b = Math.max(0, Math.min(255, i.b - Math.round(255 * -(e / 100)))), A(i);
}
function qI(t, e) {
  e = e === 0 ? 0 : e || 10;
  var i = A(t).toHsl();
  return i.l -= e / 100, i.l = Tu(i.l), A(i);
}
function zI(t, e) {
  var i = A(t).toHsl(), n = (i.h + e) % 360;
  return i.h = n < 0 ? 360 + n : n, A(i);
}
function CI(t) {
  var e = A(t).toHsl();
  return e.h = (e.h + 180) % 360, A(e);
}
function ly(t, e) {
  if (isNaN(e) || e <= 0)
    throw new Error("Argument to polyad must be a positive number");
  for (var i = A(t).toHsl(), n = [A(t)], O = 360 / e, r = 1; r < e; r++)
    n.push(A({
      h: (i.h + r * O) % 360,
      s: i.s,
      l: i.l
    }));
  return n;
}
function EI(t) {
  var e = A(t).toHsl(), i = e.h;
  return [A(t), A({
    h: (i + 72) % 360,
    s: e.s,
    l: e.l
  }), A({
    h: (i + 216) % 360,
    s: e.s,
    l: e.l
  })];
}
function jI(t, e, i) {
  e = e || 6, i = i || 30;
  var n = A(t).toHsl(), O = 360 / i, r = [A(t)];
  for (n.h = (n.h - (O * e >> 1) + 720) % 360; --e; )
    n.h = (n.h + O) % 360, r.push(A(n));
  return r;
}
function II(t, e) {
  e = e || 6;
  for (var i = A(t).toHsv(), n = i.h, O = i.s, r = i.v, a = [], o = 1 / e; e--; )
    a.push(A({
      h: n,
      s: O,
      v: r
    })), r = (r + o) % 1;
  return a;
}
A.mix = function(t, e, i) {
  i = i === 0 ? 0 : i || 50;
  var n = A(t).toRgb(), O = A(e).toRgb(), r = i / 100, a = {
    r: (O.r - n.r) * r + n.r,
    g: (O.g - n.g) * r + n.g,
    b: (O.b - n.b) * r + n.b,
    a: (O.a - n.a) * r + n.a
  };
  return A(a);
};
A.readability = function(t, e) {
  var i = A(t), n = A(e);
  return (Math.max(i.getLuminance(), n.getLuminance()) + 0.05) / (Math.min(i.getLuminance(), n.getLuminance()) + 0.05);
};
A.isReadable = function(t, e, i) {
  var n = A.readability(t, e), O, r;
  switch (r = false, O = NI(i), O.level + O.size) {
    case "AAsmall":
    case "AAAlarge":
      r = n >= 4.5;
      break;
    case "AAlarge":
      r = n >= 3;
      break;
    case "AAAsmall":
      r = n >= 7;
      break;
  }
  return r;
};
A.mostReadable = function(t, e, i) {
  var n = null, O = 0, r, a, o, s;
  i = i || {}, a = i.includeFallbackColors, o = i.level, s = i.size;
  for (var l = 0; l < e.length; l++)
    r = A.readability(t, e[l]), r > O && (O = r, n = A(e[l]));
  return A.isReadable(t, n, {
    level: o,
    size: s
  }) || !a ? n : (i.includeFallbackColors = false, A.mostReadable(t, ["#fff", "#000"], i));
};
var Fd = A.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
var AI = A.hexNames = GI(Fd);
function GI(t) {
  var e = {};
  for (var i in t)
    t.hasOwnProperty(i) && (e[t[i]] = i);
  return e;
}
function Sw(t) {
  return t = parseFloat(t), (isNaN(t) || t < 0 || t > 1) && (t = 1), t;
}
function Ge(t, e) {
  LI(t) && (t = "100%");
  var i = DI(t);
  return t = Math.min(e, Math.max(0, parseFloat(t))), i && (t = parseInt(t * e, 10) / 100), Math.abs(t - e) < 1e-6 ? 1 : t % e / parseFloat(e);
}
function Tu(t) {
  return Math.min(1, Math.max(0, t));
}
function di(t) {
  return parseInt(t, 16);
}
function LI(t) {
  return typeof t == "string" && t.indexOf(".") != -1 && parseFloat(t) === 1;
}
function DI(t) {
  return typeof t == "string" && t.indexOf("%") != -1;
}
function Ji(t) {
  return t.length == 1 ? "0" + t : "" + t;
}
function So(t) {
  return t <= 1 && (t = t * 100 + "%"), t;
}
function Pw(t) {
  return Math.round(parseFloat(t) * 255).toString(16);
}
function cy(t) {
  return di(t) / 255;
}
var Ni = function() {
  var t = "[-\\+]?\\d+%?", e = "[-\\+]?\\d*\\.\\d+%?", i = "(?:" + e + ")|(?:" + t + ")", n = "[\\s|\\(]+(" + i + ")[,|\\s]+(" + i + ")[,|\\s]+(" + i + ")\\s*\\)?", O = "[\\s|\\(]+(" + i + ")[,|\\s]+(" + i + ")[,|\\s]+(" + i + ")[,|\\s]+(" + i + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(i),
    rgb: new RegExp("rgb" + n),
    rgba: new RegExp("rgba" + O),
    hsl: new RegExp("hsl" + n),
    hsla: new RegExp("hsla" + O),
    hsv: new RegExp("hsv" + n),
    hsva: new RegExp("hsva" + O),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function _n(t) {
  return !!Ni.CSS_UNIT.exec(t);
}
function MI(t) {
  t = t.replace(XI, "").replace(xI, "").toLowerCase();
  var e = false;
  if (Fd[t])
    t = Fd[t], e = true;
  else if (t == "transparent")
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  var i;
  return (i = Ni.rgb.exec(t)) ? {
    r: i[1],
    g: i[2],
    b: i[3]
  } : (i = Ni.rgba.exec(t)) ? {
    r: i[1],
    g: i[2],
    b: i[3],
    a: i[4]
  } : (i = Ni.hsl.exec(t)) ? {
    h: i[1],
    s: i[2],
    l: i[3]
  } : (i = Ni.hsla.exec(t)) ? {
    h: i[1],
    s: i[2],
    l: i[3],
    a: i[4]
  } : (i = Ni.hsv.exec(t)) ? {
    h: i[1],
    s: i[2],
    v: i[3]
  } : (i = Ni.hsva.exec(t)) ? {
    h: i[1],
    s: i[2],
    v: i[3],
    a: i[4]
  } : (i = Ni.hex8.exec(t)) ? {
    r: di(i[1]),
    g: di(i[2]),
    b: di(i[3]),
    a: cy(i[4]),
    format: e ? "name" : "hex8"
  } : (i = Ni.hex6.exec(t)) ? {
    r: di(i[1]),
    g: di(i[2]),
    b: di(i[3]),
    format: e ? "name" : "hex"
  } : (i = Ni.hex4.exec(t)) ? {
    r: di(i[1] + "" + i[1]),
    g: di(i[2] + "" + i[2]),
    b: di(i[3] + "" + i[3]),
    a: cy(i[4] + "" + i[4]),
    format: e ? "name" : "hex8"
  } : (i = Ni.hex3.exec(t)) ? {
    r: di(i[1] + "" + i[1]),
    g: di(i[2] + "" + i[2]),
    b: di(i[3] + "" + i[3]),
    format: e ? "name" : "hex"
  } : false;
}
function NI(t) {
  var e, i;
  return t = t || {
    level: "AA",
    size: "small"
  }, e = (t.level || "AA").toUpperCase(), i = (t.size || "small").toLowerCase(), e !== "AA" && e !== "AAA" && (e = "AA"), i !== "small" && i !== "large" && (i = "small"), {
    level: e,
    size: i
  };
}
var uy = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function C$(t) {
  var e = { exports: {} };
  return t(e, e.exports), e.exports;
}
var gl = function(t) {
  return t && t.Math == Math && t;
};
var pt = gl(typeof globalThis == "object" && globalThis) || gl(typeof window == "object" && window) || gl(typeof self == "object" && self) || gl(typeof uy == "object" && uy) || function() {
  return this;
}() || Function("return this")();
var je = function(t) {
  try {
    return !!t();
  } catch {
    return true;
  }
};
var ki = !je(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] != 7;
});
var fy = {}.propertyIsEnumerable;
var hy = Object.getOwnPropertyDescriptor;
var BI = { f: hy && !fy.call({ 1: 2 }, 1) ? function(t) {
  var e = hy(this, t);
  return !!e && e.enumerable;
} : fy };
var ku = function(t, e) {
  return { enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: e };
};
var FI = {}.toString;
var In = function(t) {
  return FI.call(t).slice(8, -1);
};
var HI = "".split;
var _u = je(function() {
  return !Object("z").propertyIsEnumerable(0);
}) ? function(t) {
  return In(t) == "String" ? HI.call(t, "") : Object(t);
} : Object;
var vO = function(t) {
  if (t == null)
    throw TypeError("Can't call method on " + t);
  return t;
};
var Va = function(t) {
  return _u(vO(t));
};
var Qt = function(t) {
  return typeof t == "object" ? t !== null : typeof t == "function";
};
var E$ = function(t, e) {
  if (!Qt(t))
    return t;
  var i, n;
  if (e && typeof (i = t.toString) == "function" && !Qt(n = i.call(t)) || typeof (i = t.valueOf) == "function" && !Qt(n = i.call(t)) || !e && typeof (i = t.toString) == "function" && !Qt(n = i.call(t)))
    return n;
  throw TypeError("Can't convert object to primitive value");
};
var KI = {}.hasOwnProperty;
var st = function(t, e) {
  return KI.call(t, e);
};
var Hd = pt.document;
var JI = Qt(Hd) && Qt(Hd.createElement);
var yw = function(t) {
  return JI ? Hd.createElement(t) : {};
};
var bw = !ki && !je(function() {
  return Object.defineProperty(yw("div"), "a", { get: function() {
    return 7;
  } }).a != 7;
});
var dy = Object.getOwnPropertyDescriptor;
var j$ = { f: ki ? dy : function(t, e) {
  if (t = Va(t), e = E$(e, true), bw)
    try {
      return dy(t, e);
    } catch {
    }
  if (st(t, e))
    return ku(!BI.f.call(t, e), t[e]);
} };
var Ht = function(t) {
  if (!Qt(t))
    throw TypeError(String(t) + " is not an object");
  return t;
};
var py = Object.defineProperty;
var Bn = { f: ki ? py : function(t, e, i) {
  if (Ht(t), e = E$(e, true), Ht(i), bw)
    try {
      return py(t, e, i);
    } catch {
    }
  if ("get" in i || "set" in i)
    throw TypeError("Accessors not supported");
  return "value" in i && (t[e] = i.value), t;
} };
var Zi = ki ? function(t, e, i) {
  return Bn.f(t, e, ku(1, i));
} : function(t, e, i) {
  return t[e] = i, t;
};
var I$ = function(t, e) {
  try {
    Zi(pt, t, e);
  } catch {
    pt[t] = e;
  }
  return e;
};
var lr = pt["__core-js_shared__"] || I$("__core-js_shared__", {});
var eA = Function.toString;
typeof lr.inspectSource != "function" && (lr.inspectSource = function(t) {
  return eA.call(t);
});
var _c;
var Uo;
var Wc;
var vw = lr.inspectSource;
var $y = pt.WeakMap;
var tA = typeof $y == "function" && /native code/.test(vw($y));
var Xw = C$(function(t) {
  (t.exports = function(e, i) {
    return lr[e] || (lr[e] = i !== void 0 ? i : {});
  })("versions", []).push({ version: "3.8.3", mode: "global", copyright: "© 2021 Denis Pushkarev (zloirock.ru)" });
});
var iA = 0;
var nA = Math.random();
var A$ = function(t) {
  return "Symbol(" + String(t === void 0 ? "" : t) + ")_" + (++iA + nA).toString(36);
};
var Qy = Xw("keys");
var G$ = function(t) {
  return Qy[t] || (Qy[t] = A$(t));
};
var Wu = {};
var OA = pt.WeakMap;
if (tA) {
  Wr = lr.state || (lr.state = new OA()), rA = Wr.get, aA = Wr.has, oA = Wr.set;
  _c = function(t, e) {
    return e.facade = t, oA.call(Wr, t, e), e;
  }, Uo = function(t) {
    return rA.call(Wr, t) || {};
  }, Wc = function(t) {
    return aA.call(Wr, t);
  };
} else {
  ao = G$("state");
  Wu[ao] = true, _c = function(t, e) {
    return e.facade = t, Zi(t, ao, e), e;
  }, Uo = function(t) {
    return st(t, ao) ? t[ao] : {};
  }, Wc = function(t) {
    return st(t, ao);
  };
}
var Wr;
var rA;
var aA;
var oA;
var ao;
var XO = { set: _c, get: Uo, has: Wc, enforce: function(t) {
  return Wc(t) ? Uo(t) : _c(t, {});
}, getterFor: function(t) {
  return function(e) {
    var i;
    if (!Qt(e) || (i = Uo(e)).type !== t)
      throw TypeError("Incompatible receiver, " + t + " required");
    return i;
  };
} };
var xO = C$(function(t) {
  var e = XO.get, i = XO.enforce, n = String(String).split("String");
  (t.exports = function(O, r, a, o) {
    var s, l = !!o && !!o.unsafe, c = !!o && !!o.enumerable, u = !!o && !!o.noTargetGet;
    typeof a == "function" && (typeof r != "string" || st(a, "name") || Zi(a, "name", r), (s = i(a)).source || (s.source = n.join(typeof r == "string" ? r : ""))), O !== pt ? (l ? !u && O[r] && (c = true) : delete O[r], c ? O[r] = a : Zi(O, r, a)) : c ? O[r] = a : I$(r, a);
  })(Function.prototype, "toString", function() {
    return typeof this == "function" && e(this).source || vw(this);
  });
});
var Lf = pt;
var gy = function(t) {
  return typeof t == "function" ? t : void 0;
};
var Yu = function(t, e) {
  return arguments.length < 2 ? gy(Lf[t]) || gy(pt[t]) : Lf[t] && Lf[t][e] || pt[t] && pt[t][e];
};
var sA = Math.ceil;
var lA = Math.floor;
var qa = function(t) {
  return isNaN(t = +t) ? 0 : (t > 0 ? lA : sA)(t);
};
var cA = Math.min;
var Xi = function(t) {
  return t > 0 ? cA(qa(t), 9007199254740991) : 0;
};
var uA = Math.max;
var fA = Math.min;
var Yc = function(t, e) {
  var i = qa(t);
  return i < 0 ? uA(i + e, 0) : fA(i, e);
};
var my = function(t) {
  return function(e, i, n) {
    var O, r = Va(e), a = Xi(r.length), o = Yc(n, a);
    if (t && i != i) {
      for (; a > o; )
        if ((O = r[o++]) != O)
          return true;
    } else
      for (; a > o; o++)
        if ((t || o in r) && r[o] === i)
          return t || o || 0;
    return !t && -1;
  };
};
var xw = { includes: my(true), indexOf: my(false) };
var hA = xw.indexOf;
var ww = function(t, e) {
  var i, n = Va(t), O = 0, r = [];
  for (i in n)
    !st(Wu, i) && st(n, i) && r.push(i);
  for (; e.length > O; )
    st(n, i = e[O++]) && (~hA(r, i) || r.push(i));
  return r;
};
var Rc = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
var dA = Rc.concat("length", "prototype");
var pA = { f: Object.getOwnPropertyNames || function(t) {
  return ww(t, dA);
} };
var $A = { f: Object.getOwnPropertySymbols };
var QA = Yu("Reflect", "ownKeys") || function(t) {
  var e = pA.f(Ht(t)), i = $A.f;
  return i ? e.concat(i(t)) : e;
};
var gA = function(t, e) {
  for (var i = QA(e), n = Bn.f, O = j$.f, r = 0; r < i.length; r++) {
    var a = i[r];
    st(t, a) || n(t, a, O(e, a));
  }
};
var mA = /#|\.prototype\./;
var Ws = function(t, e) {
  var i = PA[SA(t)];
  return i == bA || i != yA && (typeof e == "function" ? je(e) : !!e);
};
var SA = Ws.normalize = function(t) {
  return String(t).replace(mA, ".").toLowerCase();
};
var PA = Ws.data = {};
var yA = Ws.NATIVE = "N";
var bA = Ws.POLYFILL = "P";
var Kd = Ws;
var vA = j$.f;
var Ct = function(t, e) {
  var i, n, O, r, a, o = t.target, s = t.global, l = t.stat;
  if (i = s ? pt : l ? pt[o] || I$(o, {}) : (pt[o] || {}).prototype)
    for (n in e) {
      if (r = e[n], O = t.noTargetGet ? (a = vA(i, n)) && a.value : i[n], !Kd(s ? n : o + (l ? "." : "#") + n, t.forced) && O !== void 0) {
        if (typeof r == typeof O)
          continue;
        gA(r, O);
      }
      (t.sham || O && O.sham) && Zi(r, "sham", true), xO(i, n, r, t);
    }
};
var L$ = function(t, e) {
  var i = [][t];
  return !!i && je(function() {
    i.call(null, e || function() {
      throw 1;
    }, 1);
  });
};
var XA = Object.defineProperty;
var Df = {};
var Sy = function(t) {
  throw t;
};
var za = function(t, e) {
  if (st(Df, t))
    return Df[t];
  e || (e = {});
  var i = [][t], n = !!st(e, "ACCESSORS") && e.ACCESSORS, O = st(e, 0) ? e[0] : Sy, r = st(e, 1) ? e[1] : void 0;
  return Df[t] = !!i && !je(function() {
    if (n && !ki)
      return true;
    var a = { length: -1 };
    n ? XA(a, 1, { enumerable: true, get: Sy }) : a[1] = 1, i.call(a, O, r);
  });
};
var xA = xw.indexOf;
var Tw = [].indexOf;
var Py = !!Tw && 1 / [1].indexOf(1, -0) < 0;
var wA = L$("indexOf");
var TA = za("indexOf", { ACCESSORS: true, 1: 0 });
function $r(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function yy(t, e) {
  for (var i = 0; i < e.length; i++) {
    var n = e[i];
    n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
  }
}
function Qr(t, e, i) {
  return e && yy(t.prototype, e), i && yy(t, i), t;
}
Ct({ target: "Array", proto: true, forced: Py || !wA || !TA }, { indexOf: function(t) {
  return Py ? Tw.apply(this, arguments) || 0 : xA(this, t, arguments.length > 1 ? arguments[1] : void 0);
} });
(function() {
  function t() {
    $r(this, t);
  }
  return Qr(t, null, [{ key: "isInBrowser", value: function() {
    return typeof window < "u";
  } }, { key: "isServer", value: function() {
    return typeof window > "u";
  } }, { key: "getUA", value: function() {
    return t.isInBrowser() ? window.navigator.userAgent.toLowerCase() : "";
  } }, { key: "isMobile", value: function() {
    return /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(navigator.appVersion);
  } }, { key: "isOpera", value: function() {
    return navigator.userAgent.indexOf("Opera") !== -1;
  } }, { key: "isIE", value: function() {
    var e = t.getUA();
    return e !== "" && e.indexOf("msie") > 0;
  } }, { key: "isIE9", value: function() {
    var e = t.getUA();
    return e !== "" && e.indexOf("msie 9.0") > 0;
  } }, { key: "isEdge", value: function() {
    var e = t.getUA();
    return e !== "" && e.indexOf("edge/") > 0;
  } }, { key: "isChrome", value: function() {
    var e = t.getUA();
    return e !== "" && /chrome\/\d+/.test(e) && !t.isEdge();
  } }, { key: "isPhantomJS", value: function() {
    var e = t.getUA();
    return e !== "" && /phantomjs/.test(e);
  } }, { key: "isFirefox", value: function() {
    var e = t.getUA();
    return e !== "" && /firefox/.test(e);
  } }]), t;
})();
var kA = [].join;
var _A = _u != Object;
var WA = L$("join", ",");
Ct({ target: "Array", proto: true, forced: _A || !WA }, { join: function(t) {
  return kA.call(Va(this), t === void 0 ? "," : t);
} });
var Yr;
var Zc;
var Fn = function(t) {
  return Object(vO(t));
};
var Sa = Array.isArray || function(t) {
  return In(t) == "Array";
};
var kw = !!Object.getOwnPropertySymbols && !je(function() {
  return !String(Symbol());
});
var YA = kw && !Symbol.sham && typeof Symbol.iterator == "symbol";
var ml = Xw("wks");
var Vo = pt.Symbol;
var RA = YA ? Vo : Vo && Vo.withoutSetter || A$;
var Ke = function(t) {
  return st(ml, t) || (kw && st(Vo, t) ? ml[t] = Vo[t] : ml[t] = RA("Symbol." + t)), ml[t];
};
var ZA = Ke("species");
var Ru = function(t, e) {
  var i;
  return Sa(t) && (typeof (i = t.constructor) != "function" || i !== Array && !Sa(i.prototype) ? Qt(i) && (i = i[ZA]) === null && (i = void 0) : i = void 0), new (i === void 0 ? Array : i)(e === 0 ? 0 : e);
};
var Pa = function(t, e, i) {
  var n = E$(e);
  n in t ? Bn.f(t, n, ku(0, i)) : t[n] = i;
};
var Mf = Yu("navigator", "userAgent") || "";
var by = pt.process;
var vy = by && by.versions;
var Xy = vy && vy.v8;
Xy ? Zc = (Yr = Xy.split("."))[0] + Yr[1] : Mf && (!(Yr = Mf.match(/Edge\/(\d+)/)) || Yr[1] >= 74) && (Yr = Mf.match(/Chrome\/(\d+)/)) && (Zc = Yr[1]);
var Uc = Zc && +Zc;
var UA = Ke("species");
var D$ = function(t) {
  return Uc >= 51 || !je(function() {
    var e = [];
    return (e.constructor = {})[UA] = function() {
      return { foo: 1 };
    }, e[t](Boolean).foo !== 1;
  });
};
var VA = D$("splice");
var qA = za("splice", { ACCESSORS: true, 0: 0, 1: 2 });
var zA = Math.max;
var CA = Math.min;
Ct({ target: "Array", proto: true, forced: !VA || !qA }, { splice: function(t, e) {
  var i, n, O, r, a, o, s = Fn(this), l = Xi(s.length), c = Yc(t, l), u = arguments.length;
  if (u === 0 ? i = n = 0 : u === 1 ? (i = 0, n = l - c) : (i = u - 2, n = CA(zA(qa(e), 0), l - c)), l + i - n > 9007199254740991)
    throw TypeError("Maximum allowed length exceeded");
  for (O = Ru(s, n), r = 0; r < n; r++)
    (a = c + r) in s && Pa(O, r, s[a]);
  if (O.length = n, i < n) {
    for (r = c; r < l - n; r++)
      o = r + i, (a = r + n) in s ? s[o] = s[a] : delete s[o];
    for (r = l; r > l - n + i; r--)
      delete s[r - 1];
  } else if (i > n)
    for (r = l - n; r > c; r--)
      o = r + i - 1, (a = r + n - 1) in s ? s[o] = s[a] : delete s[o];
  for (r = 0; r < i; r++)
    s[r + c] = arguments[r + 2];
  return s.length = l - n + i, O;
} });
var _w = {};
_w[Ke("toStringTag")] = "z";
var M$ = String(_w) === "[object z]";
var EA = Ke("toStringTag");
var jA = In(function() {
  return arguments;
}()) == "Arguments";
var Ww = M$ ? In : function(t) {
  var e, i, n;
  return t === void 0 ? "Undefined" : t === null ? "Null" : typeof (i = function(O, r) {
    try {
      return O[r];
    } catch {
    }
  }(e = Object(t), EA)) == "string" ? i : jA ? In(e) : (n = In(e)) == "Object" && typeof e.callee == "function" ? "Arguments" : n;
};
var IA = M$ ? {}.toString : function() {
  return "[object " + Ww(this) + "]";
};
M$ || xO(Object.prototype, "toString", IA, { unsafe: true });
var Yw = function() {
  var t = Ht(this), e = "";
  return t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.dotAll && (e += "s"), t.unicode && (e += "u"), t.sticky && (e += "y"), e;
};
function xy(t, e) {
  return RegExp(t, e);
}
var Nf;
var Bf;
var wy = { UNSUPPORTED_Y: je(function() {
  var t = xy("a", "y");
  return t.lastIndex = 2, t.exec("abcd") != null;
}), BROKEN_CARET: je(function() {
  var t = xy("^r", "gy");
  return t.lastIndex = 2, t.exec("str") != null;
}) };
var Vc = RegExp.prototype.exec;
var AA = String.prototype.replace;
var Rw = Vc;
var Ff = (Nf = /a/, Bf = /b*/g, Vc.call(Nf, "a"), Vc.call(Bf, "a"), Nf.lastIndex !== 0 || Bf.lastIndex !== 0);
var Ty = wy.UNSUPPORTED_Y || wy.BROKEN_CARET;
var Hf = /()??/.exec("")[1] !== void 0;
(Ff || Hf || Ty) && (Rw = function(t) {
  var e, i, n, O, r = this, a = Ty && r.sticky, o = Yw.call(r), s = r.source, l = 0, c = t;
  return a && ((o = o.replace("y", "")).indexOf("g") === -1 && (o += "g"), c = String(t).slice(r.lastIndex), r.lastIndex > 0 && (!r.multiline || r.multiline && t[r.lastIndex - 1] !== `
`) && (s = "(?: " + s + ")", c = " " + c, l++), i = new RegExp("^(?:" + s + ")", o)), Hf && (i = new RegExp("^" + s + "$(?!\\s)", o)), Ff && (e = r.lastIndex), n = Vc.call(a ? i : r, c), a ? n ? (n.input = n.input.slice(l), n[0] = n[0].slice(l), n.index = r.lastIndex, r.lastIndex += n[0].length) : r.lastIndex = 0 : Ff && n && (r.lastIndex = r.global ? n.index + n[0].length : e), Hf && n && n.length > 1 && AA.call(n[0], i, function() {
    for (O = 1; O < arguments.length - 2; O++)
      arguments[O] === void 0 && (n[O] = void 0);
  }), n;
});
var hs = Rw;
Ct({ target: "RegExp", proto: true, forced: /./.exec !== hs }, { exec: hs });
var Zw = RegExp.prototype;
var Uw = Zw.toString;
var GA = je(function() {
  return Uw.call({ source: "a", flags: "b" }) != "/a/b";
});
var LA = Uw.name != "toString";
(GA || LA) && xO(RegExp.prototype, "toString", function() {
  var t = Ht(this), e = String(t.source), i = t.flags;
  return "/" + e + "/" + String(i === void 0 && t instanceof RegExp && !("flags" in Zw) ? Yw.call(t) : i);
}, { unsafe: true });
var DA = Ke("species");
var MA = !je(function() {
  var t = /./;
  return t.exec = function() {
    var e = [];
    return e.groups = { a: "7" }, e;
  }, "".replace(t, "$<a>") !== "7";
});
var ky = "a".replace(/./, "$0") === "$0";
var _y = Ke("replace");
var Wy = !!/./[_y] && /./[_y]("a", "$0") === "";
var NA = !je(function() {
  var t = /(?:)/, e = t.exec;
  t.exec = function() {
    return e.apply(this, arguments);
  };
  var i = "ab".split(t);
  return i.length !== 2 || i[0] !== "a" || i[1] !== "b";
});
var Vw = function(t, e, i, n) {
  var O = Ke(t), r = !je(function() {
    var u = {};
    return u[O] = function() {
      return 7;
    }, ""[t](u) != 7;
  }), a = r && !je(function() {
    var u = false, h10 = /a/;
    return t === "split" && ((h10 = {}).constructor = {}, h10.constructor[DA] = function() {
      return h10;
    }, h10.flags = "", h10[O] = /./[O]), h10.exec = function() {
      return u = true, null;
    }, h10[O](""), !u;
  });
  if (!r || !a || t === "replace" && (!MA || !ky || Wy) || t === "split" && !NA) {
    var o = /./[O], s = i(O, ""[t], function(u, h10, d, p, $) {
      return h10.exec === hs ? r && !$ ? { done: true, value: o.call(h10, d, p) } : { done: true, value: u.call(d, h10, p) } : { done: false };
    }, { REPLACE_KEEPS_$0: ky, REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: Wy }), l = s[0], c = s[1];
    xO(String.prototype, t, l), xO(RegExp.prototype, O, e == 2 ? function(u, h10) {
      return c.call(u, this, h10);
    } : function(u) {
      return c.call(u, this);
    });
  }
  n && Zi(RegExp.prototype[O], "sham", true);
};
var BA = Ke("match");
var qw = function(t) {
  var e;
  return Qt(t) && ((e = t[BA]) !== void 0 ? !!e : In(t) == "RegExp");
};
var N$ = function(t) {
  if (typeof t != "function")
    throw TypeError(String(t) + " is not a function");
  return t;
};
var FA = Ke("species");
var Yy = function(t) {
  return function(e, i) {
    var n, O, r = String(vO(e)), a = qa(i), o = r.length;
    return a < 0 || a >= o ? t ? "" : void 0 : (n = r.charCodeAt(a)) < 55296 || n > 56319 || a + 1 === o || (O = r.charCodeAt(a + 1)) < 56320 || O > 57343 ? t ? r.charAt(a) : n : t ? r.slice(a, a + 2) : O - 56320 + (n - 55296 << 10) + 65536;
  };
};
var zw = { codeAt: Yy(false), charAt: Yy(true) };
var HA = zw.charAt;
var Cw = function(t, e, i) {
  return e + (i ? HA(t, e).length : 1);
};
var Jd = function(t, e) {
  var i = t.exec;
  if (typeof i == "function") {
    var n = i.call(t, e);
    if (typeof n != "object")
      throw TypeError("RegExp exec method returned something other than an Object or null");
    return n;
  }
  if (In(t) !== "RegExp")
    throw TypeError("RegExp#exec called on incompatible receiver");
  return hs.call(t, e);
};
var KA = [].push;
var JA = Math.min;
var Rr = !je(function() {
  return !RegExp(4294967295, "y");
});
Vw("split", 2, function(t, e, i) {
  var n;
  return n = "abbc".split(/(b)*/)[1] == "c" || "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(O, r) {
    var a = String(vO(this)), o = r === void 0 ? 4294967295 : r >>> 0;
    if (o === 0)
      return [];
    if (O === void 0)
      return [a];
    if (!qw(O))
      return e.call(a, O, o);
    for (var s, l, c, u = [], h10 = (O.ignoreCase ? "i" : "") + (O.multiline ? "m" : "") + (O.unicode ? "u" : "") + (O.sticky ? "y" : ""), d = 0, p = new RegExp(O.source, h10 + "g"); (s = hs.call(p, a)) && !((l = p.lastIndex) > d && (u.push(a.slice(d, s.index)), s.length > 1 && s.index < a.length && KA.apply(u, s.slice(1)), c = s[0].length, d = l, u.length >= o)); )
      p.lastIndex === s.index && p.lastIndex++;
    return d === a.length ? !c && p.test("") || u.push("") : u.push(a.slice(d)), u.length > o ? u.slice(0, o) : u;
  } : "0".split(void 0, 0).length ? function(O, r) {
    return O === void 0 && r === 0 ? [] : e.call(this, O, r);
  } : e, [function(O, r) {
    var a = vO(this), o = O == null ? void 0 : O[t];
    return o !== void 0 ? o.call(O, a, r) : n.call(String(a), O, r);
  }, function(O, r) {
    var a = i(n, O, this, r, n !== e);
    if (a.done)
      return a.value;
    var o = Ht(O), s = String(this), l = function(P, S) {
      var y, v = Ht(P).constructor;
      return v === void 0 || (y = Ht(v)[FA]) == null ? S : N$(y);
    }(o, RegExp), c = o.unicode, u = (o.ignoreCase ? "i" : "") + (o.multiline ? "m" : "") + (o.unicode ? "u" : "") + (Rr ? "y" : "g"), h10 = new l(Rr ? o : "^(?:" + o.source + ")", u), d = r === void 0 ? 4294967295 : r >>> 0;
    if (d === 0)
      return [];
    if (s.length === 0)
      return Jd(h10, s) === null ? [s] : [];
    for (var p = 0, $ = 0, g = []; $ < s.length; ) {
      h10.lastIndex = Rr ? $ : 0;
      var Q, m = Jd(h10, Rr ? s : s.slice($));
      if (m === null || (Q = JA(Xi(h10.lastIndex + (Rr ? 0 : $)), s.length)) === p)
        $ = Cw(s, $, c);
      else {
        if (g.push(s.slice(p, $)), g.length === d)
          return g;
        for (var b = 1; b <= m.length - 1; b++)
          if (g.push(m[b]), g.length === d)
            return g;
        $ = p = Q;
      }
    }
    return g.push(s.slice(p)), g;
  }];
}, !Rr);
var ep = `	
\v\f\r                　\u2028\u2029\uFEFF`;
var qc = "[" + ep + "]";
var eG = RegExp("^" + qc + qc + "*");
var tG = RegExp(qc + qc + "*$");
var Kf = function(t) {
  return function(e) {
    var i = String(vO(e));
    return 1 & t && (i = i.replace(eG, "")), 2 & t && (i = i.replace(tG, "")), i;
  };
};
var iG = { start: Kf(1), end: Kf(2), trim: Kf(3) };
var nG = iG.trim;
Ct({ target: "String", proto: true, forced: function(t) {
  return je(function() {
    return !!ep[t]() || "​᠎"[t]() != "​᠎" || ep[t].name !== t;
  });
}("trim") }, { trim: function() {
  return nG(this);
} });
var OG = D$("slice");
var rG = za("slice", { ACCESSORS: true, 0: 0, 1: 2 });
var aG = Ke("species");
var oG = [].slice;
var sG = Math.max;
Ct({ target: "Array", proto: true, forced: !OG || !rG }, { slice: function(t, e) {
  var i, n, O, r = Va(this), a = Xi(r.length), o = Yc(t, a), s = Yc(e === void 0 ? a : e, a);
  if (Sa(r) && (typeof (i = r.constructor) != "function" || i !== Array && !Sa(i.prototype) ? Qt(i) && (i = i[aG]) === null && (i = void 0) : i = void 0, i === Array || i === void 0))
    return oG.call(r, o, s);
  for (n = new (i === void 0 ? Array : i)(sG(s - o, 0)), O = 0; o < s; o++, O++)
    o in r && Pa(n, O, r[o]);
  return n.length = O, n;
} });
var B$ = Object.keys || function(t) {
  return ww(t, Rc);
};
var lG = je(function() {
  B$(1);
});
Ct({ target: "Object", stat: true, forced: lG }, { keys: function(t) {
  return B$(Fn(t));
} });
var Jf;
var cG = function(t) {
  if (qw(t))
    throw TypeError("The method doesn't accept regular expressions");
  return t;
};
var uG = Ke("match");
var fG = j$.f;
var Ry = "".startsWith;
var hG = Math.min;
var Ew = function(t) {
  var e = /./;
  try {
    "/./"[t](e);
  } catch {
    try {
      return e[uG] = false, "/./"[t](e);
    } catch {
    }
  }
  return false;
}("startsWith");
var dG = !(Ew || (Jf = fG(String.prototype, "startsWith"), !Jf || Jf.writable));
function jw(t) {
  return (jw = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  })(t);
}
Ct({ target: "String", proto: true, forced: !dG && !Ew }, { startsWith: function(t) {
  var e = String(vO(this));
  cG(t);
  var i = Xi(hG(arguments.length > 1 ? arguments[1] : void 0, e.length)), n = String(t);
  return Ry ? Ry.call(e, n, i) : e.slice(i, i + n.length) === n;
} });
var Zr = function(t) {
  return typeof t == "string";
};
var Ur = function(t) {
  return t !== null && jw(t) === "object";
};
var ya = function() {
  function t() {
    $r(this, t);
  }
  return Qr(t, null, [{ key: "isWindow", value: function(e) {
    return e === window;
  } }, { key: "addEventListener", value: function(e, i, n) {
    var O = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
    e && i && n && e.addEventListener(i, n, O);
  } }, { key: "removeEventListener", value: function(e, i, n) {
    var O = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
    e && i && n && e.removeEventListener(i, n, O);
  } }, { key: "triggerDragEvent", value: function(e, i) {
    var n = false, O = function(a) {
      var o;
      (o = i.drag) === null || o === void 0 || o.call(i, a);
    }, r = function a(o) {
      var s;
      t.removeEventListener(document, "mousemove", O), t.removeEventListener(document, "mouseup", a), document.onselectstart = null, document.ondragstart = null, n = false, (s = i.end) === null || s === void 0 || s.call(i, o);
    };
    t.addEventListener(e, "mousedown", function(a) {
      var o;
      n || (document.onselectstart = function() {
        return false;
      }, document.ondragstart = function() {
        return false;
      }, t.addEventListener(document, "mousemove", O), t.addEventListener(document, "mouseup", r), n = true, (o = i.start) === null || o === void 0 || o.call(i, a));
    });
  } }, { key: "getBoundingClientRect", value: function(e) {
    return e && Ur(e) && e.nodeType === 1 ? e.getBoundingClientRect() : null;
  } }, { key: "hasClass", value: function(e, i) {
    return !!(e && Ur(e) && Zr(i) && e.nodeType === 1) && e.classList.contains(i.trim());
  } }, { key: "addClass", value: function(e, i) {
    if (e && Ur(e) && Zr(i) && e.nodeType === 1 && (i = i.trim(), !t.hasClass(e, i))) {
      var n = e.className;
      e.className = n ? n + " " + i : i;
    }
  } }, { key: "removeClass", value: function(e, i) {
    if (e && Ur(e) && Zr(i) && e.nodeType === 1 && typeof e.className == "string") {
      i = i.trim();
      for (var n = e.className.trim().split(" "), O = n.length - 1; O >= 0; O--)
        n[O] = n[O].trim(), n[O] && n[O] !== i || n.splice(O, 1);
      e.className = n.join(" ");
    }
  } }, { key: "toggleClass", value: function(e, i, n) {
    e && Ur(e) && Zr(i) && e.nodeType === 1 && e.classList.toggle(i, n);
  } }, { key: "replaceClass", value: function(e, i, n) {
    e && Ur(e) && Zr(i) && Zr(n) && e.nodeType === 1 && (i = i.trim(), n = n.trim(), t.removeClass(e, i), t.addClass(e, n));
  } }, { key: "getScrollTop", value: function(e) {
    var i = "scrollTop" in e ? e.scrollTop : e.pageYOffset;
    return Math.max(i, 0);
  } }, { key: "setScrollTop", value: function(e, i) {
    "scrollTop" in e ? e.scrollTop = i : e.scrollTo(e.scrollX, i);
  } }, { key: "getRootScrollTop", value: function() {
    return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
  } }, { key: "setRootScrollTop", value: function(e) {
    t.setScrollTop(window, e), t.setScrollTop(document.body, e);
  } }, { key: "getElementTop", value: function(e, i) {
    if (t.isWindow(e))
      return 0;
    var n = i ? t.getScrollTop(i) : t.getRootScrollTop();
    return e.getBoundingClientRect().top + n;
  } }, { key: "getVisibleHeight", value: function(e) {
    return t.isWindow(e) ? e.innerHeight : e.getBoundingClientRect().height;
  } }, { key: "isHidden", value: function(e) {
    if (!e)
      return false;
    var i = window.getComputedStyle(e), n = i.display === "none", O = e.offsetParent === null && i.position !== "fixed";
    return n || O;
  } }, { key: "triggerEvent", value: function(e, i) {
    if ("createEvent" in document) {
      var n = document.createEvent("HTMLEvents");
      n.initEvent(i, false, true), e.dispatchEvent(n);
    }
  } }, { key: "calcAngle", value: function(e, i) {
    var n = e.getBoundingClientRect(), O = n.left + n.width / 2, r = n.top + n.height / 2, a = Math.abs(O - i.clientX), o = Math.abs(r - i.clientY), s = o / Math.sqrt(Math.pow(a, 2) + Math.pow(o, 2)), l = Math.acos(s), c = Math.floor(180 / (Math.PI / l));
    return i.clientX > O && i.clientY > r && (c = 180 - c), i.clientX == O && i.clientY > r && (c = 180), i.clientX > O && i.clientY == r && (c = 90), i.clientX < O && i.clientY > r && (c = 180 + c), i.clientX < O && i.clientY == r && (c = 270), i.clientX < O && i.clientY < r && (c = 360 - c), c;
  } }, { key: "querySelector", value: function(e, i) {
    return i ? i.querySelector(e) : document.querySelector(e);
  } }, { key: "createElement", value: function(e) {
    for (var i = document.createElement(e), n = arguments.length, O = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++)
      O[r - 1] = arguments[r];
    for (var a = 0; a < O.length; a++)
      O[a] && i.classList.add(O[a]);
    return i;
  } }, { key: "appendChild", value: function(e) {
    for (var i = 0; i < (arguments.length <= 1 ? 0 : arguments.length - 1); i++)
      e.appendChild(i + 1 < 1 || arguments.length <= i + 1 ? void 0 : arguments[i + 1]);
  } }, { key: "getWindow", value: function(e) {
    if (e.toString() !== "[object Window]") {
      var i = e.ownerDocument;
      return i && i.defaultView || window;
    }
    return e;
  } }, { key: "isElement", value: function(e) {
    return e instanceof this.getWindow(e).Element || e instanceof Element;
  } }, { key: "isHTMLElement", value: function(e) {
    return e instanceof this.getWindow(e).HTMLElement || e instanceof HTMLElement;
  } }, { key: "isShadowRoot", value: function(e) {
    return typeof ShadowRoot < "u" && (e instanceof this.getWindow(e).ShadowRoot || e instanceof ShadowRoot);
  } }, { key: "getWindowScroll", value: function(e) {
    var i = this.getWindow(e);
    return { scrollLeft: i.pageXOffset || 0, scrollTop: i.pageYOffset || 0 };
  } }]), t;
}();
var pG = Math.floor;
var $G = "".replace;
var QG = /\$([$&'`]|\d\d?|<[^>]*>)/g;
var gG = /\$([$&'`]|\d\d?)/g;
var mG = function(t, e, i, n, O, r) {
  var a = i + t.length, o = n.length, s = gG;
  return O !== void 0 && (O = Fn(O), s = QG), $G.call(r, s, function(l, c) {
    var u;
    switch (c.charAt(0)) {
      case "$":
        return "$";
      case "&":
        return t;
      case "`":
        return e.slice(0, i);
      case "'":
        return e.slice(a);
      case "<":
        u = O[c.slice(1, -1)];
        break;
      default:
        var h10 = +c;
        if (h10 === 0)
          return l;
        if (h10 > o) {
          var d = pG(h10 / 10);
          return d === 0 ? l : d <= o ? n[d - 1] === void 0 ? c.charAt(1) : n[d - 1] + c.charAt(1) : l;
        }
        u = n[h10 - 1];
    }
    return u === void 0 ? "" : u;
  });
};
var SG = Math.max;
var PG = Math.min;
Vw("replace", 2, function(t, e, i, n) {
  var O = n.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE, r = n.REPLACE_KEEPS_$0, a = O ? "$" : "$0";
  return [function(o, s) {
    var l = vO(this), c = o == null ? void 0 : o[t];
    return c !== void 0 ? c.call(o, l, s) : e.call(String(l), o, s);
  }, function(o, s) {
    if (!O && r || typeof s == "string" && s.indexOf(a) === -1) {
      var l = i(e, o, this, s);
      if (l.done)
        return l.value;
    }
    var c = Ht(o), u = String(this), h10 = typeof s == "function";
    h10 || (s = String(s));
    var d = c.global;
    if (d) {
      var p = c.unicode;
      c.lastIndex = 0;
    }
    for (var $ = []; ; ) {
      var g = Jd(c, u);
      if (g === null || ($.push(g), !d))
        break;
      String(g[0]) === "" && (c.lastIndex = Cw(u, Xi(c.lastIndex), p));
    }
    for (var Q, m = "", b = 0, P = 0; P < $.length; P++) {
      g = $[P];
      for (var S = String(g[0]), y = SG(PG(qa(g.index), u.length), 0), v = [], T = 1; T < g.length; T++)
        v.push((Q = g[T]) === void 0 ? Q : String(Q));
      var _ = g.groups;
      if (h10) {
        var x = [S].concat(v, y, u);
        _ !== void 0 && x.push(_);
        var k = String(s.apply(void 0, x));
      } else
        k = mG(S, u, y, v, _, s);
      y >= b && (m += u.slice(b, y) + k, b = y + S.length);
    }
    return m + u.slice(b);
  }];
});
(function() {
  function t() {
    $r(this, t);
  }
  return Qr(t, null, [{ key: "camelize", value: function(e) {
    return e.replace(/-(\w)/g, function(i, n) {
      return n ? n.toUpperCase() : "";
    });
  } }, { key: "capitalize", value: function(e) {
    return e.charAt(0).toUpperCase() + e.slice(1);
  } }]), t;
})();
(function() {
  function t() {
    $r(this, t);
  }
  return Qr(t, null, [{ key: "_clone", value: function() {
  } }]), t;
})();
var Iw = Ke("isConcatSpreadable");
var yG = Uc >= 51 || !je(function() {
  var t = [];
  return t[Iw] = false, t.concat()[0] !== t;
});
var bG = D$("concat");
var vG = function(t) {
  if (!Qt(t))
    return false;
  var e = t[Iw];
  return e !== void 0 ? !!e : Sa(t);
};
Ct({ target: "Array", proto: true, forced: !yG || !bG }, { concat: function(t) {
  var e, i, n, O, r, a = Fn(this), o = Ru(a, 0), s = 0;
  for (e = -1, n = arguments.length; e < n; e++)
    if (vG(r = e === -1 ? a : arguments[e])) {
      if (s + (O = Xi(r.length)) > 9007199254740991)
        throw TypeError("Maximum allowed index exceeded");
      for (i = 0; i < O; i++, s++)
        i in r && Pa(o, s, r[i]);
    } else {
      if (s >= 9007199254740991)
        throw TypeError("Maximum allowed index exceeded");
      Pa(o, s++, r);
    }
  return o.length = s, o;
} });
var eh;
var Ys = function(t, e, i) {
  if (N$(t), e === void 0)
    return t;
  switch (i) {
    case 0:
      return function() {
        return t.call(e);
      };
    case 1:
      return function(n) {
        return t.call(e, n);
      };
    case 2:
      return function(n, O) {
        return t.call(e, n, O);
      };
    case 3:
      return function(n, O, r) {
        return t.call(e, n, O, r);
      };
  }
  return function() {
    return t.apply(e, arguments);
  };
};
var Zy = [].push;
var iO = function(t) {
  var e = t == 1, i = t == 2, n = t == 3, O = t == 4, r = t == 6, a = t == 7, o = t == 5 || r;
  return function(s, l, c, u) {
    for (var h10, d, p = Fn(s), $ = _u(p), g = Ys(l, c, 3), Q = Xi($.length), m = 0, b = u || Ru, P = e ? b(s, Q) : i || a ? b(s, 0) : void 0; Q > m; m++)
      if ((o || m in $) && (d = g(h10 = $[m], m, p), t))
        if (e)
          P[m] = d;
        else if (d)
          switch (t) {
            case 3:
              return true;
            case 5:
              return h10;
            case 6:
              return m;
            case 2:
              Zy.call(P, h10);
          }
        else
          switch (t) {
            case 4:
              return false;
            case 7:
              Zy.call(P, h10);
          }
    return r ? -1 : n || O ? O : P;
  };
};
var Aw = { forEach: iO(0), map: iO(1), filter: iO(2), some: iO(3), every: iO(4), find: iO(5), findIndex: iO(6), filterOut: iO(7) };
var XG = ki ? Object.defineProperties : function(t, e) {
  Ht(t);
  for (var i, n = B$(e), O = n.length, r = 0; O > r; )
    Bn.f(t, i = n[r++], e[i]);
  return t;
};
var xG = Yu("document", "documentElement");
var Gw = G$("IE_PROTO");
var th = function() {
};
var Uy = function(t) {
  return "<script>" + t + "<\/script>";
};
var El = function() {
  try {
    eh = document.domain && new ActiveXObject("htmlfile");
  } catch {
  }
  var t, e;
  El = eh ? function(n) {
    n.write(Uy("")), n.close();
    var O = n.parentWindow.Object;
    return n = null, O;
  }(eh) : ((e = yw("iframe")).style.display = "none", xG.appendChild(e), e.src = String("javascript:"), (t = e.contentWindow.document).open(), t.write(Uy("document.F=Object")), t.close(), t.F);
  for (var i = Rc.length; i--; )
    delete El.prototype[Rc[i]];
  return El();
};
Wu[Gw] = true;
var F$ = Object.create || function(t, e) {
  var i;
  return t !== null ? (th.prototype = Ht(t), i = new th(), th.prototype = null, i[Gw] = t) : i = El(), e === void 0 ? i : XG(i, e);
};
var tp = Ke("unscopables");
var ip = Array.prototype;
ip[tp] == null && Bn.f(ip, tp, { configurable: true, value: F$(null) });
var Fr = function(t) {
  ip[tp][t] = true;
};
var wG = Aw.find;
var Vy = true;
var TG = za("find");
"find" in [] && Array(1).find(function() {
  Vy = false;
}), Ct({ target: "Array", proto: true, forced: Vy || !TG }, { find: function(t) {
  return wG(this, t, arguments.length > 1 ? arguments[1] : void 0);
} }), Fr("find");
var kG = Aw.findIndex;
var qy = true;
var _G = za("findIndex");
"findIndex" in [] && Array(1).findIndex(function() {
  qy = false;
}), Ct({ target: "Array", proto: true, forced: qy || !_G }, { findIndex: function(t) {
  return kG(this, t, arguments.length > 1 ? arguments[1] : void 0);
} }), Fr("findIndex");
var Lw = function(t, e, i, n, O, r, a, o) {
  for (var s, l = O, c = 0, u = !!a && Ys(a, o, 3); c < n; ) {
    if (c in i) {
      if (s = u ? u(i[c], c, e) : i[c], r > 0 && Sa(s))
        l = Lw(t, e, s, Xi(s.length), l, r - 1) - 1;
      else {
        if (l >= 9007199254740991)
          throw TypeError("Exceed the acceptable array length");
        t[l] = s;
      }
      l++;
    }
    c++;
  }
  return l;
};
var WG = Lw;
Ct({ target: "Array", proto: true }, { flat: function() {
  var t = arguments.length ? arguments[0] : void 0, e = Fn(this), i = Xi(e.length), n = Ru(e, 0);
  return n.length = WG(n, e, e, i, 0, t === void 0 ? 1 : qa(t)), n;
} });
var np = function(t) {
  var e = t.return;
  if (e !== void 0)
    return Ht(e.call(t)).value;
};
var YG = function(t, e, i, n) {
  try {
    return n ? e(Ht(i)[0], i[1]) : e(i);
  } catch (O) {
    throw np(t), O;
  }
};
var ba = {};
var RG = Ke("iterator");
var ZG = Array.prototype;
var Dw = function(t) {
  return t !== void 0 && (ba.Array === t || ZG[RG] === t);
};
var UG = Ke("iterator");
var Mw = function(t) {
  if (t != null)
    return t[UG] || t["@@iterator"] || ba[Ww(t)];
};
var Nw = Ke("iterator");
var Bw = false;
try {
  VG = 0, zy = { next: function() {
    return { done: !!VG++ };
  }, return: function() {
    Bw = true;
  } };
  zy[Nw] = function() {
    return this;
  }, Array.from(zy, function() {
    throw 2;
  });
} catch {
}
var VG;
var zy;
var Fw = function(t, e) {
  if (!e && !Bw)
    return false;
  var i = false;
  try {
    var n = {};
    n[Nw] = function() {
      return { next: function() {
        return { done: i = true };
      } };
    }, t(n);
  } catch {
  }
  return i;
};
var qG = !Fw(function(t) {
  Array.from(t);
});
Ct({ target: "Array", stat: true, forced: qG }, { from: function(t) {
  var e, i, n, O, r, a, o = Fn(t), s = typeof this == "function" ? this : Array, l = arguments.length, c = l > 1 ? arguments[1] : void 0, u = c !== void 0, h10 = Mw(o), d = 0;
  if (u && (c = Ys(c, l > 2 ? arguments[2] : void 0, 2)), h10 == null || s == Array && Dw(h10))
    for (i = new s(e = Xi(o.length)); e > d; d++)
      a = u ? c(o[d], d) : o[d], Pa(i, d, a);
  else
    for (r = (O = h10.call(o)).next, i = new s(); !(n = r.call(O)).done; d++)
      a = u ? YG(O, c, [n.value, d], true) : n.value, Pa(i, d, a);
  return i.length = d, i;
} });
var Cy = function(t) {
  return function(e, i, n, O) {
    N$(i);
    var r = Fn(e), a = _u(r), o = Xi(r.length), s = t ? o - 1 : 0, l = t ? -1 : 1;
    if (n < 2)
      for (; ; ) {
        if (s in a) {
          O = a[s], s += l;
          break;
        }
        if (s += l, t ? s < 0 : o <= s)
          throw TypeError("Reduce of empty array with no initial value");
      }
    for (; t ? s >= 0 : o > s; s += l)
      s in a && (O = i(O, a[s], s, r));
    return O;
  };
};
var zG = { left: Cy(false), right: Cy(true) };
var CG = In(pt.process) == "process";
var EG = zG.left;
var jG = L$("reduce");
var IG = za("reduce", { 1: 0 });
Ct({ target: "Array", proto: true, forced: !jG || !IG || !CG && Uc > 79 && Uc < 83 }, { reduce: function(t) {
  return EG(this, t, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
} }), Fr("flat");
var jO;
var Ey;
var jy;
var AG = !je(function() {
  return Object.isExtensible(Object.preventExtensions({}));
});
var Hw = C$(function(t) {
  var e = Bn.f, i = A$("meta"), n = 0, O = Object.isExtensible || function() {
    return true;
  }, r = function(o) {
    e(o, i, { value: { objectID: "O" + ++n, weakData: {} } });
  }, a = t.exports = { REQUIRED: false, fastKey: function(o, s) {
    if (!Qt(o))
      return typeof o == "symbol" ? o : (typeof o == "string" ? "S" : "P") + o;
    if (!st(o, i)) {
      if (!O(o))
        return "F";
      if (!s)
        return "E";
      r(o);
    }
    return o[i].objectID;
  }, getWeakData: function(o, s) {
    if (!st(o, i)) {
      if (!O(o))
        return true;
      if (!s)
        return false;
      r(o);
    }
    return o[i].weakData;
  }, onFreeze: function(o) {
    return AG && a.REQUIRED && O(o) && !st(o, i) && r(o), o;
  } };
  Wu[i] = true;
});
var oo = function(t, e) {
  this.stopped = t, this.result = e;
};
var Iy = function(t, e, i) {
  var n, O, r, a, o, s, l, c = i && i.that, u = !(!i || !i.AS_ENTRIES), h10 = !(!i || !i.IS_ITERATOR), d = !(!i || !i.INTERRUPTED), p = Ys(e, c, 1 + u + d), $ = function(Q) {
    return n && np(n), new oo(true, Q);
  }, g = function(Q) {
    return u ? (Ht(Q), d ? p(Q[0], Q[1], $) : p(Q[0], Q[1])) : d ? p(Q, $) : p(Q);
  };
  if (h10)
    n = t;
  else {
    if (typeof (O = Mw(t)) != "function")
      throw TypeError("Target is not iterable");
    if (Dw(O)) {
      for (r = 0, a = Xi(t.length); a > r; r++)
        if ((o = g(t[r])) && o instanceof oo)
          return o;
      return new oo(false);
    }
    n = O.call(t);
  }
  for (s = n.next; !(l = s.call(n)).done; ) {
    try {
      o = g(l.value);
    } catch (Q) {
      throw np(n), Q;
    }
    if (typeof o == "object" && o && o instanceof oo)
      return o;
  }
  return new oo(false);
};
var Ay = function(t, e, i) {
  if (!(t instanceof e))
    throw TypeError("Incorrect " + (i ? i + " " : "") + "invocation");
  return t;
};
var GG = Bn.f;
var Gy = Ke("toStringTag");
var Op = function(t, e, i) {
  t && !st(t = i ? t : t.prototype, Gy) && GG(t, Gy, { configurable: true, value: e });
};
var zc = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var t, e = false, i = {};
  try {
    (t = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(i, []), e = i instanceof Array;
  } catch {
  }
  return function(n, O) {
    return Ht(n), function(r) {
      if (!Qt(r) && r !== null)
        throw TypeError("Can't set " + String(r) + " as a prototype");
    }(O), e ? t.call(n, O) : n.__proto__ = O, n;
  };
}() : void 0);
var Ly = function(t, e, i) {
  for (var n in e)
    xO(t, n, e[n], i);
  return t;
};
var LG = !je(function() {
  function t() {
  }
  return t.prototype.constructor = null, Object.getPrototypeOf(new t()) !== t.prototype;
});
var Dy = G$("IE_PROTO");
var DG = Object.prototype;
var Cc = LG ? Object.getPrototypeOf : function(t) {
  return t = Fn(t), st(t, Dy) ? t[Dy] : typeof t.constructor == "function" && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? DG : null;
};
var ih = Ke("iterator");
var Kw = false;
[].keys && ("next" in (jy = [].keys()) ? (Ey = Cc(Cc(jy))) !== Object.prototype && (jO = Ey) : Kw = true), (jO == null || je(function() {
  var t = {};
  return jO[ih].call(t) !== t;
})) && (jO = {}), st(jO, ih) || Zi(jO, ih, function() {
  return this;
});
var H$ = { IteratorPrototype: jO, BUGGY_SAFARI_ITERATORS: Kw };
var MG = H$.IteratorPrototype;
var NG = function() {
  return this;
};
var nh = H$.IteratorPrototype;
var Sl = H$.BUGGY_SAFARI_ITERATORS;
var so = Ke("iterator");
var BG = function() {
  return this;
};
var K$ = function(t, e, i, n, O, r, a) {
  (function(Q, m, b) {
    var P = m + " Iterator";
    Q.prototype = F$(MG, { next: ku(1, b) }), Op(Q, P, false), ba[P] = NG;
  })(i, e, n);
  var o, s, l, c = function(Q) {
    if (Q === O && $)
      return $;
    if (!Sl && Q in d)
      return d[Q];
    switch (Q) {
      case "keys":
      case "values":
      case "entries":
        return function() {
          return new i(this, Q);
        };
    }
    return function() {
      return new i(this);
    };
  }, u = e + " Iterator", h10 = false, d = t.prototype, p = d[so] || d["@@iterator"] || O && d[O], $ = !Sl && p || c(O), g = e == "Array" && d.entries || p;
  if (g && (o = Cc(g.call(new t())), nh !== Object.prototype && o.next && (Cc(o) !== nh && (zc ? zc(o, nh) : typeof o[so] != "function" && Zi(o, so, BG)), Op(o, u, true))), O == "values" && p && p.name !== "values" && (h10 = true, $ = function() {
    return p.call(this);
  }), d[so] !== $ && Zi(d, so, $), ba[e] = $, O)
    if (s = { values: c("values"), keys: r ? $ : c("keys"), entries: c("entries") }, a)
      for (l in s)
        (Sl || h10 || !(l in d)) && xO(d, l, s[l]);
    else
      Ct({ target: e, proto: true, forced: Sl || h10 }, s);
  return s;
};
var My = Ke("species");
var FG = Bn.f;
var Ny = Hw.fastKey;
var By = XO.set;
var Oh = XO.getterFor;
(function(t, e, i) {
  var n = t.indexOf("Map") !== -1, O = t.indexOf("Weak") !== -1, r = n ? "set" : "add", a = pt[t], o = a && a.prototype, s = a, l = {}, c = function(g) {
    var Q = o[g];
    xO(o, g, g == "add" ? function(m) {
      return Q.call(this, m === 0 ? 0 : m), this;
    } : g == "delete" ? function(m) {
      return !(O && !Qt(m)) && Q.call(this, m === 0 ? 0 : m);
    } : g == "get" ? function(m) {
      return O && !Qt(m) ? void 0 : Q.call(this, m === 0 ? 0 : m);
    } : g == "has" ? function(m) {
      return !(O && !Qt(m)) && Q.call(this, m === 0 ? 0 : m);
    } : function(m, b) {
      return Q.call(this, m === 0 ? 0 : m, b), this;
    });
  };
  if (Kd(t, typeof a != "function" || !(O || o.forEach && !je(function() {
    new a().entries().next();
  }))))
    s = i.getConstructor(e, t, n, r), Hw.REQUIRED = true;
  else if (Kd(t, true)) {
    var u = new s(), h10 = u[r](O ? {} : -0, 1) != u, d = je(function() {
      u.has(1);
    }), p = Fw(function(g) {
      new a(g);
    }), $ = !O && je(function() {
      for (var g = new a(), Q = 5; Q--; )
        g[r](Q, Q);
      return !g.has(-0);
    });
    p || ((s = e(function(g, Q) {
      Ay(g, s, t);
      var m = function(b, P, S) {
        var y, v;
        return zc && typeof (y = P.constructor) == "function" && y !== S && Qt(v = y.prototype) && v !== S.prototype && zc(b, v), b;
      }(new a(), g, s);
      return Q != null && Iy(Q, m[r], { that: m, AS_ENTRIES: n }), m;
    })).prototype = o, o.constructor = s), (d || $) && (c("delete"), c("has"), n && c("get")), ($ || h10) && c(r), O && o.clear && delete o.clear;
  }
  l[t] = s, Ct({ global: true, forced: s != a }, l), Op(s, t), O || i.setStrong(s, t, n);
})("Set", function(t) {
  return function() {
    return t(this, arguments.length ? arguments[0] : void 0);
  };
}, { getConstructor: function(t, e, i, n) {
  var O = t(function(s, l) {
    Ay(s, O, e), By(s, { type: e, index: F$(null), first: void 0, last: void 0, size: 0 }), ki || (s.size = 0), l != null && Iy(l, s[n], { that: s, AS_ENTRIES: i });
  }), r = Oh(e), a = function(s, l, c) {
    var u, h10, d = r(s), p = o(s, l);
    return p ? p.value = c : (d.last = p = { index: h10 = Ny(l, true), key: l, value: c, previous: u = d.last, next: void 0, removed: false }, d.first || (d.first = p), u && (u.next = p), ki ? d.size++ : s.size++, h10 !== "F" && (d.index[h10] = p)), s;
  }, o = function(s, l) {
    var c, u = r(s), h10 = Ny(l);
    if (h10 !== "F")
      return u.index[h10];
    for (c = u.first; c; c = c.next)
      if (c.key == l)
        return c;
  };
  return Ly(O.prototype, { clear: function() {
    for (var s = r(this), l = s.index, c = s.first; c; )
      c.removed = true, c.previous && (c.previous = c.previous.next = void 0), delete l[c.index], c = c.next;
    s.first = s.last = void 0, ki ? s.size = 0 : this.size = 0;
  }, delete: function(s) {
    var l = this, c = r(l), u = o(l, s);
    if (u) {
      var h10 = u.next, d = u.previous;
      delete c.index[u.index], u.removed = true, d && (d.next = h10), h10 && (h10.previous = d), c.first == u && (c.first = h10), c.last == u && (c.last = d), ki ? c.size-- : l.size--;
    }
    return !!u;
  }, forEach: function(s) {
    for (var l, c = r(this), u = Ys(s, arguments.length > 1 ? arguments[1] : void 0, 3); l = l ? l.next : c.first; )
      for (u(l.value, l.key, this); l && l.removed; )
        l = l.previous;
  }, has: function(s) {
    return !!o(this, s);
  } }), Ly(O.prototype, i ? { get: function(s) {
    var l = o(this, s);
    return l && l.value;
  }, set: function(s, l) {
    return a(this, s === 0 ? 0 : s, l);
  } } : { add: function(s) {
    return a(this, s = s === 0 ? 0 : s, s);
  } }), ki && FG(O.prototype, "size", { get: function() {
    return r(this).size;
  } }), O;
}, setStrong: function(t, e, i) {
  var n = e + " Iterator", O = Oh(e), r = Oh(n);
  K$(t, e, function(a, o) {
    By(this, { type: n, target: a, state: O(a), kind: o, last: void 0 });
  }, function() {
    for (var a = r(this), o = a.kind, s = a.last; s && s.removed; )
      s = s.previous;
    return a.target && (a.last = s = s ? s.next : a.state.first) ? o == "keys" ? { value: s.key, done: false } : o == "values" ? { value: s.value, done: false } : { value: [s.key, s.value], done: false } : (a.target = void 0, { value: void 0, done: true });
  }, i ? "entries" : "values", !i, true), function(a) {
    var o = Yu(a), s = Bn.f;
    ki && o && !o[My] && s(o, My, { configurable: true, get: function() {
      return this;
    } });
  }(e);
} });
var HG = zw.charAt;
var KG = XO.set;
var JG = XO.getterFor("String Iterator");
K$(String, "String", function(t) {
  KG(this, { type: "String Iterator", string: String(t), index: 0 });
}, function() {
  var t, e = JG(this), i = e.string, n = e.index;
  return n >= i.length ? { value: void 0, done: true } : (t = HG(i, n), e.index += t.length, { value: t, done: false });
});
var Fy = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 };
var eL = XO.set;
var tL = XO.getterFor("Array Iterator");
var Po = K$(Array, "Array", function(t, e) {
  eL(this, { type: "Array Iterator", target: Va(t), index: 0, kind: e });
}, function() {
  var t = tL(this), e = t.target, i = t.kind, n = t.index++;
  return !e || n >= e.length ? (t.target = void 0, { value: void 0, done: true }) : i == "keys" ? { value: n, done: false } : i == "values" ? { value: e[n], done: false } : { value: [n, e[n]], done: false };
}, "values");
ba.Arguments = ba.Array, Fr("keys"), Fr("values"), Fr("entries");
var rh = Ke("iterator");
var Hy = Ke("toStringTag");
var ah = Po.values;
for (oh in Fy) {
  Ky = pt[oh], Wn = Ky && Ky.prototype;
  if (Wn) {
    if (Wn[rh] !== ah)
      try {
        Zi(Wn, rh, ah);
      } catch {
        Wn[rh] = ah;
      }
    if (Wn[Hy] || Zi(Wn, Hy, oh), Fy[oh]) {
      for (Vr in Po)
        if (Wn[Vr] !== Po[Vr])
          try {
            Zi(Wn, Vr, Po[Vr]);
          } catch {
            Wn[Vr] = Po[Vr];
          }
    }
  }
}
var Ky;
var Wn;
var Vr;
var oh;
(function() {
  function t() {
    $r(this, t);
  }
  return Qr(t, null, [{ key: "deduplicate", value: function(e) {
    return Array.from(new Set(e));
  } }, { key: "flat", value: function(e) {
    return e.reduce(function(i, n) {
      var O = Array.isArray(n) ? t.flat(n) : n;
      return i.concat(O);
    }, []);
  } }, { key: "find", value: function(e, i) {
    return e.find(i);
  } }, { key: "findIndex", value: function(e, i) {
    return e.findIndex(i);
  } }]), t;
})();
(function() {
  function t() {
    $r(this, t);
  }
  return Qr(t, null, [{ key: "today", value: function() {
    return new Date();
  } }]), t;
})();
(function() {
  function t() {
    $r(this, t);
  }
  return Qr(t, null, [{ key: "range", value: function(e, i, n) {
    return Math.min(Math.max(e, i), n);
  } }, { key: "clamp", value: function(e, i, n) {
    return i < n ? e < i ? i : e > n ? n : e : e < n ? n : e > i ? i : e;
  } }]), t;
})();
var iL = typeof global == "object" && global && global.Object === Object && global;
var Jw = iL;
var nL = typeof self == "object" && self && self.Object === Object && self;
var OL = Jw || nL || Function("return this")();
var Ca = OL;
var rL = Ca.Symbol;
var Ec = rL;
var eT = Object.prototype;
var aL = eT.hasOwnProperty;
var oL = eT.toString;
var lo = Ec ? Ec.toStringTag : void 0;
function sL(t) {
  var e = aL.call(t, lo), i = t[lo];
  try {
    t[lo] = void 0;
    var n = true;
  } catch {
  }
  var O = oL.call(t);
  return n && (e ? t[lo] = i : delete t[lo]), O;
}
var lL = Object.prototype;
var cL = lL.toString;
function uL(t) {
  return cL.call(t);
}
var fL = "[object Null]";
var hL = "[object Undefined]";
var Jy = Ec ? Ec.toStringTag : void 0;
function Zu(t) {
  return t == null ? t === void 0 ? hL : fL : Jy && Jy in Object(t) ? sL(t) : uL(t);
}
function Rs(t) {
  return t != null && typeof t == "object";
}
var dL = Array.isArray;
var rp = dL;
function gr(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
function tT(t) {
  return t;
}
var pL = "[object AsyncFunction]";
var $L = "[object Function]";
var QL = "[object GeneratorFunction]";
var gL = "[object Proxy]";
function J$(t) {
  if (!gr(t))
    return false;
  var e = Zu(t);
  return e == $L || e == QL || e == pL || e == gL;
}
var mL = Ca["__core-js_shared__"];
var sh = mL;
var eb = function() {
  var t = /[^.]+$/.exec(sh && sh.keys && sh.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
}();
function SL(t) {
  return !!eb && eb in t;
}
var PL = Function.prototype;
var yL = PL.toString;
function bL(t) {
  if (t != null) {
    try {
      return yL.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var vL = /[\\^$.*+?()[\]{}|]/g;
var XL = /^\[object .+?Constructor\]$/;
var xL = Function.prototype;
var wL = Object.prototype;
var TL = xL.toString;
var kL = wL.hasOwnProperty;
var _L = RegExp(
  "^" + TL.call(kL).replace(vL, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function WL(t) {
  if (!gr(t) || SL(t))
    return false;
  var e = J$(t) ? _L : XL;
  return e.test(bL(t));
}
function YL(t, e) {
  return t == null ? void 0 : t[e];
}
function eQ(t, e) {
  var i = YL(t, e);
  return WL(i) ? i : void 0;
}
var tb = Object.create;
var RL = function() {
  function t() {
  }
  return function(e) {
    if (!gr(e))
      return {};
    if (tb)
      return tb(e);
    t.prototype = e;
    var i = new t();
    return t.prototype = void 0, i;
  };
}();
var ZL = RL;
function UL(t, e, i) {
  switch (i.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, i[0]);
    case 2:
      return t.call(e, i[0], i[1]);
    case 3:
      return t.call(e, i[0], i[1], i[2]);
  }
  return t.apply(e, i);
}
function VL(t, e) {
  var i = -1, n = t.length;
  for (e || (e = Array(n)); ++i < n; )
    e[i] = t[i];
  return e;
}
var qL = 800;
var zL = 16;
var CL = Date.now;
function EL(t) {
  var e = 0, i = 0;
  return function() {
    var n = CL(), O = zL - (n - i);
    if (i = n, O > 0) {
      if (++e >= qL)
        return arguments[0];
    } else
      e = 0;
    return t.apply(void 0, arguments);
  };
}
function jL(t) {
  return function() {
    return t;
  };
}
var IL = function() {
  try {
    var t = eQ(Object, "defineProperty");
    return t({}, "", {}), t;
  } catch {
  }
}();
var jc = IL;
var AL = jc ? function(t, e) {
  return jc(t, "toString", {
    configurable: true,
    enumerable: false,
    value: jL(e),
    writable: true
  });
} : tT;
var GL = AL;
var LL = EL(GL);
var DL = LL;
var ML = 9007199254740991;
var NL = /^(?:0|[1-9]\d*)$/;
function iT(t, e) {
  var i = typeof t;
  return e = e ?? ML, !!e && (i == "number" || i != "symbol" && NL.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
function tQ(t, e, i) {
  e == "__proto__" && jc ? jc(t, e, {
    configurable: true,
    enumerable: true,
    value: i,
    writable: true
  }) : t[e] = i;
}
function Uu(t, e) {
  return t === e || t !== t && e !== e;
}
var BL = Object.prototype;
var FL = BL.hasOwnProperty;
function HL(t, e, i) {
  var n = t[e];
  (!(FL.call(t, e) && Uu(n, i)) || i === void 0 && !(e in t)) && tQ(t, e, i);
}
function KL(t, e, i, n) {
  var O = !i;
  i || (i = {});
  for (var r = -1, a = e.length; ++r < a; ) {
    var o = e[r], s = n ? n(i[o], t[o], o, i, t) : void 0;
    s === void 0 && (s = t[o]), O ? tQ(i, o, s) : HL(i, o, s);
  }
  return i;
}
var ib = Math.max;
function JL(t, e, i) {
  return e = ib(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var n = arguments, O = -1, r = ib(n.length - e, 0), a = Array(r); ++O < r; )
      a[O] = n[e + O];
    O = -1;
    for (var o = Array(e + 1); ++O < e; )
      o[O] = n[O];
    return o[e] = i(a), UL(t, this, o);
  };
}
function eD(t, e) {
  return DL(JL(t, e, tT), t + "");
}
var tD = 9007199254740991;
function nT(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= tD;
}
function iQ(t) {
  return t != null && nT(t.length) && !J$(t);
}
function iD(t, e, i) {
  if (!gr(i))
    return false;
  var n = typeof e;
  return (n == "number" ? iQ(i) && iT(e, i.length) : n == "string" && e in i) ? Uu(i[e], t) : false;
}
function nD(t) {
  return eD(function(e, i) {
    var n = -1, O = i.length, r = O > 1 ? i[O - 1] : void 0, a = O > 2 ? i[2] : void 0;
    for (r = t.length > 3 && typeof r == "function" ? (O--, r) : void 0, a && iD(i[0], i[1], a) && (r = O < 3 ? void 0 : r, O = 1), e = Object(e); ++n < O; ) {
      var o = i[n];
      o && t(e, o, n, r);
    }
    return e;
  });
}
var OD = Object.prototype;
function OT(t) {
  var e = t && t.constructor, i = typeof e == "function" && e.prototype || OD;
  return t === i;
}
function rD(t, e) {
  for (var i = -1, n = Array(t); ++i < t; )
    n[i] = e(i);
  return n;
}
var aD = "[object Arguments]";
function nb(t) {
  return Rs(t) && Zu(t) == aD;
}
var rT = Object.prototype;
var oD = rT.hasOwnProperty;
var sD = rT.propertyIsEnumerable;
var lD = nb(function() {
  return arguments;
}()) ? nb : function(t) {
  return Rs(t) && oD.call(t, "callee") && !sD.call(t, "callee");
};
var ap = lD;
function cD() {
  return false;
}
var aT = typeof exports == "object" && exports && !exports.nodeType && exports;
var Ob = aT && typeof module == "object" && module && !module.nodeType && module;
var uD = Ob && Ob.exports === aT;
var rb = uD ? Ca.Buffer : void 0;
var fD = rb ? rb.isBuffer : void 0;
var hD = fD || cD;
var oT = hD;
var dD = "[object Arguments]";
var pD = "[object Array]";
var $D = "[object Boolean]";
var QD = "[object Date]";
var gD = "[object Error]";
var mD = "[object Function]";
var SD = "[object Map]";
var PD = "[object Number]";
var yD = "[object Object]";
var bD = "[object RegExp]";
var vD = "[object Set]";
var XD = "[object String]";
var xD = "[object WeakMap]";
var wD = "[object ArrayBuffer]";
var TD = "[object DataView]";
var kD = "[object Float32Array]";
var _D = "[object Float64Array]";
var WD = "[object Int8Array]";
var YD = "[object Int16Array]";
var RD = "[object Int32Array]";
var ZD = "[object Uint8Array]";
var UD = "[object Uint8ClampedArray]";
var VD = "[object Uint16Array]";
var qD = "[object Uint32Array]";
var Ve = {};
Ve[kD] = Ve[_D] = Ve[WD] = Ve[YD] = Ve[RD] = Ve[ZD] = Ve[UD] = Ve[VD] = Ve[qD] = true;
Ve[dD] = Ve[pD] = Ve[wD] = Ve[$D] = Ve[TD] = Ve[QD] = Ve[gD] = Ve[mD] = Ve[SD] = Ve[PD] = Ve[yD] = Ve[bD] = Ve[vD] = Ve[XD] = Ve[xD] = false;
function zD(t) {
  return Rs(t) && nT(t.length) && !!Ve[Zu(t)];
}
function CD(t) {
  return function(e) {
    return t(e);
  };
}
var sT = typeof exports == "object" && exports && !exports.nodeType && exports;
var qo = sT && typeof module == "object" && module && !module.nodeType && module;
var ED = qo && qo.exports === sT;
var lh = ED && Jw.process;
var jD = function() {
  try {
    var t = qo && qo.require && qo.require("util").types;
    return t || lh && lh.binding && lh.binding("util");
  } catch {
  }
}();
var ab = jD;
var ob = ab && ab.isTypedArray;
var ID = ob ? CD(ob) : zD;
var lT = ID;
var AD = Object.prototype;
var GD = AD.hasOwnProperty;
function LD(t, e) {
  var i = rp(t), n = !i && ap(t), O = !i && !n && oT(t), r = !i && !n && !O && lT(t), a = i || n || O || r, o = a ? rD(t.length, String) : [], s = o.length;
  for (var l in t)
    (e || GD.call(t, l)) && !(a && // Safari 9 has enumerable `arguments.length` in strict mode.
    (l == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    O && (l == "offset" || l == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    r && (l == "buffer" || l == "byteLength" || l == "byteOffset") || // Skip index properties.
    iT(l, s))) && o.push(l);
  return o;
}
function DD(t, e) {
  return function(i) {
    return t(e(i));
  };
}
function MD(t) {
  var e = [];
  if (t != null)
    for (var i in Object(t))
      e.push(i);
  return e;
}
var ND = Object.prototype;
var BD = ND.hasOwnProperty;
function FD(t) {
  if (!gr(t))
    return MD(t);
  var e = OT(t), i = [];
  for (var n in t)
    n == "constructor" && (e || !BD.call(t, n)) || i.push(n);
  return i;
}
function cT(t) {
  return iQ(t) ? LD(t, true) : FD(t);
}
var HD = eQ(Object, "create");
var ds = HD;
function KD() {
  this.__data__ = ds ? ds(null) : {}, this.size = 0;
}
function JD(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var eM = "__lodash_hash_undefined__";
var tM = Object.prototype;
var iM = tM.hasOwnProperty;
function nM(t) {
  var e = this.__data__;
  if (ds) {
    var i = e[t];
    return i === eM ? void 0 : i;
  }
  return iM.call(e, t) ? e[t] : void 0;
}
var OM = Object.prototype;
var rM = OM.hasOwnProperty;
function aM(t) {
  var e = this.__data__;
  return ds ? e[t] !== void 0 : rM.call(e, t);
}
var oM = "__lodash_hash_undefined__";
function sM(t, e) {
  var i = this.__data__;
  return this.size += this.has(t) ? 0 : 1, i[t] = ds && e === void 0 ? oM : e, this;
}
function cr(t) {
  var e = -1, i = t == null ? 0 : t.length;
  for (this.clear(); ++e < i; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
cr.prototype.clear = KD;
cr.prototype.delete = JD;
cr.prototype.get = nM;
cr.prototype.has = aM;
cr.prototype.set = sM;
function lM() {
  this.__data__ = [], this.size = 0;
}
function Vu(t, e) {
  for (var i = t.length; i--; )
    if (Uu(t[i][0], e))
      return i;
  return -1;
}
var cM = Array.prototype;
var uM = cM.splice;
function fM(t) {
  var e = this.__data__, i = Vu(e, t);
  if (i < 0)
    return false;
  var n = e.length - 1;
  return i == n ? e.pop() : uM.call(e, i, 1), --this.size, true;
}
function hM(t) {
  var e = this.__data__, i = Vu(e, t);
  return i < 0 ? void 0 : e[i][1];
}
function dM(t) {
  return Vu(this.__data__, t) > -1;
}
function pM(t, e) {
  var i = this.__data__, n = Vu(i, t);
  return n < 0 ? (++this.size, i.push([t, e])) : i[n][1] = e, this;
}
function Hn(t) {
  var e = -1, i = t == null ? 0 : t.length;
  for (this.clear(); ++e < i; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
Hn.prototype.clear = lM;
Hn.prototype.delete = fM;
Hn.prototype.get = hM;
Hn.prototype.has = dM;
Hn.prototype.set = pM;
var $M = eQ(Ca, "Map");
var uT = $M;
function QM() {
  this.size = 0, this.__data__ = {
    hash: new cr(),
    map: new (uT || Hn)(),
    string: new cr()
  };
}
function gM(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function qu(t, e) {
  var i = t.__data__;
  return gM(e) ? i[typeof e == "string" ? "string" : "hash"] : i.map;
}
function mM(t) {
  var e = qu(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
function SM(t) {
  return qu(this, t).get(t);
}
function PM(t) {
  return qu(this, t).has(t);
}
function yM(t, e) {
  var i = qu(this, t), n = i.size;
  return i.set(t, e), this.size += i.size == n ? 0 : 1, this;
}
function Ea(t) {
  var e = -1, i = t == null ? 0 : t.length;
  for (this.clear(); ++e < i; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
Ea.prototype.clear = QM;
Ea.prototype.delete = mM;
Ea.prototype.get = SM;
Ea.prototype.has = PM;
Ea.prototype.set = yM;
var bM = DD(Object.getPrototypeOf, Object);
var fT = bM;
var vM = "[object Object]";
var XM = Function.prototype;
var xM = Object.prototype;
var hT = XM.toString;
var wM = xM.hasOwnProperty;
var TM = hT.call(Object);
function kM(t) {
  if (!Rs(t) || Zu(t) != vM)
    return false;
  var e = fT(t);
  if (e === null)
    return true;
  var i = wM.call(e, "constructor") && e.constructor;
  return typeof i == "function" && i instanceof i && hT.call(i) == TM;
}
function _M() {
  this.__data__ = new Hn(), this.size = 0;
}
function WM(t) {
  var e = this.__data__, i = e.delete(t);
  return this.size = e.size, i;
}
function YM(t) {
  return this.__data__.get(t);
}
function RM(t) {
  return this.__data__.has(t);
}
var ZM = 200;
function UM(t, e) {
  var i = this.__data__;
  if (i instanceof Hn) {
    var n = i.__data__;
    if (!uT || n.length < ZM - 1)
      return n.push([t, e]), this.size = ++i.size, this;
    i = this.__data__ = new Ea(n);
  }
  return i.set(t, e), this.size = i.size, this;
}
function ja(t) {
  var e = this.__data__ = new Hn(t);
  this.size = e.size;
}
ja.prototype.clear = _M;
ja.prototype.delete = WM;
ja.prototype.get = YM;
ja.prototype.has = RM;
ja.prototype.set = UM;
var dT = typeof exports == "object" && exports && !exports.nodeType && exports;
var sb = dT && typeof module == "object" && module && !module.nodeType && module;
var VM = sb && sb.exports === dT;
var lb = VM ? Ca.Buffer : void 0;
var cb = lb ? lb.allocUnsafe : void 0;
function qM(t, e) {
  if (e)
    return t.slice();
  var i = t.length, n = cb ? cb(i) : new t.constructor(i);
  return t.copy(n), n;
}
var zM = Ca.Uint8Array;
var ub = zM;
function CM(t) {
  var e = new t.constructor(t.byteLength);
  return new ub(e).set(new ub(t)), e;
}
function EM(t, e) {
  var i = e ? CM(t.buffer) : t.buffer;
  return new t.constructor(i, t.byteOffset, t.length);
}
function jM(t) {
  return typeof t.constructor == "function" && !OT(t) ? ZL(fT(t)) : {};
}
function IM(t) {
  return function(e, i, n) {
    for (var O = -1, r = Object(e), a = n(e), o = a.length; o--; ) {
      var s = a[t ? o : ++O];
      if (i(r[s], s, r) === false)
        break;
    }
    return e;
  };
}
var AM = IM();
var GM = AM;
function op(t, e, i) {
  (i !== void 0 && !Uu(t[e], i) || i === void 0 && !(e in t)) && tQ(t, e, i);
}
function LM(t) {
  return Rs(t) && iQ(t);
}
function sp(t, e) {
  if (!(e === "constructor" && typeof t[e] == "function") && e != "__proto__")
    return t[e];
}
function DM(t) {
  return KL(t, cT(t));
}
function MM(t, e, i, n, O, r, a) {
  var o = sp(t, i), s = sp(e, i), l = a.get(s);
  if (l) {
    op(t, i, l);
    return;
  }
  var c = r ? r(o, s, i + "", t, e, a) : void 0, u = c === void 0;
  if (u) {
    var h10 = rp(s), d = !h10 && oT(s), p = !h10 && !d && lT(s);
    c = s, h10 || d || p ? rp(o) ? c = o : LM(o) ? c = VL(o) : d ? (u = false, c = qM(s, true)) : p ? (u = false, c = EM(s, true)) : c = [] : kM(s) || ap(s) ? (c = o, ap(o) ? c = DM(o) : (!gr(o) || J$(o)) && (c = jM(s))) : u = false;
  }
  u && (a.set(s, c), O(c, s, n, r, a), a.delete(s)), op(t, i, c);
}
function pT(t, e, i, n, O) {
  t !== e && GM(e, function(r, a) {
    if (O || (O = new ja()), gr(r))
      MM(t, e, a, i, pT, n, O);
    else {
      var o = n ? n(sp(t, a), r, a + "", t, e, O) : void 0;
      o === void 0 && (o = r), op(t, a, o);
    }
  }, cT);
}
var NM = nD(function(t, e, i) {
  pT(t, e, i);
});
var zu = NM;
var BM = (t, e) => {
  const i = t.getBoundingClientRect(), n = i.left + i.width / 2, O = i.top + i.height / 2, r = Math.abs(n - e.clientX), a = Math.abs(O - e.clientY), o = Math.sqrt(Math.pow(r, 2) + Math.pow(a, 2)), s = a / o, l = Math.acos(s);
  let c = Math.floor(180 / (Math.PI / l));
  return e.clientX > n && e.clientY > O && (c = 180 - c), e.clientX == n && e.clientY > O && (c = 180), e.clientX > n && e.clientY == O && (c = 90), e.clientX < n && e.clientY > O && (c = 180 + c), e.clientX < n && e.clientY == O && (c = 270), e.clientX < n && e.clientY < O && (c = 360 - c), c;
};
var ch = false;
var FM = (t, e) => {
  const i = function(O) {
    var r;
    (r = e.drag) == null || r.call(e, O);
  }, n = function(O) {
    var r;
    document.removeEventListener("mousemove", i, false), document.removeEventListener("mouseup", n, false), document.onselectstart = null, document.ondragstart = null, ch = false, (r = e.end) == null || r.call(e, O);
  };
  t && t.addEventListener("mousedown", (O) => {
    var r;
    ch || (document.onselectstart = () => false, document.ondragstart = () => false, document.addEventListener("mousemove", i, false), document.addEventListener("mouseup", n, false), ch = true, (r = e.start) == null || r.call(e, O));
  });
};
var HM = {
  angle: {
    type: Number,
    default: 0
  },
  size: {
    type: Number,
    default: 16,
    validator: (t) => t >= 16
  },
  borderWidth: {
    type: Number,
    default: 1,
    validator: (t) => t >= 1
  },
  borderColor: {
    type: String,
    default: "#666"
  }
};
var KM = defineComponent({
  name: "Angle",
  props: HM,
  emits: ["update:angle", "change"],
  setup(t, {
    emit: e
  }) {
    const i = ref(null), n = ref(t.angle);
    watch(() => t.angle, (o) => {
      n.value = o;
    });
    const O = () => {
      let o = Number(n.value);
      isNaN(o) || (o = o > 360 || o < 0 ? t.angle : o, n.value = o === 360 ? 0 : o, e("update:angle", n.value), e("change", n.value));
    }, r = computed(() => ({
      width: t.size + "px",
      height: t.size + "px",
      borderWidth: t.borderWidth + "px",
      borderColor: t.borderColor,
      transform: `rotate(${n.value}deg)`
    })), a = (o) => {
      i.value && (n.value = BM(i.value, o) % 360, O());
    };
    return onMounted(() => {
      const o = {
        drag: (s) => {
          a(s);
        },
        end: (s) => {
          a(s);
        }
      };
      i.value && FM(i.value, o);
    }), () => createVNode("div", {
      class: "bee-angle"
    }, [createVNode("div", {
      class: "bee-angle__round",
      ref: i,
      style: r.value
    }, null)]);
  }
});
var oi = "top";
var qi = "bottom";
var zi = "right";
var si = "left";
var Cu = "auto";
var Zs = [oi, qi, zi, si];
var va = "start";
var ps = "end";
var JM = "clippingParents";
var $T = "viewport";
var co = "popper";
var eN = "reference";
var fb = Zs.reduce(function(t, e) {
  return t.concat([e + "-" + va, e + "-" + ps]);
}, []);
var QT = [].concat(Zs, [Cu]).reduce(function(t, e) {
  return t.concat([e, e + "-" + va, e + "-" + ps]);
}, []);
var tN = "beforeRead";
var iN = "read";
var nN = "afterRead";
var ON = "beforeMain";
var rN = "main";
var aN = "afterMain";
var oN = "beforeWrite";
var sN = "write";
var lN = "afterWrite";
var lp = [tN, iN, nN, ON, rN, aN, oN, sN, lN];
function vn(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}
function ji(t) {
  if (t == null)
    return window;
  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return e && e.defaultView || window;
  }
  return t;
}
function ur(t) {
  var e = ji(t).Element;
  return t instanceof e || t instanceof Element;
}
function bi(t) {
  var e = ji(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}
function nQ(t) {
  if (typeof ShadowRoot > "u")
    return false;
  var e = ji(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function cN(t) {
  var e = t.state;
  Object.keys(e.elements).forEach(function(i) {
    var n = e.styles[i] || {}, O = e.attributes[i] || {}, r = e.elements[i];
    !bi(r) || !vn(r) || (Object.assign(r.style, n), Object.keys(O).forEach(function(a) {
      var o = O[a];
      o === false ? r.removeAttribute(a) : r.setAttribute(a, o === true ? "" : o);
    }));
  });
}
function uN(t) {
  var e = t.state, i = {
    popper: {
      position: e.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(e.elements.popper.style, i.popper), e.styles = i, e.elements.arrow && Object.assign(e.elements.arrow.style, i.arrow), function() {
    Object.keys(e.elements).forEach(function(n) {
      var O = e.elements[n], r = e.attributes[n] || {}, a = Object.keys(e.styles.hasOwnProperty(n) ? e.styles[n] : i[n]), o = a.reduce(function(s, l) {
        return s[l] = "", s;
      }, {});
      !bi(O) || !vn(O) || (Object.assign(O.style, o), Object.keys(r).forEach(function(s) {
        O.removeAttribute(s);
      }));
    });
  };
}
var fN = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: cN,
  effect: uN,
  requires: ["computeStyles"]
};
function tn(t) {
  return t.split("-")[0];
}
var FO = Math.max;
var Ic = Math.min;
var Xa = Math.round;
function cp() {
  var t = navigator.userAgentData;
  return t != null && t.brands ? t.brands.map(function(e) {
    return e.brand + "/" + e.version;
  }).join(" ") : navigator.userAgent;
}
function gT() {
  return !/^((?!chrome|android).)*safari/i.test(cp());
}
function xa(t, e, i) {
  e === void 0 && (e = false), i === void 0 && (i = false);
  var n = t.getBoundingClientRect(), O = 1, r = 1;
  e && bi(t) && (O = t.offsetWidth > 0 && Xa(n.width) / t.offsetWidth || 1, r = t.offsetHeight > 0 && Xa(n.height) / t.offsetHeight || 1);
  var a = ur(t) ? ji(t) : window, o = a.visualViewport, s = !gT() && i, l = (n.left + (s && o ? o.offsetLeft : 0)) / O, c = (n.top + (s && o ? o.offsetTop : 0)) / r, u = n.width / O, h10 = n.height / r;
  return {
    width: u,
    height: h10,
    top: c,
    right: l + u,
    bottom: c + h10,
    left: l,
    x: l,
    y: c
  };
}
function OQ(t) {
  var e = xa(t), i = t.offsetWidth, n = t.offsetHeight;
  return Math.abs(e.width - i) <= 1 && (i = e.width), Math.abs(e.height - n) <= 1 && (n = e.height), {
    x: t.offsetLeft,
    y: t.offsetTop,
    width: i,
    height: n
  };
}
function mT(t, e) {
  var i = e.getRootNode && e.getRootNode();
  if (t.contains(e))
    return true;
  if (i && nQ(i)) {
    var n = e;
    do {
      if (n && t.isSameNode(n))
        return true;
      n = n.parentNode || n.host;
    } while (n);
  }
  return false;
}
function nn(t) {
  return ji(t).getComputedStyle(t);
}
function hN(t) {
  return ["table", "td", "th"].indexOf(vn(t)) >= 0;
}
function WO(t) {
  return ((ur(t) ? t.ownerDocument : (
    // $FlowFixMe[prop-missing]
    t.document
  )) || window.document).documentElement;
}
function Eu(t) {
  return vn(t) === "html" ? t : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    t.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    t.parentNode || // DOM Element detected
    (nQ(t) ? t.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    WO(t)
  );
}
function hb(t) {
  return !bi(t) || // https://github.com/popperjs/popper-core/issues/837
  nn(t).position === "fixed" ? null : t.offsetParent;
}
function dN(t) {
  var e = /firefox/i.test(cp()), i = /Trident/i.test(cp());
  if (i && bi(t)) {
    var n = nn(t);
    if (n.position === "fixed")
      return null;
  }
  var O = Eu(t);
  for (nQ(O) && (O = O.host); bi(O) && ["html", "body"].indexOf(vn(O)) < 0; ) {
    var r = nn(O);
    if (r.transform !== "none" || r.perspective !== "none" || r.contain === "paint" || ["transform", "perspective"].indexOf(r.willChange) !== -1 || e && r.willChange === "filter" || e && r.filter && r.filter !== "none")
      return O;
    O = O.parentNode;
  }
  return null;
}
function Us(t) {
  for (var e = ji(t), i = hb(t); i && hN(i) && nn(i).position === "static"; )
    i = hb(i);
  return i && (vn(i) === "html" || vn(i) === "body" && nn(i).position === "static") ? e : i || dN(t) || e;
}
function rQ(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function zo(t, e, i) {
  return FO(t, Ic(e, i));
}
function pN(t, e, i) {
  var n = zo(t, e, i);
  return n > i ? i : n;
}
function ST() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function PT(t) {
  return Object.assign({}, ST(), t);
}
function yT(t, e) {
  return e.reduce(function(i, n) {
    return i[n] = t, i;
  }, {});
}
var $N = function(e, i) {
  return e = typeof e == "function" ? e(Object.assign({}, i.rects, {
    placement: i.placement
  })) : e, PT(typeof e != "number" ? e : yT(e, Zs));
};
function QN(t) {
  var e, i = t.state, n = t.name, O = t.options, r = i.elements.arrow, a = i.modifiersData.popperOffsets, o = tn(i.placement), s = rQ(o), l = [si, zi].indexOf(o) >= 0, c = l ? "height" : "width";
  if (!(!r || !a)) {
    var u = $N(O.padding, i), h10 = OQ(r), d = s === "y" ? oi : si, p = s === "y" ? qi : zi, $ = i.rects.reference[c] + i.rects.reference[s] - a[s] - i.rects.popper[c], g = a[s] - i.rects.reference[s], Q = Us(r), m = Q ? s === "y" ? Q.clientHeight || 0 : Q.clientWidth || 0 : 0, b = $ / 2 - g / 2, P = u[d], S = m - h10[c] - u[p], y = m / 2 - h10[c] / 2 + b, v = zo(P, y, S), T = s;
    i.modifiersData[n] = (e = {}, e[T] = v, e.centerOffset = v - y, e);
  }
}
function gN(t) {
  var e = t.state, i = t.options, n = i.element, O = n === void 0 ? "[data-popper-arrow]" : n;
  if (O != null && !(typeof O == "string" && (O = e.elements.popper.querySelector(O), !O))) {
    if (bi(O) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" ")), !mT(e.elements.popper, O)) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      return;
    }
    e.elements.arrow = O;
  }
}
var mN = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: QN,
  effect: gN,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function wa(t) {
  return t.split("-")[1];
}
var SN = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function PN(t) {
  var e = t.x, i = t.y, n = window, O = n.devicePixelRatio || 1;
  return {
    x: Xa(e * O) / O || 0,
    y: Xa(i * O) / O || 0
  };
}
function db(t) {
  var e, i = t.popper, n = t.popperRect, O = t.placement, r = t.variation, a = t.offsets, o = t.position, s = t.gpuAcceleration, l = t.adaptive, c = t.roundOffsets, u = t.isFixed, h10 = a.x, d = h10 === void 0 ? 0 : h10, p = a.y, $ = p === void 0 ? 0 : p, g = typeof c == "function" ? c({
    x: d,
    y: $
  }) : {
    x: d,
    y: $
  };
  d = g.x, $ = g.y;
  var Q = a.hasOwnProperty("x"), m = a.hasOwnProperty("y"), b = si, P = oi, S = window;
  if (l) {
    var y = Us(i), v = "clientHeight", T = "clientWidth";
    if (y === ji(i) && (y = WO(i), nn(y).position !== "static" && o === "absolute" && (v = "scrollHeight", T = "scrollWidth")), y = y, O === oi || (O === si || O === zi) && r === ps) {
      P = qi;
      var _ = u && y === S && S.visualViewport ? S.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        y[v]
      );
      $ -= _ - n.height, $ *= s ? 1 : -1;
    }
    if (O === si || (O === oi || O === qi) && r === ps) {
      b = zi;
      var x = u && y === S && S.visualViewport ? S.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        y[T]
      );
      d -= x - n.width, d *= s ? 1 : -1;
    }
  }
  var k = Object.assign({
    position: o
  }, l && SN), Y = c === true ? PN({
    x: d,
    y: $
  }) : {
    x: d,
    y: $
  };
  if (d = Y.x, $ = Y.y, s) {
    var Z;
    return Object.assign({}, k, (Z = {}, Z[P] = m ? "0" : "", Z[b] = Q ? "0" : "", Z.transform = (S.devicePixelRatio || 1) <= 1 ? "translate(" + d + "px, " + $ + "px)" : "translate3d(" + d + "px, " + $ + "px, 0)", Z));
  }
  return Object.assign({}, k, (e = {}, e[P] = m ? $ + "px" : "", e[b] = Q ? d + "px" : "", e.transform = "", e));
}
function yN(t) {
  var e = t.state, i = t.options, n = i.gpuAcceleration, O = n === void 0 ? true : n, r = i.adaptive, a = r === void 0 ? true : r, o = i.roundOffsets, s = o === void 0 ? true : o;
  if (true) {
    var l = nn(e.elements.popper).transitionProperty || "";
    a && ["transform", "top", "right", "bottom", "left"].some(function(u) {
      return l.indexOf(u) >= 0;
    }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
  }
  var c = {
    placement: tn(e.placement),
    variation: wa(e.placement),
    popper: e.elements.popper,
    popperRect: e.rects.popper,
    gpuAcceleration: O,
    isFixed: e.options.strategy === "fixed"
  };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, db(Object.assign({}, c, {
    offsets: e.modifiersData.popperOffsets,
    position: e.options.strategy,
    adaptive: a,
    roundOffsets: s
  })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, db(Object.assign({}, c, {
    offsets: e.modifiersData.arrow,
    position: "absolute",
    adaptive: false,
    roundOffsets: s
  })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-placement": e.placement
  });
}
var bN = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: yN,
  data: {}
};
var Pl = {
  passive: true
};
function vN(t) {
  var e = t.state, i = t.instance, n = t.options, O = n.scroll, r = O === void 0 ? true : O, a = n.resize, o = a === void 0 ? true : a, s = ji(e.elements.popper), l = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return r && l.forEach(function(c) {
    c.addEventListener("scroll", i.update, Pl);
  }), o && s.addEventListener("resize", i.update, Pl), function() {
    r && l.forEach(function(c) {
      c.removeEventListener("scroll", i.update, Pl);
    }), o && s.removeEventListener("resize", i.update, Pl);
  };
}
var XN = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function() {
  },
  effect: vN,
  data: {}
};
var xN = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function jl(t) {
  return t.replace(/left|right|bottom|top/g, function(e) {
    return xN[e];
  });
}
var wN = {
  start: "end",
  end: "start"
};
function pb(t) {
  return t.replace(/start|end/g, function(e) {
    return wN[e];
  });
}
function aQ(t) {
  var e = ji(t), i = e.pageXOffset, n = e.pageYOffset;
  return {
    scrollLeft: i,
    scrollTop: n
  };
}
function oQ(t) {
  return xa(WO(t)).left + aQ(t).scrollLeft;
}
function TN(t, e) {
  var i = ji(t), n = WO(t), O = i.visualViewport, r = n.clientWidth, a = n.clientHeight, o = 0, s = 0;
  if (O) {
    r = O.width, a = O.height;
    var l = gT();
    (l || !l && e === "fixed") && (o = O.offsetLeft, s = O.offsetTop);
  }
  return {
    width: r,
    height: a,
    x: o + oQ(t),
    y: s
  };
}
function kN(t) {
  var e, i = WO(t), n = aQ(t), O = (e = t.ownerDocument) == null ? void 0 : e.body, r = FO(i.scrollWidth, i.clientWidth, O ? O.scrollWidth : 0, O ? O.clientWidth : 0), a = FO(i.scrollHeight, i.clientHeight, O ? O.scrollHeight : 0, O ? O.clientHeight : 0), o = -n.scrollLeft + oQ(t), s = -n.scrollTop;
  return nn(O || i).direction === "rtl" && (o += FO(i.clientWidth, O ? O.clientWidth : 0) - r), {
    width: r,
    height: a,
    x: o,
    y: s
  };
}
function sQ(t) {
  var e = nn(t), i = e.overflow, n = e.overflowX, O = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(i + O + n);
}
function bT(t) {
  return ["html", "body", "#document"].indexOf(vn(t)) >= 0 ? t.ownerDocument.body : bi(t) && sQ(t) ? t : bT(Eu(t));
}
function Co(t, e) {
  var i;
  e === void 0 && (e = []);
  var n = bT(t), O = n === ((i = t.ownerDocument) == null ? void 0 : i.body), r = ji(n), a = O ? [r].concat(r.visualViewport || [], sQ(n) ? n : []) : n, o = e.concat(a);
  return O ? o : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    o.concat(Co(Eu(a)))
  );
}
function up(t) {
  return Object.assign({}, t, {
    left: t.x,
    top: t.y,
    right: t.x + t.width,
    bottom: t.y + t.height
  });
}
function _N(t, e) {
  var i = xa(t, false, e === "fixed");
  return i.top = i.top + t.clientTop, i.left = i.left + t.clientLeft, i.bottom = i.top + t.clientHeight, i.right = i.left + t.clientWidth, i.width = t.clientWidth, i.height = t.clientHeight, i.x = i.left, i.y = i.top, i;
}
function $b(t, e, i) {
  return e === $T ? up(TN(t, i)) : ur(e) ? _N(e, i) : up(kN(WO(t)));
}
function WN(t) {
  var e = Co(Eu(t)), i = ["absolute", "fixed"].indexOf(nn(t).position) >= 0, n = i && bi(t) ? Us(t) : t;
  return ur(n) ? e.filter(function(O) {
    return ur(O) && mT(O, n) && vn(O) !== "body";
  }) : [];
}
function YN(t, e, i, n) {
  var O = e === "clippingParents" ? WN(t) : [].concat(e), r = [].concat(O, [i]), a = r[0], o = r.reduce(function(s, l) {
    var c = $b(t, l, n);
    return s.top = FO(c.top, s.top), s.right = Ic(c.right, s.right), s.bottom = Ic(c.bottom, s.bottom), s.left = FO(c.left, s.left), s;
  }, $b(t, a, n));
  return o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o;
}
function vT(t) {
  var e = t.reference, i = t.element, n = t.placement, O = n ? tn(n) : null, r = n ? wa(n) : null, a = e.x + e.width / 2 - i.width / 2, o = e.y + e.height / 2 - i.height / 2, s;
  switch (O) {
    case oi:
      s = {
        x: a,
        y: e.y - i.height
      };
      break;
    case qi:
      s = {
        x: a,
        y: e.y + e.height
      };
      break;
    case zi:
      s = {
        x: e.x + e.width,
        y: o
      };
      break;
    case si:
      s = {
        x: e.x - i.width,
        y: o
      };
      break;
    default:
      s = {
        x: e.x,
        y: e.y
      };
  }
  var l = O ? rQ(O) : null;
  if (l != null) {
    var c = l === "y" ? "height" : "width";
    switch (r) {
      case va:
        s[l] = s[l] - (e[c] / 2 - i[c] / 2);
        break;
      case ps:
        s[l] = s[l] + (e[c] / 2 - i[c] / 2);
        break;
    }
  }
  return s;
}
function $s(t, e) {
  e === void 0 && (e = {});
  var i = e, n = i.placement, O = n === void 0 ? t.placement : n, r = i.strategy, a = r === void 0 ? t.strategy : r, o = i.boundary, s = o === void 0 ? JM : o, l = i.rootBoundary, c = l === void 0 ? $T : l, u = i.elementContext, h10 = u === void 0 ? co : u, d = i.altBoundary, p = d === void 0 ? false : d, $ = i.padding, g = $ === void 0 ? 0 : $, Q = PT(typeof g != "number" ? g : yT(g, Zs)), m = h10 === co ? eN : co, b = t.rects.popper, P = t.elements[p ? m : h10], S = YN(ur(P) ? P : P.contextElement || WO(t.elements.popper), s, c, a), y = xa(t.elements.reference), v = vT({
    reference: y,
    element: b,
    strategy: "absolute",
    placement: O
  }), T = up(Object.assign({}, b, v)), _ = h10 === co ? T : y, x = {
    top: S.top - _.top + Q.top,
    bottom: _.bottom - S.bottom + Q.bottom,
    left: S.left - _.left + Q.left,
    right: _.right - S.right + Q.right
  }, k = t.modifiersData.offset;
  if (h10 === co && k) {
    var Y = k[O];
    Object.keys(x).forEach(function(Z) {
      var L = [zi, qi].indexOf(Z) >= 0 ? 1 : -1, ae = [oi, qi].indexOf(Z) >= 0 ? "y" : "x";
      x[Z] += Y[ae] * L;
    });
  }
  return x;
}
function RN(t, e) {
  e === void 0 && (e = {});
  var i = e, n = i.placement, O = i.boundary, r = i.rootBoundary, a = i.padding, o = i.flipVariations, s = i.allowedAutoPlacements, l = s === void 0 ? QT : s, c = wa(n), u = c ? o ? fb : fb.filter(function(p) {
    return wa(p) === c;
  }) : Zs, h10 = u.filter(function(p) {
    return l.indexOf(p) >= 0;
  });
  h10.length === 0 && (h10 = u, console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
  var d = h10.reduce(function(p, $) {
    return p[$] = $s(t, {
      placement: $,
      boundary: O,
      rootBoundary: r,
      padding: a
    })[tn($)], p;
  }, {});
  return Object.keys(d).sort(function(p, $) {
    return d[p] - d[$];
  });
}
function ZN(t) {
  if (tn(t) === Cu)
    return [];
  var e = jl(t);
  return [pb(t), e, pb(e)];
}
function UN(t) {
  var e = t.state, i = t.options, n = t.name;
  if (!e.modifiersData[n]._skip) {
    for (var O = i.mainAxis, r = O === void 0 ? true : O, a = i.altAxis, o = a === void 0 ? true : a, s = i.fallbackPlacements, l = i.padding, c = i.boundary, u = i.rootBoundary, h10 = i.altBoundary, d = i.flipVariations, p = d === void 0 ? true : d, $ = i.allowedAutoPlacements, g = e.options.placement, Q = tn(g), m = Q === g, b = s || (m || !p ? [jl(g)] : ZN(g)), P = [g].concat(b).reduce(function(jt, ii) {
      return jt.concat(tn(ii) === Cu ? RN(e, {
        placement: ii,
        boundary: c,
        rootBoundary: u,
        padding: l,
        flipVariations: p,
        allowedAutoPlacements: $
      }) : ii);
    }, []), S = e.rects.reference, y = e.rects.popper, v = /* @__PURE__ */ new Map(), T = true, _ = P[0], x = 0; x < P.length; x++) {
      var k = P[x], Y = tn(k), Z = wa(k) === va, L = [oi, qi].indexOf(Y) >= 0, ae = L ? "width" : "height", Oe = $s(e, {
        placement: k,
        boundary: c,
        rootBoundary: u,
        altBoundary: h10,
        padding: l
      }), C = L ? Z ? zi : si : Z ? qi : oi;
      S[ae] > y[ae] && (C = jl(C));
      var M = jl(C), H = [];
      if (r && H.push(Oe[Y] <= 0), o && H.push(Oe[C] <= 0, Oe[M] <= 0), H.every(function(jt) {
        return jt;
      })) {
        _ = k, T = false;
        break;
      }
      v.set(k, H);
    }
    if (T)
      for (var xe = p ? 3 : 1, Fe = function(ii) {
        var Ai = P.find(function(on) {
          var It = v.get(on);
          if (It)
            return It.slice(0, ii).every(function(Gi) {
              return Gi;
            });
        });
        if (Ai)
          return _ = Ai, "break";
      }, nt = xe; nt > 0; nt--) {
        var Et = Fe(nt);
        if (Et === "break")
          break;
      }
    e.placement !== _ && (e.modifiersData[n]._skip = true, e.placement = _, e.reset = true);
  }
}
var VN = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: UN,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function Qb(t, e, i) {
  return i === void 0 && (i = {
    x: 0,
    y: 0
  }), {
    top: t.top - e.height - i.y,
    right: t.right - e.width + i.x,
    bottom: t.bottom - e.height + i.y,
    left: t.left - e.width - i.x
  };
}
function gb(t) {
  return [oi, zi, qi, si].some(function(e) {
    return t[e] >= 0;
  });
}
function qN(t) {
  var e = t.state, i = t.name, n = e.rects.reference, O = e.rects.popper, r = e.modifiersData.preventOverflow, a = $s(e, {
    elementContext: "reference"
  }), o = $s(e, {
    altBoundary: true
  }), s = Qb(a, n), l = Qb(o, O, r), c = gb(s), u = gb(l);
  e.modifiersData[i] = {
    referenceClippingOffsets: s,
    popperEscapeOffsets: l,
    isReferenceHidden: c,
    hasPopperEscaped: u
  }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-reference-hidden": c,
    "data-popper-escaped": u
  });
}
var zN = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: qN
};
function CN(t, e, i) {
  var n = tn(t), O = [si, oi].indexOf(n) >= 0 ? -1 : 1, r = typeof i == "function" ? i(Object.assign({}, e, {
    placement: t
  })) : i, a = r[0], o = r[1];
  return a = a || 0, o = (o || 0) * O, [si, zi].indexOf(n) >= 0 ? {
    x: o,
    y: a
  } : {
    x: a,
    y: o
  };
}
function EN(t) {
  var e = t.state, i = t.options, n = t.name, O = i.offset, r = O === void 0 ? [0, 0] : O, a = QT.reduce(function(c, u) {
    return c[u] = CN(u, e.rects, r), c;
  }, {}), o = a[e.placement], s = o.x, l = o.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += s, e.modifiersData.popperOffsets.y += l), e.modifiersData[n] = a;
}
var jN = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: EN
};
function IN(t) {
  var e = t.state, i = t.name;
  e.modifiersData[i] = vT({
    reference: e.rects.reference,
    element: e.rects.popper,
    strategy: "absolute",
    placement: e.placement
  });
}
var AN = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: IN,
  data: {}
};
function GN(t) {
  return t === "x" ? "y" : "x";
}
function LN(t) {
  var e = t.state, i = t.options, n = t.name, O = i.mainAxis, r = O === void 0 ? true : O, a = i.altAxis, o = a === void 0 ? false : a, s = i.boundary, l = i.rootBoundary, c = i.altBoundary, u = i.padding, h10 = i.tether, d = h10 === void 0 ? true : h10, p = i.tetherOffset, $ = p === void 0 ? 0 : p, g = $s(e, {
    boundary: s,
    rootBoundary: l,
    padding: u,
    altBoundary: c
  }), Q = tn(e.placement), m = wa(e.placement), b = !m, P = rQ(Q), S = GN(P), y = e.modifiersData.popperOffsets, v = e.rects.reference, T = e.rects.popper, _ = typeof $ == "function" ? $(Object.assign({}, e.rects, {
    placement: e.placement
  })) : $, x = typeof _ == "number" ? {
    mainAxis: _,
    altAxis: _
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, _), k = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, Y = {
    x: 0,
    y: 0
  };
  if (y) {
    if (r) {
      var Z, L = P === "y" ? oi : si, ae = P === "y" ? qi : zi, Oe = P === "y" ? "height" : "width", C = y[P], M = C + g[L], H = C - g[ae], xe = d ? -T[Oe] / 2 : 0, Fe = m === va ? v[Oe] : T[Oe], nt = m === va ? -T[Oe] : -v[Oe], Et = e.elements.arrow, jt = d && Et ? OQ(Et) : {
        width: 0,
        height: 0
      }, ii = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : ST(), Ai = ii[L], on = ii[ae], It = zo(0, v[Oe], jt[Oe]), Gi = b ? v[Oe] / 2 - xe - It - Ai - x.mainAxis : Fe - It - Ai - x.mainAxis, sn = b ? -v[Oe] / 2 + xe + It + on + x.mainAxis : nt + It + on + x.mainAxis, Li = e.elements.arrow && Us(e.elements.arrow), YO = Li ? P === "y" ? Li.clientTop || 0 : Li.clientLeft || 0 : 0, w = (Z = k == null ? void 0 : k[P]) != null ? Z : 0, X = C + Gi - w - YO, W = C + sn - w, D = zo(d ? Ic(M, X) : M, C, d ? FO(H, W) : H);
      y[P] = D, Y[P] = D - C;
    }
    if (o) {
      var le, we = P === "x" ? oi : si, xi = P === "x" ? qi : zi, Pt = y[S], Sr = S === "y" ? "height" : "width", De = Pt + g[we], U = Pt - g[xi], z = [oi, si].indexOf(Q) !== -1, yt = (le = k == null ? void 0 : k[S]) != null ? le : 0, $t = z ? De : Pt - v[Sr] - T[Sr] - yt + x.altAxis, Pr = z ? Pt + v[Sr] + T[Sr] - yt - x.altAxis : U, RO = d && z ? pN($t, Pt, Pr) : zo(d ? $t : De, Pt, d ? Pr : U);
      y[S] = RO, Y[S] = RO - Pt;
    }
    e.modifiersData[n] = Y;
  }
}
var DN = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: LN,
  requiresIfExists: ["offset"]
};
function MN(t) {
  return {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  };
}
function NN(t) {
  return t === ji(t) || !bi(t) ? aQ(t) : MN(t);
}
function BN(t) {
  var e = t.getBoundingClientRect(), i = Xa(e.width) / t.offsetWidth || 1, n = Xa(e.height) / t.offsetHeight || 1;
  return i !== 1 || n !== 1;
}
function FN(t, e, i) {
  i === void 0 && (i = false);
  var n = bi(e), O = bi(e) && BN(e), r = WO(e), a = xa(t, O, i), o = {
    scrollLeft: 0,
    scrollTop: 0
  }, s = {
    x: 0,
    y: 0
  };
  return (n || !n && !i) && ((vn(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  sQ(r)) && (o = NN(e)), bi(e) ? (s = xa(e, true), s.x += e.clientLeft, s.y += e.clientTop) : r && (s.x = oQ(r))), {
    x: a.left + o.scrollLeft - s.x,
    y: a.top + o.scrollTop - s.y,
    width: a.width,
    height: a.height
  };
}
function HN(t) {
  var e = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set(), n = [];
  t.forEach(function(r) {
    e.set(r.name, r);
  });
  function O(r) {
    i.add(r.name);
    var a = [].concat(r.requires || [], r.requiresIfExists || []);
    a.forEach(function(o) {
      if (!i.has(o)) {
        var s = e.get(o);
        s && O(s);
      }
    }), n.push(r);
  }
  return t.forEach(function(r) {
    i.has(r.name) || O(r);
  }), n;
}
function KN(t) {
  var e = HN(t);
  return lp.reduce(function(i, n) {
    return i.concat(e.filter(function(O) {
      return O.phase === n;
    }));
  }, []);
}
function JN(t) {
  var e;
  return function() {
    return e || (e = new Promise(function(i) {
      Promise.resolve().then(function() {
        e = void 0, i(t());
      });
    })), e;
  };
}
function nO(t) {
  for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
    i[n - 1] = arguments[n];
  return [].concat(i).reduce(function(O, r) {
    return O.replace(/%s/, r);
  }, t);
}
var CO = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var eB = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var mb = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function tB(t) {
  t.forEach(function(e) {
    [].concat(Object.keys(e), mb).filter(function(i, n, O) {
      return O.indexOf(i) === n;
    }).forEach(function(i) {
      switch (i) {
        case "name":
          typeof e.name != "string" && console.error(nO(CO, String(e.name), '"name"', '"string"', '"' + String(e.name) + '"'));
          break;
        case "enabled":
          typeof e.enabled != "boolean" && console.error(nO(CO, e.name, '"enabled"', '"boolean"', '"' + String(e.enabled) + '"'));
          break;
        case "phase":
          lp.indexOf(e.phase) < 0 && console.error(nO(CO, e.name, '"phase"', "either " + lp.join(", "), '"' + String(e.phase) + '"'));
          break;
        case "fn":
          typeof e.fn != "function" && console.error(nO(CO, e.name, '"fn"', '"function"', '"' + String(e.fn) + '"'));
          break;
        case "effect":
          e.effect != null && typeof e.effect != "function" && console.error(nO(CO, e.name, '"effect"', '"function"', '"' + String(e.fn) + '"'));
          break;
        case "requires":
          e.requires != null && !Array.isArray(e.requires) && console.error(nO(CO, e.name, '"requires"', '"array"', '"' + String(e.requires) + '"'));
          break;
        case "requiresIfExists":
          Array.isArray(e.requiresIfExists) || console.error(nO(CO, e.name, '"requiresIfExists"', '"array"', '"' + String(e.requiresIfExists) + '"'));
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + e.name + '" modifier, valid properties are ' + mb.map(function(n) {
            return '"' + n + '"';
          }).join(", ") + '; but "' + i + '" was provided.');
      }
      e.requires && e.requires.forEach(function(n) {
        t.find(function(O) {
          return O.name === n;
        }) == null && console.error(nO(eB, String(e.name), n, n));
      });
    });
  });
}
function iB(t, e) {
  var i = /* @__PURE__ */ new Set();
  return t.filter(function(n) {
    var O = e(n);
    if (!i.has(O))
      return i.add(O), true;
  });
}
function nB(t) {
  var e = t.reduce(function(i, n) {
    var O = i[n.name];
    return i[n.name] = O ? Object.assign({}, O, n, {
      options: Object.assign({}, O.options, n.options),
      data: Object.assign({}, O.data, n.data)
    }) : n, i;
  }, {});
  return Object.keys(e).map(function(i) {
    return e[i];
  });
}
var Sb = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var OB = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var Pb = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function yb() {
  for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)
    e[i] = arguments[i];
  return !e.some(function(n) {
    return !(n && typeof n.getBoundingClientRect == "function");
  });
}
function rB(t) {
  t === void 0 && (t = {});
  var e = t, i = e.defaultModifiers, n = i === void 0 ? [] : i, O = e.defaultOptions, r = O === void 0 ? Pb : O;
  return function(o, s, l) {
    l === void 0 && (l = r);
    var c = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, Pb, r),
      modifiersData: {},
      elements: {
        reference: o,
        popper: s
      },
      attributes: {},
      styles: {}
    }, u = [], h10 = false, d = {
      state: c,
      setOptions: function(Q) {
        var m = typeof Q == "function" ? Q(c.options) : Q;
        $(), c.options = Object.assign({}, r, c.options, m), c.scrollParents = {
          reference: ur(o) ? Co(o) : o.contextElement ? Co(o.contextElement) : [],
          popper: Co(s)
        };
        var b = KN(nB([].concat(n, c.options.modifiers)));
        if (c.orderedModifiers = b.filter(function(k) {
          return k.enabled;
        }), true) {
          var P = iB([].concat(b, c.options.modifiers), function(k) {
            var Y = k.name;
            return Y;
          });
          if (tB(P), tn(c.options.placement) === Cu) {
            var S = c.orderedModifiers.find(function(k) {
              var Y = k.name;
              return Y === "flip";
            });
            S || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
          }
          var y = nn(s), v = y.marginTop, T = y.marginRight, _ = y.marginBottom, x = y.marginLeft;
          [v, T, _, x].some(function(k) {
            return parseFloat(k);
          }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
        }
        return p(), d.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!h10) {
          var Q = c.elements, m = Q.reference, b = Q.popper;
          if (!yb(m, b)) {
            console.error(Sb);
            return;
          }
          c.rects = {
            reference: FN(m, Us(b), c.options.strategy === "fixed"),
            popper: OQ(b)
          }, c.reset = false, c.placement = c.options.placement, c.orderedModifiers.forEach(function(k) {
            return c.modifiersData[k.name] = Object.assign({}, k.data);
          });
          for (var P = 0, S = 0; S < c.orderedModifiers.length; S++) {
            if (P += 1, P > 100) {
              console.error(OB);
              break;
            }
            if (c.reset === true) {
              c.reset = false, S = -1;
              continue;
            }
            var y = c.orderedModifiers[S], v = y.fn, T = y.options, _ = T === void 0 ? {} : T, x = y.name;
            typeof v == "function" && (c = v({
              state: c,
              options: _,
              name: x,
              instance: d
            }) || c);
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: JN(function() {
        return new Promise(function(g) {
          d.forceUpdate(), g(c);
        });
      }),
      destroy: function() {
        $(), h10 = true;
      }
    };
    if (!yb(o, s))
      return console.error(Sb), d;
    d.setOptions(l).then(function(g) {
      !h10 && l.onFirstUpdate && l.onFirstUpdate(g);
    });
    function p() {
      c.orderedModifiers.forEach(function(g) {
        var Q = g.name, m = g.options, b = m === void 0 ? {} : m, P = g.effect;
        if (typeof P == "function") {
          var S = P({
            state: c,
            name: Q,
            instance: d,
            options: b
          }), y = function() {
          };
          u.push(S || y);
        }
      });
    }
    function $() {
      u.forEach(function(g) {
        return g();
      }), u = [];
    }
    return d;
  };
}
var aB = [XN, AN, bN, fN, jN, VN, DN, mN, zN];
var oB = rB({
  defaultModifiers: aB
});
var mr = mr || {};
mr.stringify = function() {
  var t = {
    "visit_linear-gradient": function(e) {
      return t.visit_gradient(e);
    },
    "visit_repeating-linear-gradient": function(e) {
      return t.visit_gradient(e);
    },
    "visit_radial-gradient": function(e) {
      return t.visit_gradient(e);
    },
    "visit_repeating-radial-gradient": function(e) {
      return t.visit_gradient(e);
    },
    visit_gradient: function(e) {
      var i = t.visit(e.orientation);
      return i && (i += ", "), e.type + "(" + i + t.visit(e.colorStops) + ")";
    },
    visit_shape: function(e) {
      var i = e.value, n = t.visit(e.at), O = t.visit(e.style);
      return O && (i += " " + O), n && (i += " at " + n), i;
    },
    "visit_default-radial": function(e) {
      var i = "", n = t.visit(e.at);
      return n && (i += n), i;
    },
    "visit_extent-keyword": function(e) {
      var i = e.value, n = t.visit(e.at);
      return n && (i += " at " + n), i;
    },
    "visit_position-keyword": function(e) {
      return e.value;
    },
    visit_position: function(e) {
      return t.visit(e.value.x) + " " + t.visit(e.value.y);
    },
    "visit_%": function(e) {
      return e.value + "%";
    },
    visit_em: function(e) {
      return e.value + "em";
    },
    visit_px: function(e) {
      return e.value + "px";
    },
    visit_literal: function(e) {
      return t.visit_color(e.value, e);
    },
    visit_hex: function(e) {
      return t.visit_color("#" + e.value, e);
    },
    visit_rgb: function(e) {
      return t.visit_color("rgb(" + e.value.join(", ") + ")", e);
    },
    visit_rgba: function(e) {
      return t.visit_color("rgba(" + e.value.join(", ") + ")", e);
    },
    visit_color: function(e, i) {
      var n = e, O = t.visit(i.length);
      return O && (n += " " + O), n;
    },
    visit_angular: function(e) {
      return e.value + "deg";
    },
    visit_directional: function(e) {
      return "to " + e.value;
    },
    visit_array: function(e) {
      var i = "", n = e.length;
      return e.forEach(function(O, r) {
        i += t.visit(O), r < n - 1 && (i += ", ");
      }), i;
    },
    visit: function(e) {
      if (!e)
        return "";
      var i = "";
      if (e instanceof Array)
        return t.visit_array(e, i);
      if (e.type) {
        var n = t["visit_" + e.type];
        if (n)
          return n(e);
        throw Error("Missing visitor visit_" + e.type);
      } else
        throw Error("Invalid node.");
    }
  };
  return function(e) {
    return t.visit(e);
  };
}();
var mr = mr || {};
mr.parse = function() {
  var t = {
    linearGradient: /^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i,
    repeatingLinearGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i,
    radialGradient: /^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i,
    repeatingRadialGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /^\#([0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^rgb/i,
    rgbaColor: /^rgba/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  }, e = "";
  function i(C) {
    var M = new Error(e + ": " + C);
    throw M.source = e, M;
  }
  function n() {
    var C = O();
    return e.length > 0 && i("Invalid input not EOF"), C;
  }
  function O() {
    return b(r);
  }
  function r() {
    return a(
      "linear-gradient",
      t.linearGradient,
      s
    ) || a(
      "repeating-linear-gradient",
      t.repeatingLinearGradient,
      s
    ) || a(
      "radial-gradient",
      t.radialGradient,
      u
    ) || a(
      "repeating-radial-gradient",
      t.repeatingRadialGradient,
      u
    );
  }
  function a(C, M, H) {
    return o(M, function(xe) {
      var Fe = H();
      return Fe && (ae(t.comma) || i("Missing comma before color stops")), {
        type: C,
        orientation: Fe,
        colorStops: b(P)
      };
    });
  }
  function o(C, M) {
    var H = ae(C);
    if (H) {
      ae(t.startCall) || i("Missing (");
      var xe = M(H);
      return ae(t.endCall) || i("Missing )"), xe;
    }
  }
  function s() {
    return l() || c();
  }
  function l() {
    return L("directional", t.sideOrCorner, 1);
  }
  function c() {
    return L("angular", t.angleValue, 1);
  }
  function u() {
    var C, M = h10(), H;
    return M && (C = [], C.push(M), H = e, ae(t.comma) && (M = h10(), M ? C.push(M) : e = H)), C;
  }
  function h10() {
    var C = d() || p();
    if (C)
      C.at = g();
    else {
      var M = $();
      if (M) {
        C = M;
        var H = g();
        H && (C.at = H);
      } else {
        var xe = Q();
        xe && (C = {
          type: "default-radial",
          at: xe
        });
      }
    }
    return C;
  }
  function d() {
    var C = L("shape", /^(circle)/i, 0);
    return C && (C.style = Z() || $()), C;
  }
  function p() {
    var C = L("shape", /^(ellipse)/i, 0);
    return C && (C.style = k() || $()), C;
  }
  function $() {
    return L("extent-keyword", t.extentKeywords, 1);
  }
  function g() {
    if (L("position", /^at/, 0)) {
      var C = Q();
      return C || i("Missing positioning value"), C;
    }
  }
  function Q() {
    var C = m();
    if (C.x || C.y)
      return {
        type: "position",
        value: C
      };
  }
  function m() {
    return {
      x: k(),
      y: k()
    };
  }
  function b(C) {
    var M = C(), H = [];
    if (M)
      for (H.push(M); ae(t.comma); )
        M = C(), M ? H.push(M) : i("One extra comma");
    return H;
  }
  function P() {
    var C = S();
    return C || i("Expected color definition"), C.length = k(), C;
  }
  function S() {
    return v() || _() || T() || y();
  }
  function y() {
    return L("literal", t.literalColor, 0);
  }
  function v() {
    return L("hex", t.hexColor, 1);
  }
  function T() {
    return o(t.rgbColor, function() {
      return {
        type: "rgb",
        value: b(x)
      };
    });
  }
  function _() {
    return o(t.rgbaColor, function() {
      return {
        type: "rgba",
        value: b(x)
      };
    });
  }
  function x() {
    return ae(t.number)[1];
  }
  function k() {
    return L("%", t.percentageValue, 1) || Y() || Z();
  }
  function Y() {
    return L("position-keyword", t.positionKeywords, 1);
  }
  function Z() {
    return L("px", t.pixelValue, 1) || L("em", t.emValue, 1);
  }
  function L(C, M, H) {
    var xe = ae(M);
    if (xe)
      return {
        type: C,
        value: xe[H]
      };
  }
  function ae(C) {
    var M, H;
    return H = /^[\n\r\t\s]+/.exec(e), H && Oe(H[0].length), M = C.exec(e), M && Oe(M[0].length), M;
  }
  function Oe(C) {
    e = e.substr(C);
  }
  return function(C) {
    return e = C.toString(), n();
  };
}();
var sB = mr.parse;
var lB = mr.stringify;
var cB = Object.defineProperty;
var uB = (t, e, i) => e in t ? cB(t, e, { enumerable: true, configurable: true, writable: true, value: i }) : t[e] = i;
var _t = (t, e, i) => (uB(t, typeof e != "symbol" ? e + "" : e, i), i);
var Je = (t) => Math.round(t * 100) / 100;
var He = class {
  constructor(e) {
    _t(this, "instance"), _t(this, "alphaValue", 0), _t(this, "redValue", 0), _t(this, "greenValue", 0), _t(this, "blueValue", 0), _t(this, "hueValue", 0), _t(this, "saturationValue", 0), _t(this, "brightnessValue", 0), _t(this, "hslSaturationValue", 0), _t(this, "lightnessValue", 0), _t(this, "initAlpha", () => {
      const i = this.instance.getAlpha();
      this.alphaValue = Math.min(1, i) * 100;
    }), _t(this, "initLightness", () => {
      const { s: i, l: n } = this.instance.toHsl();
      this.hslSaturationValue = Je(i), this.lightnessValue = Je(n);
    }), _t(this, "initRgb", () => {
      const { r: i, g: n, b: O } = this.instance.toRgb();
      this.redValue = Je(i), this.greenValue = Je(n), this.blueValue = Je(O);
    }), _t(this, "initHsb", () => {
      const { h: i, s: n, v: O } = this.instance.toHsv();
      this.hueValue = Math.min(360, Math.ceil(i)), this.saturationValue = Je(n), this.brightnessValue = Je(O);
    }), _t(this, "toHexString", () => this.instance.toHexString()), _t(this, "toRgbString", () => this.instance.toRgbString()), this.instance = A(e), this.initRgb(), this.initHsb(), this.initLightness(), this.initAlpha();
  }
  toString(e) {
    return this.instance.toString(e);
  }
  get hex() {
    return this.instance.toHex();
  }
  set hex(e) {
    this.instance = A(e), this.initHsb(), this.initRgb(), this.initAlpha(), this.initLightness();
  }
  // 色调
  set hue(e) {
    this.saturation === 0 && this.brightness === 0 && (this.saturationValue = 1, this.brightnessValue = 1), this.instance = A({
      h: Je(e),
      s: this.saturation,
      v: this.brightness,
      a: this.alphaValue / 100
    }), this.initRgb(), this.initLightness(), this.hueValue = Je(e);
  }
  get hue() {
    return this.hueValue;
  }
  // 饱和度
  set saturation(e) {
    this.instance = A({
      h: this.hue,
      s: Je(e),
      v: this.brightness,
      a: this.alphaValue / 100
    }), this.initRgb(), this.initLightness(), this.saturationValue = Je(e);
  }
  get saturation() {
    return this.saturationValue;
  }
  // 明度
  set brightness(e) {
    this.instance = A({
      h: this.hue,
      s: this.saturation,
      v: Je(e),
      a: this.alphaValue / 100
    }), this.initRgb(), this.initLightness(), this.brightnessValue = Je(e);
  }
  get brightness() {
    return this.brightnessValue;
  }
  // 亮度
  set lightness(e) {
    this.instance = A({
      h: this.hue,
      s: this.hslSaturationValue,
      l: Je(e),
      a: this.alphaValue / 100
    }), this.initRgb(), this.initHsb(), this.lightnessValue = Je(e);
  }
  get lightness() {
    return this.lightnessValue;
  }
  // red
  set red(e) {
    const i = this.instance.toRgb();
    this.instance = A({
      ...i,
      r: Je(e),
      a: this.alphaValue / 100
    }), this.initHsb(), this.initLightness(), this.redValue = Je(e);
  }
  get red() {
    return this.redValue;
  }
  // green
  set green(e) {
    const i = this.instance.toRgb();
    this.instance = A({
      ...i,
      g: Je(e),
      a: this.alphaValue / 100
    }), this.initHsb(), this.initLightness(), this.greenValue = Je(e);
  }
  get green() {
    return this.greenValue;
  }
  // blue
  set blue(e) {
    const i = this.instance.toRgb();
    this.instance = A({
      ...i,
      b: Je(e),
      a: this.alphaValue / 100
    }), this.initHsb(), this.initLightness(), this.blueValue = Je(e);
  }
  get blue() {
    return this.blueValue;
  }
  // alpha
  set alpha(e) {
    this.instance.setAlpha(e / 100), this.alphaValue = e;
  }
  get alpha() {
    return this.alphaValue;
  }
  get RGB() {
    return [this.red, this.green, this.blue, this.alpha / 100];
  }
  get HSB() {
    return [this.hue, this.saturation, this.brightness, this.alpha / 100];
  }
  get HSL() {
    return [this.hue, this.hslSaturationValue, this.lightness, this.alpha / 100];
  }
};
function bb(t, e, i, n) {
  return `rgba(${[t, e, i, n / 100].join(",")})`;
}
var uh = (t, e, i) => e < i ? t < e ? e : t > i ? i : t : t < i ? i : t > e ? e : t;
var lQ = "color-history";
var cQ = 8;
var Ii = (t, e) => {
  const i = t.__vccOpts || t;
  for (const [n, O] of e)
    i[n] = O;
  return i;
};
var fB = defineComponent({
  name: "Alpha",
  props: {
    color: he.instanceOf(He),
    size: he.oneOf(["small", "default"]).def("default")
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const i = ref(null), n = ref(null);
    let O = t.color || new He();
    const r = reactive({
      red: O.red,
      green: O.green,
      blue: O.blue,
      alpha: O.alpha
    });
    watch(
      () => t.color,
      (u) => {
        u && (O = u, zu(r, {
          red: u.red,
          green: u.green,
          blue: u.blue,
          alpha: u.alpha
        }));
      },
      { deep: true }
    );
    const a = computed(() => {
      const u = bb(r.red, r.green, r.blue, 0), h10 = bb(r.red, r.green, r.blue, 100);
      return {
        background: `linear-gradient(to right, ${u} , ${h10})`
      };
    }), o = () => {
      if (i.value && n.value) {
        const u = r.alpha / 100, h10 = i.value.getBoundingClientRect(), d = n.value.offsetWidth;
        return Math.round(u * (h10.width - d) + d / 2);
      }
      return 0;
    }, s = computed(() => ({
      left: o() + "px",
      top: 0
    })), l = (u) => {
      u.target !== i.value && c(u);
    }, c = (u) => {
      if (u.stopPropagation(), i.value && n.value) {
        const h10 = i.value.getBoundingClientRect(), d = n.value.offsetWidth;
        let p = u.clientX - h10.left;
        p = Math.max(d / 2, p), p = Math.min(p, h10.width - d / 2);
        const $ = Math.round((p - d / 2) / (h10.width - d) * 100);
        O.alpha = $, r.alpha = $, e("change", $);
      }
    };
    return dr(() => {
      const u = {
        drag: (h10) => {
          c(h10);
        },
        end: (h10) => {
          c(h10);
        }
      };
      i.value && n.value && ya.triggerDragEvent(i.value, u);
    }), { barElement: i, cursorElement: n, getCursorStyle: s, getBackgroundStyle: a, onClickSider: l };
  }
});
var hB = (t) => (pushScopeId("data-v-18925ba6"), t = t(), popScopeId(), t);
var dB = hB(() => createBaseVNode("div", { class: "vc-alpha-slider__bar-handle" }, null, -1));
var pB = [
  dB
];
function $B(t, e, i, n, O, r) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-alpha-slider", "transparent", { "small-slider": t.size === "small" }])
  }, [
    createBaseVNode("div", {
      ref: "barElement",
      class: "vc-alpha-slider__bar",
      style: normalizeStyle(t.getBackgroundStyle),
      onClick: e[0] || (e[0] = (...a) => t.onClickSider && t.onClickSider(...a))
    }, [
      createBaseVNode("div", {
        class: normalizeClass(["vc-alpha-slider__bar-pointer", { "small-bar": t.size === "small" }]),
        ref: "cursorElement",
        style: normalizeStyle(t.getCursorStyle)
      }, pB, 6)
    ], 4)
  ], 2);
}
var uQ = Ii(fB, [["render", $B], ["__scopeId", "data-v-18925ba6"]]);
var QB = [
  // 第一行
  [
    "#fcc02e",
    "#f67c01",
    "#e64a19",
    "#d81b43",
    "#8e24aa",
    "#512da7",
    "#1f87e8",
    "#008781",
    "#05a045"
  ],
  // 第二行
  [
    "#fed835",
    "#fb8c00",
    "#f5511e",
    "#eb1d4e",
    "#9c28b1",
    "#5d35b0",
    "#2097f3",
    "#029688",
    "#4cb050"
  ],
  // 第三行
  [
    "#ffeb3c",
    "#ffa727",
    "#fe5722",
    "#eb4165",
    "#aa47bc",
    "#673bb7",
    "#42a5f6",
    "#26a59a",
    "#83c683"
  ],
  // 第四行
  [
    "#fff176",
    "#ffb74e",
    "#ff8a66",
    "#f1627e",
    "#b968c7",
    "#7986cc",
    "#64b5f6",
    "#80cbc4",
    "#a5d6a7"
  ],
  // 第五行
  [
    "#fff59c",
    "#ffcc80",
    "#ffab91",
    "#fb879e",
    "#cf93d9",
    "#9ea8db",
    "#90caf8",
    "#b2dfdc",
    "#c8e6ca"
  ],
  // 最后一行
  [
    "transparent",
    "#ffffff",
    "#dedede",
    "#a9a9a9",
    "#4b4b4b",
    "#353535",
    "#212121",
    "#000000",
    "advance"
  ]
];
var gB = defineComponent({
  name: "Palette",
  emits: ["change"],
  setup(t, { emit: e }) {
    return { palettes: QB, computedBgStyle: (i) => i === "transparent" ? i : i === "advance" ? {} : { background: A(i).toRgbString() }, onColorChange: (i) => {
      e("change", i);
    } };
  }
});
var mB = { class: "vc-compact" };
var SB = ["onClick"];
function PB(t, e, i, n, O, r) {
  return openBlock(), createElementBlock("div", mB, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(t.palettes, (a, o) => (openBlock(), createElementBlock("div", {
      key: o,
      class: "vc-compact__row"
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(a, (s, l) => (openBlock(), createElementBlock("div", {
        key: l,
        class: "vc-compact__color-cube--wrap",
        onClick: (c) => t.onColorChange(s)
      }, [
        createBaseVNode("div", {
          class: normalizeClass([
            "vc-compact__color_cube",
            {
              advance: s === "advance",
              transparent: s === "transparent"
            }
          ]),
          style: normalizeStyle(t.computedBgStyle(s))
        }, null, 6)
      ], 8, SB))), 128))
    ]))), 128))
  ]);
}
var XT = Ii(gB, [["render", PB], ["__scopeId", "data-v-b969fd48"]]);
var yB = defineComponent({
  name: "Board",
  props: {
    color: he.instanceOf(He),
    round: he.bool.def(false),
    hide: he.bool.def(true)
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    var i, n, O;
    const r = getCurrentInstance(), a = {
      h: ((i = t.color) == null ? void 0 : i.hue) || 0,
      s: 1,
      v: 1
    }, o = new He(a).toHexString(), s = reactive({
      hueColor: o,
      saturation: ((n = t.color) == null ? void 0 : n.saturation) || 0,
      brightness: ((O = t.color) == null ? void 0 : O.brightness) || 0
    }), l = ref(0), c = ref(0), u = ref(), h10 = ref(), d = computed(() => ({
      top: l.value + "px",
      left: c.value + "px"
    })), p = () => {
      if (r) {
        const Q = r.vnode.el;
        c.value = s.saturation * (Q == null ? void 0 : Q.clientWidth), l.value = (1 - s.brightness) * (Q == null ? void 0 : Q.clientHeight);
      }
    }, $ = (Q) => {
      Q.target !== h10.value && g(Q);
    }, g = (Q) => {
      if (r) {
        const m = r.vnode.el, b = m == null ? void 0 : m.getBoundingClientRect();
        let P = Q.clientX - b.left, S = Q.clientY - b.top;
        P = uh(P, 0, b.width), S = uh(S, 0, b.height);
        const y = P / b.width, v = uh(-(S / b.height) + 1, 0, 1);
        c.value = P, l.value = S, s.saturation = y, s.brightness = v, e("change", y, v);
      }
    };
    return dr(() => {
      r && r.vnode.el && u.value && (ya.triggerDragEvent(u.value, {
        drag: (Q) => {
          g(Q);
        },
        end: (Q) => {
          g(Q);
        }
      }), p());
    }), Rt(
      () => t.color,
      (Q) => {
        zu(s, {
          hueColor: new He({ h: Q.hue, s: 1, v: 1 }).toHexString(),
          saturation: Q.saturation,
          brightness: Q.brightness
        }), p();
      },
      { deep: true }
    ), { state: s, cursorElement: u, getCursorStyle: d, onClickBoard: $ };
  }
});
var fQ = (t) => (pushScopeId("data-v-63803390"), t = t(), popScopeId(), t);
var bB = fQ(() => createBaseVNode("div", { class: "vc-saturation__white" }, null, -1));
var vB = fQ(() => createBaseVNode("div", { class: "vc-saturation__black" }, null, -1));
var XB = fQ(() => createBaseVNode("div", null, null, -1));
var xB = [
  XB
];
function wB(t, e, i, n, O, r) {
  return openBlock(), createElementBlock("div", {
    ref: "boardElement",
    class: normalizeClass(["vc-saturation", { "vc-saturation__chrome": t.round, "vc-saturation__hidden": t.hide }]),
    style: normalizeStyle({ backgroundColor: t.state.hueColor }),
    onClick: e[0] || (e[0] = (...a) => t.onClickBoard && t.onClickBoard(...a))
  }, [
    bB,
    vB,
    createBaseVNode("div", {
      class: "vc-saturation__cursor",
      ref: "cursorElement",
      style: normalizeStyle(t.getCursorStyle)
    }, xB, 4)
  ], 6);
}
var hQ = Ii(yB, [["render", wB], ["__scopeId", "data-v-63803390"]]);
var TB = defineComponent({
  name: "Hue",
  props: {
    color: he.instanceOf(He),
    size: he.oneOf(["small", "default"]).def("default")
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const i = ref(null), n = ref(null);
    let O = t.color || new He();
    const r = reactive({
      hue: O.hue || 0
    });
    watch(
      () => t.color,
      (c) => {
        c && (O = c, zu(r, { hue: O.hue }));
      },
      { deep: true }
    );
    const a = () => {
      if (i.value && n.value) {
        const c = i.value.getBoundingClientRect(), u = n.value.offsetWidth;
        return r.hue === 360 ? c.width - u / 2 : r.hue % 360 * (c.width - u) / 360 + u / 2;
      }
      return 0;
    }, o = computed(() => ({
      left: a() + "px",
      top: 0
    })), s = (c) => {
      c.target !== i.value && l(c);
    }, l = (c) => {
      if (c.stopPropagation(), i.value && n.value) {
        const u = i.value.getBoundingClientRect(), h10 = n.value.offsetWidth;
        let d = c.clientX - u.left;
        d = Math.min(d, u.width - h10 / 2), d = Math.max(h10 / 2, d);
        const p = Math.round((d - h10 / 2) / (u.width - h10) * 360);
        O.hue = p, r.hue = p, e("change", p);
      }
    };
    return dr(() => {
      const c = {
        drag: (u) => {
          l(u);
        },
        end: (u) => {
          l(u);
        }
      };
      i.value && n.value && ya.triggerDragEvent(i.value, c);
    }), { barElement: i, cursorElement: n, getCursorStyle: o, onClickSider: s };
  }
});
var kB = (t) => (pushScopeId("data-v-5c4cae5b"), t = t(), popScopeId(), t);
var _B = kB(() => createBaseVNode("div", { class: "vc-hue-slider__bar-handle" }, null, -1));
var WB = [
  _B
];
function YB(t, e, i, n, O, r) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-hue-slider", { "small-slider": t.size === "small" }])
  }, [
    createBaseVNode("div", {
      ref: "barElement",
      class: "vc-hue-slider__bar",
      onClick: e[0] || (e[0] = (...a) => t.onClickSider && t.onClickSider(...a))
    }, [
      createBaseVNode("div", {
        class: normalizeClass(["vc-hue-slider__bar-pointer", { "small-bar": t.size === "small" }]),
        ref: "cursorElement",
        style: normalizeStyle(t.getCursorStyle)
      }, WB, 6)
    ], 512)
  ], 2);
}
var dQ = Ii(TB, [["render", YB], ["__scopeId", "data-v-5c4cae5b"]]);
var RB = defineComponent({
  name: "Lightness",
  props: {
    color: he.instanceOf(He),
    size: he.oneOf(["small", "default"]).def("default")
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const i = ref(null), n = ref(null);
    let O = t.color || new He();
    const [r, a, o] = O.HSL, s = reactive({
      hue: r,
      saturation: a,
      lightness: o
    });
    watch(
      () => t.color,
      (p) => {
        if (p) {
          O = p;
          const [$, g, Q] = O.HSL;
          zu(s, {
            hue: $,
            saturation: g,
            lightness: Q
          });
        }
      },
      { deep: true }
    );
    const l = computed(() => {
      const p = A({
        h: s.hue,
        s: s.saturation,
        l: 0.8
      }).toPercentageRgbString(), $ = A({
        h: s.hue,
        s: s.saturation,
        l: 0.6
      }).toPercentageRgbString(), g = A({
        h: s.hue,
        s: s.saturation,
        l: 0.4
      }).toPercentageRgbString(), Q = A({
        h: s.hue,
        s: s.saturation,
        l: 0.2
      }).toPercentageRgbString();
      return {
        background: [
          `-webkit-linear-gradient(left, rgb(255, 255, 255), ${p}, ${$}, ${g}, ${Q}, rgb(0, 0, 0))`,
          `-moz-linear-gradient(left, rgb(255, 255, 255), ${p}, ${$}, ${g}, ${Q}, rgb(0, 0, 0))`,
          `-ms-linear-gradient(left, rgb(255, 255, 255), ${p}, ${$}, ${g}, ${Q}, rgb(0, 0, 0))`
        ]
      };
    }), c = () => {
      if (i.value && n.value) {
        const p = s.lightness, $ = i.value.getBoundingClientRect(), g = n.value.offsetWidth;
        return (1 - p) * ($.width - g) + g / 2;
      }
      return 0;
    }, u = computed(() => ({
      left: c() + "px",
      top: 0
    })), h10 = (p) => {
      p.target !== i.value && d(p);
    }, d = (p) => {
      if (p.stopPropagation(), i.value && n.value) {
        const $ = i.value.getBoundingClientRect(), g = n.value.offsetWidth;
        let Q = p.clientX - $.left;
        Q = Math.max(g / 2, Q), Q = Math.min(Q, $.width - g / 2);
        const m = 1 - (Q - g / 2) / ($.width - g);
        O.lightness = m, e("change", m);
      }
    };
    return dr(() => {
      const p = {
        drag: ($) => {
          d($);
        },
        end: ($) => {
          d($);
        }
      };
      i.value && n.value && ya.triggerDragEvent(i.value, p);
    }), { barElement: i, cursorElement: n, getCursorStyle: u, getBackgroundStyle: l, onClickSider: h10 };
  }
});
var ZB = (t) => (pushScopeId("data-v-6156acb7"), t = t(), popScopeId(), t);
var UB = ZB(() => createBaseVNode("div", { class: "vc-lightness-slider__bar-handle" }, null, -1));
var VB = [
  UB
];
function qB(t, e, i, n, O, r) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-lightness-slider", { "small-slider": t.size === "small" }])
  }, [
    createBaseVNode("div", {
      ref: "barElement",
      class: "vc-lightness-slider__bar",
      style: normalizeStyle(t.getBackgroundStyle),
      onClick: e[0] || (e[0] = (...a) => t.onClickSider && t.onClickSider(...a))
    }, [
      createBaseVNode("div", {
        class: normalizeClass(["vc-lightness-slider__bar-pointer", { "small-bar": t.size === "small" }]),
        ref: "cursorElement",
        style: normalizeStyle(t.getCursorStyle)
      }, VB, 6)
    ], 4)
  ], 2);
}
var xT = Ii(RB, [["render", qB], ["__scopeId", "data-v-6156acb7"]]);
var zB = defineComponent({
  name: "History",
  props: {
    colors: he.arrayOf(String).def(() => []),
    round: he.bool.def(false)
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    return { onColorSelect: (i) => {
      e("change", i);
    } };
  }
});
var CB = {
  key: 0,
  class: "vc-colorPicker__record"
};
var EB = { class: "color-list" };
var jB = ["onClick"];
function IB(t, e, i, n, O, r) {
  return t.colors && t.colors.length > 0 ? (openBlock(), createElementBlock("div", CB, [
    createBaseVNode("div", EB, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(t.colors, (a, o) => (openBlock(), createElementBlock("div", {
        key: o,
        class: normalizeClass(["color-item", "transparent", { "color-item__round": t.round }]),
        onClick: (s) => t.onColorSelect(a)
      }, [
        createBaseVNode("div", {
          class: "color-item__display",
          style: normalizeStyle({ backgroundColor: a })
        }, null, 4)
      ], 10, jB))), 128))
    ])
  ])) : createCommentVNode("", true);
}
var pQ = Ii(zB, [["render", IB], ["__scopeId", "data-v-7e6b67ca"]]);
var AB = defineComponent({
  name: "Display",
  props: {
    color: he.instanceOf(He),
    disableAlpha: he.bool.def(false)
  },
  emits: ["update:color", "change"],
  setup(t, { emit: e }) {
    var i, n, O;
    const r = reactive({
      color: t.color,
      hex: (i = t.color) == null ? void 0 : i.hex,
      alpha: ((n = t.color) == null ? void 0 : n.alpha) + "%",
      previewBgColor: (O = t.color) == null ? void 0 : O.toRgbString()
    }), a = computed(() => ({
      background: r.previewBgColor
    })), o = rr((l) => {
      if (!l.target.value)
        return;
      const c = parseInt(l.target.value.replace("%", ""));
      !isNaN(c) && r.color && (r.color.alpha = c), e("update:color", r.color), e("change", r.color);
    }, 300), s = rr((l) => {
      if (!l.target.value)
        return;
      const c = l.target.value.replace("#", "");
      A(c).isValid() && r.color && (r.color.hex = c), e("update:color", r.color), e("change", r.color);
    }, 300);
    return Rt(
      () => t.color,
      (l) => {
        l && (r.color = l, r.alpha = r.color.alpha + "%", r.hex = r.color.hex);
      },
      { deep: true }
    ), Rt(
      () => r.color,
      () => {
        r.color && (r.previewBgColor = r.color.toRgbString());
      },
      { deep: true }
    ), { state: r, getBgColorStyle: a, onAlphaBlur: o, onInputChange: s };
  }
});
var GB = { class: "vc-display" };
var LB = { class: "vc-current-color vc-transparent" };
var DB = { class: "vc-color-input" };
var MB = ["value"];
var NB = {
  key: 0,
  class: "vc-alpha-input"
};
var BB = ["value"];
function FB(t, e, i, n, O, r) {
  return openBlock(), createElementBlock("div", GB, [
    createBaseVNode("div", LB, [
      createBaseVNode("div", {
        class: "color-cube",
        style: normalizeStyle(t.getBgColorStyle)
      }, null, 4)
    ]),
    createBaseVNode("div", DB, [
      createBaseVNode("input", {
        value: t.state.hex,
        onInput: e[0] || (e[0] = (...a) => t.onInputChange && t.onInputChange(...a))
      }, null, 40, MB)
    ]),
    t.disableAlpha ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", NB, [
      createBaseVNode("input", {
        class: "vc-alpha-input__inner",
        value: t.state.alpha,
        onInput: e[1] || (e[1] = (...a) => t.onAlphaBlur && t.onAlphaBlur(...a))
      }, null, 40, BB)
    ]))
  ]);
}
var $Q = Ii(AB, [["render", FB], ["__scopeId", "data-v-ffdc53e2"]]);
var HB = defineComponent({
  name: "FkColorPicker",
  components: { Display: $Q, Alpha: uQ, Palette: XT, Board: hQ, Hue: dQ, Lightness: xT, History: pQ },
  props: {
    color: he.instanceOf(He),
    disableHistory: he.bool.def(false),
    roundHistory: he.bool.def(false),
    disableAlpha: he.bool.def(false)
  },
  emits: ["update:color", "change", "advanceChange"],
  setup(t, { emit: e }) {
    const i = t.color || new He(), n = reactive({
      color: i,
      hex: i.toHexString(),
      rgb: i.toRgbString()
    }), O = ref(false), r = computed(() => ({ background: n.rgb })), a = () => {
      O.value = false, e("advanceChange", false);
    }, o = U$(lQ, [], {}), s = rr(() => {
      if (t.disableHistory)
        return;
      const $ = n.color.toRgbString();
      if (o.value = o.value.filter((g) => !A.equals(g, $)), !o.value.includes($)) {
        for (; o.value.length > cQ; )
          o.value.pop();
        o.value.unshift($);
      }
    }, 500), l = ($) => {
      $ === "advance" ? (O.value = true, e("advanceChange", true)) : (n.color.hex = $, e("advanceChange", false));
    }, c = ($) => {
      n.color.alpha = $;
    }, u = ($) => {
      n.color.hue = $;
    }, h10 = ($, g) => {
      n.color.saturation = $, n.color.brightness = g;
    }, d = ($) => {
      n.color.lightness = $;
    }, p = ($) => {
      const g = $.target.value.replace("#", "");
      A(g).isValid() && (n.color.hex = g);
    };
    return Rt(
      () => t.color,
      ($) => {
        $ && (n.color = $);
      },
      { deep: true }
    ), Rt(
      () => n.color,
      () => {
        n.hex = n.color.hex, n.rgb = n.color.toRgbString(), s(), e("update:color", n.color), e("change", n.color);
      },
      { deep: true }
    ), {
      state: n,
      advancePanelShow: O,
      onBack: a,
      onCompactChange: l,
      onAlphaChange: c,
      onHueChange: u,
      onBoardChange: h10,
      onLightChange: d,
      onInputChange: p,
      previewStyle: r,
      historyColors: o
    };
  }
});
var KB = (t) => (pushScopeId("data-v-592a5ec3"), t = t(), popScopeId(), t);
var JB = { class: "vc-fk-colorPicker" };
var eF = { class: "vc-fk-colorPicker__inner" };
var tF = { class: "vc-fk-colorPicker__header" };
var iF = KB(() => createBaseVNode("div", { class: "back" }, null, -1));
var nF = [
  iF
];
function OF(t, e, i, n, O, r) {
  const a = resolveComponent("Palette"), o = resolveComponent("Board"), s = resolveComponent("Hue"), l = resolveComponent("Lightness"), c = resolveComponent("Alpha"), u = resolveComponent("Display"), h10 = resolveComponent("History");
  return openBlock(), createElementBlock("div", JB, [
    createBaseVNode("div", eF, [
      createBaseVNode("div", tF, [
        t.advancePanelShow ? (openBlock(), createElementBlock("span", {
          key: 0,
          style: { cursor: "pointer" },
          onClick: e[0] || (e[0] = (...d) => t.onBack && t.onBack(...d))
        }, nF)) : createCommentVNode("", true)
      ]),
      t.advancePanelShow ? createCommentVNode("", true) : (openBlock(), createBlock(a, {
        key: 0,
        onChange: t.onCompactChange
      }, null, 8, ["onChange"])),
      t.advancePanelShow ? (openBlock(), createBlock(o, {
        key: 1,
        color: t.state.color,
        onChange: t.onBoardChange
      }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
      t.advancePanelShow ? (openBlock(), createBlock(s, {
        key: 2,
        color: t.state.color,
        onChange: t.onHueChange
      }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
      t.advancePanelShow ? createCommentVNode("", true) : (openBlock(), createBlock(l, {
        key: 3,
        color: t.state.color,
        onChange: t.onLightChange
      }, null, 8, ["color", "onChange"])),
      t.disableAlpha ? createCommentVNode("", true) : (openBlock(), createBlock(c, {
        key: 4,
        color: t.state.color,
        onChange: t.onAlphaChange
      }, null, 8, ["color", "onChange"])),
      createVNode(u, {
        color: t.state.color,
        "disable-alpha": t.disableAlpha
      }, null, 8, ["color", "disable-alpha"]),
      t.disableHistory ? createCommentVNode("", true) : (openBlock(), createBlock(h10, {
        key: 5,
        round: t.roundHistory,
        colors: t.historyColors,
        onChange: t.onCompactChange
      }, null, 8, ["round", "colors", "onChange"]))
    ])
  ]);
}
var vb = Ii(HB, [["render", OF], ["__scopeId", "data-v-592a5ec3"]]);
var rF = defineComponent({
  name: "ChromeColorPicker",
  components: { Display: $Q, Alpha: uQ, Board: hQ, Hue: dQ, History: pQ },
  props: {
    color: he.instanceOf(He),
    disableHistory: he.bool.def(false),
    roundHistory: he.bool.def(false),
    disableAlpha: he.bool.def(false)
  },
  emits: ["update:color", "change"],
  setup(t, { emit: e }) {
    const i = t.color || new He(), n = reactive({
      color: i,
      hex: i.toHexString(),
      rgb: i.toRgbString()
    }), O = computed(() => ({ background: n.rgb })), r = U$(lQ, [], {}), a = rr(() => {
      if (t.disableHistory)
        return;
      const u = n.color.toRgbString();
      if (r.value = r.value.filter((h10) => !A.equals(h10, u)), !r.value.includes(u)) {
        for (; r.value.length > cQ; )
          r.value.pop();
        r.value.unshift(u);
      }
    }, 500), o = (u) => {
      n.color.alpha = u;
    }, s = (u) => {
      n.color.hue = u;
    }, l = (u, h10) => {
      n.color.saturation = u, n.color.brightness = h10;
    }, c = (u) => {
      u !== "advance" && (n.color.hex = u);
    };
    return Rt(
      () => t.color,
      (u) => {
        u && (n.color = u);
      },
      { deep: true }
    ), Rt(
      () => n.color,
      () => {
        n.hex = n.color.hex, n.rgb = n.color.toRgbString(), a(), e("update:color", n.color), e("change", n.color);
      },
      { deep: true }
    ), {
      state: n,
      previewStyle: O,
      historyColors: r,
      onAlphaChange: o,
      onHueChange: s,
      onBoardChange: l,
      onCompactChange: c
    };
  }
});
var aF = { class: "vc-chrome-colorPicker" };
var oF = { class: "vc-chrome-colorPicker-body" };
var sF = { class: "chrome-controls" };
var lF = { class: "chrome-color-wrap transparent" };
var cF = { class: "chrome-sliders" };
function uF(t, e, i, n, O, r) {
  const a = resolveComponent("Board"), o = resolveComponent("Hue"), s = resolveComponent("Alpha"), l = resolveComponent("Display"), c = resolveComponent("History");
  return openBlock(), createElementBlock("div", aF, [
    createVNode(a, {
      round: true,
      hide: false,
      color: t.state.color,
      onChange: t.onBoardChange
    }, null, 8, ["color", "onChange"]),
    createBaseVNode("div", oF, [
      createBaseVNode("div", sF, [
        createBaseVNode("div", lF, [
          createBaseVNode("div", {
            class: "current-color",
            style: normalizeStyle(t.previewStyle)
          }, null, 4)
        ]),
        createBaseVNode("div", cF, [
          createVNode(o, {
            size: "small",
            color: t.state.color,
            onChange: t.onHueChange
          }, null, 8, ["color", "onChange"]),
          t.disableAlpha ? createCommentVNode("", true) : (openBlock(), createBlock(s, {
            key: 0,
            size: "small",
            color: t.state.color,
            onChange: t.onAlphaChange
          }, null, 8, ["color", "onChange"]))
        ])
      ]),
      createVNode(l, {
        color: t.state.color,
        "disable-alpha": t.disableAlpha
      }, null, 8, ["color", "disable-alpha"]),
      t.disableHistory ? createCommentVNode("", true) : (openBlock(), createBlock(c, {
        key: 0,
        round: t.roundHistory,
        colors: t.historyColors,
        onChange: t.onCompactChange
      }, null, 8, ["round", "colors", "onChange"]))
    ])
  ]);
}
var Xb = Ii(rF, [["render", uF], ["__scopeId", "data-v-61d7303b"]]);
var QQ = "Vue3ColorPickerProvider";
var fF = defineComponent({
  name: "GradientColorPicker",
  components: { Angle: KM, Display: $Q, Alpha: uQ, Palette: XT, Board: hQ, Hue: dQ, Lightness: xT, History: pQ },
  props: {
    startColor: he.instanceOf(He).isRequired,
    endColor: he.instanceOf(He).isRequired,
    startColorStop: he.number.def(0),
    endColorStop: he.number.def(100),
    angle: he.number.def(0),
    disableHistory: he.bool.def(false),
    roundHistory: he.bool.def(false),
    disableAlpha: he.bool.def(false)
  },
  emits: [
    "update:startColor",
    "update:endColor",
    "update:angle",
    "update:startColorStop",
    "update:endColorStop",
    "startColorChange",
    "endColorChange",
    "advanceChange",
    "angleChange",
    "startColorStopChange",
    "endColorStopChange"
  ],
  setup(t, { emit: e }) {
    const i = reactive({
      startActive: true,
      startColor: t.startColor,
      endColor: t.endColor,
      startColorStop: t.startColorStop,
      endColorStop: t.endColorStop,
      angle: t.angle,
      // rgba
      startColorRgba: t.startColor.toRgbString(),
      endColorRgba: t.endColor.toRgbString()
    }), n = inject(QQ), O = ref(false), r = ref(), a = ref(), o = ref();
    watch(
      () => [t.startColor, t.endColor, t.angle],
      (x) => {
        i.startColor = x[0], i.endColor = x[1], i.angle = x[2];
      }
    );
    const s = computed({
      get: () => i.startActive ? i.startColor : i.endColor,
      set: (x) => {
        if (i.startActive) {
          i.startColor = x;
          return;
        }
        i.endColor = x;
      }
    }), l = computed(() => {
      if (o.value && r.value) {
        const x = i.startColorStop / 100, k = o.value.getBoundingClientRect(), Y = r.value.offsetWidth;
        return Math.round(x * (k.width - Y) + Y / 2);
      }
      return 0;
    }), c = computed(() => {
      if (o.value && a.value) {
        const x = i.endColorStop / 100, k = o.value.getBoundingClientRect(), Y = a.value.offsetWidth;
        return Math.round(x * (k.width - Y) + Y / 2);
      }
      return 0;
    }), u = computed(() => ({
      background: `linear-gradient(${i.angle}deg, ${i.startColorRgba} ${i.startColorStop}%, ${i.endColorRgba} ${i.endColorStop}%)`
    })), h10 = (x) => {
      var k;
      if (i.startActive = true, o.value && r.value) {
        const Y = (k = o.value) == null ? void 0 : k.getBoundingClientRect();
        let Z = x.clientX - Y.left;
        Z = Math.max(r.value.offsetWidth / 2, Z), Z = Math.min(Z, Y.width - r.value.offsetWidth / 2), i.startColorStop = Math.round(
          (Z - r.value.offsetWidth / 2) / (Y.width - r.value.offsetWidth) * 100
        ), e("update:startColorStop", i.startColorStop), e("startColorStopChange", i.startColorStop);
      }
    }, d = (x) => {
      var k;
      if (i.startActive = false, o.value && a.value) {
        const Y = (k = o.value) == null ? void 0 : k.getBoundingClientRect();
        let Z = x.clientX - Y.left;
        Z = Math.max(a.value.offsetWidth / 2, Z), Z = Math.min(Z, Y.width - a.value.offsetWidth / 2), i.endColorStop = Math.round(
          (Z - a.value.offsetWidth / 2) / (Y.width - a.value.offsetWidth) * 100
        ), e("update:endColorStop", i.endColorStop), e("endColorStopChange", i.endColorStop);
      }
    }, p = (x) => {
      const k = x.target, Y = parseInt(k.value.replace("°", ""));
      isNaN(Y) || (i.angle = Y % 360), e("update:angle", i.angle), e("angleChange", i.angle);
    }, $ = (x) => {
      i.angle = x, e("update:angle", i.angle), e("angleChange", i.angle);
    }, g = (x) => {
      x === "advance" ? (O.value = true, e("advanceChange", true)) : (s.value.hex = x, e("advanceChange", false)), y();
    }, Q = (x) => {
      s.value.alpha = x, y();
    }, m = (x) => {
      s.value.hue = x, y();
    }, b = (x, k) => {
      s.value.saturation = x, s.value.brightness = k, y();
    }, P = (x) => {
      s.value.lightness = x, y();
    }, S = () => {
      y();
    }, y = () => {
      i.startActive ? (e("update:startColor", i.startColor), e("startColorChange", i.startColor)) : (e("update:endColor", i.endColor), e("endColorChange", i.endColor));
    }, v = () => {
      O.value = false, e("advanceChange", false);
    }, T = U$(lQ, [], {}), _ = rr(() => {
      if (t.disableHistory)
        return;
      const x = s.value.toRgbString();
      if (T.value = T.value.filter((k) => !A.equals(k, x)), !T.value.includes(x)) {
        for (; T.value.length > cQ; )
          T.value.pop();
        T.value.unshift(x);
      }
    }, 500);
    return dr(() => {
      a.value && r.value && (ya.triggerDragEvent(a.value, {
        drag: (x) => {
          d(x);
        },
        end: (x) => {
          d(x);
        }
      }), ya.triggerDragEvent(r.value, {
        drag: (x) => {
          h10(x);
        },
        end: (x) => {
          h10(x);
        }
      }));
    }), Rt(
      () => i.startColor,
      (x) => {
        i.startColorRgba = x.toRgbString();
      },
      { deep: true }
    ), Rt(
      () => i.endColor,
      (x) => {
        i.endColorRgba = x.toRgbString();
      },
      { deep: true }
    ), Rt(
      () => s.value,
      () => {
        _();
      },
      { deep: true }
    ), {
      startGradientRef: r,
      stopGradientRef: a,
      colorRangeRef: o,
      state: i,
      currentColor: s,
      getStartColorLeft: l,
      getEndColorLeft: c,
      gradientBg: u,
      advancePanelShow: O,
      onDegreeBlur: p,
      onCompactChange: g,
      onAlphaChange: Q,
      onHueChange: m,
      onBoardChange: b,
      onLightChange: P,
      historyColors: T,
      onBack: v,
      onDegreeChange: $,
      onDisplayChange: S,
      lang: n == null ? void 0 : n.lang
    };
  }
});
var gQ = (t) => (pushScopeId("data-v-46339c64"), t = t(), popScopeId(), t);
var hF = { class: "vc-gradient-picker" };
var dF = { class: "vc-gradient-picker__header" };
var pF = gQ(() => createBaseVNode("div", { class: "back" }, null, -1));
var $F = [
  pF
];
var QF = { class: "vc-gradient-picker__body" };
var gF = {
  class: "vc-color-range",
  ref: "colorRangeRef"
};
var mF = { class: "vc-color-range__container" };
var SF = { class: "vc-gradient__stop__container" };
var PF = ["title"];
var yF = gQ(() => createBaseVNode("span", { class: "vc-gradient__stop--inner" }, null, -1));
var bF = [
  yF
];
var vF = ["title"];
var XF = gQ(() => createBaseVNode("span", { class: "vc-gradient__stop--inner" }, null, -1));
var xF = [
  XF
];
var wF = { class: "vc-picker-degree-input vc-degree-input" };
var TF = { class: "vc-degree-input__control" };
var kF = ["value"];
var _F = { class: "vc-degree-input__panel" };
var WF = { class: "vc-degree-input__disk" };
function YF(t, e, i, n, O, r) {
  const a = resolveComponent("Angle"), o = resolveComponent("Palette"), s = resolveComponent("Board"), l = resolveComponent("Hue"), c = resolveComponent("Lightness"), u = resolveComponent("Alpha"), h10 = resolveComponent("Display"), d = resolveComponent("History");
  return openBlock(), createElementBlock("div", hF, [
    withDirectives(createBaseVNode("div", dF, [
      createBaseVNode("span", {
        style: { cursor: "pointer" },
        onClick: e[0] || (e[0] = (...p) => t.onBack && t.onBack(...p))
      }, $F)
    ], 512), [
      [vShow, t.advancePanelShow]
    ]),
    createBaseVNode("div", QF, [
      createBaseVNode("div", gF, [
        createBaseVNode("div", mF, [
          createBaseVNode("div", {
            class: "vc-background",
            style: normalizeStyle(t.gradientBg)
          }, null, 4),
          createBaseVNode("div", SF, [
            createBaseVNode("div", {
              class: normalizeClass(["vc-gradient__stop", {
                "vc-gradient__stop--current": t.state.startActive
              }]),
              ref: "startGradientRef",
              title: t.lang === "ZH-cn" ? "开始" : "Start",
              style: normalizeStyle({ left: t.getStartColorLeft + "px" })
            }, bF, 14, PF),
            createBaseVNode("div", {
              class: normalizeClass(["vc-gradient__stop", {
                "vc-gradient__stop--current": !t.state.startActive
              }]),
              ref: "stopGradientRef",
              title: t.lang === "ZH-cn" ? "结束" : "End",
              style: normalizeStyle({ left: t.getEndColorLeft + "px" })
            }, xF, 14, vF)
          ])
        ])
      ], 512),
      createBaseVNode("div", wF, [
        createBaseVNode("div", TF, [
          createBaseVNode("input", {
            value: t.state.angle,
            onBlur: e[1] || (e[1] = (...p) => t.onDegreeBlur && t.onDegreeBlur(...p))
          }, null, 40, kF)
        ]),
        createBaseVNode("div", _F, [
          createBaseVNode("div", WF, [
            createVNode(a, {
              angle: t.state.angle,
              "onUpdate:angle": e[2] || (e[2] = (p) => t.state.angle = p),
              size: 40,
              onChange: t.onDegreeChange
            }, null, 8, ["angle", "onChange"])
          ])
        ])
      ])
    ]),
    t.advancePanelShow ? createCommentVNode("", true) : (openBlock(), createBlock(o, {
      key: 0,
      onChange: t.onCompactChange
    }, null, 8, ["onChange"])),
    t.advancePanelShow ? (openBlock(), createBlock(s, {
      key: 1,
      color: t.currentColor,
      onChange: t.onBoardChange
    }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
    t.advancePanelShow ? (openBlock(), createBlock(l, {
      key: 2,
      color: t.currentColor,
      onChange: t.onHueChange
    }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
    t.advancePanelShow ? createCommentVNode("", true) : (openBlock(), createBlock(c, {
      key: 3,
      color: t.currentColor,
      onChange: t.onLightChange
    }, null, 8, ["color", "onChange"])),
    t.disableAlpha ? createCommentVNode("", true) : (openBlock(), createBlock(u, {
      key: 4,
      color: t.currentColor,
      onChange: t.onAlphaChange
    }, null, 8, ["color", "onChange"])),
    createVNode(h10, {
      color: t.currentColor,
      "disable-alpha": t.disableAlpha,
      onChange: t.onDisplayChange
    }, null, 8, ["color", "disable-alpha", "onChange"]),
    t.disableHistory ? createCommentVNode("", true) : (openBlock(), createBlock(d, {
      key: 5,
      round: t.roundHistory,
      colors: t.historyColors,
      onChange: t.onCompactChange
    }, null, 8, ["round", "colors", "onChange"]))
  ]);
}
var xb = Ii(fF, [["render", YF], ["__scopeId", "data-v-46339c64"]]);
var RF = defineComponent({
  name: "WrapContainer",
  props: {
    showTab: he.bool.def(false),
    activeKey: he.oneOf(["pure", "gradient"]).def("pure")
  },
  emits: ["update:activeKey", "change"],
  setup(t, { emit: e }) {
    const i = reactive({
      activeKey: t.activeKey
    }), n = inject(QQ), O = (r) => {
      i.activeKey = r, e("update:activeKey", r), e("change", r);
    };
    return Rt(
      () => t.activeKey,
      (r) => {
        i.activeKey = r;
      }
    ), { state: i, onActiveKeyChange: O, lang: n == null ? void 0 : n.lang };
  }
});
var ZF = { class: "vc-colorpicker" };
var UF = { class: "vc-colorpicker--container" };
var VF = {
  key: 0,
  class: "vc-colorpicker--tabs"
};
var qF = { class: "vc-colorpicker--tabs__inner" };
var zF = { class: "vc-btn__content" };
var CF = { class: "vc-btn__content" };
function EF(t, e, i, n, O, r) {
  return openBlock(), createElementBlock("div", ZF, [
    createBaseVNode("div", UF, [
      t.showTab ? (openBlock(), createElementBlock("div", VF, [
        createBaseVNode("div", qF, [
          createBaseVNode("div", {
            class: normalizeClass([
              "vc-colorpicker--tabs__btn",
              {
                "vc-btn-active": t.state.activeKey === "pure"
              }
            ]),
            onClick: e[0] || (e[0] = (a) => t.onActiveKeyChange("pure"))
          }, [
            createBaseVNode("button", null, [
              createBaseVNode("div", zF, toDisplayString(t.lang === "ZH-cn" ? "纯色" : "Pure"), 1)
            ])
          ], 2),
          createBaseVNode("div", {
            class: normalizeClass([
              "vc-colorpicker--tabs__btn",
              {
                "vc-btn-active": t.state.activeKey === "gradient"
              }
            ]),
            onClick: e[1] || (e[1] = (a) => t.onActiveKeyChange("gradient"))
          }, [
            createBaseVNode("button", null, [
              createBaseVNode("div", CF, toDisplayString(t.lang === "ZH-cn" ? "渐变色" : "Gradient"), 1)
            ])
          ], 2),
          createBaseVNode("div", {
            class: "vc-colorpicker--tabs__bg",
            style: normalizeStyle({
              width: "50%",
              left: `calc(${t.state.activeKey === "gradient" ? 50 : 0}%)`
            })
          }, null, 4)
        ])
      ])) : createCommentVNode("", true),
      renderSlot(t.$slots, "default", {}, void 0, true)
    ])
  ]);
}
var jF = Ii(RF, [["render", EF], ["__scopeId", "data-v-4afdf3bb"]]);
var IF = {
  isWidget: he.bool.def(false),
  pickerType: he.oneOf(["fk", "chrome"]).def("fk"),
  shape: he.oneOf(["circle", "square"]).def("square"),
  pureColor: {
    type: [String, Object],
    default: "#000000"
  },
  gradientColor: he.string.def(
    "linear-gradient(90deg, rgba(255, 255, 255, 1) 0%, rgba(0, 0, 0, 1) 100%)"
  ),
  format: {
    type: String,
    default: "rgb"
  },
  disableAlpha: he.bool.def(false),
  disableHistory: he.bool.def(false),
  roundHistory: he.bool.def(false),
  useType: he.oneOf(["pure", "gradient", "both"]).def("pure"),
  activeKey: he.oneOf(["pure", "gradient"]).def("pure"),
  lang: {
    type: String,
    default: "ZH-cn"
  },
  zIndex: he.number.def(9999)
};
var AF = defineComponent({
  name: "ColorPicker",
  components: { FkColorPicker: vb, ChromeColorPicker: Xb, GradientColorPicker: xb, WrapContainer: jF },
  inheritAttrs: false,
  props: IF,
  emits: [
    "update:pureColor",
    "pureColorChange",
    "update:gradientColor",
    "gradientColorChange",
    "update:activeKey",
    "activeKeyChange"
  ],
  setup(t, { emit: e }) {
    const i = reactive({
      pureColor: t.pureColor || "",
      activeKey: t.useType === "gradient" ? "gradient" : t.activeKey,
      //  "pure" | "gradient"
      isAdvanceMode: false
    });
    provide(QQ, {
      lang: computed(() => t.lang || "ZH-cn")
    });
    const n = new He(i.pureColor), O = ref(n), r = new He("#000"), a = new He("#000"), o = reactive({
      startColor: r,
      endColor: a,
      startColorStop: 0,
      endColorStop: 100,
      angle: 0,
      gradientColor: t.gradientColor
    }), s = ref(false), l = ref(null), c = ref(null), u = computed(() => ({
      background: i.activeKey !== "gradient" ? A(i.pureColor).toRgbString() : o.gradientColor
    })), h10 = computed(() => i.activeKey === "gradient" ? xb.name : t.pickerType === "fk" ? vb.name : Xb.name), d = computed(() => i.activeKey === "gradient" ? {
      startColor: o.startColor,
      endColor: o.endColor,
      onStartColorChange: (T) => {
        o.startColor = T, m();
      },
      onEndColorChange: (T) => {
        o.endColor = T, m();
      },
      angle: o.angle,
      startColorStop: o.startColorStop,
      endColorStop: o.endColorStop,
      onStartColorStopChange: (T) => {
        o.startColorStop = T, m();
      },
      onEndColorStopChange: (T) => {
        o.endColorStop = T, m();
      },
      onAngleChange: (T) => {
        o.angle = T, m();
      },
      onAdvanceChange: (T) => {
        i.isAdvanceMode = T;
      }
    } : {
      disableAlpha: t.disableAlpha,
      disableHistory: t.disableHistory,
      roundHistory: t.roundHistory,
      color: O.value,
      onChange: S,
      onAdvanceChange: p
    }), p = (T) => {
      i.isAdvanceMode = T;
    }, $ = () => {
      s.value = true;
    }, g = () => {
      s.value = false;
    }, Q = () => {
      var T, _, x, k;
      try {
        const [Y] = sB(o.gradientColor);
        if (Y && Y.type === "linear-gradient" && ((T = Y.orientation) == null ? void 0 : T.type) === "angular" && Y.colorStops.length >= 2) {
          const Z = Y.colorStops[0], L = Y.colorStops[1];
          o.startColorStop = Number((_ = Z.length) == null ? void 0 : _.value) || 0, o.endColorStop = Number((x = L.length) == null ? void 0 : x.value) || 0, o.angle = Number((k = Y.orientation) == null ? void 0 : k.value) || 0;
          const [ae, Oe, C, M] = Z.value, [H, xe, Fe, nt] = L.value;
          o.startColor = new He({
            r: Number(ae),
            g: Number(Oe),
            b: Number(C),
            a: Number(M)
          }), o.endColor = new He({
            r: Number(H),
            g: Number(xe),
            b: Number(Fe),
            a: Number(nt)
          });
        }
      } catch (Y) {
        console.log(`[Parse Color]: ${Y}`);
      }
    }, m = rr(() => {
      const T = b();
      try {
        o.gradientColor = lB(T), e("update:gradientColor", o.gradientColor), e("gradientColorChange", o.gradientColor);
      } catch (_) {
        console.log(_);
      }
    }, 300), b = () => {
      const T = [], _ = o.startColor.RGB.map((k) => k.toString()), x = o.endColor.RGB.map((k) => k.toString());
      return T.push({
        type: "linear-gradient",
        orientation: { type: "angular", value: o.angle + "" },
        colorStops: [
          {
            type: "rgba",
            value: [_[0], _[1], _[2], _[3]],
            length: { value: o.startColorStop + "", type: "%" }
          },
          {
            type: "rgba",
            value: [x[0], x[1], x[2], x[3]],
            length: { value: o.endColorStop + "", type: "%" }
          }
        ]
      }), T;
    }, P = () => {
      if (l.value && c.value) {
        const T = l.value.offsetParent, _ = l.value.offsetTop || (T == null ? void 0 : T.offsetTop), x = window.innerHeight - (_ - window.pageYOffset) - l.value.offsetHeight;
        oB(l.value, c.value, {
          placement: "auto",
          modifiers: [
            {
              name: "flip",
              options: {
                boundary: x > 500 ? "clippingParents" : l.value,
                fallbackPlacements: ["bottom", "left"]
              }
            }
          ]
        });
      }
    }, S = (T) => {
      O.value = T, i.pureColor = T.toString(t.format), y();
    }, y = rr(() => {
      e("update:pureColor", i.pureColor), e("pureColorChange", i.pureColor);
    }, 300);
    P7(c, () => {
      g();
    });
    const v = (T) => {
      i.activeKey = T, e("update:activeKey", T), e("activeKeyChange", T);
    };
    return dr(() => {
      Q(), P();
    }), Rt(
      () => t.gradientColor,
      (T) => {
        T != o.gradientColor && (o.gradientColor = T);
      }
    ), Rt(
      () => o.gradientColor,
      () => {
        Q();
      }
    ), Rt(
      () => t.activeKey,
      (T) => {
        i.activeKey = T;
      }
    ), Rt(
      () => t.useType,
      (T) => {
        i.activeKey !== "gradient" && T === "gradient" ? i.activeKey = "gradient" : i.activeKey = "pure";
      }
    ), Rt(
      () => t.pureColor,
      (T) => {
        A.equals(T, i.pureColor) || (i.pureColor = T, O.value = new He(T), y());
      },
      { deep: true }
    ), {
      colorCubeRef: l,
      pickerRef: c,
      showPicker: s,
      colorInstance: O,
      getBgColorStyle: u,
      onColorChange: S,
      onShowPicker: $,
      onActiveKeyChange: v,
      getComponentName: h10,
      getBindArgs: d,
      state: i
    };
  }
});
function GF(t, e, i, n, O, r) {
  const a = resolveComponent("WrapContainer");
  return openBlock(), createElementBlock(Fragment, null, [
    t.isWidget ? (openBlock(), createBlock(a, {
      key: 0,
      "active-key": t.state.activeKey,
      "onUpdate:active-key": e[0] || (e[0] = (o) => t.state.activeKey = o),
      "show-tab": t.useType === "both",
      onChange: t.onActiveKeyChange,
      style: normalizeStyle({ zIndex: t.zIndex })
    }, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent(t.getComponentName), mergeProps({ key: t.getComponentName }, t.getBindArgs), null, 16))
      ]),
      _: 1
    }, 8, ["active-key", "show-tab", "onChange", "style"])) : createCommentVNode("", true),
    t.isWidget ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
      createBaseVNode("div", {
        class: normalizeClass(["vc-color-wrap transparent", { round: t.shape === "circle" }]),
        ref: "colorCubeRef"
      }, [
        createBaseVNode("div", {
          class: "current-color",
          style: normalizeStyle(t.getBgColorStyle),
          onClick: e[1] || (e[1] = (...o) => t.onShowPicker && t.onShowPicker(...o))
        }, null, 4)
      ], 2),
      (openBlock(), createBlock(Teleport, { to: "body" }, [
        withDirectives(createBaseVNode("div", {
          ref: "pickerRef",
          style: normalizeStyle({ zIndex: t.zIndex })
        }, [
          t.showPicker ? (openBlock(), createBlock(a, {
            key: 0,
            "show-tab": t.useType === "both" && !t.state.isAdvanceMode,
            "active-key": t.state.activeKey,
            "onUpdate:active-key": e[2] || (e[2] = (o) => t.state.activeKey = o),
            onChange: t.onActiveKeyChange
          }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(t.getComponentName), mergeProps({ key: t.getComponentName }, t.getBindArgs), null, 16))
            ]),
            _: 1
          }, 8, ["show-tab", "active-key", "onChange"])) : createCommentVNode("", true)
        ], 4), [
          [vShow, t.showPicker]
        ])
      ]))
    ], 64))
  ], 64);
}
var LF = Ii(AF, [["render", GF], ["__scopeId", "data-v-730ef6cd"]]);
var DF = (t) => (pushScopeId("data-v-ee3ff47c"), t = t(), popScopeId(), t);
var MF = { class: "color-picker-plus-wrapper" };
var NF = {
  key: 0,
  class: "screen-color-picker"
};
var BF = DF(() => createBaseVNode("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "20",
  height: "20",
  viewBox: "0 0 24 24"
}, [
  createBaseVNode("path", {
    fill: "currentColor",
    d: "M3 21v-4.75l8.95-8.95l-1.45-1.4l1.45-1.4l1.9 1.9l3.1-3.1q.275-.275.7-.275q.425 0 .7.275l2.35 2.35q.275.275.275.7q0 .425-.275.7l-3.075 3.075l1.9 1.95L18.1 13.5l-1.4-1.45L7.75 21Zm2-2h1.95l8.3-8.35l-1.9-1.9L5 17.05Z"
  })
], -1));
var FF = {
  name: "HColorPicker"
};
var HF = defineComponent({
  ...FF,
  props: {
    pureColor: { default: "rgb(0,0,0)" },
    gradientColor: { default: "linear-gradient(0deg, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 1) 100%)" },
    activeKey: { default: "pure" },
    isWidget: { type: Boolean, default: false },
    pickerType: { default: "fk" },
    useType: { default: "pure" },
    disableHistory: { type: Boolean, default: false },
    roundHistory: { type: Boolean, default: false },
    disableAlpha: { type: Boolean, default: false },
    closeBtnCorner: { default: "TOP_RIGHT" },
    position: null,
    colorCallBack: null
  },
  emits: ["update:pureColor", "update:gradientColor", "update:activeKey", "pureColorChange", "gradientColorChange", "activeKeyChange"],
  setup(t, { emit: e }) {
    const i = t, { t: n } = hr(), O = {
      HEX: "HEX",
      HEXA: "HEXA",
      RGB: "RGB",
      RGBA: "RGBA",
      HSL: "HSL",
      HSLA: "HSLA",
      CMYK: "CMYK"
    };
    function r(y, v) {
      try {
        return hw[`to${v}`](y);
      } catch (T) {
        return console.error(T), "";
      }
    }
    const a = ref(i.pureColor), o = ref(i.gradientColor), s = ref(i.activeKey);
    watch(
      () => i.pureColor,
      (y) => {
        tI.validateHTMLColorRgb(y) && (a.value = y);
      },
      {
        immediate: true
      }
    ), watch(a, (y) => {
      i.colorCallBack && i.colorCallBack(y);
    });
    const l = (y) => {
      e("update:pureColor", y);
    }, c = {
      TOP_LEFT: {
        top: "-10px",
        left: "-6px"
      },
      TOP_RIGHT: {
        top: "-11px",
        left: "268px"
      },
      BOTTOM_LEFT: {
        top: "320px",
        left: "-6px"
      },
      BOTTOM_RIGHT: {
        top: "320px",
        left: "268px"
      }
    }, u = ref(false), h10 = ref(false);
    onMounted(async () => {
      h10.value = await window.$he3.getTheme(), window.$he3.subscribeThemeChange((y) => {
        h10.value = y;
      });
    });
    const d = (y) => {
      y !== u.value && (u.value = y);
    }, p = computed(() => s.value === "pure" ? a.value : o.value), $ = ref(false), g = (y) => {
      y !== $.value && ($.value = y);
    }, Q = cw(), { open: m } = U7(), b = async () => {
      g(true), m().then((y) => {
        if (y) {
          console.log(y.sRGBHex);
          const v = r(y.sRGBHex, O.RGB);
          a.value = v, o.value = v, e("update:pureColor", v), e("update:gradientColor", v);
        }
      }).finally(() => {
        g(false);
      });
    }, P = (y) => {
      Q || y.key === "c" && b();
    };
    watch(
      u,
      (y) => {
        y ? (document.addEventListener("keydown", P), document.addEventListener("click", (v) => {
          v.target != S.value && d(false);
        })) : document.removeEventListener("keydown", P);
      },
      {
        immediate: true
      }
    ), onUnmounted(() => {
      document.removeEventListener("keydown", P);
    });
    const S = ref(null);
    return onMounted(() => {
      if (S.value) {
        const y = S.value.getElementsByClassName("vc-btn__content");
        y.length === 2 && (y[0].textContent = n("colorPickerPlus.pure"), y[1].textContent = n("colorPickerPlus.gradient"));
      }
    }), (y, v) => {
      const T = resolveComponent("a-icon"), _ = resolveComponent("a-button");
      return openBlock(), createElementBlock("div", MF, [
        createBaseVNode("div", {
          class: "preview-color-block",
          style: normalizeStyle({ backgroundColor: unref(p) }),
          onClick: v[10] || (v[10] = withModifiers((x) => d(!u.value), ["stop"]))
        }, [
          withDirectives(createBaseVNode("div", {
            ref_key: "colorPickerEle",
            ref: S,
            class: normalizeClass(["color-picker", !t.disableAlpha && "enable-alpha"]),
            style: normalizeStyle(t.position ? t.position : ""),
            onClick: v[8] || (v[8] = withModifiers(() => {
            }, ["stop"])),
            onKeydown: v[9] || (v[9] = withModifiers(() => {
            }, ["stop"]))
          }, [
            createVNode(unref(LF), {
              pureColor: a.value,
              "onUpdate:pureColor": [
                v[0] || (v[0] = (x) => a.value = x),
                l
              ],
              gradientColor: o.value,
              "onUpdate:gradientColor": [
                v[1] || (v[1] = (x) => o.value = x),
                v[3] || (v[3] = (x) => e("update:gradientColor", x))
              ],
              "active-key": s.value,
              "onUpdate:activeKey": [
                v[2] || (v[2] = (x) => s.value = x),
                v[4] || (v[4] = (x) => e("update:activeKey", x))
              ],
              lang: "En",
              "is-widget": true,
              format: "rgb",
              "picker-type": t.pickerType,
              "use-type": t.useType,
              "disable-history": t.disableHistory,
              "round-history": t.roundHistory,
              "disable-alpha": t.disableAlpha,
              onPureColorChange: v[5] || (v[5] = (x) => e("pureColorChange", x)),
              onGradientColorChange: v[6] || (v[6] = (x) => e("gradientColorChange", x)),
              onActiveKeyChange: v[7] || (v[7] = (x) => e("activeKeyChange", x))
            }, null, 8, ["pureColor", "gradientColor", "active-key", "picker-type", "use-type", "disable-history", "round-history", "disable-alpha"]),
            createBaseVNode("div", {
              class: "close-btn",
              shape: "round",
              type: "text",
              style: normalizeStyle({
                color: h10.value ? "var(--gray-7)" : "var(--gray-6)",
                ...c[t.closeBtnCorner]
              })
            }, null, 4),
            unref(Q) ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", NF, [
              createTextVNode(toDisplayString(y.$t("colorPickerPlus.pressC")) + " ", 1),
              createVNode(_, {
                shape: "circle",
                loading: $.value,
                size: "small",
                onClick: withModifiers(b, ["stop"])
              }, {
                icon: withCtx(() => [
                  createVNode(T, null, {
                    component: withCtx(() => [
                      BF
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["loading", "onClick"])
            ]))
          ], 38), [
            [vShow, u.value]
          ])
        ], 4)
      ]);
    };
  }
});
var KF = ei(HF, [["__scopeId", "data-v-ee3ff47c"]]);
var wT = Be(KF);
var JF = { class: "box" };
var eH = {
  name: "HColorInput"
};
var tH = defineComponent({
  ...eH,
  props: {
    pureColor: null
  },
  emits: ["update:pureColor"],
  setup(t, { emit: e }) {
    const i = t, n = ref("HEXA"), O = ref([
      {
        value: "HEX",
        label: "HEX"
      },
      {
        value: "HEXA",
        label: "HEXA"
      },
      {
        value: "RGB",
        label: "RGB"
      },
      {
        value: "RGBA",
        label: "RGBA"
      },
      {
        value: "HSL",
        label: "HSL"
      },
      {
        value: "HSLA",
        label: "HSLA"
      },
      {
        value: "CMYK",
        label: "CMYK"
      }
    ]), r = ref("#FCC02EFF"), a = ref(i.pureColor);
    function o(c, u) {
      try {
        return hw[`to${u}`](c);
      } catch (h10) {
        return console.error(h10), "";
      }
    }
    const s = () => {
      r.value = o(a.value || "", n.value), e("update:pureColor", r.value);
    }, l = () => {
      a.value = r.value;
    };
    return watch(a, (c, u) => {
      r.value = o(a.value || "", n.value), e("update:pureColor", r.value);
    }), (c, u) => {
      const h10 = resolveComponent("a-tooltip"), d = resolveComponent("a-input"), p = resolveComponent("a-select");
      return openBlock(), createElementBlock("div", JF, [
        createVNode(d, {
          value: r.value,
          "onUpdate:value": u[1] || (u[1] = ($) => r.value = $),
          style: { width: "60%" },
          onPressEnter: l
        }, {
          suffix: withCtx(() => [
            createVNode(h10, { title: "Select Color" }, {
              default: withCtx(() => [
                createVNode(unref(wT), {
                  "pure-color": a.value,
                  "onUpdate:pureColor": u[0] || (u[0] = ($) => a.value = $),
                  class: "color-block"
                }, null, 8, ["pure-color"])
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["value"]),
        createVNode(p, {
          ref: "select",
          value: n.value,
          "onUpdate:value": u[2] || (u[2] = ($) => n.value = $),
          style: { width: "35%" },
          options: O.value,
          onChange: s
        }, null, 8, ["value", "options"])
      ]);
    };
  }
});
var iH = ei(tH, [["__scopeId", "data-v-0c95683b"]]);
var nH = Be(iH);
var OH = /("(?:[^\\"]|\\.)*")|[:,]/g;
function TT(t, e = {}) {
  const i = JSON.stringify(
    [1],
    void 0,
    e.indent === void 0 ? 2 : e.indent
  ).slice(2, -3), n = i === "" ? 1 / 0 : e.maxLength === void 0 ? 80 : e.maxLength;
  let { replacer: O } = e;
  return function r(a, o, s) {
    a && typeof a.toJSON == "function" && (a = a.toJSON());
    const l = JSON.stringify(a, O);
    if (l === void 0)
      return l;
    const c = n - o.length - s;
    if (l.length <= c) {
      const u = l.replace(
        OH,
        (h10, d) => d || `${h10} `
      );
      if (u.length <= c)
        return u;
    }
    if (O != null && (a = JSON.parse(l), O = void 0), typeof a == "object" && a !== null) {
      const u = o + i, h10 = [];
      let d = 0, p, $;
      if (Array.isArray(a)) {
        p = "[", $ = "]";
        const { length: g } = a;
        for (; d < g; d++)
          h10.push(
            r(a[d], u, d === g - 1 ? 0 : 1) || "null"
          );
      } else {
        p = "{", $ = "}";
        const g = Object.keys(a), { length: Q } = g;
        for (; d < Q; d++) {
          const m = g[d], b = `${JSON.stringify(m)}: `, P = r(
            a[m],
            u,
            b.length + (d === Q - 1 ? 0 : 1)
          );
          P !== void 0 && h10.push(b + P);
        }
      }
      if (h10.length > 0)
        return [p, i + h10.join(`,
${u}`), $].join(
          `
${o}`
        );
    }
    return l;
  }(t, "", 0);
}
var rH = (t) => {
  let e = 0;
  if (typeof t != "object" || !t)
    return;
  const i = (n, O = 1) => {
    Object.values(n).forEach((r) => {
      typeof r == "object" && r !== null && i(r, O + 1);
    }), e = Math.max(e, O);
  };
  return i(t), e;
};
var kT = (t) => (pushScopeId("data-v-badc8c71"), t = t(), popScopeId(), t);
var aH = { style: { position: "relative" } };
var oH = { class: "title" };
var sH = { style: { display: "flex" } };
var lH = kT(() => createBaseVNode("div", { class: "label" }, "Key:", -1));
var cH = kT(() => createBaseVNode("div", { class: "label" }, "Value:", -1));
var uH = {
  name: "HKVInput",
  components: { HIcon: Bt }
};
var fH = defineComponent({
  ...uH,
  props: {
    modelValue: null,
    defaultRow: null,
    changeProps: null
  },
  emits: ["update:modelValue", "change"],
  setup(t, { emit: e }) {
    const i = t;
    useCssVars(($) => ({
      "1bf086ad": r.value
    }));
    const { t: n } = hr(), O = ref(), r = ref("200px"), a = ref(true);
    watch(
      () => a.value,
      ($) => {
        var g;
        if (o.length >= 3 && (r.value = `${((g = O.value) == null ? void 0 : g.clientHeight) + 10}px`), $) {
          e(
            "change",
            o,
            ...i.changeProps ? i.changeProps : []
          );
          let Q;
          try {
            Q = JSON.parse(s.value);
          } catch {
            window.$he3.message.error(n("KVInput.jsonFormat"));
          }
          if (rH(Q) === 1) {
            o.length = 0;
            for (const [m, b] of Object.entries(Q))
              o.push({
                key: m,
                value: b,
                index: Date.now()
              });
          }
        } else {
          const Q = o.reduce((m, b) => b.key ? Object.assign(m, { [b.key]: b.value }) : m, {});
          s.value = TT(Q, { maxLength: 10 });
        }
      }
    );
    const o = reactive([
      {
        key: "admin",
        value: "true",
        index: Date.now()
      },
      {
        key: "user",
        value: "He3",
        index: Date.now()
      },
      {
        key: "exp",
        value: "1666865683",
        index: Date.now()
      }
    ]), s = ref(i.modelValue);
    watch(
      () => s.value,
      () => {
        e("update:modelValue", s.value);
      }
    );
    const l = ref(-1);
    function c() {
      e(
        "change",
        o,
        ...i.changeProps ? i.changeProps : []
      );
    }
    function u($) {
      const g = o.indexOf($);
      g > -1 && (o.splice(g, 1), e(
        "change",
        o,
        ...i.changeProps ? i.changeProps : []
      ));
    }
    let h10 = 1;
    function d() {
      o.push({
        key: `key${h10}`,
        value: `value${h10++}`,
        index: Date.now()
      }), e(
        "change",
        o,
        ...i.changeProps ? i.changeProps : []
      );
    }
    function p($) {
      l.value = $;
    }
    return onBeforeMount(() => {
      if (i.defaultRow) {
        o.length = 0;
        for (const $ of Object.entries(i.defaultRow)) {
          const g = {
            key: $[0],
            value: $[1],
            index: Date.now()
          };
          o.push(g);
        }
      }
    }), onMounted(() => {
      c();
    }), ($, g) => {
      const Q = resolveComponent("a-radio-button"), m = resolveComponent("a-radio-group"), b = resolveComponent("a-button"), P = resolveComponent("a-input"), S = resolveComponent("a-col"), y = resolveComponent("a-row");
      return openBlock(), createElementBlock("div", aH, [
        createVNode(m, {
          value: a.value,
          "onUpdate:value": g[0] || (g[0] = (v) => a.value = v),
          size: "small",
          style: { position: "absolute", right: "50px", "z-index": "2" }
        }, {
          default: withCtx(() => [
            createVNode(Q, { value: true }, {
              default: withCtx(() => [
                createTextVNode("KV")
              ]),
              _: 1
            }),
            createVNode(Q, { value: false }, {
              default: withCtx(() => [
                createTextVNode("JSON")
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["value"]),
        a.value ? (openBlock(), createElementBlock("div", {
          key: 0,
          ref_key: "kvRef",
          ref: O,
          class: "kvinput"
        }, [
          createBaseVNode("div", oH, [
            createVNode(b, {
              class: "add",
              size: "small",
              onClick: d
            }, {
              default: withCtx(() => [
                createVNode(unref(Bt), { icon: "ant-design:plus-outlined" }),
                createTextVNode(" " + toDisplayString(unref(n)("jwtGenerator.add")), 1)
              ]),
              _: 1
            })
          ]),
          createVNode(TransitionGroup, {
            name: "anilist",
            tag: "div"
          }, {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(o, (v, T) => (openBlock(), createBlock(y, {
                key: v.index,
                type: "flex",
                class: "row",
                onMouseenter: (_) => p(T),
                onMouseleave: g[1] || (g[1] = (_) => p(-1))
              }, {
                default: withCtx(() => [
                  createVNode(S, { style: { width: "calc(100% - 40px)" } }, {
                    default: withCtx(() => [
                      createBaseVNode("div", sH, [
                        lH,
                        createVNode(P, {
                          value: v.key,
                          "onUpdate:value": (_) => v.key = _,
                          size: "small",
                          placeholder: "key",
                          style: { width: "calc(50%- 50px)" },
                          onChange: c
                        }, null, 8, ["value", "onUpdate:value"]),
                        cH,
                        createVNode(P, {
                          value: v.value,
                          "onUpdate:value": (_) => v.value = _,
                          size: "small",
                          placeholder: "key",
                          style: { width: "calc(50%- 50px)" },
                          onChange: c
                        }, null, 8, ["value", "onUpdate:value"])
                      ])
                    ]),
                    _: 2
                  }, 1024),
                  createVNode(S, { flex: "40px" }, {
                    default: withCtx(() => [
                      createVNode(Transition, { name: "fade" }, {
                        default: withCtx(() => [
                          withDirectives(createVNode(b, {
                            size: "small",
                            class: "delete",
                            onClick: (_) => u(v)
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(Bt), {
                                icon: "ant-design:delete-outlined",
                                size: 14
                              })
                            ]),
                            _: 2
                          }, 1032, ["onClick"]), [
                            [vShow, l.value === T]
                          ])
                        ]),
                        _: 2
                      }, 1024)
                    ]),
                    _: 2
                  }, 1024)
                ]),
                _: 2
              }, 1032, ["onMouseenter"]))), 128))
            ]),
            _: 1
          })
        ], 512)) : createCommentVNode("", true),
        a.value ? createCommentVNode("", true) : (openBlock(), createBlock(unref(ca), {
          key: 1,
          modelValue: s.value,
          "onUpdate:modelValue": g[2] || (g[2] = (v) => s.value = v),
          "current-language": "JSON",
          lang: "JSON",
          theme: "GITHUB_LIGHT",
          class: "editor"
        }, null, 8, ["modelValue"]))
      ]);
    };
  }
});
var hH = ei(fH, [["__scopeId", "data-v-badc8c71"]]);
var dH = Be(hH);
var pH = { class: "result" };
var $H = {
  key: 1,
  class: "single"
};
var QH = { class: "single-flex" };
var gH = {
  key: 2,
  class: "json"
};
var mH = {
  name: "HKVResult"
};
var SH = defineComponent({
  ...mH,
  props: {
    result: null,
    width: null,
    model: { default: "list" },
    modelSwitch: { type: Boolean }
  },
  setup(t) {
    const e = t;
    useCssVars((o) => ({
      "5da33e2e": O.value
    }));
    const i = {
      json: true,
      list: false
    }, n = ref(e.model === "json"), O = ref(e.width ? e.width + "px" : "300px"), r = ref(e.model ? e.model : "list"), a = computed(() => TT(e.result, { maxLength: 20 }));
    return watch(r, (o) => {
      n.value = i[o];
    }), (o, s) => {
      const l = resolveComponent("a-radio-button"), c = resolveComponent("a-radio-group");
      return openBlock(), createElementBlock("div", pH, [
        e.modelSwitch ? (openBlock(), createBlock(c, {
          key: 0,
          value: r.value,
          "onUpdate:value": s[0] || (s[0] = (u) => r.value = u),
          class: "switchButton",
          "button-style": "solid",
          size: "small"
        }, {
          default: withCtx(() => [
            createVNode(l, { value: "json" }, {
              default: withCtx(() => [
                createTextVNode("JSON")
              ]),
              _: 1
            }),
            createVNode(l, { value: "list" }, {
              default: withCtx(() => [
                createTextVNode("List")
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["value"])) : createCommentVNode("", true),
        n.value ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", $H, [
          createBaseVNode("div", QH, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(e.result, (u, h10) => (openBlock(), createElementBlock("div", {
              key: h10,
              class: "item"
            }, [
              createVNode(unref(_T), {
                "result-desc": h10,
                result: typeof u == "object" ? JSON.stringify(u) : u + "",
                size: "small"
              }, null, 8, ["result-desc", "result"])
            ]))), 128))
          ])
        ])),
        n.value ? (openBlock(), createElementBlock("div", gH, [
          createVNode(unref(qx), {
            code: unref(a),
            lang: "JSON",
            class: "editor"
          }, null, 8, ["code"])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});
var PH = ei(SH, [["__scopeId", "data-v-fcfb6a64"]]);
var yH = Be(PH);
var bH = (t) => (pushScopeId("data-v-28d6c69f"), t = t(), popScopeId(), t);
var vH = { class: "input" };
var XH = { key: 0 };
var xH = { key: 0 };
var wH = { key: 0 };
var TH = bH(() => createBaseVNode("div", { class: "card-footer" }, null, -1));
var kH = {
  name: "HMultilineInput",
  components: { HCodeEditor: ca, HIcon: Bt }
};
var _H = defineComponent({
  ...kH,
  props: {
    title: { default: "Input content:" },
    code: { type: Boolean, default: false },
    lang: null,
    modelValue: { default: "" },
    autofocus: { type: Boolean, default: true },
    placeholder: null,
    id: null
  },
  emits: ["update:modelValue", "change"],
  setup(t, { emit: e }) {
    const i = t, { t: n } = hr(), O = ref(i.modelValue), r = ref();
    watch(O, () => {
      e("update:modelValue", O.value), e("change");
    }), watch(
      () => i.modelValue,
      () => {
        O.value = i.modelValue;
      }
    );
    const a = async (g) => {
      let Q = g.type.split("/")[0];
      if (Q === "image" || Q === "video" || Q === "audio") {
        window.$he3.message.warn(n("multilineInput.chooseTextFile"));
        return;
      }
      cw() ? g.path : `${g.path}`;
      let m;
      return new Promise((b, P) => {
        let S = new FileReader();
        S.readAsText(g, m), S.onload = function(y) {
          var v;
          b(m), O.value = (v = y.target) == null ? void 0 : v.result;
        };
      });
    }, o = () => {
      O.value = "", window.$he3.message.success(n("multilineInput.clearSuccess"));
    }, s = (g) => {
      var m;
      let Q = (m = g.clipboardData) == null ? void 0 : m.items[0];
      if ((Q == null ? void 0 : Q.kind) == "file") {
        g.preventDefault();
        let b = Q.getAsFile();
        a(b);
      }
    }, l = () => {
      navigator.clipboard.readText().then((g) => {
        O.value += g, window.$he3.message.success(n("multilineInput.pasteSuccess"));
      });
    };
    let c = (g) => {
      var m, b, P;
      g.preventDefault();
      let Q = (m = g.dataTransfer) == null ? void 0 : m.files;
      if (Q != null && Q.length && g.type === "drop" && (b = g.dataTransfer) != null && b.files)
        for (const S of (P = g.dataTransfer) == null ? void 0 : P.files)
          a(S);
    };
    const u = ref(), h10 = ref(), d = ref(true), { width: p } = NP(u), { width: $ } = NP(h10);
    return watch([p, $], () => {
      p.value - $.value < 230 ? d.value = false : d.value = true;
    }), (g, Q) => {
      const m = resolveComponent("a-button"), b = resolveComponent("a-upload"), P = resolveComponent("a-textarea");
      return openBlock(), createElementBlock("div", vH, [
        createBaseVNode("div", {
          ref_key: "headerRef",
          ref: u,
          class: "header"
        }, [
          createBaseVNode("div", {
            ref_key: "titleRef",
            ref: h10,
            style: { float: "left" },
            class: "overflow"
          }, toDisplayString(i.title), 513),
          createVNode(m, {
            class: "button",
            type: "link",
            size: "small",
            onClick: o
          }, {
            default: withCtx(() => [
              createVNode(unref(Bt), { icon: "ant-design:delete-outlined" }),
              d.value ? (openBlock(), createElementBlock("span", XH, toDisplayString(g.$t("multilineInput.clear")), 1)) : createCommentVNode("", true)
            ]),
            _: 1
          }),
          createVNode(m, {
            class: "button",
            type: "link",
            size: "small",
            onClick: l
          }, {
            default: withCtx(() => [
              createVNode(unref(Bt), { icon: "ant-design:snippets-outlined" }),
              d.value ? (openBlock(), createElementBlock("span", xH, toDisplayString(g.$t("multilineInput.paste")), 1)) : createCommentVNode("", true)
            ]),
            _: 1
          }),
          createVNode(b, {
            class: "button",
            "before-upload": a,
            "max-count": 1
          }, {
            itemRender: withCtx(({}) => []),
            default: withCtx(() => [
              createVNode(m, {
                size: "small",
                type: "link"
              }, {
                default: withCtx(() => [
                  createVNode(unref(Bt), { icon: "ant-design:upload-outlined" }),
                  d.value ? (openBlock(), createElementBlock("span", wH, toDisplayString(unref(n)("multilineInput.read_file")), 1)) : createCommentVNode("", true)
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ], 512),
        i.code ? createCommentVNode("", true) : (openBlock(), createBlock(P, {
          key: 0,
          id: t.id,
          ref_key: "textarea",
          ref: r,
          value: O.value,
          "onUpdate:value": Q[0] || (Q[0] = (S) => O.value = S),
          autofocus: t.autofocus,
          placeholder: t.placeholder,
          onPaste: s,
          onDragenter: unref(c),
          onDragover: unref(c),
          onDrop: unref(c)
        }, null, 8, ["id", "value", "autofocus", "placeholder", "onDragenter", "onDragover", "onDrop"])),
        i.code ? (openBlock(), createBlock(unref(ca), {
          key: 1,
          modelValue: O.value,
          "onUpdate:modelValue": Q[1] || (Q[1] = (S) => O.value = S),
          "current-language": "JavaScript",
          lang: i.lang,
          autofocus: t.autofocus,
          style: { height: "calc(100% - 50px)" }
        }, null, 8, ["modelValue", "lang", "autofocus"])) : createCommentVNode("", true),
        TH
      ]);
    };
  }
});
var WH = ei(_H, [["__scopeId", "data-v-28d6c69f"]]);
var YH = Be(WH);
var RH = { style: { position: "relative" } };
var ZH = { class: "output" };
var UH = { class: "button-list" };
var VH = {
  name: "HMultilineResult"
};
var qH = defineComponent({
  ...VH,
  props: {
    title: { default: "result" },
    result: null,
    height: null,
    fileType: null,
    outputFile: null
  },
  setup(t, { expose: e }) {
    const i = t, n = ref(false), O = o7(() => {
      n.value = true, setTimeout(() => {
        n.value = false;
      }, 1e3);
    }, 1200);
    return e({
      warnDisabled: O
    }), (r, a) => {
      const o = resolveComponent("a-textarea");
      return openBlock(), createElementBlock("div", RH, [
        createBaseVNode("div", ZH, [
          createBaseVNode("div", {
            class: normalizeClass({ title: true, shake: n.value })
          }, [
            createBaseVNode("span", null, toDisplayString(t.title), 1),
            n.value ? (openBlock(), createBlock(unref(Bt), {
              key: 0,
              icon: "ant-design:close-outlined",
              style: { color: "red" }
            })) : createCommentVNode("", true)
          ], 2),
          createVNode(o, {
            style: normalizeStyle(`height: ${(i == null ? void 0 : i.height) || "200px"}`),
            value: i.result,
            class: "result",
            readonly: ""
          }, null, 8, ["style", "value"])
        ]),
        createBaseVNode("div", UH, [
          i.outputFile ? (openBlock(), createBlock(unref(V$), {
            key: 0,
            disabled: i.result === void 0 || i.result.length === 0,
            "save-text": i.result,
            size: "small",
            type: "default",
            icon: "",
            "file-type": i.fileType
          }, null, 8, ["disabled", "save-text", "file-type"])) : createCommentVNode("", true),
          createVNode(unref(pa), {
            disabled: i.result === void 0 || i.result.length === 0,
            "copy-content": i.result,
            icon: "",
            title: " ",
            type: "text"
          }, null, 8, ["disabled", "copy-content"])
        ])
      ]);
    };
  }
});
var zH = ei(qH, [["__scopeId", "data-v-3533ffbb"]]);
var CH = Be(zH);
var EH = { class: "output" };
var jH = { class: "title" };
var IH = { key: 0 };
var AH = {
  name: "HSinglelineResult"
};
var GH = defineComponent({
  ...AH,
  props: {
    resultDesc: null,
    result: null,
    size: { default: "middle" },
    showCopyButton: { type: Boolean, default: true }
  },
  setup(t) {
    const e = t, i = computed(() => {
      if (e.showCopyButton)
        switch (e.size) {
          case "small":
            return "24";
          case "large":
            return "40";
          default:
            return "32";
        }
      else
        return "0";
    });
    return (n, O) => {
      const r = resolveComponent("a-input"), a = resolveComponent("a-tooltip"), o = resolveComponent("a-input-group");
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("div", EH, [
          createBaseVNode("div", jH, [
            renderSlot(n.$slots, "title", {}, () => [
              t.resultDesc ? (openBlock(), createElementBlock("span", IH, toDisplayString(t.resultDesc) + " : ", 1)) : createCommentVNode("", true)
            ], true)
          ]),
          createVNode(o, {
            compact: "",
            class: "result"
          }, {
            default: withCtx(() => [
              createVNode(r, {
                value: typeof e.result == "object" ? e.result.toString() : e.result,
                size: e.size,
                style: normalizeStyle({ width: "calc(100% - " + unref(i) + "px)" }),
                readonly: ""
              }, null, 8, ["value", "size", "style"]),
              e.showCopyButton ? (openBlock(), createBlock(a, {
                key: 0,
                title: "copy"
              }, {
                default: withCtx(() => [
                  createVNode(unref(pa), {
                    "copy-content": typeof e.result == "object" ? e.result.toString() : e.result,
                    icon: "",
                    title: " ",
                    size: "middle",
                    type: "text"
                  }, null, 8, ["copy-content"])
                ]),
                _: 1
              })) : createCommentVNode("", true)
            ]),
            _: 1
          })
        ])
      ]);
    };
  }
});
var LH = ei(GH, [["__scopeId", "data-v-0fdb306c"]]);
var _T = Be(LH);
function wb(t) {
  return new Promise((e, i) => {
    const n = new FileReader();
    n.readAsDataURL(t), n.onload = () => e(n.result), n.onerror = (O) => i(O);
  });
}
var DH = { class: "upload-area" };
var MH = { key: 0 };
var NH = {
  key: 1,
  class: "preview-image"
};
var BH = ["src"];
var FH = {
  name: "HImagePicker",
  components: { HIcon: Bt }
};
var HH = defineComponent({
  ...FH,
  props: {
    width: { default: "100%" },
    height: { default: "100%" },
    imageHeight: { default: "78vh" },
    pickHook: null,
    onLoadHook: { type: Function, default: () => {
    } },
    resetHook: { type: Function, default: () => {
    } }
  },
  setup(t) {
    const e = t;
    useCssVars((c) => ({
      fcc9079c: c.$props.imageHeight
    }));
    const i = ref(""), n = ref(null), O = ref(false), r = () => {
      navigator.clipboard.read().then((c) => {
        c[0].types[0].includes("image") ? O.value = true : O.value = false;
      });
    }, a = async (c) => {
      var h10;
      let u = (h10 = c.clipboardData) == null ? void 0 : h10.items[0];
      if ((u == null ? void 0 : u.kind) == "file") {
        let d = u.getAsFile();
        d && d.size !== 0 && (i.value = await wb(d));
      }
    };
    onMounted(() => {
      r(), BO(document, "paste", a);
    });
    const o = ref(false), s = () => {
      r(), o.value = true, setTimeout(() => {
        o.value = false, i.value = "", e.resetHook();
      }, 500);
    }, l = async (c) => (e.pickHook(c), i.value = await wb(c), false);
    return watch(i, async (c) => {
      c && (await nextTick(), e.onLoadHook(n.value));
    }), (c, u) => {
      const h10 = resolveComponent("a-upload-dragger"), d = resolveComponent("a-button");
      return openBlock(), createElementBlock("div", {
        style: normalizeStyle({ width: t.width, height: t.height })
      }, [
        i.value ? (openBlock(), createElementBlock("div", NH, [
          createBaseVNode("img", {
            ref_key: "imgEle",
            ref: n,
            class: "image",
            alt: "He3",
            src: i.value
          }, null, 8, BH),
          createVNode(d, {
            type: "primary",
            shape: "round",
            onClick: s
          }, {
            default: withCtx(() => [
              createVNode(unref(Bt), { icon: "ant-design:sync-outlined" }),
              createTextVNode(" " + toDisplayString(c.$t("imagePicker.reselect")), 1)
            ]),
            _: 1
          })
        ])) : (openBlock(), createBlock(h10, {
          key: 0,
          accept: "image/png,image/jpeg,image/apng,image/avif,image/gif,image/svg+xml,image/webp",
          "max-count": 1,
          "before-upload": l,
          "show-upload-list": false,
          "list-type": "picture",
          style: normalizeStyle({ width: t.width })
        }, {
          default: withCtx(() => [
            createBaseVNode("div", DH, [
              createBaseVNode("p", null, toDisplayString(c.$t("imagePicker.upload")), 1),
              O.value ? (openBlock(), createElementBlock("p", MH, " (" + toDisplayString(unref(A7)() ? c.$t("imagePicker.clipboardMac") : c.$t("imagePicker.clipboardWin")) + ") ", 1)) : createCommentVNode("", true)
            ])
          ]),
          _: 1
        }, 8, ["style"]))
      ], 4);
    };
  }
});
var KH = ei(HH, [["__scopeId", "data-v-5bbb34b0"]]);
var JH = { key: 0 };
var eK = { style: { "margin-top": "8px" } };
var tK = ["src"];
var iK = {
  name: "HMultiImagePicker"
};
var nK = defineComponent({
  ...iK,
  props: {
    pickHook: { type: Function, default: () => {
    } },
    onLoadHook: { type: Function, default: () => {
    } },
    removeHook: { type: Function, default: () => {
    } }
  },
  setup(t, { expose: e }) {
    const i = t, n = ref(false), O = ref(""), r = ref(""), a = reactive([]), o = [];
    onMounted(() => {
      p(), document.addEventListener("paste", $, false);
    }), onUnmounted(() => {
      document.removeEventListener("paste", $);
    });
    const s = (Q) => {
      const m = a == null ? void 0 : a.findIndex((b) => b.uid === Q.uid);
      a == null || a.splice(m, 1), o == null || o.splice(m, 1), i.removeHook();
    }, l = () => {
      a.length = 0, o.length = 0;
    }, c = (Q) => new Promise((m, b) => {
      O.value = Q.url || Q.preview, n.value = true, r.value = Q.name || Q.url.substring(Q.url.lastIndexOf("/") + 1);
    });
    watch(
      () => a,
      async (Q, m) => {
        await nextTick(), i.onLoadHook();
      }
    );
    const u = () => {
      n.value = false, r.value = "";
    }, h10 = (Q) => (a == null || a.push({
      uid: Q.uid,
      name: Q.name,
      status: "done",
      url: `file://${Q.path}`
    }), g(Q).then((m) => {
      const b = Object.assign(Q, m);
      o.push(b), i.pickHook();
    }), false), d = ref(false), p = () => {
      navigator.clipboard.read().then((Q) => {
        Q[0].types[0].includes("image") ? d.value = true : d.value = false;
      });
    }, $ = async (Q) => {
      var b;
      let m = (b = Q.clipboardData) == null ? void 0 : b.items[0];
      if ((m == null ? void 0 : m.kind) == "file") {
        let P = Object.assign(
          { uid: Math.random().toString() },
          m.getAsFile()
        );
        P && P.size !== 0 && (a == null || a.push({
          uid: P.uid,
          name: P.name,
          status: "done",
          url: URL.createObjectURL(P)
        }), g(P).then((S) => {
          const y = Object.assign(P, S);
          o.push(y), i.pickHook();
        }));
      }
    }, g = (Q) => new Promise((m, b) => {
      let P = new FileReader();
      P.readAsDataURL(Q), P.onload = (S) => {
        const y = new Image();
        y.src = S.target.result, y.onerror = b, y.onload = function() {
          const v = this;
          m({ width: v.width, height: v.height });
        };
      };
    });
    return e({ fileList: o, clearImage: l }), (Q, m) => {
      const b = resolveComponent("a-upload"), P = resolveComponent("a-modal");
      return openBlock(), createElementBlock("div", null, [
        createVNode(b, {
          "file-list": a,
          "list-type": "picture-card",
          "before-upload": h10,
          multiple: "",
          onPreview: c,
          onRemove: s
        }, {
          default: withCtx(() => [
            (a == null ? void 0 : a.length) < 8 ? (openBlock(), createElementBlock("div", JH, [
              createVNode(unref(Bt), { icon: "ant-design:plus-outlined" }),
              createBaseVNode("div", eK, toDisplayString(Q.$t("image.choose")), 1)
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["file-list"]),
        createVNode(P, {
          visible: n.value,
          title: r.value,
          footer: null,
          onCancel: u
        }, {
          default: withCtx(() => [
            createBaseVNode("img", {
              alt: "example",
              style: { width: "100%" },
              src: O.value
            }, null, 8, tK)
          ]),
          _: 1
        }, 8, ["visible", "title"])
      ]);
    };
  }
});
var OK = Be(KH);
var rK = Be(nK);
var aK = { class: "terminal-view" };
var oK = { class: "title-line" };
var sK = { class: "output" };
var lK = {
  name: "HTerminalView"
};
var cK = defineComponent({
  ...lK,
  props: {
    result: null
  },
  setup(t) {
    const e = t;
    return (i, n) => (openBlock(), createElementBlock("div", aK, [
      createBaseVNode("div", oK, [
        createVNode(unref(pa), {
          type: "default",
          "copy-content": e.result,
          style: { float: "right" },
          icon: "",
          title: " "
        }, null, 8, ["copy-content"])
      ]),
      createBaseVNode("div", sK, [
        createBaseVNode("pre", null, toDisplayString(e.result), 1)
      ])
    ]));
  }
});
var uK = ei(cK, [["__scopeId", "data-v-c7964397"]]);
var fK = Be(uK);
function hK(t) {
  async function e(n) {
    var a, o, s, l, c, u;
    (o = (a = n.dataTransfer) == null ? void 0 : a.files) != null && o.length && ((l = (s = n.dataTransfer) == null ? void 0 : s.files) == null ? void 0 : l.length) > 1 && window.$he3.message.warn("暂时只支持拖拽一个文件");
    const O = (u = (c = n.dataTransfer) == null ? void 0 : c.files[0]) == null ? void 0 : u.path, r = await window.$he3.readFileByUrl(O);
    setTimeout(() => {
      t.value = r;
    }, 0);
  }
  return {
    handleDrag: e,
    handleFileSelected: async (n) => {
      t.value = await window.$he3.readFileByUrl(n.path);
    }
  };
}
var dK = { class: "TransForm-left-header" };
var pK = { class: "TransForm-left-header-button" };
var $K = {
  key: 0,
  class: "error-message"
};
var QK = {
  key: 0,
  class: "error"
};
var gK = { class: "TransForm-right-header" };
var mK = { class: "TransForm-right-header-button" };
var SK = {
  key: 0,
  class: "error-message"
};
var PK = { class: "TransForm-right-content" };
var yK = {
  key: 0,
  class: "error"
};
var bK = {
  name: "HTransform"
};
var vK = defineComponent({
  ...bK,
  props: {
    leftConfig: { default: () => ({
      placeholder: "",
      leftTitle: "Input",
      isTitleShow: true,
      editorLang: "TYPESCRIPT",
      editorTheme: "GITHUB_LIGHT"
    }) },
    rightConfig: { default: () => ({
      placeholder: "",
      rightTitle: "Output",
      isTitleShow: true,
      editorLang: "TYPESCRIPT",
      editorTheme: "GITHUB_LIGHT"
    }) },
    canChooseFile: { type: Boolean, default: true },
    onMounted: { type: Function, default: () => {
    } },
    onChange: null,
    onResultChange: null,
    autoFill: { type: Boolean, default: false },
    autoFillType: { default: "" }
  },
  setup(t) {
    const e = t, i = toRefs(
      reactive({
        inputValue: "",
        outputValue: ""
      })
    ), n = toRefs(
      reactive({
        isFocus: true,
        error: false,
        errorMessage: "",
        errLine: 0
      })
    ), O = toRefs(
      reactive({
        isFocus: false,
        error: false,
        errorMessage: "",
        errLine: 0
      })
    );
    watch(i.inputValue, () => {
      n.error.value = false, n.errLine.value = 0, !(e.onResultChange && !n.isFocus.value) && o();
    }), watch(i.outputValue, () => {
      e.onResultChange && (O.error.value = false, O.errLine.value = 0, O.isFocus.value && s());
    });
    const { handleDrag: r, handleFileSelected: a } = hK(i.inputValue);
    async function o() {
      if (e.onChange)
        try {
          i.outputValue.value = await e.onChange(i.inputValue);
        } catch (l) {
          n.error.value = true, n.errorMessage.value = l.message, l.line && (n.errLine.value = l.line), console.error(l);
          return;
        }
      else
        return;
    }
    async function s() {
      if (e.onResultChange)
        try {
          i.inputValue.value = await e.onResultChange(i.outputValue);
        } catch (l) {
          O.error.value = true, O.errorMessage.value = l.message, l.line && (O.errLine.value = l.line), console.error(l);
          return;
        }
      else
        return;
    }
    return (l, c) => {
      const u = resolveComponent("a-alert"), h10 = resolveComponent("a-tooltip");
      return openBlock(), createBlock(unref(Wb), { class: "TransForm" }, {
        left: withCtx(() => [
          createBaseVNode("div", dK, [
            renderSlot(l.$slots, "leftHeader", {
              inputValue: unref(i).inputValue
            }, () => [
              createBaseVNode("div", pK, [
                e.onResultChange ? (openBlock(), createBlock(unref(pa), {
                  key: 0,
                  "copy-content": unref(i).inputValue.value,
                  type: "primary",
                  icon: ""
                }, null, 8, ["copy-content"])) : createCommentVNode("", true),
                t.canChooseFile ? (openBlock(), createBlock(unref(lw), {
                  key: 1,
                  "handle-file-selected": unref(a),
                  type: "primary",
                  icon: ""
                }, null, 8, ["handle-file-selected"])) : createCommentVNode("", true),
                createTextVNode("    "),
                renderSlot(l.$slots, "left", {}, void 0, true)
              ])
            ], true),
            unref(n).error.value ? (openBlock(), createElementBlock("div", $K, [
              createVNode(h10, {
                placement: "bottom",
                title: unref(n).errorMessage.value,
                "overlay-style": {
                  overflow: "hidden",
                  maxHeight: "500px"
                }
              }, {
                default: withCtx(() => [
                  createVNode(u, {
                    message: unref(n).errorMessage.value,
                    type: "error",
                    "show-icon": ""
                  }, null, 8, ["message"])
                ]),
                _: 1
              }, 8, ["title"])
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", {
            class: "TransForm-left-content",
            onDrop: c[2] || (c[2] = //@ts-ignore
            (...d) => unref(r) && unref(r)(...d)),
            onDragenter: c[3] || (c[3] = withModifiers(() => {
            }, ["prevent"]))
          }, [
            unref(n).error.value ? (openBlock(), createElementBlock("div", QK)) : createCommentVNode("", true),
            createVNode(unref(ca), {
              modelValue: unref(i).inputValue.value,
              "onUpdate:modelValue": c[0] || (c[0] = (d) => unref(i).inputValue.value = d),
              isFocus: unref(n).isFocus.value,
              "onUpdate:isFocus": c[1] || (c[1] = (d) => unref(n).isFocus.value = d),
              lang: t.leftConfig.editorLang,
              theme: t.leftConfig.editorTheme,
              placeholder: t.leftConfig.placeholder ? l.$t(t.leftConfig.placeholder ?? "") : "",
              class: "TransForm-left-input",
              autofocus: true,
              "error-line": unref(n).errLine.value
            }, null, 8, ["modelValue", "isFocus", "lang", "theme", "placeholder", "error-line"])
          ], 32)
        ]),
        right: withCtx(() => [
          createBaseVNode("div", gK, [
            renderSlot(l.$slots, "rightHeader", {
              outputValue: unref(i).outputValue
            }, () => [
              createBaseVNode("div", mK, [
                createVNode(unref(pa), {
                  "copy-content": unref(i).outputValue.value,
                  type: "primary",
                  icon: ""
                }, null, 8, ["copy-content"]),
                createVNode(unref(V$), {
                  size: "small",
                  "save-text": unref(i).outputValue.value,
                  icon: ""
                }, null, 8, ["save-text"]),
                renderSlot(l.$slots, "right", {}, void 0, true)
              ])
            ], true),
            unref(O).error.value ? (openBlock(), createElementBlock("div", SK, [
              createVNode(h10, {
                placement: "bottom",
                title: unref(O).errorMessage.value,
                "overlay-style": {
                  overflow: "hidden",
                  maxHeight: "500px"
                }
              }, {
                default: withCtx(() => [
                  createVNode(u, {
                    message: unref(O).errorMessage.value,
                    type: "error",
                    "show-icon": ""
                  }, null, 8, ["message"])
                ]),
                _: 1
              }, 8, ["title"])
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", PK, [
            unref(O).error.value ? (openBlock(), createElementBlock("div", yK)) : createCommentVNode("", true),
            createVNode(unref(ca), {
              modelValue: unref(i).outputValue.value,
              "onUpdate:modelValue": c[4] || (c[4] = (d) => unref(i).outputValue.value = d),
              isFocus: unref(O).isFocus.value,
              "onUpdate:isFocus": c[5] || (c[5] = (d) => unref(O).isFocus.value = d),
              lang: t.rightConfig.editorLang,
              theme: t.rightConfig.editorTheme,
              placeholder: t.rightConfig.placeholder ? l.$t(t.rightConfig.placeholder ?? "") : "",
              class: "TransForm-right-input",
              autofocus: false,
              "error-line": unref(O).errLine.value
            }, null, 8, ["modelValue", "isFocus", "lang", "theme", "placeholder", "error-line"])
          ])
        ]),
        _: 3
      });
    };
  }
});
var XK = ei(vK, [["__scopeId", "data-v-7c696578"]]);
var xK = Be(XK);
var Tb = Object.freeze(Object.defineProperty({
  __proto__: null,
  HCodeEditor: ca,
  HCodeResult: qx,
  HColorInput: nH,
  HColorPicker: wT,
  HContentSaveButton: V$,
  HFileUploadButton: lw,
  HHighlightInput: h9,
  HIcon: Bt,
  HImagePicker: OK,
  HImagePreview: p_,
  HKVInput: dH,
  HKVResult: yH,
  HLayoutHorizontal: lk,
  HLayoutSingle: ck,
  HLayoutSplitPane: Wb,
  HLayoutVertical: sk,
  HMultiImagePicker: rK,
  HMultilineInput: YH,
  HMultilineResult: CH,
  HSinglelineResult: _T,
  HTerminalView: fK,
  HTextCopyButton: pa,
  HTransform: xK
}, Symbol.toStringTag, { value: "Module" }));
var wK = function(t) {
  return Object.keys(Tb).forEach((e) => {
    const i = Tb[e];
    i.install && t.use(i);
  }), t;
};
var CK = {
  install: wK
};
export {
  ca as HCodeEditor,
  qx as HCodeResult,
  nH as HColorInput,
  wT as HColorPicker,
  V$ as HContentSaveButton,
  lw as HFileUploadButton,
  h9 as HHighlightInput,
  Bt as HIcon,
  OK as HImagePicker,
  p_ as HImagePreview,
  dH as HKVInput,
  yH as HKVResult,
  lk as HLayoutHorizontal,
  ck as HLayoutSingle,
  Wb as HLayoutSplitPane,
  sk as HLayoutVertical,
  rK as HMultiImagePicker,
  YH as HMultilineInput,
  CH as HMultilineResult,
  _T as HSinglelineResult,
  fK as HTerminalView,
  pa as HTextCopyButton,
  xK as HTransform,
  CK as default,
  wK as install
};
/*! Bundled license information:

@he3-kit/ui/dist/index.js:
  (*!
  * VueCodemirror v6.1.1
  * Copyright (c) Surmon. All rights reserved.
  * Released under the MIT License.
  * Surmon
  *)
  (*!
    * shared v9.2.2
    * (c) 2022 kazuya kawaguchi
    * Released under the MIT License.
    *)
  (*!
    * message-compiler v9.2.2
    * (c) 2022 kazuya kawaguchi
    * Released under the MIT License.
    *)
  (*!
    * devtools-if v9.2.2
    * (c) 2022 kazuya kawaguchi
    * Released under the MIT License.
    *)
  (*!
    * core-base v9.2.2
    * (c) 2022 kazuya kawaguchi
    * Released under the MIT License.
    *)
  (*!
    * vue-i18n v9.2.2
    * (c) 2022 kazuya kawaguchi
    * Released under the MIT License.
    *)

@he3-kit/ui/dist/index.js:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=@he3-kit_ui.js.map
