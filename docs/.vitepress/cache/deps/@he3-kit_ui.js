import {
  Fragment,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createVNode,
  defineComponent,
  h,
  inject,
  nextTick,
  normalizeStyle,
  onBeforeMount,
  onBeforeUnmount,
  onMounted,
  openBlock,
  popScopeId,
  pushScopeId,
  ref,
  renderSlot,
  resolveComponent,
  shallowRef,
  toDisplayString,
  toRaw,
  unref,
  useCssVars,
  vModelText,
  watch,
  withCtx,
  withDirectives,
  withKeys
} from "./chunk-R647EDCJ.js";

// node_modules/@he3-kit/ui/dist/index.js
var Rt = (O, e) => {
  if (O.install = (t) => {
    for (const i of [O, ...Object.values(e ?? {})])
      t.component(i.name, i);
  }, e)
    for (const [t, i] of Object.entries(e))
      O[t] = i;
  return O;
};
var Pg = (O) => (pushScopeId("data-v-d9294b3a"), O = O(), popScopeId(), O);
var yg = Pg(() => createBaseVNode("div", null, null, -1));
var Xg = {
  name: "HLayoutVertical"
};
var xg = defineComponent({
  ...Xg,
  props: {
    mode: { default: "middle" },
    width: { default: 300 }
  },
  setup(O) {
    const e = O, t = ref({
      above: `${e.width}px 20px calc(100% - 20px - ${e.width}px)`,
      middle: "49% 2% 49%",
      below: `calc(100% - 20px - ${e.width}px) 20px ${e.width}px`
    });
    return (i, n) => (openBlock(), createElementBlock("div", {
      class: "wrap",
      style: normalizeStyle(`grid-template-rows: ${t.value[e.mode]};`)
    }, [
      createBaseVNode("div", null, [
        renderSlot(i.$slots, "above", {}, void 0, true)
      ]),
      yg,
      createBaseVNode("div", null, [
        renderSlot(i.$slots, "below", {}, void 0, true)
      ])
    ], 4));
  }
});
var ln = (O, e) => {
  const t = O.__vccOpts || O;
  for (const [i, n] of e)
    t[i] = n;
  return t;
};
var bg = ln(xg, [["__scopeId", "data-v-d9294b3a"]]);
var wg = (O) => (pushScopeId("data-v-dcbb783a"), O = O(), popScopeId(), O);
var Tg = wg(() => createBaseVNode("div", null, null, -1));
var Wg = {
  name: "HLayoutHorizontal"
};
var vg = defineComponent({
  ...Wg,
  props: {
    mode: { default: "middle" },
    width: { default: 300 }
  },
  setup(O) {
    const e = O, t = ref({
      left: `${e.width}px 20px calc(100% - 20px - ${e.width}px)`,
      middle: "49% 2% 49%",
      right: `calc(100% - 20px - ${e.width}px) 20px ${e.width}px`
    });
    return (i, n) => (openBlock(), createElementBlock("div", {
      class: "wrap",
      style: normalizeStyle(`grid-template-columns: ${t.value[e.mode]};`)
    }, [
      createBaseVNode("div", null, [
        renderSlot(i.$slots, "left", {}, void 0, true)
      ]),
      Tg,
      createBaseVNode("div", null, [
        renderSlot(i.$slots, "right", {}, void 0, true)
      ])
    ], 4));
  }
});
var kg = ln(vg, [["__scopeId", "data-v-dcbb783a"]]);
var Yg = {
  name: "HLayoutSingle"
};
var Zg = defineComponent({
  ...Yg,
  props: {
    mode: { default: "middle" },
    width: { default: 600 }
  },
  setup(O) {
    const e = O, t = {
      left: "flex-start",
      middle: "center",
      right: "flex-end"
    };
    return (i, n) => (openBlock(), createElementBlock("div", {
      class: "layout-wrapper",
      style: normalizeStyle(`justify-content: ${t[e.mode]}`)
    }, [
      createBaseVNode("div", {
        style: normalizeStyle(`max-width: ${e.width}px`)
      }, [
        renderSlot(i.$slots, "default", {}, void 0, true)
      ], 4)
    ], 4));
  }
});
var qg = ln(Zg, [["__scopeId", "data-v-a7cd2de0"]]);
var zg = {
  name: "splitpanes",
  emits: ["ready", "resize", "resized", "pane-click", "pane-maximize", "pane-add", "pane-remove", "splitter-click"],
  props: {
    horizontal: { type: Boolean },
    pushOtherPanes: { type: Boolean, default: true },
    dblClickSplitter: { type: Boolean, default: true },
    rtl: { type: Boolean, default: false },
    firstSplitter: { type: Boolean }
  },
  provide() {
    return {
      requestUpdate: this.requestUpdate,
      onPaneAdd: this.onPaneAdd,
      onPaneRemove: this.onPaneRemove,
      onPaneClick: this.onPaneClick
    };
  },
  data: () => ({
    container: null,
    ready: false,
    panes: [],
    touch: {
      mouseDown: false,
      dragging: false,
      activeSplitter: null
    },
    splitterTaps: {
      splitter: null,
      timeoutId: null
    }
  }),
  computed: {
    panesCount() {
      return this.panes.length;
    },
    indexedPanes() {
      return this.panes.reduce((O, e) => (O[e.id] = e) && O, {});
    }
  },
  methods: {
    updatePaneComponents() {
      this.panes.forEach((O) => {
        O.update && O.update({
          [this.horizontal ? "height" : "width"]: `${this.indexedPanes[O.id].size}%`
        });
      });
    },
    bindEvents() {
      document.addEventListener("mousemove", this.onMouseMove, { passive: false }), document.addEventListener("mouseup", this.onMouseUp), "ontouchstart" in window && (document.addEventListener("touchmove", this.onMouseMove, { passive: false }), document.addEventListener("touchend", this.onMouseUp));
    },
    unbindEvents() {
      document.removeEventListener("mousemove", this.onMouseMove, { passive: false }), document.removeEventListener("mouseup", this.onMouseUp), "ontouchstart" in window && (document.removeEventListener("touchmove", this.onMouseMove, { passive: false }), document.removeEventListener("touchend", this.onMouseUp));
    },
    onMouseDown(O, e) {
      this.bindEvents(), this.touch.mouseDown = true, this.touch.activeSplitter = e;
    },
    onMouseMove(O) {
      this.touch.mouseDown && (O.preventDefault(), this.touch.dragging = true, this.calculatePanesSize(this.getCurrentMouseDrag(O)), this.$emit("resize", this.panes.map((e) => ({ min: e.min, max: e.max, size: e.size }))));
    },
    onMouseUp() {
      this.touch.dragging && this.$emit("resized", this.panes.map((O) => ({ min: O.min, max: O.max, size: O.size }))), this.touch.mouseDown = false, setTimeout(() => {
        this.touch.dragging = false, this.unbindEvents();
      }, 100);
    },
    onSplitterClick(O, e) {
      "ontouchstart" in window && (O.preventDefault(), this.dblClickSplitter && (this.splitterTaps.splitter === e ? (clearTimeout(this.splitterTaps.timeoutId), this.splitterTaps.timeoutId = null, this.onSplitterDblClick(O, e), this.splitterTaps.splitter = null) : (this.splitterTaps.splitter = e, this.splitterTaps.timeoutId = setTimeout(() => {
        this.splitterTaps.splitter = null;
      }, 500)))), this.touch.dragging || this.$emit("splitter-click", this.panes[e]);
    },
    onSplitterDblClick(O, e) {
      let t = 0;
      this.panes = this.panes.map((i, n) => (i.size = n === e ? i.max : i.min, n !== e && (t += i.min), i)), this.panes[e].size -= t, this.$emit("pane-maximize", this.panes[e]), this.$emit("resized", this.panes.map((i) => ({ min: i.min, max: i.max, size: i.size })));
    },
    onPaneClick(O, e) {
      this.$emit("pane-click", this.indexedPanes[e]);
    },
    getCurrentMouseDrag(O) {
      const e = this.container.getBoundingClientRect(), { clientX: t, clientY: i } = "ontouchstart" in window && O.touches ? O.touches[0] : O;
      return {
        x: t - e.left,
        y: i - e.top
      };
    },
    getCurrentDragPercentage(O) {
      O = O[this.horizontal ? "y" : "x"];
      const e = this.container[this.horizontal ? "clientHeight" : "clientWidth"];
      return this.rtl && !this.horizontal && (O = e - O), O * 100 / e;
    },
    calculatePanesSize(O) {
      const e = this.touch.activeSplitter;
      let t = {
        prevPanesSize: this.sumPrevPanesSize(e),
        nextPanesSize: this.sumNextPanesSize(e),
        prevReachedMinPanes: 0,
        nextReachedMinPanes: 0
      };
      const i = 0 + (this.pushOtherPanes ? 0 : t.prevPanesSize), n = 100 - (this.pushOtherPanes ? 0 : t.nextPanesSize), r = Math.max(Math.min(this.getCurrentDragPercentage(O), n), i);
      let s = [e, e + 1], o = this.panes[s[0]] || null, a = this.panes[s[1]] || null;
      const l = o.max < 100 && r >= o.max + t.prevPanesSize, h2 = a.max < 100 && r <= 100 - (a.max + this.sumNextPanesSize(e + 1));
      if (l || h2) {
        l ? (o.size = o.max, a.size = Math.max(100 - o.max - t.prevPanesSize - t.nextPanesSize, 0)) : (o.size = Math.max(100 - a.max - t.prevPanesSize - this.sumNextPanesSize(e + 1), 0), a.size = a.max);
        return;
      }
      if (this.pushOtherPanes) {
        const u = this.doPushOtherPanes(t, r);
        if (!u)
          return;
        ({ sums: t, panesToResize: s } = u), o = this.panes[s[0]] || null, a = this.panes[s[1]] || null;
      }
      o !== null && (o.size = Math.min(Math.max(r - t.prevPanesSize - t.prevReachedMinPanes, o.min), o.max)), a !== null && (a.size = Math.min(Math.max(100 - r - t.nextPanesSize - t.nextReachedMinPanes, a.min), a.max));
    },
    doPushOtherPanes(O, e) {
      const t = this.touch.activeSplitter, i = [t, t + 1];
      return e < O.prevPanesSize + this.panes[i[0]].min && (i[0] = this.findPrevExpandedPane(t).index, O.prevReachedMinPanes = 0, i[0] < t && this.panes.forEach((n, r) => {
        r > i[0] && r <= t && (n.size = n.min, O.prevReachedMinPanes += n.min);
      }), O.prevPanesSize = this.sumPrevPanesSize(i[0]), i[0] === void 0) ? (O.prevReachedMinPanes = 0, this.panes[0].size = this.panes[0].min, this.panes.forEach((n, r) => {
        r > 0 && r <= t && (n.size = n.min, O.prevReachedMinPanes += n.min);
      }), this.panes[i[1]].size = 100 - O.prevReachedMinPanes - this.panes[0].min - O.prevPanesSize - O.nextPanesSize, null) : e > 100 - O.nextPanesSize - this.panes[i[1]].min && (i[1] = this.findNextExpandedPane(t).index, O.nextReachedMinPanes = 0, i[1] > t + 1 && this.panes.forEach((n, r) => {
        r > t && r < i[1] && (n.size = n.min, O.nextReachedMinPanes += n.min);
      }), O.nextPanesSize = this.sumNextPanesSize(i[1] - 1), i[1] === void 0) ? (O.nextReachedMinPanes = 0, this.panes[this.panesCount - 1].size = this.panes[this.panesCount - 1].min, this.panes.forEach((n, r) => {
        r < this.panesCount - 1 && r >= t + 1 && (n.size = n.min, O.nextReachedMinPanes += n.min);
      }), this.panes[i[0]].size = 100 - O.prevPanesSize - O.nextReachedMinPanes - this.panes[this.panesCount - 1].min - O.nextPanesSize, null) : { sums: O, panesToResize: i };
    },
    sumPrevPanesSize(O) {
      return this.panes.reduce((e, t, i) => e + (i < O ? t.size : 0), 0);
    },
    sumNextPanesSize(O) {
      return this.panes.reduce((e, t, i) => e + (i > O + 1 ? t.size : 0), 0);
    },
    findPrevExpandedPane(O) {
      return [...this.panes].reverse().find((e) => e.index < O && e.size > e.min) || {};
    },
    findNextExpandedPane(O) {
      return this.panes.find((e) => e.index > O + 1 && e.size > e.min) || {};
    },
    checkSplitpanesNodes() {
      Array.from(this.container.children).forEach((O) => {
        const e = O.classList.contains("splitpanes__pane"), t = O.classList.contains("splitpanes__splitter");
        !e && !t && (O.parentNode.removeChild(O), console.warn("Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed."));
      });
    },
    addSplitter(O, e, t = false) {
      const i = O - 1, n = document.createElement("div");
      n.classList.add("splitpanes__splitter"), t || (n.onmousedown = (r) => this.onMouseDown(r, i), typeof window < "u" && "ontouchstart" in window && (n.ontouchstart = (r) => this.onMouseDown(r, i)), n.onclick = (r) => this.onSplitterClick(r, i + 1)), this.dblClickSplitter && (n.ondblclick = (r) => this.onSplitterDblClick(r, i + 1)), e.parentNode.insertBefore(n, e);
    },
    removeSplitter(O) {
      O.onmousedown = void 0, O.onclick = void 0, O.ondblclick = void 0, O.parentNode.removeChild(O);
    },
    redoSplitters() {
      const O = Array.from(this.container.children);
      O.forEach((t) => {
        t.className.includes("splitpanes__splitter") && this.removeSplitter(t);
      });
      let e = 0;
      O.forEach((t) => {
        t.className.includes("splitpanes__pane") && (!e && this.firstSplitter ? this.addSplitter(e, t, true) : e && this.addSplitter(e, t), e++);
      });
    },
    requestUpdate({ target: O, ...e }) {
      const t = this.indexedPanes[O._.uid];
      Object.entries(e).forEach(([i, n]) => t[i] = n);
    },
    onPaneAdd(O) {
      let e = -1;
      Array.from(O.$el.parentNode.children).some((n) => (n.className.includes("splitpanes__pane") && e++, n === O.$el));
      const t = parseFloat(O.minSize), i = parseFloat(O.maxSize);
      this.panes.splice(e, 0, {
        id: O._.uid,
        index: e,
        min: isNaN(t) ? 0 : t,
        max: isNaN(i) ? 100 : i,
        size: O.size === null ? null : parseFloat(O.size),
        givenSize: O.size,
        update: O.update
      }), this.panes.forEach((n, r) => n.index = r), this.ready && this.$nextTick(() => {
        this.redoSplitters(), this.resetPaneSizes({ addedPane: this.panes[e] }), this.$emit("pane-add", { index: e, panes: this.panes.map((n) => ({ min: n.min, max: n.max, size: n.size })) });
      });
    },
    onPaneRemove(O) {
      const e = this.panes.findIndex((i) => i.id === O._.uid), t = this.panes.splice(e, 1)[0];
      this.panes.forEach((i, n) => i.index = n), this.$nextTick(() => {
        this.redoSplitters(), this.resetPaneSizes({ removedPane: { ...t, index: e } }), this.$emit("pane-remove", { removed: t, panes: this.panes.map((i) => ({ min: i.min, max: i.max, size: i.size })) });
      });
    },
    resetPaneSizes(O = {}) {
      !O.addedPane && !O.removedPane ? this.initialPanesSizing() : this.panes.some((e) => e.givenSize !== null || e.min || e.max < 100) ? this.equalizeAfterAddOrRemove(O) : this.equalize(), this.ready && this.$emit("resized", this.panes.map((e) => ({ min: e.min, max: e.max, size: e.size })));
    },
    equalize() {
      const O = 100 / this.panesCount;
      let e = 0;
      const t = [], i = [];
      this.panes.forEach((n) => {
        n.size = Math.max(Math.min(O, n.max), n.min), e -= n.size, n.size >= n.max && t.push(n.id), n.size <= n.min && i.push(n.id);
      }), e > 0.1 && this.readjustSizes(e, t, i);
    },
    initialPanesSizing() {
      let O = 100;
      const e = [], t = [];
      let i = 0;
      this.panes.forEach((r) => {
        O -= r.size, r.size !== null && i++, r.size >= r.max && e.push(r.id), r.size <= r.min && t.push(r.id);
      });
      let n = 100;
      O > 0.1 && (this.panes.forEach((r) => {
        r.size === null && (r.size = Math.max(Math.min(O / (this.panesCount - i), r.max), r.min)), n -= r.size;
      }), n > 0.1 && this.readjustSizes(O, e, t));
    },
    equalizeAfterAddOrRemove({ addedPane: O, removedPane: e } = {}) {
      let t = 100 / this.panesCount, i = 0;
      const n = [], r = [];
      O && O.givenSize !== null && (t = (100 - O.givenSize) / (this.panesCount - 1)), this.panes.forEach((s) => {
        i -= s.size, s.size >= s.max && n.push(s.id), s.size <= s.min && r.push(s.id);
      }), !(Math.abs(i) < 0.1) && (this.panes.forEach((s) => {
        O && O.givenSize !== null && O.id === s.id || (s.size = Math.max(Math.min(t, s.max), s.min)), i -= s.size, s.size >= s.max && n.push(s.id), s.size <= s.min && r.push(s.id);
      }), i > 0.1 && this.readjustSizes(i, n, r));
    },
    readjustSizes(O, e, t) {
      let i;
      O > 0 ? i = O / (this.panesCount - e.length) : i = O / (this.panesCount - t.length), this.panes.forEach((n, r) => {
        if (O > 0 && !e.includes(n.id)) {
          const s = Math.max(Math.min(n.size + i, n.max), n.min), o = s - n.size;
          O -= o, n.size = s;
        } else if (!t.includes(n.id)) {
          const s = Math.max(Math.min(n.size + i, n.max), n.min), o = s - n.size;
          O -= o, n.size = s;
        }
        n.update({
          [this.horizontal ? "height" : "width"]: `${this.indexedPanes[n.id].size}%`
        });
      }), Math.abs(O) > 0.1 && this.$nextTick(() => {
        this.ready && console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
      });
    }
  },
  watch: {
    panes: {
      deep: true,
      immediate: false,
      handler() {
        this.updatePaneComponents();
      }
    },
    horizontal() {
      this.updatePaneComponents();
    },
    firstSplitter() {
      this.redoSplitters();
    },
    dblClickSplitter(O) {
      [...this.container.querySelectorAll(".splitpanes__splitter")].forEach((e, t) => {
        e.ondblclick = O ? (i) => this.onSplitterDblClick(i, t) : void 0;
      });
    }
  },
  beforeUnmount() {
    this.ready = false;
  },
  mounted() {
    this.container = this.$refs.container, this.checkSplitpanesNodes(), this.redoSplitters(), this.resetPaneSizes(), this.$emit("ready"), this.ready = true;
  },
  render() {
    return h(
      "div",
      {
        ref: "container",
        class: [
          "splitpanes",
          `splitpanes--${this.horizontal ? "horizontal" : "vertical"}`,
          {
            "splitpanes--dragging": this.touch.dragging
          }
        ]
      },
      this.$slots.default()
    );
  }
};
var Ug = (O, e) => {
  const t = O.__vccOpts || O;
  for (const [i, n] of e)
    t[i] = n;
  return t;
};
var Vg = {
  name: "pane",
  inject: ["requestUpdate", "onPaneAdd", "onPaneRemove", "onPaneClick"],
  props: {
    size: { type: [Number, String], default: null },
    minSize: { type: [Number, String], default: 0 },
    maxSize: { type: [Number, String], default: 100 }
  },
  data: () => ({
    style: {}
  }),
  mounted() {
    this.onPaneAdd(this);
  },
  beforeUnmount() {
    this.onPaneRemove(this);
  },
  methods: {
    update(O) {
      this.style = O;
    }
  },
  computed: {
    sizeNumber() {
      return this.size || this.size === 0 ? parseFloat(this.size) : null;
    },
    minSizeNumber() {
      return parseFloat(this.minSize);
    },
    maxSizeNumber() {
      return parseFloat(this.maxSize);
    }
  },
  watch: {
    sizeNumber(O) {
      this.requestUpdate({ target: this, size: O });
    },
    minSizeNumber(O) {
      this.requestUpdate({ target: this, min: O });
    },
    maxSizeNumber(O) {
      this.requestUpdate({ target: this, max: O });
    }
  }
};
function Rg(O, e, t, i, n, r) {
  return openBlock(), createElementBlock("div", {
    class: "splitpanes__pane",
    onClick: e[0] || (e[0] = (s) => r.onPaneClick(s, O._.uid)),
    style: normalizeStyle(O.style)
  }, [
    renderSlot(O.$slots, "default")
  ], 4);
}
var pc = Ug(Vg, [["render", Rg]]);
var _g = { class: "horizontal-leftside" };
var jg = { class: "horizontal-rightside" };
var Cg = {
  name: "HLayoutSplitPane"
};
var Gg = defineComponent({
  ...Cg,
  setup(O) {
    return (e, t) => (openBlock(), createBlock(unref(zg), { class: "horizontal he3-theme" }, {
      default: withCtx(() => [
        createVNode(unref(pc), { "min-size": "20" }, {
          default: withCtx(() => [
            createBaseVNode("div", _g, [
              renderSlot(e.$slots, "left")
            ])
          ]),
          _: 3
        }),
        createVNode(unref(pc), { "min-size": "20" }, {
          default: withCtx(() => [
            createBaseVNode("div", jg, [
              renderSlot(e.$slots, "right")
            ])
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
});
var Ig = Rt(bg);
var Eg = Rt(kg);
var Ag = Rt(qg);
var Dg = Rt(Gg);
var vi = /^[a-z0-9]+(-[a-z0-9]+)*$/;
var is = (O, e, t, i = "") => {
  const n = O.split(":");
  if (O.slice(0, 1) === "@") {
    if (n.length < 2 || n.length > 3)
      return null;
    i = n.shift().slice(1);
  }
  if (n.length > 3 || !n.length)
    return null;
  if (n.length > 1) {
    const o = n.pop(), a = n.pop(), l = {
      provider: n.length > 0 ? n[0] : i,
      prefix: a,
      name: o
    };
    return e && !er(l) ? null : l;
  }
  const r = n[0], s = r.split("-");
  if (s.length > 1) {
    const o = {
      provider: i,
      prefix: s.shift(),
      name: s.join("-")
    };
    return e && !er(o) ? null : o;
  }
  if (t && i === "") {
    const o = {
      provider: i,
      prefix: "",
      name: r
    };
    return e && !er(o, t) ? null : o;
  }
  return null;
};
var er = (O, e) => O ? !!((O.provider === "" || O.provider.match(vi)) && (e && O.prefix === "" || O.prefix.match(vi)) && O.name.match(vi)) : false;
var fd = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
);
var Pr = Object.freeze({
  rotate: 0,
  vFlip: false,
  hFlip: false
});
var ns = Object.freeze({
  ...fd,
  ...Pr
});
var zo = Object.freeze({
  ...ns,
  body: "",
  hidden: false
});
function Mg(O, e) {
  const t = {};
  !O.hFlip != !e.hFlip && (t.hFlip = true), !O.vFlip != !e.vFlip && (t.vFlip = true);
  const i = ((O.rotate || 0) + (e.rotate || 0)) % 4;
  return i && (t.rotate = i), t;
}
function mc(O, e) {
  const t = Mg(O, e);
  for (const i in zo)
    i in Pr ? i in O && !(i in t) && (t[i] = Pr[i]) : i in e ? t[i] = e[i] : i in O && (t[i] = O[i]);
  return t;
}
function Lg(O, e) {
  const t = O.icons, i = O.aliases || /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  function r(s) {
    if (t[s])
      return n[s] = [];
    if (!(s in n)) {
      n[s] = null;
      const o = i[s] && i[s].parent, a = o && r(o);
      a && (n[s] = [o].concat(a));
    }
    return n[s];
  }
  return (e || Object.keys(t).concat(Object.keys(i))).forEach(r), n;
}
function Bg(O, e, t) {
  const i = O.icons, n = O.aliases || /* @__PURE__ */ Object.create(null);
  let r = {};
  function s(o) {
    r = mc(
      i[o] || n[o],
      r
    );
  }
  return s(e), t.forEach(s), mc(O, r);
}
function dd(O, e) {
  const t = [];
  if (typeof O != "object" || typeof O.icons != "object")
    return t;
  O.not_found instanceof Array && O.not_found.forEach((n) => {
    e(n, null), t.push(n);
  });
  const i = Lg(O);
  for (const n in i) {
    const r = i[n];
    r && (e(n, Bg(O, n, r)), t.push(n));
  }
  return t;
}
var Ng = {
  provider: "",
  aliases: {},
  not_found: {},
  ...fd
};
function qs(O, e) {
  for (const t in e)
    if (t in O && typeof O[t] != typeof e[t])
      return false;
  return true;
}
function Qd(O) {
  if (typeof O != "object" || O === null)
    return null;
  const e = O;
  if (typeof e.prefix != "string" || !O.icons || typeof O.icons != "object" || !qs(O, Ng))
    return null;
  const t = e.icons;
  for (const n in t) {
    const r = t[n];
    if (!n.match(vi) || typeof r.body != "string" || !qs(
      r,
      zo
    ))
      return null;
  }
  const i = e.aliases || /* @__PURE__ */ Object.create(null);
  for (const n in i) {
    const r = i[n], s = r.parent;
    if (!n.match(vi) || typeof s != "string" || !t[s] && !i[s] || !qs(
      r,
      zo
    ))
      return null;
  }
  return e;
}
var gc = /* @__PURE__ */ Object.create(null);
function Fg(O, e) {
  return {
    provider: O,
    prefix: e,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function SO(O, e) {
  const t = gc[O] || (gc[O] = /* @__PURE__ */ Object.create(null));
  return t[e] || (t[e] = Fg(O, e));
}
function il(O, e) {
  return Qd(e) ? dd(e, (t, i) => {
    i ? O.icons[t] = i : O.missing.add(t);
  }) : [];
}
function Hg(O, e, t) {
  try {
    if (typeof t.body == "string")
      return O.icons[e] = { ...t }, true;
  } catch {
  }
  return false;
}
var _i = false;
function $d(O) {
  return typeof O == "boolean" && (_i = O), _i;
}
function Kg(O) {
  const e = typeof O == "string" ? is(O, true, _i) : O;
  if (e) {
    const t = SO(e.provider, e.prefix), i = e.name;
    return t.icons[i] || (t.missing.has(i) ? null : void 0);
  }
}
function Jg(O, e) {
  const t = is(O, true, _i);
  if (!t)
    return false;
  const i = SO(t.provider, t.prefix);
  return Hg(i, t.name, e);
}
function eS(O, e) {
  if (typeof O != "object")
    return false;
  if (typeof e != "string" && (e = O.provider || ""), _i && !e && !O.prefix) {
    let n = false;
    return Qd(O) && (O.prefix = "", dd(O, (r, s) => {
      s && Jg(r, s) && (n = true);
    })), n;
  }
  const t = O.prefix;
  if (!er({
    provider: e,
    prefix: t,
    name: "a"
  }))
    return false;
  const i = SO(e, t);
  return !!il(i, O);
}
var pd = Object.freeze({
  width: null,
  height: null
});
var md = Object.freeze({
  ...pd,
  ...Pr
});
var tS = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
var OS = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function Sc(O, e, t) {
  if (e === 1)
    return O;
  if (t = t || 100, typeof O == "number")
    return Math.ceil(O * e * t) / t;
  if (typeof O != "string")
    return O;
  const i = O.split(tS);
  if (i === null || !i.length)
    return O;
  const n = [];
  let r = i.shift(), s = OS.test(r);
  for (; ; ) {
    if (s) {
      const o = parseFloat(r);
      isNaN(o) ? n.push(r) : n.push(Math.ceil(o * e * t) / t);
    } else
      n.push(r);
    if (r = i.shift(), r === void 0)
      return n.join("");
    s = !s;
  }
}
var iS = (O) => O === "unset" || O === "undefined" || O === "none";
function nS(O, e) {
  const t = {
    ...ns,
    ...O
  }, i = {
    ...md,
    ...e
  }, n = {
    left: t.left,
    top: t.top,
    width: t.width,
    height: t.height
  };
  let r = t.body;
  [t, i].forEach((Q) => {
    const $ = [], p = Q.hFlip, m = Q.vFlip;
    let g = Q.rotate;
    p ? m ? g += 2 : ($.push(
      "translate(" + (n.width + n.left).toString() + " " + (0 - n.top).toString() + ")"
    ), $.push("scale(-1 1)"), n.top = n.left = 0) : m && ($.push(
      "translate(" + (0 - n.left).toString() + " " + (n.height + n.top).toString() + ")"
    ), $.push("scale(1 -1)"), n.top = n.left = 0);
    let b;
    switch (g < 0 && (g -= Math.floor(g / 4) * 4), g = g % 4, g) {
      case 1:
        b = n.height / 2 + n.top, $.unshift(
          "rotate(90 " + b.toString() + " " + b.toString() + ")"
        );
        break;
      case 2:
        $.unshift(
          "rotate(180 " + (n.width / 2 + n.left).toString() + " " + (n.height / 2 + n.top).toString() + ")"
        );
        break;
      case 3:
        b = n.width / 2 + n.left, $.unshift(
          "rotate(-90 " + b.toString() + " " + b.toString() + ")"
        );
        break;
    }
    g % 2 === 1 && (n.left !== n.top && (b = n.left, n.left = n.top, n.top = b), n.width !== n.height && (b = n.width, n.width = n.height, n.height = b)), $.length && (r = '<g transform="' + $.join(" ") + '">' + r + "</g>");
  });
  const s = i.width, o = i.height, a = n.width, l = n.height;
  let h2, u;
  s === null ? (u = o === null ? "1em" : o === "auto" ? l : o, h2 = Sc(u, a / l)) : (h2 = s === "auto" ? a : s, u = o === null ? Sc(h2, l / a) : o === "auto" ? l : o);
  const f = {}, d = (Q, $) => {
    iS($) || (f[Q] = $.toString());
  };
  return d("width", h2), d("height", u), f.viewBox = n.left.toString() + " " + n.top.toString() + " " + a.toString() + " " + l.toString(), {
    attributes: f,
    body: r
  };
}
var rS = /\sid="(\S+)"/g;
var sS = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
var oS = 0;
function aS(O, e = sS) {
  const t = [];
  let i;
  for (; i = rS.exec(O); )
    t.push(i[1]);
  if (!t.length)
    return O;
  const n = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return t.forEach((r) => {
    const s = typeof e == "function" ? e(r) : e + (oS++).toString(), o = r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    O = O.replace(
      new RegExp('([#;"])(' + o + ')([")]|\\.[a-z])', "g"),
      "$1" + s + n + "$3"
    );
  }), O = O.replace(new RegExp(n, "g"), ""), O;
}
var Uo = /* @__PURE__ */ Object.create(null);
function lS(O, e) {
  Uo[O] = e;
}
function Vo(O) {
  return Uo[O] || Uo[""];
}
function nl(O) {
  let e;
  if (typeof O.resources == "string")
    e = [O.resources];
  else if (e = O.resources, !(e instanceof Array) || !e.length)
    return null;
  return {
    resources: e,
    path: O.path || "/",
    maxURL: O.maxURL || 500,
    rotate: O.rotate || 750,
    timeout: O.timeout || 5e3,
    random: O.random === true,
    index: O.index || 0,
    dataAfterTimeout: O.dataAfterTimeout !== false
  };
}
var rl = /* @__PURE__ */ Object.create(null);
var li = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
];
var tr = [];
for (; li.length > 0; )
  li.length === 1 || Math.random() > 0.5 ? tr.push(li.shift()) : tr.push(li.pop());
rl[""] = nl({
  resources: ["https://api.iconify.design"].concat(tr)
});
function cS(O, e) {
  const t = nl(e);
  return t === null ? false : (rl[O] = t, true);
}
function sl(O) {
  return rl[O];
}
var hS = () => {
  let O;
  try {
    if (O = fetch, typeof O == "function")
      return O;
  } catch {
  }
};
var Pc = hS();
function uS(O, e) {
  const t = sl(O);
  if (!t)
    return 0;
  let i;
  if (!t.maxURL)
    i = 0;
  else {
    let n = 0;
    t.resources.forEach((s) => {
      n = Math.max(n, s.length);
    });
    const r = e + ".json?icons=";
    i = t.maxURL - n - t.path.length - r.length;
  }
  return i;
}
function fS(O) {
  return O === 404;
}
var dS = (O, e, t) => {
  const i = [], n = uS(O, e), r = "icons";
  let s = {
    type: r,
    provider: O,
    prefix: e,
    icons: []
  }, o = 0;
  return t.forEach((a, l) => {
    o += a.length + 1, o >= n && l > 0 && (i.push(s), s = {
      type: r,
      provider: O,
      prefix: e,
      icons: []
    }, o = a.length), s.icons.push(a);
  }), i.push(s), i;
};
function QS(O) {
  if (typeof O == "string") {
    const e = sl(O);
    if (e)
      return e.path;
  }
  return "/";
}
var $S = (O, e, t) => {
  if (!Pc) {
    t("abort", 424);
    return;
  }
  let i = QS(e.provider);
  switch (e.type) {
    case "icons": {
      const r = e.prefix, o = e.icons.join(","), a = new URLSearchParams({
        icons: o
      });
      i += r + ".json?" + a.toString();
      break;
    }
    case "custom": {
      const r = e.uri;
      i += r.slice(0, 1) === "/" ? r.slice(1) : r;
      break;
    }
    default:
      t("abort", 400);
      return;
  }
  let n = 503;
  Pc(O + i).then((r) => {
    const s = r.status;
    if (s !== 200) {
      setTimeout(() => {
        t(fS(s) ? "abort" : "next", s);
      });
      return;
    }
    return n = 501, r.json();
  }).then((r) => {
    if (typeof r != "object" || r === null) {
      setTimeout(() => {
        r === 404 ? t("abort", r) : t("next", n);
      });
      return;
    }
    setTimeout(() => {
      t("success", r);
    });
  }).catch(() => {
    t("next", n);
  });
};
var pS = {
  prepare: dS,
  send: $S
};
function mS(O) {
  const e = {
    loaded: [],
    missing: [],
    pending: []
  }, t = /* @__PURE__ */ Object.create(null);
  O.sort((n, r) => n.provider !== r.provider ? n.provider.localeCompare(r.provider) : n.prefix !== r.prefix ? n.prefix.localeCompare(r.prefix) : n.name.localeCompare(r.name));
  let i = {
    provider: "",
    prefix: "",
    name: ""
  };
  return O.forEach((n) => {
    if (i.name === n.name && i.prefix === n.prefix && i.provider === n.provider)
      return;
    i = n;
    const r = n.provider, s = n.prefix, o = n.name, a = t[r] || (t[r] = /* @__PURE__ */ Object.create(null)), l = a[s] || (a[s] = SO(r, s));
    let h2;
    o in l.icons ? h2 = e.loaded : s === "" || l.missing.has(o) ? h2 = e.missing : h2 = e.pending;
    const u = {
      provider: r,
      prefix: s,
      name: o
    };
    h2.push(u);
  }), e;
}
function gd(O, e) {
  O.forEach((t) => {
    const i = t.loaderCallbacks;
    i && (t.loaderCallbacks = i.filter((n) => n.id !== e));
  });
}
function gS(O) {
  O.pendingCallbacksFlag || (O.pendingCallbacksFlag = true, setTimeout(() => {
    O.pendingCallbacksFlag = false;
    const e = O.loaderCallbacks ? O.loaderCallbacks.slice(0) : [];
    if (!e.length)
      return;
    let t = false;
    const i = O.provider, n = O.prefix;
    e.forEach((r) => {
      const s = r.icons, o = s.pending.length;
      s.pending = s.pending.filter((a) => {
        if (a.prefix !== n)
          return true;
        const l = a.name;
        if (O.icons[l])
          s.loaded.push({
            provider: i,
            prefix: n,
            name: l
          });
        else if (O.missing.has(l))
          s.missing.push({
            provider: i,
            prefix: n,
            name: l
          });
        else
          return t = true, true;
        return false;
      }), s.pending.length !== o && (t || gd([O], r.id), r.callback(
        s.loaded.slice(0),
        s.missing.slice(0),
        s.pending.slice(0),
        r.abort
      ));
    });
  }));
}
var SS = 0;
function PS(O, e, t) {
  const i = SS++, n = gd.bind(null, t, i);
  if (!e.pending.length)
    return n;
  const r = {
    id: i,
    icons: e,
    callback: O,
    abort: n
  };
  return t.forEach((s) => {
    (s.loaderCallbacks || (s.loaderCallbacks = [])).push(r);
  }), n;
}
function yS(O, e = true, t = false) {
  const i = [];
  return O.forEach((n) => {
    const r = typeof n == "string" ? is(n, e, t) : n;
    r && i.push(r);
  }), i;
}
var XS = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: false,
  dataAfterTimeout: false
};
function xS(O, e, t, i) {
  const n = O.resources.length, r = O.random ? Math.floor(Math.random() * n) : O.index;
  let s;
  if (O.random) {
    let P = O.resources.slice(0);
    for (s = []; P.length > 1; ) {
      const z = Math.floor(Math.random() * P.length);
      s.push(P[z]), P = P.slice(0, z).concat(P.slice(z + 1));
    }
    s = s.concat(P);
  } else
    s = O.resources.slice(r).concat(O.resources.slice(0, r));
  const o = Date.now();
  let a = "pending", l = 0, h2, u = null, f = [], d = [];
  typeof i == "function" && d.push(i);
  function Q() {
    u && (clearTimeout(u), u = null);
  }
  function $() {
    a === "pending" && (a = "aborted"), Q(), f.forEach((P) => {
      P.status === "pending" && (P.status = "aborted");
    }), f = [];
  }
  function p(P, z) {
    z && (d = []), typeof P == "function" && d.push(P);
  }
  function m() {
    return {
      startTime: o,
      payload: e,
      status: a,
      queriesSent: l,
      queriesPending: f.length,
      subscribe: p,
      abort: $
    };
  }
  function g() {
    a = "failed", d.forEach((P) => {
      P(void 0, h2);
    });
  }
  function b() {
    f.forEach((P) => {
      P.status === "pending" && (P.status = "aborted");
    }), f = [];
  }
  function y(P, z, A) {
    const C = z !== "success";
    switch (f = f.filter((X) => X !== P), a) {
      case "pending":
        break;
      case "failed":
        if (C || !O.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (z === "abort") {
      h2 = A, g();
      return;
    }
    if (C) {
      h2 = A, f.length || (s.length ? w() : g());
      return;
    }
    if (Q(), b(), !O.random) {
      const X = O.resources.indexOf(P.resource);
      X !== -1 && X !== O.index && (O.index = X);
    }
    a = "completed", d.forEach((X) => {
      X(A);
    });
  }
  function w() {
    if (a !== "pending")
      return;
    Q();
    const P = s.shift();
    if (P === void 0) {
      if (f.length) {
        u = setTimeout(() => {
          Q(), a === "pending" && (b(), g());
        }, O.timeout);
        return;
      }
      g();
      return;
    }
    const z = {
      status: "pending",
      resource: P,
      callback: (A, C) => {
        y(z, A, C);
      }
    };
    f.push(z), l++, u = setTimeout(w, O.rotate), t(P, e, z.callback);
  }
  return setTimeout(w), m;
}
function Sd(O) {
  const e = {
    ...XS,
    ...O
  };
  let t = [];
  function i() {
    t = t.filter((o) => o().status === "pending");
  }
  function n(o, a, l) {
    const h2 = xS(
      e,
      o,
      a,
      (u, f) => {
        i(), l && l(u, f);
      }
    );
    return t.push(h2), h2;
  }
  function r(o) {
    return t.find((a) => o(a)) || null;
  }
  return {
    query: n,
    find: r,
    setIndex: (o) => {
      e.index = o;
    },
    getIndex: () => e.index,
    cleanup: i
  };
}
function yc() {
}
var zs = /* @__PURE__ */ Object.create(null);
function bS(O) {
  if (!zs[O]) {
    const e = sl(O);
    if (!e)
      return;
    const t = Sd(e), i = {
      config: e,
      redundancy: t
    };
    zs[O] = i;
  }
  return zs[O];
}
function wS(O, e, t) {
  let i, n;
  if (typeof O == "string") {
    const r = Vo(O);
    if (!r)
      return t(void 0, 424), yc;
    n = r.send;
    const s = bS(O);
    s && (i = s.redundancy);
  } else {
    const r = nl(O);
    if (r) {
      i = Sd(r);
      const s = O.resources ? O.resources[0] : "", o = Vo(s);
      o && (n = o.send);
    }
  }
  return !i || !n ? (t(void 0, 424), yc) : i.query(e, n, t)().abort;
}
var Xc = "iconify2";
var ji = "iconify";
var Pd = ji + "-count";
var xc = ji + "-version";
var yd = 36e5;
var TS = 168;
function Ro(O, e) {
  try {
    return O.getItem(e);
  } catch {
  }
}
function ol(O, e, t) {
  try {
    return O.setItem(e, t), true;
  } catch {
  }
}
function bc(O, e) {
  try {
    O.removeItem(e);
  } catch {
  }
}
function _o(O, e) {
  return ol(O, Pd, e.toString());
}
function jo(O) {
  return parseInt(Ro(O, Pd)) || 0;
}
var rs = {
  local: true,
  session: true
};
var Xd = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
var al = false;
function WS(O) {
  al = O;
}
var yn = typeof window > "u" ? {} : window;
function xd(O) {
  const e = O + "Storage";
  try {
    if (yn && yn[e] && typeof yn[e].length == "number")
      return yn[e];
  } catch {
  }
  rs[O] = false;
}
function bd(O, e) {
  const t = xd(O);
  if (!t)
    return;
  const i = Ro(t, xc);
  if (i !== Xc) {
    if (i) {
      const o = jo(t);
      for (let a = 0; a < o; a++)
        bc(t, ji + a.toString());
    }
    ol(t, xc, Xc), _o(t, 0);
    return;
  }
  const n = Math.floor(Date.now() / yd) - TS, r = (o) => {
    const a = ji + o.toString(), l = Ro(t, a);
    if (typeof l == "string") {
      try {
        const h2 = JSON.parse(l);
        if (typeof h2 == "object" && typeof h2.cached == "number" && h2.cached > n && typeof h2.provider == "string" && typeof h2.data == "object" && typeof h2.data.prefix == "string" && e(h2, o))
          return true;
      } catch {
      }
      bc(t, a);
    }
  };
  let s = jo(t);
  for (let o = s - 1; o >= 0; o--)
    r(o) || (o === s - 1 ? (s--, _o(t, s)) : Xd[O].add(o));
}
function wd() {
  if (!al) {
    WS(true);
    for (const O in rs)
      bd(O, (e) => {
        const t = e.data, i = e.provider, n = t.prefix, r = SO(
          i,
          n
        );
        if (!il(r, t).length)
          return false;
        const s = t.lastModified || -1;
        return r.lastModifiedCached = r.lastModifiedCached ? Math.min(r.lastModifiedCached, s) : s, true;
      });
  }
}
function vS(O, e) {
  const t = O.lastModifiedCached;
  if (t && t >= e)
    return t === e;
  if (O.lastModifiedCached = e, t)
    for (const i in rs)
      bd(i, (n) => {
        const r = n.data;
        return n.provider !== O.provider || r.prefix !== O.prefix || r.lastModified === e;
      });
  return true;
}
function kS(O, e) {
  al || wd();
  function t(i) {
    let n;
    if (!rs[i] || !(n = xd(i)))
      return;
    const r = Xd[i];
    let s;
    if (r.size)
      r.delete(s = Array.from(r).shift());
    else if (s = jo(n), !_o(n, s + 1))
      return;
    const o = {
      cached: Math.floor(Date.now() / yd),
      provider: O.provider,
      data: e
    };
    return ol(
      n,
      ji + s.toString(),
      JSON.stringify(o)
    );
  }
  e.lastModified && !vS(O, e.lastModified) || Object.keys(e.icons).length && (e.not_found && (e = Object.assign({}, e), delete e.not_found), t("local") || t("session"));
}
function wc() {
}
function YS(O) {
  O.iconsLoaderFlag || (O.iconsLoaderFlag = true, setTimeout(() => {
    O.iconsLoaderFlag = false, gS(O);
  }));
}
function ZS(O, e) {
  O.iconsToLoad ? O.iconsToLoad = O.iconsToLoad.concat(e).sort() : O.iconsToLoad = e, O.iconsQueueFlag || (O.iconsQueueFlag = true, setTimeout(() => {
    O.iconsQueueFlag = false;
    const { provider: t, prefix: i } = O, n = O.iconsToLoad;
    delete O.iconsToLoad;
    let r;
    if (!n || !(r = Vo(t)))
      return;
    r.prepare(t, i, n).forEach((o) => {
      wS(t, o, (a) => {
        if (typeof a != "object")
          o.icons.forEach((l) => {
            O.missing.add(l);
          });
        else
          try {
            const l = il(
              O,
              a
            );
            if (!l.length)
              return;
            const h2 = O.pendingIcons;
            h2 && l.forEach((u) => {
              h2.delete(u);
            }), kS(O, a);
          } catch (l) {
            console.error(l);
          }
        YS(O);
      });
    });
  }));
}
var qS = (O, e) => {
  const t = yS(O, true, $d()), i = mS(t);
  if (!i.pending.length) {
    let a = true;
    return e && setTimeout(() => {
      a && e(
        i.loaded,
        i.missing,
        i.pending,
        wc
      );
    }), () => {
      a = false;
    };
  }
  const n = /* @__PURE__ */ Object.create(null), r = [];
  let s, o;
  return i.pending.forEach((a) => {
    const { provider: l, prefix: h2 } = a;
    if (h2 === o && l === s)
      return;
    s = l, o = h2, r.push(SO(l, h2));
    const u = n[l] || (n[l] = /* @__PURE__ */ Object.create(null));
    u[h2] || (u[h2] = []);
  }), i.pending.forEach((a) => {
    const { provider: l, prefix: h2, name: u } = a, f = SO(l, h2), d = f.pendingIcons || (f.pendingIcons = /* @__PURE__ */ new Set());
    d.has(u) || (d.add(u), n[l][h2].push(u));
  }), r.forEach((a) => {
    const { provider: l, prefix: h2 } = a;
    n[l][h2].length && ZS(a, n[l][h2]);
  }), e ? PS(e, i, r) : wc;
};
function zS(O, e) {
  const t = {
    ...O
  };
  for (const i in e) {
    const n = e[i], r = typeof n;
    i in pd ? (n === null || n && (r === "string" || r === "number")) && (t[i] = n) : r === typeof t[i] && (t[i] = i === "rotate" ? n % 4 : n);
  }
  return t;
}
var US = /[\s,]+/;
function VS(O, e) {
  e.split(US).forEach((t) => {
    switch (t.trim()) {
      case "horizontal":
        O.hFlip = true;
        break;
      case "vertical":
        O.vFlip = true;
        break;
    }
  });
}
function RS(O, e = 0) {
  const t = O.replace(/^-?[0-9.]*/, "");
  function i(n) {
    for (; n < 0; )
      n += 4;
    return n % 4;
  }
  if (t === "") {
    const n = parseInt(O);
    return isNaN(n) ? 0 : i(n);
  } else if (t !== O) {
    let n = 0;
    switch (t) {
      case "%":
        n = 25;
        break;
      case "deg":
        n = 90;
    }
    if (n) {
      let r = parseFloat(O.slice(0, O.length - t.length));
      return isNaN(r) ? 0 : (r = r / n, r % 1 === 0 ? i(r) : 0);
    }
  }
  return e;
}
function _S(O, e) {
  let t = O.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const i in e)
    t += " " + i + '="' + e[i] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + t + ">" + O + "</svg>";
}
function jS(O) {
  return O.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function CS(O) {
  return 'url("data:image/svg+xml,' + jS(O) + '")';
}
var Tc = {
  ...md,
  inline: false
};
var GS = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "aria-hidden": true,
  role: "img"
};
var IS = {
  display: "inline-block"
};
var Co = {
  backgroundColor: "currentColor"
};
var Td = {
  backgroundColor: "transparent"
};
var Wc = {
  Image: "var(--svg)",
  Repeat: "no-repeat",
  Size: "100% 100%"
};
var vc = {
  webkitMask: Co,
  mask: Co,
  background: Td
};
for (const O in vc) {
  const e = vc[O];
  for (const t in Wc)
    e[O + t] = Wc[t];
}
var Or = {};
["horizontal", "vertical"].forEach((O) => {
  const e = O.slice(0, 1) + "Flip";
  Or[O + "-flip"] = e, Or[O.slice(0, 1) + "-flip"] = e, Or[O + "Flip"] = e;
});
function kc(O) {
  return O + (O.match(/^[-0-9.]+$/) ? "px" : "");
}
var Yc = (O, e) => {
  const t = zS(Tc, e), i = { ...GS }, n = e.mode || "svg", r = {}, s = e.style, o = typeof s == "object" && !(s instanceof Array) ? s : {};
  for (let $ in e) {
    const p = e[$];
    if (p !== void 0)
      switch ($) {
        case "icon":
        case "style":
        case "onLoad":
        case "mode":
          break;
        case "inline":
        case "hFlip":
        case "vFlip":
          t[$] = p === true || p === "true" || p === 1;
          break;
        case "flip":
          typeof p == "string" && VS(t, p);
          break;
        case "color":
          r.color = p;
          break;
        case "rotate":
          typeof p == "string" ? t[$] = RS(p) : typeof p == "number" && (t[$] = p);
          break;
        case "ariaHidden":
        case "aria-hidden":
          p !== true && p !== "true" && delete i["aria-hidden"];
          break;
        default: {
          const m = Or[$];
          m ? (p === true || p === "true" || p === 1) && (t[m] = true) : Tc[$] === void 0 && (i[$] = p);
        }
      }
  }
  const a = nS(O, t), l = a.attributes;
  if (t.inline && (r.verticalAlign = "-0.125em"), n === "svg") {
    i.style = {
      ...r,
      ...o
    }, Object.assign(i, l);
    let $ = 0, p = e.id;
    return typeof p == "string" && (p = p.replace(/-/g, "_")), i.innerHTML = aS(a.body, p ? () => p + "ID" + $++ : "iconifyVue"), h("svg", i);
  }
  const { body: h2, width: u, height: f } = O, d = n === "mask" || (n === "bg" ? false : h2.indexOf("currentColor") !== -1), Q = _S(h2, {
    ...l,
    width: u + "",
    height: f + ""
  });
  return i.style = {
    ...r,
    "--svg": CS(Q),
    width: kc(l.width),
    height: kc(l.height),
    ...IS,
    ...d ? Co : Td,
    ...o
  }, h("span", i);
};
$d(true);
lS("", pS);
if (typeof document < "u" && typeof window < "u") {
  wd();
  const O = window;
  if (O.IconifyPreload !== void 0) {
    const e = O.IconifyPreload, t = "Invalid IconifyPreload syntax.";
    typeof e == "object" && e !== null && (e instanceof Array ? e : [e]).forEach((i) => {
      try {
        (typeof i != "object" || i === null || i instanceof Array || // Check for 'icons' and 'prefix'
        typeof i.icons != "object" || typeof i.prefix != "string" || // Add icon set
        !eS(i)) && console.error(t);
      } catch {
        console.error(t);
      }
    });
  }
  if (O.IconifyProviders !== void 0) {
    const e = O.IconifyProviders;
    if (typeof e == "object" && e !== null)
      for (let t in e) {
        const i = "IconifyProviders[" + t + "] is invalid.";
        try {
          const n = e[t];
          if (typeof n != "object" || !n || n.resources === void 0)
            continue;
          cS(t, n) || console.error(i);
        } catch {
          console.error(i);
        }
      }
  }
}
var ES = {
  ...ns,
  body: ""
};
var AS = defineComponent({
  // Do not inherit other attributes: it is handled by render()
  inheritAttrs: false,
  // Set initial data
  data() {
    return {
      // Mounted status
      iconMounted: false,
      // Callback counter to trigger re-render
      counter: 0
    };
  },
  mounted() {
    this._name = "", this._loadingIcon = null, this.iconMounted = true;
  },
  unmounted() {
    this.abortLoading();
  },
  methods: {
    abortLoading() {
      this._loadingIcon && (this._loadingIcon.abort(), this._loadingIcon = null);
    },
    // Get data for icon to render or null
    getIcon(O, e) {
      if (typeof O == "object" && O !== null && typeof O.body == "string")
        return this._name = "", this.abortLoading(), {
          data: O
        };
      let t;
      if (typeof O != "string" || (t = is(O, false, true)) === null)
        return this.abortLoading(), null;
      const i = Kg(t);
      if (!i)
        return (!this._loadingIcon || this._loadingIcon.name !== O) && (this.abortLoading(), this._name = "", i !== null && (this._loadingIcon = {
          name: O,
          abort: qS([t], () => {
            this.counter++;
          })
        })), null;
      this.abortLoading(), this._name !== O && (this._name = O, e && e(O));
      const n = ["iconify"];
      return t.prefix !== "" && n.push("iconify--" + t.prefix), t.provider !== "" && n.push("iconify--" + t.provider), { data: i, classes: n };
    }
  },
  // Render icon
  render() {
    this.counter;
    const O = this.$attrs, e = this.iconMounted ? this.getIcon(O.icon, O.onLoad) : null;
    if (!e)
      return Yc(ES, O);
    let t = O;
    return e.classes && (t = {
      ...O,
      class: (typeof O.class == "string" ? O.class + " " : "") + e.classes.join(" ")
    }), Yc({
      ...ns,
      ...e.data
    }, t);
  }
});
var DS = {
  name: "HIcon"
};
var MS = defineComponent({
  ...DS,
  props: {
    icon: null,
    size: { default: 20 }
  },
  setup(O) {
    const e = O;
    return useCssVars((t) => ({
      "7cf82c99": `${e.size}px`
    })), (t, i) => (openBlock(), createBlock(unref(AS), {
      icon: O.icon,
      class: "icon"
    }, null, 8, ["icon"]));
  }
});
var LS = Rt(MS);
var BS = ["src"];
var NS = {
  name: "HImagePreview"
};
var FS = defineComponent({
  ...NS,
  props: {
    data: null,
    mime: { default: "image/png" }
  },
  setup(O) {
    const e = O;
    let t = /* @__PURE__ */ new Map([
      ["image/png", "img"],
      ["image/jpeg", "img"],
      ["image/gif", "img"]
    ]);
    const i = computed(() => t.get(e.mime)), n = computed(() => e.data.includes("data:image") && e.data.includes(";base64,") ? e.data : "data:" + e.mime + ";base64," + e.data);
    return (r, s) => unref(i) === "img" ? (openBlock(), createElementBlock("img", {
      key: 0,
      src: unref(n)
    }, null, 8, BS)) : createCommentVNode("", true);
  }
});
var HS = Rt(FS);
var Zc = "theme";
function KS() {
  return window.matchMedia("(prefers-color-scheme: dark)").matches;
}
function JS() {
  const O = localStorage.getItem(Zc);
  return O || (localStorage.setItem(Zc, "system"), "system");
}
function eP() {
  const O = JS();
  switch (true) {
    case O === "dark":
      return true;
    case O === "light":
      return false;
    case O === "system":
      return KS();
    default:
      throw new Error("Unknown theme");
  }
}
var Wd = () => ({
  dark: eP(),
  hasUpdate: false,
  // token: nodeAbility?.token(),
  nickname: "",
  email: "",
  isMenuSpread: true,
  userSetSpreadFlag: false,
  userSetInfoFlag: false,
  isInfoCollapsed: false
});
var D = class {
  /**
  @internal
  */
  constructor() {
  }
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, false, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, true, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, t, i) {
    let n = [];
    return this.decompose(
      0,
      e,
      n,
      2
      /* Open.To */
    ), i.length && i.decompose(
      0,
      i.length,
      n,
      3
      /* Open.To */
    ), this.decompose(
      t,
      this.length,
      n,
      1
      /* Open.From */
    ), mt.from(n, this.length - (t - e) + i.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, t = this.length) {
    let i = [];
    return this.decompose(e, t, i, 0), mt.from(i, t - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return true;
    if (e.length != this.length || e.lines != this.lines)
      return false;
    let t = this.scanIdentical(e, 1), i = this.length - this.scanIdentical(e, -1), n = new ki(this), r = new ki(e);
    for (let s = t, o = t; ; ) {
      if (n.next(s), r.next(s), s = 0, n.lineBreak != r.lineBreak || n.done != r.done || n.value != r.value)
        return false;
      if (o += n.value.length, n.done || o >= i)
        return true;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new ki(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, t = this.length) {
    return new vd(this, e, t);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, t) {
    let i;
    if (e == null)
      i = this.iter();
    else {
      t == null && (t = this.lines + 1);
      let n = this.line(e).from;
      i = this.iterRange(n, Math.max(n, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to));
    }
    return new kd(i);
  }
  /**
  @internal
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? D.empty : e.length <= 32 ? new re(e) : mt.from(re.split(e, []));
  }
};
var re = class extends D {
  constructor(e, t = tP(e)) {
    super(), this.text = e, this.length = t;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, t, i, n) {
    for (let r = 0; ; r++) {
      let s = this.text[r], o = n + s.length;
      if ((t ? i : o) >= e)
        return new OP(n, o, i, s);
      n = o + 1, i++;
    }
  }
  decompose(e, t, i, n) {
    let r = e <= 0 && t >= this.length ? this : new re(qc(this.text, e, t), Math.min(t, this.length) - Math.max(0, e));
    if (n & 1) {
      let s = i.pop(), o = ir(r.text, s.text.slice(), 0, r.length);
      if (o.length <= 32)
        i.push(new re(o, s.length + r.length));
      else {
        let a = o.length >> 1;
        i.push(new re(o.slice(0, a)), new re(o.slice(a)));
      }
    } else
      i.push(r);
  }
  replace(e, t, i) {
    if (!(i instanceof re))
      return super.replace(e, t, i);
    let n = ir(this.text, ir(i.text, qc(this.text, 0, e)), t), r = this.length + i.length - (t - e);
    return n.length <= 32 ? new re(n, r) : mt.from(re.split(n, []), r);
  }
  sliceString(e, t = this.length, i = `
`) {
    let n = "";
    for (let r = 0, s = 0; r <= t && s < this.text.length; s++) {
      let o = this.text[s], a = r + o.length;
      r > e && s && (n += i), e < a && t > r && (n += o.slice(Math.max(0, e - r), t - r)), r = a + 1;
    }
    return n;
  }
  flatten(e) {
    for (let t of this.text)
      e.push(t);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, t) {
    let i = [], n = -1;
    for (let r of e)
      i.push(r), n += r.length + 1, i.length == 32 && (t.push(new re(i, n)), i = [], n = -1);
    return n > -1 && t.push(new re(i, n)), t;
  }
};
var mt = class extends D {
  constructor(e, t) {
    super(), this.children = e, this.length = t, this.lines = 0;
    for (let i of e)
      this.lines += i.lines;
  }
  lineInner(e, t, i, n) {
    for (let r = 0; ; r++) {
      let s = this.children[r], o = n + s.length, a = i + s.lines - 1;
      if ((t ? a : o) >= e)
        return s.lineInner(e, t, i, n);
      n = o + 1, i = a + 1;
    }
  }
  decompose(e, t, i, n) {
    for (let r = 0, s = 0; s <= t && r < this.children.length; r++) {
      let o = this.children[r], a = s + o.length;
      if (e <= a && t >= s) {
        let l = n & ((s <= e ? 1 : 0) | (a >= t ? 2 : 0));
        s >= e && a <= t && !l ? i.push(o) : o.decompose(e - s, t - s, i, l);
      }
      s = a + 1;
    }
  }
  replace(e, t, i) {
    if (i.lines < this.lines)
      for (let n = 0, r = 0; n < this.children.length; n++) {
        let s = this.children[n], o = r + s.length;
        if (e >= r && t <= o) {
          let a = s.replace(e - r, t - r, i), l = this.lines - s.lines + a.lines;
          if (a.lines < l >> 5 - 1 && a.lines > l >> 5 + 1) {
            let h2 = this.children.slice();
            return h2[n] = a, new mt(h2, this.length - (t - e) + i.length);
          }
          return super.replace(r, o, a);
        }
        r = o + 1;
      }
    return super.replace(e, t, i);
  }
  sliceString(e, t = this.length, i = `
`) {
    let n = "";
    for (let r = 0, s = 0; r < this.children.length && s <= t; r++) {
      let o = this.children[r], a = s + o.length;
      s > e && r && (n += i), e < a && t > s && (n += o.sliceString(e - s, t - s, i)), s = a + 1;
    }
    return n;
  }
  flatten(e) {
    for (let t of this.children)
      t.flatten(e);
  }
  scanIdentical(e, t) {
    if (!(e instanceof mt))
      return 0;
    let i = 0, [n, r, s, o] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; n += t, r += t) {
      if (n == s || r == o)
        return i;
      let a = this.children[n], l = e.children[r];
      if (a != l)
        return i + a.scanIdentical(l, t);
      i += a.length + 1;
    }
  }
  static from(e, t = e.reduce((i, n) => i + n.length + 1, -1)) {
    let i = 0;
    for (let d of e)
      i += d.lines;
    if (i < 32) {
      let d = [];
      for (let Q of e)
        Q.flatten(d);
      return new re(d, t);
    }
    let n = Math.max(
      32,
      i >> 5
      /* Tree.BranchShift */
    ), r = n << 1, s = n >> 1, o = [], a = 0, l = -1, h2 = [];
    function u(d) {
      let Q;
      if (d.lines > r && d instanceof mt)
        for (let $ of d.children)
          u($);
      else
        d.lines > s && (a > s || !a) ? (f(), o.push(d)) : d instanceof re && a && (Q = h2[h2.length - 1]) instanceof re && d.lines + Q.lines <= 32 ? (a += d.lines, l += d.length + 1, h2[h2.length - 1] = new re(Q.text.concat(d.text), Q.length + 1 + d.length)) : (a + d.lines > n && f(), a += d.lines, l += d.length + 1, h2.push(d));
    }
    function f() {
      a != 0 && (o.push(h2.length == 1 ? h2[0] : mt.from(h2, l)), l = -1, a = h2.length = 0);
    }
    for (let d of e)
      u(d);
    return f(), o.length == 1 ? o[0] : new mt(o, t);
  }
};
D.empty = new re([""], 0);
function tP(O) {
  let e = -1;
  for (let t of O)
    e += t.length + 1;
  return e;
}
function ir(O, e, t = 0, i = 1e9) {
  for (let n = 0, r = 0, s = true; r < O.length && n <= i; r++) {
    let o = O[r], a = n + o.length;
    a >= t && (a > i && (o = o.slice(0, i - n)), n < t && (o = o.slice(t - n)), s ? (e[e.length - 1] += o, s = false) : e.push(o)), n = a + 1;
  }
  return e;
}
function qc(O, e, t) {
  return ir(O, [""], e, t);
}
var ki = class {
  constructor(e, t = 1) {
    this.dir = t, this.done = false, this.lineBreak = false, this.value = "", this.nodes = [e], this.offsets = [t > 0 ? 1 : (e instanceof re ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, t) {
    for (this.done = this.lineBreak = false; ; ) {
      let i = this.nodes.length - 1, n = this.nodes[i], r = this.offsets[i], s = r >> 1, o = n instanceof re ? n.text.length : n.children.length;
      if (s == (t > 0 ? o : 0)) {
        if (i == 0)
          return this.done = true, this.value = "", this;
        t > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((r & 1) == (t > 0 ? 0 : 1)) {
        if (this.offsets[i] += t, e == 0)
          return this.lineBreak = true, this.value = `
`, this;
        e--;
      } else if (n instanceof re) {
        let a = n.text[s + (t < 0 ? -1 : 0)];
        if (this.offsets[i] += t, a.length > Math.max(0, e))
          return this.value = e == 0 ? a : t > 0 ? a.slice(e) : a.slice(0, a.length - e), this;
        e -= a.length;
      } else {
        let a = n.children[s + (t < 0 ? -1 : 0)];
        e > a.length ? (e -= a.length, this.offsets[i] += t) : (t < 0 && this.offsets[i]--, this.nodes.push(a), this.offsets.push(t > 0 ? 1 : (a instanceof re ? a.text.length : a.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
};
var vd = class {
  constructor(e, t, i) {
    this.value = "", this.done = false, this.cursor = new ki(e, t > i ? -1 : 1), this.pos = t > i ? e.length : 0, this.from = Math.min(t, i), this.to = Math.max(t, i);
  }
  nextInner(e, t) {
    if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = true, this;
    e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
    let i = t < 0 ? this.pos - this.from : this.to - this.pos;
    e > i && (e = i), i -= e;
    let { value: n } = this.cursor.next(e);
    return this.pos += (n.length + e) * t, this.value = n.length <= i ? n : t < 0 ? n.slice(n.length - i) : n.slice(0, i), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
};
var kd = class {
  constructor(e) {
    this.inner = e, this.afterBreak = true, this.value = "", this.done = false;
  }
  next(e = 0) {
    let { done: t, lineBreak: i, value: n } = this.inner.next(e);
    return t ? (this.done = true, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = true, this.next()) : (this.value = n, this.afterBreak = false), this;
  }
  get lineBreak() {
    return false;
  }
};
typeof Symbol < "u" && (D.prototype[Symbol.iterator] = function() {
  return this.iter();
}, ki.prototype[Symbol.iterator] = vd.prototype[Symbol.iterator] = kd.prototype[Symbol.iterator] = function() {
  return this;
});
var OP = class {
  /**
  @internal
  */
  constructor(e, t, i, n) {
    this.from = e, this.to = t, this.number = i, this.text = n;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
};
var CO = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((O) => O ? parseInt(O, 36) : 1);
for (let O = 1; O < CO.length; O++)
  CO[O] += CO[O - 1];
function iP(O) {
  for (let e = 1; e < CO.length; e += 2)
    if (CO[e] > O)
      return CO[e - 1] <= O;
  return false;
}
function zc(O) {
  return O >= 127462 && O <= 127487;
}
var Uc = 8205;
function ve(O, e, t = true, i = true) {
  return (t ? Yd : nP)(O, e, i);
}
function Yd(O, e, t) {
  if (e == O.length)
    return e;
  e && Zd(O.charCodeAt(e)) && qd(O.charCodeAt(e - 1)) && e--;
  let i = Pe(O, e);
  for (e += De(i); e < O.length; ) {
    let n = Pe(O, e);
    if (i == Uc || n == Uc || t && iP(n))
      e += De(n), i = n;
    else if (zc(n)) {
      let r = 0, s = e - 2;
      for (; s >= 0 && zc(Pe(O, s)); )
        r++, s -= 2;
      if (r % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function nP(O, e, t) {
  for (; e > 0; ) {
    let i = Yd(O, e - 2, t);
    if (i < e)
      return i;
    e--;
  }
  return 0;
}
function Zd(O) {
  return O >= 56320 && O < 57344;
}
function qd(O) {
  return O >= 55296 && O < 56320;
}
function Pe(O, e) {
  let t = O.charCodeAt(e);
  if (!qd(t) || e + 1 == O.length)
    return t;
  let i = O.charCodeAt(e + 1);
  return Zd(i) ? (t - 55296 << 10) + (i - 56320) + 65536 : t;
}
function ll(O) {
  return O <= 65535 ? String.fromCharCode(O) : (O -= 65536, String.fromCharCode((O >> 10) + 55296, (O & 1023) + 56320));
}
function De(O) {
  return O < 65536 ? 1 : 2;
}
var Go = /\r\n?|\n/;
var Xe = function(O) {
  return O[O.Simple = 0] = "Simple", O[O.TrackDel = 1] = "TrackDel", O[O.TrackBefore = 2] = "TrackBefore", O[O.TrackAfter = 3] = "TrackAfter", O;
}(Xe || (Xe = {}));
var yt = class {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2)
      e += this.sections[t];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2) {
      let i = this.sections[t + 1];
      e += i < 0 ? this.sections[t] : i;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let t = 0, i = 0, n = 0; t < this.sections.length; ) {
      let r = this.sections[t++], s = this.sections[t++];
      s < 0 ? (e(i, n, r), n += r) : n += s, i += r;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, t = false) {
    Io(this, e, t);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let t = 0; t < this.sections.length; ) {
      let i = this.sections[t++], n = this.sections[t++];
      n < 0 ? e.push(i, n) : e.push(n, i);
    }
    return new yt(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : zd(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(e, t = false) {
    return e.empty ? this : Eo(this, e, t);
  }
  mapPos(e, t = -1, i = Xe.Simple) {
    let n = 0, r = 0;
    for (let s = 0; s < this.sections.length; ) {
      let o = this.sections[s++], a = this.sections[s++], l = n + o;
      if (a < 0) {
        if (l > e)
          return r + (e - n);
        r += o;
      } else {
        if (i != Xe.Simple && l >= e && (i == Xe.TrackDel && n < e && l > e || i == Xe.TrackBefore && n < e || i == Xe.TrackAfter && l > e))
          return null;
        if (l > e || l == e && t < 0 && !o)
          return e == n || t < 0 ? r : r + a;
        r += a;
      }
      n = l;
    }
    if (e > n)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${n}`);
    return r;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, t = e) {
    for (let i = 0, n = 0; i < this.sections.length && n <= t; ) {
      let r = this.sections[i++], s = this.sections[i++], o = n + r;
      if (s >= 0 && n <= t && o >= e)
        return n < e && o > t ? "cover" : true;
      n = o;
    }
    return false;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 0; t < this.sections.length; ) {
      let i = this.sections[t++], n = this.sections[t++];
      e += (e ? " " : "") + i + (n >= 0 ? ":" + n : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((t) => typeof t != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new yt(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new yt(e);
  }
};
var fe = class extends yt {
  constructor(e, t) {
    super(e), this.inserted = t;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return Io(this, (t, i, n, r, s) => e = e.replace(n, n + (i - t), s), false), e;
  }
  mapDesc(e, t = false) {
    return Eo(this, e, t, true);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let t = this.sections.slice(), i = [];
    for (let n = 0, r = 0; n < t.length; n += 2) {
      let s = t[n], o = t[n + 1];
      if (o >= 0) {
        t[n] = o, t[n + 1] = s;
        let a = n >> 1;
        for (; i.length < a; )
          i.push(D.empty);
        i.push(s ? e.slice(r, r + s) : D.empty);
      }
      r += s;
    }
    return new fe(t, i);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : zd(this, e, true);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, t = false) {
    return e.empty ? this : Eo(this, e, t, true);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, t = false) {
    Io(this, e, t);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return yt.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let t = [], i = [], n = [], r = new Ci(this);
    e:
      for (let s = 0, o = 0; ; ) {
        let a = s == e.length ? 1e9 : e[s++];
        for (; o < a || o == a && r.len == 0; ) {
          if (r.done)
            break e;
          let h2 = Math.min(r.len, a - o);
          xe(n, h2, -1);
          let u = r.ins == -1 ? -1 : r.off == 0 ? r.ins : 0;
          xe(t, h2, u), u > 0 && At(i, t, r.text), r.forward(h2), o += h2;
        }
        let l = e[s++];
        for (; o < l; ) {
          if (r.done)
            break e;
          let h2 = Math.min(r.len, l - o);
          xe(t, h2, -1), xe(n, h2, r.ins == -1 ? -1 : r.off == 0 ? r.ins : 0), r.forward(h2), o += h2;
        }
      }
    return {
      changes: new fe(t, i),
      filtered: yt.create(n)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let t = 0; t < this.sections.length; t += 2) {
      let i = this.sections[t], n = this.sections[t + 1];
      n < 0 ? e.push(i) : n == 0 ? e.push([i]) : e.push([i].concat(this.inserted[t >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, t, i) {
    let n = [], r = [], s = 0, o = null;
    function a(h2 = false) {
      if (!h2 && !n.length)
        return;
      s < t && xe(n, t - s, -1);
      let u = new fe(n, r);
      o = o ? o.compose(u.map(o)) : u, n = [], r = [], s = 0;
    }
    function l(h2) {
      if (Array.isArray(h2))
        for (let u of h2)
          l(u);
      else if (h2 instanceof fe) {
        if (h2.length != t)
          throw new RangeError(`Mismatched change set length (got ${h2.length}, expected ${t})`);
        a(), o = o ? o.compose(h2.map(o)) : h2;
      } else {
        let { from: u, to: f = u, insert: d } = h2;
        if (u > f || u < 0 || f > t)
          throw new RangeError(`Invalid change range ${u} to ${f} (in doc of length ${t})`);
        let Q = d ? typeof d == "string" ? D.of(d.split(i || Go)) : d : D.empty, $ = Q.length;
        if (u == f && $ == 0)
          return;
        u < s && a(), u > s && xe(n, u - s, -1), xe(n, f - u, $), At(r, n, Q), s = f;
      }
    }
    return l(e), a(!o), o;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new fe(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let t = [], i = [];
    for (let n = 0; n < e.length; n++) {
      let r = e[n];
      if (typeof r == "number")
        t.push(r, -1);
      else {
        if (!Array.isArray(r) || typeof r[0] != "number" || r.some((s, o) => o && typeof s != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (r.length == 1)
          t.push(r[0], 0);
        else {
          for (; i.length < n; )
            i.push(D.empty);
          i[n] = D.of(r.slice(1)), t.push(r[0], i[n].length);
        }
      }
    }
    return new fe(t, i);
  }
  /**
  @internal
  */
  static createSet(e, t) {
    return new fe(e, t);
  }
};
function xe(O, e, t, i = false) {
  if (e == 0 && t <= 0)
    return;
  let n = O.length - 2;
  n >= 0 && t <= 0 && t == O[n + 1] ? O[n] += e : e == 0 && O[n] == 0 ? O[n + 1] += t : i ? (O[n] += e, O[n + 1] += t) : O.push(e, t);
}
function At(O, e, t) {
  if (t.length == 0)
    return;
  let i = e.length - 2 >> 1;
  if (i < O.length)
    O[O.length - 1] = O[O.length - 1].append(t);
  else {
    for (; O.length < i; )
      O.push(D.empty);
    O.push(t);
  }
}
function Io(O, e, t) {
  let i = O.inserted;
  for (let n = 0, r = 0, s = 0; s < O.sections.length; ) {
    let o = O.sections[s++], a = O.sections[s++];
    if (a < 0)
      n += o, r += o;
    else {
      let l = n, h2 = r, u = D.empty;
      for (; l += o, h2 += a, a && i && (u = u.append(i[s - 2 >> 1])), !(t || s == O.sections.length || O.sections[s + 1] < 0); )
        o = O.sections[s++], a = O.sections[s++];
      e(n, l, r, h2, u), n = l, r = h2;
    }
  }
}
function Eo(O, e, t, i = false) {
  let n = [], r = i ? [] : null, s = new Ci(O), o = new Ci(e);
  for (let a = -1; ; )
    if (s.ins == -1 && o.ins == -1) {
      let l = Math.min(s.len, o.len);
      xe(n, l, -1), s.forward(l), o.forward(l);
    } else if (o.ins >= 0 && (s.ins < 0 || a == s.i || s.off == 0 && (o.len < s.len || o.len == s.len && !t))) {
      let l = o.len;
      for (xe(n, o.ins, -1); l; ) {
        let h2 = Math.min(s.len, l);
        s.ins >= 0 && a < s.i && s.len <= h2 && (xe(n, 0, s.ins), r && At(r, n, s.text), a = s.i), s.forward(h2), l -= h2;
      }
      o.next();
    } else if (s.ins >= 0) {
      let l = 0, h2 = s.len;
      for (; h2; )
        if (o.ins == -1) {
          let u = Math.min(h2, o.len);
          l += u, h2 -= u, o.forward(u);
        } else if (o.ins == 0 && o.len < h2)
          h2 -= o.len, o.next();
        else
          break;
      xe(n, l, a < s.i ? s.ins : 0), r && a < s.i && At(r, n, s.text), a = s.i, s.forward(s.len - h2);
    } else {
      if (s.done && o.done)
        return r ? fe.createSet(n, r) : yt.create(n);
      throw new Error("Mismatched change set lengths");
    }
}
function zd(O, e, t = false) {
  let i = [], n = t ? [] : null, r = new Ci(O), s = new Ci(e);
  for (let o = false; ; ) {
    if (r.done && s.done)
      return n ? fe.createSet(i, n) : yt.create(i);
    if (r.ins == 0)
      xe(i, r.len, 0, o), r.next();
    else if (s.len == 0 && !s.done)
      xe(i, 0, s.ins, o), n && At(n, i, s.text), s.next();
    else {
      if (r.done || s.done)
        throw new Error("Mismatched change set lengths");
      {
        let a = Math.min(r.len2, s.len), l = i.length;
        if (r.ins == -1) {
          let h2 = s.ins == -1 ? -1 : s.off ? 0 : s.ins;
          xe(i, a, h2, o), n && h2 && At(n, i, s.text);
        } else
          s.ins == -1 ? (xe(i, r.off ? 0 : r.len, a, o), n && At(n, i, r.textBit(a))) : (xe(i, r.off ? 0 : r.len, s.off ? 0 : s.ins, o), n && !s.off && At(n, i, s.text));
        o = (r.ins > a || s.ins >= 0 && s.len > a) && (o || i.length > l), r.forward2(a), s.forward(a);
      }
    }
  }
}
var Ci = class {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, t = this.i - 2 >> 1;
    return t >= e.length ? D.empty : e[t];
  }
  textBit(e) {
    let { inserted: t } = this.set, i = this.i - 2 >> 1;
    return i >= t.length && !e ? D.empty : t[i].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
};
var $O = class {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.flags = i;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 16 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 16 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 3;
    return e == 3 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 5;
    return e == 33554431 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, t = -1) {
    let i, n;
    return this.empty ? i = n = e.mapPos(this.from, t) : (i = e.mapPos(this.from, 1), n = e.mapPos(this.to, -1)), i == this.from && n == this.to ? this : new $O(i, n, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, t = e) {
    if (e <= this.anchor && t >= this.anchor)
      return S.range(e, t);
    let i = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
    return S.range(this.anchor, i);
  }
  /**
  Compare this range to another range.
  */
  eq(e) {
    return this.anchor == e.anchor && this.head == e.head;
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return S.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new $O(e, t, i);
  }
};
var S = class {
  constructor(e, t) {
    this.ranges = e, this.mainIndex = t;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, t = -1) {
    return e.empty ? this : S.create(this.ranges.map((i) => i.map(e, t)), this.mainIndex);
  }
  /**
  Compare this selection to another selection.
  */
  eq(e) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return false;
    for (let t = 0; t < this.ranges.length; t++)
      if (!this.ranges[t].eq(e.ranges[t]))
        return false;
    return true;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new S([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, t = true) {
    return S.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, t = this.mainIndex) {
    let i = this.ranges.slice();
    return i[t] = e, S.create(i, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new S(e.ranges.map((t) => $O.fromJSON(t)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, t = e) {
    return new S([S.range(e, t)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, t = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let i = 0, n = 0; n < e.length; n++) {
      let r = e[n];
      if (r.empty ? r.from <= i : r.from < i)
        return S.normalized(e.slice(), t);
      i = r.to;
    }
    return new S(e, t);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, t = 0, i, n) {
    return $O.create(e, e, (t == 0 ? 0 : t < 0 ? 4 : 8) | (i == null ? 3 : Math.min(2, i)) | (n ?? 33554431) << 5);
  }
  /**
  Create a selection range.
  */
  static range(e, t, i, n) {
    let r = (i ?? 33554431) << 5 | (n == null ? 3 : Math.min(2, n));
    return t < e ? $O.create(t, e, 24 | r) : $O.create(e, t, (t > e ? 4 : 0) | r);
  }
  /**
  @internal
  */
  static normalized(e, t = 0) {
    let i = e[t];
    e.sort((n, r) => n.from - r.from), t = e.indexOf(i);
    for (let n = 1; n < e.length; n++) {
      let r = e[n], s = e[n - 1];
      if (r.empty ? r.from <= s.to : r.from < s.to) {
        let o = s.from, a = Math.max(r.to, s.to);
        n <= t && t--, e.splice(--n, 2, r.anchor > r.head ? S.range(a, o) : S.range(o, a));
      }
    }
    return new S(e, t);
  }
};
function Ud(O, e) {
  for (let t of O.ranges)
    if (t.to > e)
      throw new RangeError("Selection points outside of document");
}
var cl = 0;
var q = class {
  constructor(e, t, i, n, r) {
    this.combine = e, this.compareInput = t, this.compare = i, this.isStatic = n, this.id = cl++, this.default = e([]), this.extensions = typeof r == "function" ? r(this) : r;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new q(e.combine || ((t) => t), e.compareInput || ((t, i) => t === i), e.compare || (e.combine ? (t, i) => t === i : hl), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new nr([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new nr(e, this, 1, t);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new nr(e, this, 2, t);
  }
  from(e, t) {
    return t || (t = (i) => i), this.compute([e], (i) => t(i.field(e)));
  }
};
function hl(O, e) {
  return O == e || O.length == e.length && O.every((t, i) => t === e[i]);
}
var nr = class {
  constructor(e, t, i, n) {
    this.dependencies = e, this.facet = t, this.type = i, this.value = n, this.id = cl++;
  }
  dynamicSlot(e) {
    var t;
    let i = this.value, n = this.facet.compareInput, r = this.id, s = e[r] >> 1, o = this.type == 2, a = false, l = false, h2 = [];
    for (let u of this.dependencies)
      u == "doc" ? a = true : u == "selection" ? l = true : ((t = e[u.id]) !== null && t !== void 0 ? t : 1) & 1 || h2.push(e[u.id]);
    return {
      create(u) {
        return u.values[s] = i(u), 1;
      },
      update(u, f) {
        if (a && f.docChanged || l && (f.docChanged || f.selection) || Ao(u, h2)) {
          let d = i(u);
          if (o ? !Vc(d, u.values[s], n) : !n(d, u.values[s]))
            return u.values[s] = d, 1;
        }
        return 0;
      },
      reconfigure: (u, f) => {
        let d, Q = f.config.address[r];
        if (Q != null) {
          let $ = Xr(f, Q);
          if (this.dependencies.every((p) => p instanceof q ? f.facet(p) === u.facet(p) : p instanceof me ? f.field(p, false) == u.field(p, false) : true) || (o ? Vc(d = i(u), $, n) : n(d = i(u), $)))
            return u.values[s] = $, 0;
        } else
          d = i(u);
        return u.values[s] = d, 1;
      }
    };
  }
};
function Vc(O, e, t) {
  if (O.length != e.length)
    return false;
  for (let i = 0; i < O.length; i++)
    if (!t(O[i], e[i]))
      return false;
  return true;
}
function Ao(O, e) {
  let t = false;
  for (let i of e)
    Yi(O, i) & 1 && (t = true);
  return t;
}
function rP(O, e, t) {
  let i = t.map((a) => O[a.id]), n = t.map((a) => a.type), r = i.filter((a) => !(a & 1)), s = O[e.id] >> 1;
  function o(a) {
    let l = [];
    for (let h2 = 0; h2 < i.length; h2++) {
      let u = Xr(a, i[h2]);
      if (n[h2] == 2)
        for (let f of u)
          l.push(f);
      else
        l.push(u);
    }
    return e.combine(l);
  }
  return {
    create(a) {
      for (let l of i)
        Yi(a, l);
      return a.values[s] = o(a), 1;
    },
    update(a, l) {
      if (!Ao(a, r))
        return 0;
      let h2 = o(a);
      return e.compare(h2, a.values[s]) ? 0 : (a.values[s] = h2, 1);
    },
    reconfigure(a, l) {
      let h2 = Ao(a, i), u = l.config.facets[e.id], f = l.facet(e);
      if (u && !h2 && hl(t, u))
        return a.values[s] = f, 0;
      let d = o(a);
      return e.compare(d, f) ? (a.values[s] = f, 0) : (a.values[s] = d, 1);
    }
  };
}
var Rc = q.define({ static: true });
var me = class {
  constructor(e, t, i, n, r) {
    this.id = e, this.createF = t, this.updateF = i, this.compareF = n, this.spec = r, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let t = new me(cl++, e.create, e.update, e.compare || ((i, n) => i === n), e);
    return e.provide && (t.provides = e.provide(t)), t;
  }
  create(e) {
    let t = e.facet(Rc).find((i) => i.field == this);
    return ((t == null ? void 0 : t.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let t = e[this.id] >> 1;
    return {
      create: (i) => (i.values[t] = this.create(i), 1),
      update: (i, n) => {
        let r = i.values[t], s = this.updateF(r, n);
        return this.compareF(r, s) ? 0 : (i.values[t] = s, 1);
      },
      reconfigure: (i, n) => n.config.address[this.id] != null ? (i.values[t] = n.field(this), 0) : (i.values[t] = this.create(i), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, Rc.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
};
var fO = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function ci(O) {
  return (e) => new Vd(e, O);
}
var rO = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: ci(fO.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: ci(fO.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: ci(fO.default),
  /**
  A lower-than-default precedence.
  */
  low: ci(fO.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: ci(fO.lowest)
};
var Vd = class {
  constructor(e, t) {
    this.inner = e, this.prec = t;
  }
};
var cn = class {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new Do(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return cn.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
};
var Do = class {
  constructor(e, t) {
    this.compartment = e, this.inner = t;
  }
};
var yr = class {
  constructor(e, t, i, n, r, s) {
    for (this.base = e, this.compartments = t, this.dynamicSlots = i, this.address = n, this.staticValues = r, this.facets = s, this.statusTemplate = []; this.statusTemplate.length < i.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let t = this.address[e.id];
    return t == null ? e.default : this.staticValues[t >> 1];
  }
  static resolve(e, t, i) {
    let n = [], r = /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ new Map();
    for (let f of sP(e, t, s))
      f instanceof me ? n.push(f) : (r[f.facet.id] || (r[f.facet.id] = [])).push(f);
    let o = /* @__PURE__ */ Object.create(null), a = [], l = [];
    for (let f of n)
      o[f.id] = l.length << 1, l.push((d) => f.slot(d));
    let h2 = i == null ? void 0 : i.config.facets;
    for (let f in r) {
      let d = r[f], Q = d[0].facet, $ = h2 && h2[f] || [];
      if (d.every(
        (p) => p.type == 0
        /* Provider.Static */
      ))
        if (o[Q.id] = a.length << 1 | 1, hl($, d))
          a.push(i.facet(Q));
        else {
          let p = Q.combine(d.map((m) => m.value));
          a.push(i && Q.compare(p, i.facet(Q)) ? i.facet(Q) : p);
        }
      else {
        for (let p of d)
          p.type == 0 ? (o[p.id] = a.length << 1 | 1, a.push(p.value)) : (o[p.id] = l.length << 1, l.push((m) => p.dynamicSlot(m)));
        o[Q.id] = l.length << 1, l.push((p) => rP(p, Q, d));
      }
    }
    let u = l.map((f) => f(o));
    return new yr(e, s, u, o, a, r);
  }
};
function sP(O, e, t) {
  let i = [[], [], [], [], []], n = /* @__PURE__ */ new Map();
  function r(s, o) {
    let a = n.get(s);
    if (a != null) {
      if (a <= o)
        return;
      let l = i[a].indexOf(s);
      l > -1 && i[a].splice(l, 1), s instanceof Do && t.delete(s.compartment);
    }
    if (n.set(s, o), Array.isArray(s))
      for (let l of s)
        r(l, o);
    else if (s instanceof Do) {
      if (t.has(s.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let l = e.get(s.compartment) || s.inner;
      t.set(s.compartment, l), r(l, o);
    } else if (s instanceof Vd)
      r(s.inner, s.prec);
    else if (s instanceof me)
      i[o].push(s), s.provides && r(s.provides, o);
    else if (s instanceof nr)
      i[o].push(s), s.facet.extensions && r(s.facet.extensions, fO.default);
    else {
      let l = s.extension;
      if (!l)
        throw new Error(`Unrecognized extension value in extension set (${s}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      r(l, o);
    }
  }
  return r(O, fO.default), i.reduce((s, o) => s.concat(o));
}
function Yi(O, e) {
  if (e & 1)
    return 2;
  let t = e >> 1, i = O.status[t];
  if (i == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (i & 2)
    return i;
  O.status[t] = 4;
  let n = O.computeSlot(O, O.config.dynamicSlots[t]);
  return O.status[t] = 2 | n;
}
function Xr(O, e) {
  return e & 1 ? O.config.staticValues[e >> 1] : O.values[e >> 1];
}
var Rd = q.define();
var _d = q.define({
  combine: (O) => O.some((e) => e),
  static: true
});
var jd = q.define({
  combine: (O) => O.length ? O[0] : void 0,
  static: true
});
var Cd = q.define();
var Gd = q.define();
var Id = q.define();
var Ed = q.define({
  combine: (O) => O.length ? O[0] : false
});
var sO = class {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new oP();
  }
};
var oP = class {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new sO(this, e);
  }
};
var aP = class {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new j(this, e);
  }
};
var j = class {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let t = this.type.map(this.value, e);
    return t === void 0 ? void 0 : t == this.value ? this : new j(this.type, t);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds.
  */
  static define(e = {}) {
    return new aP(e.map || ((t) => t));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, t) {
    if (!e.length)
      return e;
    let i = [];
    for (let n of e) {
      let r = n.map(t);
      r && i.push(r);
    }
    return i;
  }
};
j.reconfigure = j.define();
j.appendConfig = j.define();
var de = class {
  constructor(e, t, i, n, r, s) {
    this.startState = e, this.changes = t, this.selection = i, this.effects = n, this.annotations = r, this.scrollIntoView = s, this._doc = null, this._state = null, i && Ud(i, t.newLength), r.some((o) => o.type == de.time) || (this.annotations = r.concat(de.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, t, i, n, r, s) {
    return new de(e, t, i, n, r, s);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let t of this.annotations)
      if (t.type == e)
        return t.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let t = this.annotation(de.userEvent);
    return !!(t && (t == e || t.length > e.length && t.slice(0, e.length) == e && t[e.length] == "."));
  }
};
de.time = sO.define();
de.userEvent = sO.define();
de.addToHistory = sO.define();
de.remote = sO.define();
function lP(O, e) {
  let t = [];
  for (let i = 0, n = 0; ; ) {
    let r, s;
    if (i < O.length && (n == e.length || e[n] >= O[i]))
      r = O[i++], s = O[i++];
    else if (n < e.length)
      r = e[n++], s = e[n++];
    else
      return t;
    !t.length || t[t.length - 1] < r ? t.push(r, s) : t[t.length - 1] < s && (t[t.length - 1] = s);
  }
}
function Ad(O, e, t) {
  var i;
  let n, r, s;
  return t ? (n = e.changes, r = fe.empty(e.changes.length), s = O.changes.compose(e.changes)) : (n = e.changes.map(O.changes), r = O.changes.mapDesc(e.changes, true), s = O.changes.compose(n)), {
    changes: s,
    selection: e.selection ? e.selection.map(r) : (i = O.selection) === null || i === void 0 ? void 0 : i.map(n),
    effects: j.mapEffects(O.effects, n).concat(j.mapEffects(e.effects, r)),
    annotations: O.annotations.length ? O.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: O.scrollIntoView || e.scrollIntoView
  };
}
function Mo(O, e, t) {
  let i = e.selection, n = GO(e.annotations);
  return e.userEvent && (n = n.concat(de.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof fe ? e.changes : fe.of(e.changes || [], t, O.facet(jd)),
    selection: i && (i instanceof S ? i : S.single(i.anchor, i.head)),
    effects: GO(e.effects),
    annotations: n,
    scrollIntoView: !!e.scrollIntoView
  };
}
function Dd(O, e, t) {
  let i = Mo(O, e.length ? e[0] : {}, O.doc.length);
  e.length && e[0].filter === false && (t = false);
  for (let r = 1; r < e.length; r++) {
    e[r].filter === false && (t = false);
    let s = !!e[r].sequential;
    i = Ad(i, Mo(O, e[r], s ? i.changes.newLength : O.doc.length), s);
  }
  let n = de.create(O, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView);
  return hP(t ? cP(n) : n);
}
function cP(O) {
  let e = O.startState, t = true;
  for (let n of e.facet(Cd)) {
    let r = n(O);
    if (r === false) {
      t = false;
      break;
    }
    Array.isArray(r) && (t = t === true ? r : lP(t, r));
  }
  if (t !== true) {
    let n, r;
    if (t === false)
      r = O.changes.invertedDesc, n = fe.empty(e.doc.length);
    else {
      let s = O.changes.filter(t);
      n = s.changes, r = s.filtered.mapDesc(s.changes).invertedDesc;
    }
    O = de.create(e, n, O.selection && O.selection.map(r), j.mapEffects(O.effects, r), O.annotations, O.scrollIntoView);
  }
  let i = e.facet(Gd);
  for (let n = i.length - 1; n >= 0; n--) {
    let r = i[n](O);
    r instanceof de ? O = r : Array.isArray(r) && r.length == 1 && r[0] instanceof de ? O = r[0] : O = Dd(e, GO(r), false);
  }
  return O;
}
function hP(O) {
  let e = O.startState, t = e.facet(Id), i = O;
  for (let n = t.length - 1; n >= 0; n--) {
    let r = t[n](O);
    r && Object.keys(r).length && (i = Ad(i, Mo(e, r, O.changes.newLength), true));
  }
  return i == O ? O : de.create(e, O.changes, O.selection, i.effects, i.annotations, i.scrollIntoView);
}
var uP = [];
function GO(O) {
  return O == null ? uP : Array.isArray(O) ? O : [O];
}
var ee = function(O) {
  return O[O.Word = 0] = "Word", O[O.Space = 1] = "Space", O[O.Other = 2] = "Other", O;
}(ee || (ee = {}));
var fP = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
var Lo;
try {
  Lo = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function dP(O) {
  if (Lo)
    return Lo.test(O);
  for (let e = 0; e < O.length; e++) {
    let t = O[e];
    if (/\w/.test(t) || t > "" && (t.toUpperCase() != t.toLowerCase() || fP.test(t)))
      return true;
  }
  return false;
}
function QP(O) {
  return (e) => {
    if (!/\S/.test(e))
      return ee.Space;
    if (dP(e))
      return ee.Word;
    for (let t = 0; t < O.length; t++)
      if (e.indexOf(O[t]) > -1)
        return ee.Word;
    return ee.Other;
  };
}
var I = class {
  constructor(e, t, i, n, r, s) {
    this.config = e, this.doc = t, this.selection = i, this.values = n, this.status = e.statusTemplate.slice(), this.computeSlot = r, s && (s._state = this);
    for (let o = 0; o < this.config.dynamicSlots.length; o++)
      Yi(this, o << 1);
    this.computeSlot = null;
  }
  field(e, t = true) {
    let i = this.config.address[e.id];
    if (i == null) {
      if (t)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Yi(this, i), Xr(this, i);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return Dd(this, e, true);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let t = this.config, { base: i, compartments: n } = t;
    for (let s of e.effects)
      s.is(cn.reconfigure) ? (t && (n = /* @__PURE__ */ new Map(), t.compartments.forEach((o, a) => n.set(a, o)), t = null), n.set(s.value.compartment, s.value.extension)) : s.is(j.reconfigure) ? (t = null, i = s.value) : s.is(j.appendConfig) && (t = null, i = GO(i).concat(s.value));
    let r;
    t ? r = e.startState.values.slice() : (t = yr.resolve(i, n, this), r = new I(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (o, a) => a.reconfigure(o, this), null).values), new I(t, e.newDoc, e.newSelection, r, (s, o) => o.update(s, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((t) => ({
      changes: { from: t.from, to: t.to, insert: e },
      range: S.cursor(t.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let t = this.selection, i = e(t.ranges[0]), n = this.changes(i.changes), r = [i.range], s = GO(i.effects);
    for (let o = 1; o < t.ranges.length; o++) {
      let a = e(t.ranges[o]), l = this.changes(a.changes), h2 = l.map(n);
      for (let f = 0; f < o; f++)
        r[f] = r[f].map(h2);
      let u = n.mapDesc(l, true);
      r.push(a.range.map(u)), n = n.compose(h2), s = j.mapEffects(s, h2).concat(j.mapEffects(GO(a.effects), u));
    }
    return {
      changes: n,
      selection: S.create(r, t.mainIndex),
      effects: s
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof fe ? e : fe.of(e, this.doc.length, this.facet(I.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return D.of(e.split(this.facet(I.lineSeparator) || Go));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, t = this.doc.length) {
    return this.doc.sliceString(e, t, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let t = this.config.address[e.id];
    return t == null ? e.default : (Yi(this, t), Xr(this, t));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let t = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let i in e) {
        let n = e[i];
        n instanceof me && this.config.address[n.id] != null && (t[i] = n.spec.toJSON(this.field(e[i]), this));
      }
    return t;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, t = {}, i) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let n = [];
    if (i) {
      for (let r in i)
        if (Object.prototype.hasOwnProperty.call(e, r)) {
          let s = i[r], o = e[r];
          n.push(s.init((a) => s.spec.fromJSON(o, a)));
        }
    }
    return I.create({
      doc: e.doc,
      selection: S.fromJSON(e.selection),
      extensions: t.extensions ? n.concat([t.extensions]) : n
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let t = yr.resolve(e.extensions || [], /* @__PURE__ */ new Map()), i = e.doc instanceof D ? e.doc : D.of((e.doc || "").split(t.staticFacet(I.lineSeparator) || Go)), n = e.selection ? e.selection instanceof S ? e.selection : S.single(e.selection.anchor, e.selection.head) : S.single(0);
    return Ud(n, i.length), t.staticFacet(_d) || (n = n.asSingle()), new I(t, i, n, t.dynamicSlots.map(() => null), (r, s) => s.create(r), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(I.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(I.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(Ed);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...t) {
    for (let i of this.facet(I.phrases))
      if (Object.prototype.hasOwnProperty.call(i, e)) {
        e = i[e];
        break;
      }
    return t.length && (e = e.replace(/\$(\$|\d*)/g, (i, n) => {
      if (n == "$")
        return "$";
      let r = +(n || 1);
      return !r || r > t.length ? i : t[r - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, t, i = -1) {
    let n = [];
    for (let r of this.facet(Rd))
      for (let s of r(this, t, i))
        Object.prototype.hasOwnProperty.call(s, e) && n.push(s[e]);
    return n;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return QP(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: t, from: i, length: n } = this.doc.lineAt(e), r = this.charCategorizer(e), s = e - i, o = e - i;
    for (; s > 0; ) {
      let a = ve(t, s, false);
      if (r(t.slice(a, s)) != ee.Word)
        break;
      s = a;
    }
    for (; o < n; ) {
      let a = ve(t, o);
      if (r(t.slice(o, a)) != ee.Word)
        break;
      o = a;
    }
    return s == o ? null : S.range(s + i, o + i);
  }
};
I.allowMultipleSelections = _d;
I.tabSize = q.define({
  combine: (O) => O.length ? O[0] : 4
});
I.lineSeparator = jd;
I.readOnly = Ed;
I.phrases = q.define({
  compare(O, e) {
    let t = Object.keys(O), i = Object.keys(e);
    return t.length == i.length && t.every((n) => O[n] == e[n]);
  }
});
I.languageData = Rd;
I.changeFilter = Cd;
I.transactionFilter = Gd;
I.transactionExtender = Id;
cn.reconfigure = j.define();
function bt(O, e, t = {}) {
  let i = {};
  for (let n of O)
    for (let r of Object.keys(n)) {
      let s = n[r], o = i[r];
      if (o === void 0)
        i[r] = s;
      else if (!(o === s || s === void 0))
        if (Object.hasOwnProperty.call(t, r))
          i[r] = t[r](o, s);
        else
          throw new Error("Config merge conflict for field " + r);
    }
  for (let n in e)
    i[n] === void 0 && (i[n] = e[n]);
  return i;
}
var PO = class {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, t = e) {
    return Bo.create(e, t, this);
  }
};
PO.prototype.startSide = PO.prototype.endSide = 0;
PO.prototype.point = false;
PO.prototype.mapMode = Xe.TrackDel;
var Bo = class Md {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.value = i;
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new Md(e, t, i);
  }
};
function No(O, e) {
  return O.from - e.from || O.value.startSide - e.value.startSide;
}
var ul = class {
  constructor(e, t, i, n) {
    this.from = e, this.to = t, this.value = i, this.maxPoint = n;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, t, i, n = 0) {
    let r = i ? this.to : this.from;
    for (let s = n, o = r.length; ; ) {
      if (s == o)
        return s;
      let a = s + o >> 1, l = r[a] - e || (i ? this.value[a].endSide : this.value[a].startSide) - t;
      if (a == s)
        return l >= 0 ? s : o;
      l >= 0 ? o = a : s = a + 1;
    }
  }
  between(e, t, i, n) {
    for (let r = this.findIndex(t, -1e9, true), s = this.findIndex(i, 1e9, false, r); r < s; r++)
      if (n(this.from[r] + e, this.to[r] + e, this.value[r]) === false)
        return false;
  }
  map(e, t) {
    let i = [], n = [], r = [], s = -1, o = -1;
    for (let a = 0; a < this.value.length; a++) {
      let l = this.value[a], h2 = this.from[a] + e, u = this.to[a] + e, f, d;
      if (h2 == u) {
        let Q = t.mapPos(h2, l.startSide, l.mapMode);
        if (Q == null || (f = d = Q, l.startSide != l.endSide && (d = t.mapPos(h2, l.endSide), d < f)))
          continue;
      } else if (f = t.mapPos(h2, l.startSide), d = t.mapPos(u, l.endSide), f > d || f == d && l.startSide > 0 && l.endSide <= 0)
        continue;
      (d - f || l.endSide - l.startSide) < 0 || (s < 0 && (s = f), l.point && (o = Math.max(o, d - f)), i.push(l), n.push(f - s), r.push(d - s));
    }
    return { mapped: i.length ? new ul(n, r, i, o) : null, pos: s };
  }
};
var L = class {
  constructor(e, t, i, n) {
    this.chunkPos = e, this.chunk = t, this.nextLayer = i, this.maxPoint = n;
  }
  /**
  @internal
  */
  static create(e, t, i, n) {
    return new L(e, t, i, n);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let t of this.chunk)
      e += t.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: t = [], sort: i = false, filterFrom: n = 0, filterTo: r = this.length } = e, s = e.filter;
    if (t.length == 0 && !s)
      return this;
    if (i && (t = t.slice().sort(No)), this.isEmpty)
      return t.length ? L.of(t) : this;
    let o = new Ld(this, null, -1).goto(0), a = 0, l = [], h2 = new eO();
    for (; o.value || a < t.length; )
      if (a < t.length && (o.from - t[a].from || o.startSide - t[a].value.startSide) >= 0) {
        let u = t[a++];
        h2.addInner(u.from, u.to, u.value) || l.push(u);
      } else
        o.rangeIndex == 1 && o.chunkIndex < this.chunk.length && (a == t.length || this.chunkEnd(o.chunkIndex) < t[a].from) && (!s || n > this.chunkEnd(o.chunkIndex) || r < this.chunkPos[o.chunkIndex]) && h2.addChunk(this.chunkPos[o.chunkIndex], this.chunk[o.chunkIndex]) ? o.nextChunk() : ((!s || n > o.to || r < o.from || s(o.from, o.to, o.value)) && (h2.addInner(o.from, o.to, o.value) || l.push(Bo.create(o.from, o.to, o.value))), o.next());
    return h2.finishInner(this.nextLayer.isEmpty && !l.length ? L.empty : this.nextLayer.update({ add: l, filter: s, filterFrom: n, filterTo: r }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let t = [], i = [], n = -1;
    for (let s = 0; s < this.chunk.length; s++) {
      let o = this.chunkPos[s], a = this.chunk[s], l = e.touchesRange(o, o + a.length);
      if (l === false)
        n = Math.max(n, a.maxPoint), t.push(a), i.push(e.mapPos(o));
      else if (l === true) {
        let { mapped: h2, pos: u } = a.map(o, e);
        h2 && (n = Math.max(n, h2.maxPoint), t.push(h2), i.push(u));
      }
    }
    let r = this.nextLayer.map(e);
    return t.length == 0 ? r : new L(i, t, r || L.empty, n);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, t, i) {
    if (!this.isEmpty) {
      for (let n = 0; n < this.chunk.length; n++) {
        let r = this.chunkPos[n], s = this.chunk[n];
        if (t >= r && e <= r + s.length && s.between(r, e - r, t - r, i) === false)
          return;
      }
      this.nextLayer.between(e, t, i);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return Gi.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, t = 0) {
    return Gi.from(e).goto(t);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, t, i, n, r = -1) {
    let s = e.filter((u) => u.maxPoint > 0 || !u.isEmpty && u.maxPoint >= r), o = t.filter((u) => u.maxPoint > 0 || !u.isEmpty && u.maxPoint >= r), a = _c(s, o, i), l = new hi(s, a, r), h2 = new hi(o, a, r);
    i.iterGaps((u, f, d) => jc(l, u, h2, f, d, n)), i.empty && i.length == 0 && jc(l, 0, h2, 0, 0, n);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, t, i = 0, n) {
    n == null && (n = 1e9 - 1);
    let r = e.filter((h2) => !h2.isEmpty && t.indexOf(h2) < 0), s = t.filter((h2) => !h2.isEmpty && e.indexOf(h2) < 0);
    if (r.length != s.length)
      return false;
    if (!r.length)
      return true;
    let o = _c(r, s), a = new hi(r, o, 0).goto(i), l = new hi(s, o, 0).goto(i);
    for (; ; ) {
      if (a.to != l.to || !Fo(a.active, l.active) || a.point && (!l.point || !a.point.eq(l.point)))
        return false;
      if (a.to > n)
        return true;
      a.next(), l.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, t, i, n, r = -1) {
    let s = new hi(e, null, r).goto(t), o = t, a = s.openStart;
    for (; ; ) {
      let l = Math.min(s.to, i);
      if (s.point) {
        let h2 = s.activeForPoint(s.to), u = s.pointFrom < t ? h2.length + 1 : Math.min(h2.length, a);
        n.point(o, l, s.point, h2, u, s.pointRank), a = Math.min(s.openEnd(l), h2.length);
      } else
        l > o && (n.span(o, l, s.active, a), a = s.openEnd(l));
      if (s.to > i)
        return a + (s.point && s.to > i ? 1 : 0);
      o = s.to, s.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, t = false) {
    let i = new eO();
    for (let n of e instanceof Bo ? [e] : t ? $P(e) : e)
      i.add(n.from, n.to, n.value);
    return i.finish();
  }
};
L.empty = new L([], [], null, -1);
function $P(O) {
  if (O.length > 1)
    for (let e = O[0], t = 1; t < O.length; t++) {
      let i = O[t];
      if (No(e, i) > 0)
        return O.slice().sort(No);
      e = i;
    }
  return O;
}
L.empty.nextLayer = L.empty;
var eO = class {
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  finishChunk(e) {
    this.chunks.push(new ul(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, t, i) {
    this.addInner(e, t, i) || (this.nextLayer || (this.nextLayer = new eO())).add(e, t, i);
  }
  /**
  @internal
  */
  addInner(e, t, i) {
    let n = e - this.lastTo || i.startSide - this.last.endSide;
    if (n <= 0 && (e - this.lastFrom || i.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return n < 0 ? false : (this.from.length == 250 && this.finishChunk(true), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(t - this.chunkStart), this.last = i, this.lastFrom = e, this.lastTo = t, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, t - e)), true);
  }
  /**
  @internal
  */
  addChunk(e, t) {
    if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
      return false;
    this.from.length && this.finishChunk(true), this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint), this.chunks.push(t), this.chunkPos.push(e);
    let i = t.value.length - 1;
    return this.last = t.value[i], this.lastFrom = t.from[i] + e, this.lastTo = t.to[i] + e, true;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(L.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(false), this.chunks.length == 0)
      return e;
    let t = L.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, t;
  }
};
function _c(O, e, t) {
  let i = /* @__PURE__ */ new Map();
  for (let r of O)
    for (let s = 0; s < r.chunk.length; s++)
      r.chunk[s].maxPoint <= 0 && i.set(r.chunk[s], r.chunkPos[s]);
  let n = /* @__PURE__ */ new Set();
  for (let r of e)
    for (let s = 0; s < r.chunk.length; s++) {
      let o = i.get(r.chunk[s]);
      o != null && (t ? t.mapPos(o) : o) == r.chunkPos[s] && !(t != null && t.touchesRange(o, o + r.chunk[s].length)) && n.add(r.chunk[s]);
    }
  return n;
}
var Ld = class {
  constructor(e, t, i, n = 0) {
    this.layer = e, this.skip = t, this.minPoint = i, this.rank = n;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, t = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, t, false), this;
  }
  gotoInner(e, t, i) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let n = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(n) || this.layer.chunkEnd(this.chunkIndex) < e || n.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, i = false;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let n = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, true);
      (!i || this.rangeIndex < n) && this.setRangeIndex(n);
    }
    this.next();
  }
  forward(e, t) {
    (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, true);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], t = this.layer.chunk[this.chunkIndex], i = e + t.from[this.rangeIndex];
        if (this.from = i, this.to = e + t.to[this.rangeIndex], this.value = t.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
};
var Gi = class {
  constructor(e) {
    this.heap = e;
  }
  static from(e, t = null, i = -1) {
    let n = [];
    for (let r = 0; r < e.length; r++)
      for (let s = e[r]; !s.isEmpty; s = s.nextLayer)
        s.maxPoint >= i && n.push(new Ld(s, t, i, r));
    return n.length == 1 ? n[0] : new Gi(n);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, t = -1e9) {
    for (let i of this.heap)
      i.goto(e, t);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      Us(this.heap, i);
    return this.next(), this;
  }
  forward(e, t) {
    for (let i of this.heap)
      i.forward(e, t);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      Us(this.heap, i);
    (this.to - e || this.value.endSide - t) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), Us(this.heap, 0);
    }
  }
};
function Us(O, e) {
  for (let t = O[e]; ; ) {
    let i = (e << 1) + 1;
    if (i >= O.length)
      break;
    let n = O[i];
    if (i + 1 < O.length && n.compare(O[i + 1]) >= 0 && (n = O[i + 1], i++), t.compare(n) < 0)
      break;
    O[i] = t, O[e] = n, e = i;
  }
}
var hi = class {
  constructor(e, t, i) {
    this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Gi.from(e, t, i);
  }
  goto(e, t = -1e9) {
    return this.cursor.goto(e, t), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = t, this.openStart = -1, this.next(), this;
  }
  forward(e, t) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, t);
  }
  removeActive(e) {
    Xn(this.active, e), Xn(this.activeTo, e), Xn(this.activeRank, e), this.minActive = Cc(this.active, this.activeTo);
  }
  addActive(e) {
    let t = 0, { value: i, to: n, rank: r } = this.cursor;
    for (; t < this.activeRank.length && this.activeRank[t] <= r; )
      t++;
    xn(this.active, t, i), xn(this.activeTo, t, n), xn(this.activeRank, t, r), e && xn(e, t, this.cursor.from), this.minActive = Cc(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, t = this.point;
    this.point = null;
    let i = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let n = this.minActive;
      if (n > -1 && (this.activeTo[n] - this.cursor.from || this.active[n].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[n] > e) {
          this.to = this.activeTo[n], this.endSide = this.active[n].endSide;
          break;
        }
        this.removeActive(n), i && Xn(i, n);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let r = this.cursor.value;
          if (!r.point)
            this.addActive(i), this.cursor.next();
          else if (t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = r, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = r.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i) {
      this.openStart = 0;
      for (let n = i.length - 1; n >= 0 && i[n] < e; n--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let t = [];
    for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)
      (this.activeTo[i] > e || this.activeTo[i] == e && this.active[i].endSide >= this.point.endSide) && t.push(this.active[i]);
    return t.reverse();
  }
  openEnd(e) {
    let t = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > e; i--)
      t++;
    return t;
  }
};
function jc(O, e, t, i, n, r) {
  O.goto(e), t.goto(i);
  let s = i + n, o = i, a = i - e;
  for (; ; ) {
    let l = O.to + a - t.to || O.endSide - t.endSide, h2 = l < 0 ? O.to + a : t.to, u = Math.min(h2, s);
    if (O.point || t.point ? O.point && t.point && (O.point == t.point || O.point.eq(t.point)) && Fo(O.activeForPoint(O.to + a), t.activeForPoint(t.to)) || r.comparePoint(o, u, O.point, t.point) : u > o && !Fo(O.active, t.active) && r.compareRange(o, u, O.active, t.active), h2 > s)
      break;
    o = h2, l <= 0 && O.next(), l >= 0 && t.next();
  }
}
function Fo(O, e) {
  if (O.length != e.length)
    return false;
  for (let t = 0; t < O.length; t++)
    if (O[t] != e[t] && !O[t].eq(e[t]))
      return false;
  return true;
}
function Xn(O, e) {
  for (let t = e, i = O.length - 1; t < i; t++)
    O[t] = O[t + 1];
  O.pop();
}
function xn(O, e, t) {
  for (let i = O.length - 1; i >= e; i--)
    O[i + 1] = O[i];
  O[e] = t;
}
function Cc(O, e) {
  let t = -1, i = 1e9;
  for (let n = 0; n < e.length; n++)
    (e[n] - i || O[n].endSide - O[t].endSide) < 0 && (t = n, i = e[n]);
  return t;
}
function hn(O, e, t = O.length) {
  let i = 0;
  for (let n = 0; n < t; )
    O.charCodeAt(n) == 9 ? (i += e - i % e, n++) : (i++, n = ve(O, n));
  return i;
}
function Ho(O, e, t, i) {
  for (let n = 0, r = 0; ; ) {
    if (r >= e)
      return n;
    if (n == O.length)
      break;
    r += O.charCodeAt(n) == 9 ? t - r % t : 1, n = ve(O, n);
  }
  return i === true ? -1 : O.length;
}
var Ko = "ͼ";
var Gc = typeof Symbol > "u" ? "__" + Ko : Symbol.for(Ko);
var Jo = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
var Ic = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
var tO = class {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, t) {
    this.rules = [];
    let { finish: i } = t || {};
    function n(s) {
      return /^@/.test(s) ? [s] : s.split(/,\s*/);
    }
    function r(s, o, a, l) {
      let h2 = [], u = /^@(\w+)\b/.exec(s[0]), f = u && u[1] == "keyframes";
      if (u && o == null)
        return a.push(s[0] + ";");
      for (let d in o) {
        let Q = o[d];
        if (/&/.test(d))
          r(
            d.split(/,\s*/).map(($) => s.map((p) => $.replace(/&/, p))).reduce(($, p) => $.concat(p)),
            Q,
            a
          );
        else if (Q && typeof Q == "object") {
          if (!u)
            throw new RangeError("The value of a property (" + d + ") should be a primitive value.");
          r(n(d), Q, h2, f);
        } else
          Q != null && h2.push(d.replace(/_.*/, "").replace(/[A-Z]/g, ($) => "-" + $.toLowerCase()) + ": " + Q + ";");
      }
      (h2.length || f) && a.push((i && !u && !l ? s.map(i) : s).join(", ") + " {" + h2.join(" ") + "}");
    }
    for (let s in e)
      r(n(s), e[s], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let e = Ic[Gc] || 1;
    return Ic[Gc] = e + 1, Ko + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>)
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  static mount(e, t) {
    (e[Jo] || new pP(e)).mount(Array.isArray(t) ? t : [t]);
  }
};
var bn = null;
var pP = class {
  constructor(e) {
    if (!e.head && e.adoptedStyleSheets && typeof CSSStyleSheet < "u") {
      if (bn)
        return e.adoptedStyleSheets = [bn.sheet].concat(e.adoptedStyleSheets), e[Jo] = bn;
      this.sheet = new CSSStyleSheet(), e.adoptedStyleSheets = [this.sheet].concat(e.adoptedStyleSheets), bn = this;
    } else {
      this.styleTag = (e.ownerDocument || e).createElement("style");
      let t = e.head || e;
      t.insertBefore(this.styleTag, t.firstChild);
    }
    this.modules = [], e[Jo] = this;
  }
  mount(e) {
    let t = this.sheet, i = 0, n = 0;
    for (let r = 0; r < e.length; r++) {
      let s = e[r], o = this.modules.indexOf(s);
      if (o < n && o > -1 && (this.modules.splice(o, 1), n--, o = -1), o == -1) {
        if (this.modules.splice(n++, 0, s), t)
          for (let a = 0; a < s.rules.length; a++)
            t.insertRule(s.rules[a], i++);
      } else {
        for (; n < o; )
          i += this.modules[n++].rules.length;
        i += s.rules.length, n++;
      }
    }
    if (!t) {
      let r = "";
      for (let s = 0; s < this.modules.length; s++)
        r += this.modules[s].getRules() + `
`;
      this.styleTag.textContent = r;
    }
  }
};
var OO = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var Ii = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var Ec = typeof navigator < "u" && /Chrome\/(\d+)/.exec(navigator.userAgent);
var mP = typeof navigator < "u" && /Mac/.test(navigator.platform);
var gP = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
var SP = mP || Ec && +Ec[1] < 57;
for (ye = 0; ye < 10; ye++)
  OO[48 + ye] = OO[96 + ye] = String(ye);
var ye;
for (ye = 1; ye <= 24; ye++)
  OO[ye + 111] = "F" + ye;
var ye;
for (ye = 65; ye <= 90; ye++)
  OO[ye] = String.fromCharCode(ye + 32), Ii[ye] = String.fromCharCode(ye);
var ye;
for (Vs in OO)
  Ii.hasOwnProperty(Vs) || (Ii[Vs] = OO[Vs]);
var Vs;
function PP(O) {
  var e = SP && (O.ctrlKey || O.altKey || O.metaKey) || gP && O.shiftKey && O.key && O.key.length == 1 || O.key == "Unidentified", t = !e && O.key || (O.shiftKey ? Ii : OO)[O.keyCode] || O.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
function xr(O) {
  let e;
  return O.nodeType == 11 ? e = O.getSelection ? O : O.ownerDocument : e = O, e.getSelection();
}
function MO(O, e) {
  return e ? O == e || O.contains(e.nodeType != 1 ? e.parentNode : e) : false;
}
function yP(O) {
  let e = O.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function rr(O, e) {
  if (!e.anchorNode)
    return false;
  try {
    return MO(O, e.anchorNode);
  } catch {
    return false;
  }
}
function Ei(O) {
  return O.nodeType == 3 ? LO(O, 0, O.nodeValue.length).getClientRects() : O.nodeType == 1 ? O.getClientRects() : [];
}
function br(O, e, t, i) {
  return t ? Ac(O, e, t, i, -1) || Ac(O, e, t, i, 1) : false;
}
function wr(O) {
  for (var e = 0; ; e++)
    if (O = O.previousSibling, !O)
      return e;
}
function Ac(O, e, t, i, n) {
  for (; ; ) {
    if (O == t && e == i)
      return true;
    if (e == (n < 0 ? 0 : Ai(O))) {
      if (O.nodeName == "DIV")
        return false;
      let r = O.parentNode;
      if (!r || r.nodeType != 1)
        return false;
      e = wr(O) + (n < 0 ? 0 : 1), O = r;
    } else if (O.nodeType == 1) {
      if (O = O.childNodes[e + (n < 0 ? -1 : 0)], O.nodeType == 1 && O.contentEditable == "false")
        return false;
      e = n < 0 ? Ai(O) : 0;
    } else
      return false;
  }
}
function Ai(O) {
  return O.nodeType == 3 ? O.nodeValue.length : O.childNodes.length;
}
var Bd = { left: 0, right: 0, top: 0, bottom: 0 };
function fl(O, e) {
  let t = e ? O.left : O.right;
  return { left: t, right: t, top: O.top, bottom: O.bottom };
}
function XP(O) {
  return {
    left: 0,
    right: O.innerWidth,
    top: 0,
    bottom: O.innerHeight
  };
}
function xP(O, e, t, i, n, r, s, o) {
  let a = O.ownerDocument, l = a.defaultView || window;
  for (let h2 = O; h2; )
    if (h2.nodeType == 1) {
      let u, f = h2 == a.body;
      if (f)
        u = XP(l);
      else {
        if (h2.scrollHeight <= h2.clientHeight && h2.scrollWidth <= h2.clientWidth) {
          h2 = h2.assignedSlot || h2.parentNode;
          continue;
        }
        let $ = h2.getBoundingClientRect();
        u = {
          left: $.left,
          right: $.left + h2.clientWidth,
          top: $.top,
          bottom: $.top + h2.clientHeight
        };
      }
      let d = 0, Q = 0;
      if (n == "nearest")
        e.top < u.top ? (Q = -(u.top - e.top + s), t > 0 && e.bottom > u.bottom + Q && (Q = e.bottom - u.bottom + Q + s)) : e.bottom > u.bottom && (Q = e.bottom - u.bottom + s, t < 0 && e.top - Q < u.top && (Q = -(u.top + Q - e.top + s)));
      else {
        let $ = e.bottom - e.top, p = u.bottom - u.top;
        Q = (n == "center" && $ <= p ? e.top + $ / 2 - p / 2 : n == "start" || n == "center" && t < 0 ? e.top - s : e.bottom - p + s) - u.top;
      }
      if (i == "nearest" ? e.left < u.left ? (d = -(u.left - e.left + r), t > 0 && e.right > u.right + d && (d = e.right - u.right + d + r)) : e.right > u.right && (d = e.right - u.right + r, t < 0 && e.left < u.left + d && (d = -(u.left + d - e.left + r))) : d = (i == "center" ? e.left + (e.right - e.left) / 2 - (u.right - u.left) / 2 : i == "start" == o ? e.left - r : e.right - (u.right - u.left) + r) - u.left, d || Q)
        if (f)
          l.scrollBy(d, Q);
        else {
          let $ = 0, p = 0;
          if (Q) {
            let m = h2.scrollTop;
            h2.scrollTop += Q, p = h2.scrollTop - m;
          }
          if (d) {
            let m = h2.scrollLeft;
            h2.scrollLeft += d, $ = h2.scrollLeft - m;
          }
          e = {
            left: e.left - $,
            top: e.top - p,
            right: e.right - $,
            bottom: e.bottom - p
          }, $ && Math.abs($ - d) < 1 && (i = "nearest"), p && Math.abs(p - Q) < 1 && (n = "nearest");
        }
      if (f)
        break;
      h2 = h2.assignedSlot || h2.parentNode;
    } else if (h2.nodeType == 11)
      h2 = h2.host;
    else
      break;
}
function bP(O) {
  let e = O.ownerDocument;
  for (let t = O.parentNode; t && t != e.body; )
    if (t.nodeType == 1) {
      if (t.scrollHeight > t.clientHeight || t.scrollWidth > t.clientWidth)
        return t;
      t = t.assignedSlot || t.parentNode;
    } else if (t.nodeType == 11)
      t = t.host;
    else
      break;
  return null;
}
var wP = class {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    this.set(e.anchorNode, e.anchorOffset, e.focusNode, e.focusOffset);
  }
  set(e, t, i, n) {
    this.anchorNode = e, this.anchorOffset = t, this.focusNode = i, this.focusOffset = n;
  }
};
var kO = null;
function Nd(O) {
  if (O.setActive)
    return O.setActive();
  if (kO)
    return O.focus(kO);
  let e = [];
  for (let t = O; t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode)
    ;
  if (O.focus(kO == null ? {
    get preventScroll() {
      return kO = { preventScroll: true }, true;
    }
  } : void 0), !kO) {
    kO = false;
    for (let t = 0; t < e.length; ) {
      let i = e[t++], n = e[t++], r = e[t++];
      i.scrollTop != n && (i.scrollTop = n), i.scrollLeft != r && (i.scrollLeft = r);
    }
  }
}
var Dc;
function LO(O, e, t = e) {
  let i = Dc || (Dc = document.createRange());
  return i.setEnd(O, t), i.setStart(O, e), i;
}
function IO(O, e, t) {
  let i = { key: e, code: e, keyCode: t, which: t, cancelable: true }, n = new KeyboardEvent("keydown", i);
  n.synthetic = true, O.dispatchEvent(n);
  let r = new KeyboardEvent("keyup", i);
  return r.synthetic = true, O.dispatchEvent(r), n.defaultPrevented || r.defaultPrevented;
}
function TP(O) {
  for (; O; ) {
    if (O && (O.nodeType == 9 || O.nodeType == 11 && O.host))
      return O;
    O = O.assignedSlot || O.parentNode;
  }
  return null;
}
function Fd(O) {
  for (; O.attributes.length; )
    O.removeAttributeNode(O.attributes[0]);
}
function WP(O, e) {
  let t = e.focusNode, i = e.focusOffset;
  if (!t || e.anchorNode != t || e.anchorOffset != i)
    return false;
  for (; ; )
    if (i) {
      if (t.nodeType != 1)
        return false;
      let n = t.childNodes[i - 1];
      n.contentEditable == "false" ? i-- : (t = n, i = Ai(t));
    } else {
      if (t == O)
        return true;
      i = wr(t), t = t.parentNode;
    }
}
var be = class {
  constructor(e, t, i = true) {
    this.node = e, this.offset = t, this.precise = i;
  }
  static before(e, t) {
    return new be(e.parentNode, wr(e), t);
  }
  static after(e, t) {
    return new be(e.parentNode, wr(e) + 1, t);
  }
};
var dl = [];
var J = class {
  constructor() {
    this.parent = null, this.dom = null, this.dirty = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let t = this.posAtStart;
    for (let i of this.children) {
      if (i == e)
        return t;
      t += i.length + i.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  // Will return a rectangle directly before (when side < 0), after
  // (side > 0) or directly on (when the browser supports it) the
  // given position.
  coordsAt(e, t) {
    return null;
  }
  sync(e, t) {
    if (this.dirty & 2) {
      let i = this.dom, n = null, r;
      for (let s of this.children) {
        if (s.dirty) {
          if (!s.dom && (r = n ? n.nextSibling : i.firstChild)) {
            let o = J.get(r);
            (!o || !o.parent && o.canReuseDOM(s)) && s.reuseDOM(r);
          }
          s.sync(e, t), s.dirty = 0;
        }
        if (r = n ? n.nextSibling : i.firstChild, t && !t.written && t.node == i && r != s.dom && (t.written = true), s.dom.parentNode == i)
          for (; r && r != s.dom; )
            r = Mc(r);
        else
          i.insertBefore(s.dom, r);
        n = s.dom;
      }
      for (r = n ? n.nextSibling : i.firstChild, r && t && t.node == i && (t.written = true); r; )
        r = Mc(r);
    } else if (this.dirty & 1)
      for (let i of this.children)
        i.dirty && (i.sync(e, t), i.dirty = 0);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, t) {
    let i;
    if (e == this.dom)
      i = this.dom.childNodes[t];
    else {
      let n = Ai(e) == 0 ? 0 : t == 0 ? -1 : 1;
      for (; ; ) {
        let r = e.parentNode;
        if (r == this.dom)
          break;
        n == 0 && r.firstChild != r.lastChild && (e == r.firstChild ? n = -1 : n = 1), e = r;
      }
      n < 0 ? i = e : i = e.nextSibling;
    }
    if (i == this.dom.firstChild)
      return 0;
    for (; i && !J.get(i); )
      i = i.nextSibling;
    if (!i)
      return this.length;
    for (let n = 0, r = 0; ; n++) {
      let s = this.children[n];
      if (s.dom == i)
        return r;
      r += s.length + s.breakAfter;
    }
  }
  domBoundsAround(e, t, i = 0) {
    let n = -1, r = -1, s = -1, o = -1;
    for (let a = 0, l = i, h2 = i; a < this.children.length; a++) {
      let u = this.children[a], f = l + u.length;
      if (l < e && f > t)
        return u.domBoundsAround(e, t, l);
      if (f >= e && n == -1 && (n = a, r = l), l > t && u.dom.parentNode == this.dom) {
        s = a, o = h2;
        break;
      }
      h2 = f, l = f + u.breakAfter;
    }
    return {
      from: r,
      to: o < 0 ? i + this.length : o,
      startDOM: (n ? this.children[n - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: s < this.children.length && s >= 0 ? this.children[s].dom : null
    };
  }
  markDirty(e = false) {
    this.dirty |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if (e && (t.dirty |= 2), t.dirty & 1)
        return;
      t.dirty |= 1, e = false;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.dirty && this.markParentsDirty(true));
  }
  setDOM(e) {
    this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this;
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent;
      if (!t)
        return e;
      e = t;
    }
  }
  replaceChildren(e, t, i = dl) {
    this.markDirty();
    for (let n = e; n < t; n++) {
      let r = this.children[n];
      r.parent == this && r.destroy();
    }
    this.children.splice(e, t - e, ...i);
    for (let n = 0; n < i.length; n++)
      i[n].setParent(this);
  }
  ignoreMutation(e) {
    return false;
  }
  ignoreEvent(e) {
    return false;
  }
  childCursor(e = this.length) {
    return new Hd(this.children, e, this.children.length);
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return true;
  }
  merge(e, t, i, n, r, s) {
    return false;
  }
  become(e) {
    return false;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor;
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    this.parent = null;
  }
};
J.prototype.breakAfter = 0;
function Mc(O) {
  let e = O.nextSibling;
  return O.parentNode.removeChild(O), e;
}
var Hd = class {
  constructor(e, t, i) {
    this.children = e, this.pos = t, this.i = i, this.off = 0;
  }
  findPos(e, t = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let i = this.children[--this.i];
      this.pos -= i.length + i.breakAfter;
    }
  }
};
function Kd(O, e, t, i, n, r, s, o, a) {
  let { children: l } = O, h2 = l.length ? l[e] : null, u = r.length ? r[r.length - 1] : null, f = u ? u.breakAfter : s;
  if (!(e == i && h2 && !s && !f && r.length < 2 && h2.merge(t, n, r.length ? u : null, t == 0, o, a))) {
    if (i < l.length) {
      let d = l[i];
      d && n < d.length ? (e == i && (d = d.split(n), n = 0), !f && u && d.merge(0, n, u, true, 0, a) ? r[r.length - 1] = d : (n && d.merge(0, n, null, false, 0, a), r.push(d))) : d != null && d.breakAfter && (u ? u.breakAfter = 1 : s = 1), i++;
    }
    for (h2 && (h2.breakAfter = s, t > 0 && (!s && r.length && h2.merge(t, h2.length, r[0], false, o, 0) ? h2.breakAfter = r.shift().breakAfter : (t < h2.length || h2.children.length && h2.children[h2.children.length - 1].length == 0) && h2.merge(t, h2.length, null, false, o, 0), e++)); e < i && r.length; )
      if (l[i - 1].become(r[r.length - 1]))
        i--, r.pop(), a = r.length ? 0 : o;
      else if (l[e].become(r[0]))
        e++, r.shift(), o = r.length ? 0 : a;
      else
        break;
    !r.length && e && i < l.length && !l[e - 1].breakAfter && l[i].merge(0, 0, l[e - 1], false, o, a) && e--, (e < i || r.length) && O.replaceChildren(e, i, r);
  }
}
function Jd(O, e, t, i, n, r) {
  let s = O.childCursor(), { i: o, off: a } = s.findPos(t, 1), { i: l, off: h2 } = s.findPos(e, -1), u = e - t;
  for (let f of i)
    u += f.length;
  O.length += u, Kd(O, l, h2, o, a, i, 0, n, r);
}
var Me = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" };
var ea = typeof document < "u" ? document : { documentElement: { style: {} } };
var ta = /Edge\/(\d+)/.exec(Me.userAgent);
var eQ = /MSIE \d/.test(Me.userAgent);
var Oa = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Me.userAgent);
var ss = !!(eQ || Oa || ta);
var Lc = !ss && /gecko\/(\d+)/i.test(Me.userAgent);
var Rs = !ss && /Chrome\/(\d+)/.exec(Me.userAgent);
var Bc = "webkitFontSmoothing" in ea.documentElement.style;
var tQ = !ss && /Apple Computer/.test(Me.vendor);
var Nc = tQ && (/Mobile\/\w+/.test(Me.userAgent) || Me.maxTouchPoints > 2);
var Y = {
  mac: Nc || /Mac/.test(Me.platform),
  windows: /Win/.test(Me.platform),
  linux: /Linux|X11/.test(Me.platform),
  ie: ss,
  ie_version: eQ ? ea.documentMode || 6 : Oa ? +Oa[1] : ta ? +ta[1] : 0,
  gecko: Lc,
  gecko_version: Lc ? +(/Firefox\/(\d+)/.exec(Me.userAgent) || [0, 0])[1] : 0,
  chrome: !!Rs,
  chrome_version: Rs ? +Rs[1] : 0,
  ios: Nc,
  android: /Android\b/.test(Me.userAgent),
  webkit: Bc,
  safari: tQ,
  webkit_version: Bc ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: ea.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
var vP = 256;
var iO = class extends J {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, t) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = true), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, t, i) {
    return i && (!(i instanceof iO) || this.length - (t - e) + i.length > vP) ? false : (this.text = this.text.slice(0, e) + (i ? i.text : "") + this.text.slice(t), this.markDirty(), true);
  }
  split(e) {
    let t = new iO(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), t;
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0;
  }
  domAtPos(e) {
    return new be(this.dom, e);
  }
  domBoundsAround(e, t, i) {
    return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, t) {
    return ia(this.dom, e, t);
  }
};
var xt = class extends J {
  constructor(e, t = [], i = 0) {
    super(), this.mark = e, this.children = t, this.length = i;
    for (let n of t)
      n.setParent(this);
  }
  setAttrs(e) {
    if (Fd(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let t in this.mark.attrs)
        e.setAttribute(t, this.mark.attrs[t]);
    return e;
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.dirty |= 6);
  }
  sync(e, t) {
    this.dom ? this.dirty & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, t);
  }
  merge(e, t, i, n, r, s) {
    return i && (!(i instanceof xt && i.mark.eq(this.mark)) || e && r <= 0 || t < this.length && s <= 0) ? false : (Jd(this, e, t, i ? i.children : [], r - 1, s - 1), this.markDirty(), true);
  }
  split(e) {
    let t = [], i = 0, n = -1, r = 0;
    for (let o of this.children) {
      let a = i + o.length;
      a > e && t.push(i < e ? o.split(e - i) : o), n < 0 && i >= e && (n = r), i = a, r++;
    }
    let s = this.length - e;
    return this.length = e, n > -1 && (this.children.length = n, this.markDirty()), new xt(this.mark, t, s);
  }
  domAtPos(e) {
    return nQ(this, e);
  }
  coordsAt(e, t) {
    return sQ(this, e, t);
  }
};
function ia(O, e, t) {
  let i = O.nodeValue.length;
  e > i && (e = i);
  let n = e, r = e, s = 0;
  e == 0 && t < 0 || e == i && t >= 0 ? Y.chrome || Y.gecko || (e ? (n--, s = 1) : r < i && (r++, s = -1)) : t < 0 ? n-- : r < i && r++;
  let o = LO(O, n, r).getClientRects();
  if (!o.length)
    return Bd;
  let a = o[(s ? s < 0 : t >= 0) ? 0 : o.length - 1];
  return Y.safari && !s && a.width == 0 && (a = Array.prototype.find.call(o, (l) => l.width) || a), s ? fl(a, s < 0) : a || null;
}
var Dt = class extends J {
  constructor(e, t, i) {
    super(), this.widget = e, this.length = t, this.side = i, this.prevWidget = null;
  }
  static create(e, t, i) {
    return new (e.customView || Dt)(e, t, i);
  }
  split(e) {
    let t = Dt.create(this.widget, this.length - e, this.side);
    return this.length -= e, t;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.dom.contentEditable = "false");
  }
  getSide() {
    return this.side;
  }
  merge(e, t, i, n, r, s) {
    return i && (!(i instanceof Dt) || !this.widget.compare(i.widget) || e > 0 && r <= 0 || t < this.length && s <= 0) ? false : (this.length = e + (i ? i.length : 0) + (this.length - t), true);
  }
  become(e) {
    return e.length == this.length && e instanceof Dt && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.eq(e.widget) || this.markDirty(true), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, true) : false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return D.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: t } = e, i = t && t.state.doc, n = this.posAtStart;
    return i ? i.slice(n, n + this.length) : D.empty;
  }
  domAtPos(e) {
    return e == 0 ? be.before(this.dom) : be.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, t) {
    let i = this.dom.getClientRects(), n = null;
    if (!i.length)
      return Bd;
    for (let r = e > 0 ? i.length - 1 : 0; n = i[r], !(e > 0 ? r == 0 : r == i.length - 1 || n.top < n.bottom); r += e > 0 ? -1 : 1)
      ;
    return this.length ? n : fl(n, this.side > 0);
  }
  get isEditable() {
    return false;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
};
var OQ = class extends Dt {
  domAtPos(e) {
    let { topView: t, text: i } = this.widget;
    return t ? na(e, 0, t, i, (n, r) => n.domAtPos(r), (n) => new be(i, Math.min(n, i.nodeValue.length))) : new be(i, Math.min(e, i.nodeValue.length));
  }
  sync() {
    this.setDOM(this.widget.toDOM());
  }
  localPosFromDOM(e, t) {
    let { topView: i, text: n } = this.widget;
    return i ? iQ(e, t, i, n) : Math.min(t, this.length);
  }
  ignoreMutation() {
    return false;
  }
  get overrideDOMText() {
    return null;
  }
  coordsAt(e, t) {
    let { topView: i, text: n } = this.widget;
    return i ? na(e, t, i, n, (r, s, o) => r.coordsAt(s, o), (r, s) => ia(n, r, s)) : ia(n, e, t);
  }
  destroy() {
    var e;
    super.destroy(), (e = this.widget.topView) === null || e === void 0 || e.destroy();
  }
  get isEditable() {
    return true;
  }
  canReuseDOM() {
    return true;
  }
};
function na(O, e, t, i, n, r) {
  if (t instanceof xt) {
    for (let s = t.dom.firstChild; s; s = s.nextSibling) {
      let o = J.get(s);
      if (!o)
        return r(O, e);
      let a = MO(s, i), l = o.length + (a ? i.nodeValue.length : 0);
      if (O < l || O == l && o.getSide() <= 0)
        return a ? na(O, e, o, i, n, r) : n(o, O, e);
      O -= l;
    }
    return n(t, t.length, -1);
  } else
    return t.dom == i ? r(O, e) : n(t, O, e);
}
function iQ(O, e, t, i) {
  if (t instanceof xt)
    for (let n of t.children) {
      let r = 0, s = MO(n.dom, i);
      if (MO(n.dom, O))
        return r + (s ? iQ(O, e, n, i) : n.localPosFromDOM(O, e));
      r += s ? i.nodeValue.length : n.length;
    }
  else if (t.dom == i)
    return Math.min(e, i.nodeValue.length);
  return t.localPosFromDOM(O, e);
}
var BO = class extends J {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return false;
  }
  become(e) {
    return e instanceof BO && e.side == this.side;
  }
  split() {
    return new BO(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return be.before(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    let t = this.dom.getBoundingClientRect(), i = kP(this, this.side > 0 ? -1 : 1);
    return i && i.top < t.bottom && i.bottom > t.top ? { left: t.left, right: t.right, top: i.top, bottom: i.bottom } : t;
  }
  get overrideDOMText() {
    return D.empty;
  }
};
iO.prototype.children = Dt.prototype.children = BO.prototype.children = dl;
function kP(O, e) {
  let t = O.parent, i = t ? t.children.indexOf(O) : -1;
  for (; t && i >= 0; )
    if (e < 0 ? i > 0 : i < t.children.length) {
      let n = t.children[i + e];
      if (n instanceof iO) {
        let r = n.coordsAt(e < 0 ? n.length : 0, e);
        if (r)
          return r;
      }
      i += e;
    } else if (t instanceof xt && t.parent)
      i = t.parent.children.indexOf(t) + (e < 0 ? 0 : 1), t = t.parent;
    else {
      let n = t.dom.lastChild;
      if (n && n.nodeName == "BR")
        return n.getClientRects()[0];
      break;
    }
}
function nQ(O, e) {
  let t = O.dom, { children: i } = O, n = 0;
  for (let r = 0; n < i.length; n++) {
    let s = i[n], o = r + s.length;
    if (!(o == r && s.getSide() <= 0)) {
      if (e > r && e < o && s.dom.parentNode == t)
        return s.domAtPos(e - r);
      if (e <= r)
        break;
      r = o;
    }
  }
  for (let r = n; r > 0; r--) {
    let s = i[r - 1];
    if (s.dom.parentNode == t)
      return s.domAtPos(s.length);
  }
  for (let r = n; r < i.length; r++) {
    let s = i[r];
    if (s.dom.parentNode == t)
      return s.domAtPos(0);
  }
  return new be(t, 0);
}
function rQ(O, e, t) {
  let i, { children: n } = O;
  t > 0 && e instanceof xt && n.length && (i = n[n.length - 1]) instanceof xt && i.mark.eq(e.mark) ? rQ(i, e.children[0], t - 1) : (n.push(e), e.setParent(O)), O.length += e.length;
}
function sQ(O, e, t) {
  let i = null, n = -1, r = null, s = -1;
  function o(l, h2) {
    for (let u = 0, f = 0; u < l.children.length && f <= h2; u++) {
      let d = l.children[u], Q = f + d.length;
      Q >= h2 && (d.children.length ? o(d, h2 - f) : !r && (Q > h2 || f == Q && d.getSide() > 0) ? (r = d, s = h2 - f) : (f < h2 || f == Q && d.getSide() < 0) && (i = d, n = h2 - f)), f = Q;
    }
  }
  o(O, e);
  let a = (t < 0 ? i : r) || i || r;
  return a ? a.coordsAt(Math.max(0, a == i ? n : s), t) : YP(O);
}
function YP(O) {
  let e = O.dom.lastChild;
  if (!e)
    return O.dom.getBoundingClientRect();
  let t = Ei(e);
  return t[t.length - 1] || null;
}
function ra(O, e) {
  for (let t in O)
    t == "class" && e.class ? e.class += " " + O.class : t == "style" && e.style ? e.style += ";" + O.style : e[t] = O[t];
  return e;
}
function Ql(O, e) {
  if (O == e)
    return true;
  if (!O || !e)
    return false;
  let t = Object.keys(O), i = Object.keys(e);
  if (t.length != i.length)
    return false;
  for (let n of t)
    if (i.indexOf(n) == -1 || O[n] !== e[n])
      return false;
  return true;
}
function sa(O, e, t) {
  let i = null;
  if (e)
    for (let n in e)
      t && n in t || O.removeAttribute(i = n);
  if (t)
    for (let n in t)
      e && e[n] == t[n] || O.setAttribute(i = n, t[n]);
  return !!i;
}
var wt = class {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return false;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, t) {
    return false;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return true;
  }
  /**
  @internal
  */
  get customView() {
    return null;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
};
var F = function(O) {
  return O[O.Text = 0] = "Text", O[O.WidgetBefore = 1] = "WidgetBefore", O[O.WidgetAfter = 2] = "WidgetAfter", O[O.WidgetRange = 3] = "WidgetRange", O;
}(F || (F = {}));
var V = class extends PO {
  constructor(e, t, i, n) {
    super(), this.startSide = e, this.endSide = t, this.widget = i, this.spec = n;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return false;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new os(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let t = e.side || 0, i = !!e.block;
    return t += i ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new yO(e, t, t, i, e.widget || null, false);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let t = !!e.block, i, n;
    if (e.isBlockGap)
      i = -5e8, n = 4e8;
    else {
      let { start: r, end: s } = oQ(e, t);
      i = (r ? t ? -3e8 : -1 : 5e8) - 1, n = (s ? t ? 2e8 : 1 : -6e8) + 1;
    }
    return new yO(e, i, n, t, e.widget || null, true);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new un(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, t = false) {
    return L.of(e, t);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : false;
  }
};
V.none = L.empty;
var os = class extends V {
  constructor(e) {
    let { start: t, end: i } = oQ(e);
    super(t ? -1 : 5e8, i ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    return this == e || e instanceof os && this.tagName == e.tagName && this.class == e.class && Ql(this.attrs, e.attrs);
  }
  range(e, t = e) {
    if (e >= t)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, t);
  }
};
os.prototype.point = false;
var un = class extends V {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof un && this.spec.class == e.spec.class && Ql(this.spec.attributes, e.spec.attributes);
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, t);
  }
};
un.prototype.mapMode = Xe.TrackBefore;
un.prototype.point = true;
var yO = class extends V {
  constructor(e, t, i, n, r, s) {
    super(t, i, r, e), this.block = n, this.isReplace = s, this.mapMode = n ? t <= 0 ? Xe.TrackBefore : Xe.TrackAfter : Xe.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide < this.endSide ? F.WidgetRange : this.startSide <= 0 ? F.WidgetBefore : F.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && this.widget.estimatedHeight >= 5;
  }
  eq(e) {
    return e instanceof yO && ZP(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, t = e) {
    if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && t != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, t);
  }
};
yO.prototype.point = true;
function oQ(O, e = false) {
  let { inclusiveStart: t, inclusiveEnd: i } = O;
  return t == null && (t = O.inclusive), i == null && (i = O.inclusive), { start: t ?? e, end: i ?? e };
}
function ZP(O, e) {
  return O == e || !!(O && e && O.compare(e));
}
function oa(O, e, t, i = 0) {
  let n = t.length - 1;
  n >= 0 && t[n] + i >= O ? t[n] = Math.max(t[n], e) : t.push(O, e);
}
var ke = class extends J {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, t, i, n, r, s) {
    if (i) {
      if (!(i instanceof ke))
        return false;
      this.dom || i.transferDOM(this);
    }
    return n && this.setDeco(i ? i.attrs : null), Jd(this, e, t, i ? i.children : [], r, s), true;
  }
  split(e) {
    let t = new ke();
    if (t.breakAfter = this.breakAfter, this.length == 0)
      return t;
    let { i, off: n } = this.childPos(e);
    n && (t.append(this.children[i].split(n), 0), this.children[i].merge(n, this.children[i].length, null, false, 0, 0), i++);
    for (let r = i; r < this.children.length; r++)
      t.append(this.children[r], 0);
    for (; i > 0 && this.children[i - 1].length == 0; )
      this.children[--i].destroy();
    return this.children.length = i, this.markDirty(), this.length = e, t;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    Ql(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, t) {
    rQ(this, e, t);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let t = e.spec.attributes, i = e.spec.class;
    t && (this.attrs = ra(t, this.attrs || {})), i && (this.attrs = ra({ class: i }, this.attrs || {}));
  }
  domAtPos(e) {
    return nQ(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.dirty |= 6);
  }
  sync(e, t) {
    var i;
    this.dom ? this.dirty & 4 && (Fd(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (sa(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, t);
    let n = this.dom.lastChild;
    for (; n && J.get(n) instanceof xt; )
      n = n.lastChild;
    if (!n || !this.length || n.nodeName != "BR" && ((i = J.get(n)) === null || i === void 0 ? void 0 : i.isEditable) == false && (!Y.ios || !this.children.some((r) => r instanceof iO))) {
      let r = document.createElement("BR");
      r.cmIgnore = true, this.dom.appendChild(r);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0;
    for (let t of this.children) {
      if (!(t instanceof iO) || /[^ -~]/.test(t.text))
        return null;
      let i = Ei(t.dom);
      if (i.length != 1)
        return null;
      e += i[0].width;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length
    } : null;
  }
  coordsAt(e, t) {
    return sQ(this, e, t);
  }
  become(e) {
    return false;
  }
  get type() {
    return F.Text;
  }
  static find(e, t) {
    for (let i = 0, n = 0; i < e.children.length; i++) {
      let r = e.children[i], s = n + r.length;
      if (s >= t) {
        if (r instanceof ke)
          return r;
        if (s > t)
          break;
      }
      n = s + r.breakAfter;
    }
    return null;
  }
};
var mO = class extends J {
  constructor(e, t, i) {
    super(), this.widget = e, this.length = t, this.type = i, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, t, i, n, r, s) {
    return i && (!(i instanceof mO) || !this.widget.compare(i.widget) || e > 0 && r <= 0 || t < this.length && s <= 0) ? false : (this.length = e + (i ? i.length : 0) + (this.length - t), true);
  }
  domAtPos(e) {
    return e == 0 ? be.before(this.dom) : be.after(this.dom, e == this.length);
  }
  split(e) {
    let t = this.length - e;
    this.length = e;
    let i = new mO(this.widget, t, this.type);
    return i.breakAfter = this.breakAfter, i;
  }
  get children() {
    return dl;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.dom.contentEditable = "false");
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : D.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof mO && e.type == this.type && e.widget.constructor == this.widget.constructor ? (e.widget.eq(this.widget) || this.markDirty(true), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.breakAfter = e.breakAfter, true) : false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
};
var $l = class {
  constructor(e, t, i, n) {
    this.doc = e, this.pos = t, this.end = i, this.disallowBlockEffectsFor = n, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = true, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !e.breakAfter && !(e instanceof mO && e.type == F.WidgetBefore);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new ke()), this.atCursorPos = true), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(wn(new BO(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, this.posCovered() || this.getLine();
  }
  buildText(e, t, i) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: r, lineBreak: s, done: o } = this.cursor.next(this.skip);
        if (this.skip = 0, o)
          throw new Error("Ran out of text content when drawing inline views");
        if (s) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = true, e--;
          continue;
        } else
          this.text = r, this.textOff = 0;
      }
      let n = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(t.slice(t.length - i)), this.getLine().append(wn(new iO(this.text.slice(this.textOff, this.textOff + n)), t), i), this.atCursorPos = true, this.textOff += n, e -= n, i = 0;
    }
  }
  span(e, t, i, n) {
    this.buildText(t - e, i, n), this.pos = t, this.openStart < 0 && (this.openStart = n);
  }
  point(e, t, i, n, r, s) {
    if (this.disallowBlockEffectsFor[s] && i instanceof yO) {
      if (i.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let o = t - e;
    if (i instanceof yO)
      if (i.block) {
        let { type: a } = i;
        a == F.WidgetAfter && !this.posCovered() && this.getLine(), this.addBlockWidget(new mO(i.widget || new Fc("div"), o, a));
      } else {
        let a = Dt.create(i.widget || new Fc("span"), o, o ? 0 : i.startSide), l = this.atCursorPos && !a.isEditable && r <= n.length && (e < t || i.startSide > 0), h2 = !a.isEditable && (e < t || r > n.length || i.startSide <= 0), u = this.getLine();
        this.pendingBuffer == 2 && !l && (this.pendingBuffer = 0), this.flushBuffer(n), l && (u.append(wn(new BO(1), n), r), r = n.length + Math.max(0, r - n.length)), u.append(wn(a, n), r), this.atCursorPos = h2, this.pendingBuffer = h2 ? e < t || r > n.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = n.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i);
    o && (this.textOff + o <= this.text.length ? this.textOff += o : (this.skip += o - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = r);
  }
  static build(e, t, i, n, r) {
    let s = new $l(e, t, i, r);
    return s.openEnd = L.spans(n, t, i, s), s.openStart < 0 && (s.openStart = s.openEnd), s.finish(s.openEnd), s;
  }
};
function wn(O, e) {
  for (let t of e)
    O = new xt(t, [O], O.length);
  return O;
}
var Fc = class extends wt {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
};
var aQ = q.define();
var lQ = q.define();
var cQ = q.define();
var hQ = q.define();
var aa = q.define();
var uQ = q.define();
var fQ = q.define({
  combine: (O) => O.some((e) => e)
});
var dQ = q.define({
  combine: (O) => O.some((e) => e)
});
var Tr = class {
  constructor(e, t = "nearest", i = "nearest", n = 5, r = 5) {
    this.range = e, this.y = t, this.x = i, this.yMargin = n, this.xMargin = r;
  }
  map(e) {
    return e.empty ? this : new Tr(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin);
  }
};
var Hc = j.define({ map: (O, e) => O.map(e) });
function Ne(O, e, t) {
  let i = O.facet(hQ);
  i.length ? i[0](e) : window.onerror ? window.onerror(String(e), t, void 0, void 0, e) : t ? console.error(t + ":", e) : console.error(e);
}
var as = q.define({ combine: (O) => O.length ? O[0] : true });
var qP = 0;
var Xi = q.define();
var se = class {
  constructor(e, t, i, n) {
    this.id = e, this.create = t, this.domEventHandlers = i, this.extension = n(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, t) {
    const { eventHandlers: i, provide: n, decorations: r } = t || {};
    return new se(qP++, e, i, (s) => {
      let o = [Xi.of(s)];
      return r && o.push(Di.of((a) => {
        let l = a.plugin(s);
        return l ? r(l) : V.none;
      })), n && o.push(n(s)), o;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, t) {
    return se.define((i) => new e(i), t);
  }
};
var _s = class {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(t);
          } catch (i) {
            if (Ne(t.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (t) {
        Ne(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var t;
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        Ne(e.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
};
var QQ = q.define();
var pl = q.define();
var Di = q.define();
var $Q = q.define();
var pQ = q.define();
var xi = q.define();
var Xt = class {
  constructor(e, t, i, n) {
    this.fromA = e, this.toA = t, this.fromB = i, this.toB = n;
  }
  join(e) {
    return new Xt(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let t = e.length, i = this;
    for (; t > 0; t--) {
      let n = e[t - 1];
      if (!(n.fromA > i.toA)) {
        if (n.toA < i.fromA)
          break;
        i = i.join(n), e.splice(t - 1, 1);
      }
    }
    return e.splice(t, 0, i), e;
  }
  static extendWithRanges(e, t) {
    if (t.length == 0)
      return e;
    let i = [];
    for (let n = 0, r = 0, s = 0, o = 0; ; n++) {
      let a = n == e.length ? null : e[n], l = s - o, h2 = a ? a.fromB : 1e9;
      for (; r < t.length && t[r] < h2; ) {
        let u = t[r], f = t[r + 1], d = Math.max(o, u), Q = Math.min(h2, f);
        if (d <= Q && new Xt(d + l, Q + l, d, Q).addToSet(i), f > h2)
          break;
        r += 2;
      }
      if (!a)
        return i;
      new Xt(a.fromA, a.toA, a.fromB, a.toB).addToSet(i), s = a.toA, o = a.toB;
    }
  }
};
var Wr = class {
  constructor(e, t, i) {
    this.view = e, this.state = t, this.transactions = i, this.flags = 0, this.startState = e.state, this.changes = fe.empty(this.startState.doc.length);
    for (let s of i)
      this.changes = this.changes.compose(s.changes);
    let n = [];
    this.changes.iterChangedRanges((s, o, a, l) => n.push(new Xt(s, o, a, l))), this.changedRanges = n;
    let r = e.hasFocus;
    r != e.inputState.notifiedFocused && (e.inputState.notifiedFocused = r, this.flags |= 1);
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new Wr(e, t, i);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
};
var ne = function(O) {
  return O[O.LTR = 0] = "LTR", O[O.RTL = 1] = "RTL", O;
}(ne || (ne = {}));
var la = ne.LTR;
var zP = ne.RTL;
function mQ(O) {
  let e = [];
  for (let t = 0; t < O.length; t++)
    e.push(1 << +O[t]);
  return e;
}
var UP = mQ("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
var VP = mQ("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
var ca = /* @__PURE__ */ Object.create(null);
var dt = [];
for (let O of ["()", "[]", "{}"]) {
  let e = O.charCodeAt(0), t = O.charCodeAt(1);
  ca[e] = t, ca[t] = -e;
}
function RP(O) {
  return O <= 247 ? UP[O] : 1424 <= O && O <= 1524 ? 2 : 1536 <= O && O <= 1785 ? VP[O - 1536] : 1774 <= O && O <= 2220 ? 4 : 8192 <= O && O <= 8203 ? 256 : 64336 <= O && O <= 65023 ? 4 : O == 8204 ? 256 : 1;
}
var _P = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
var EO = class {
  /**
  @internal
  */
  constructor(e, t, i) {
    this.from = e, this.to = t, this.level = i;
  }
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? zP : la;
  }
  /**
  @internal
  */
  side(e, t) {
    return this.dir == t == e ? this.to : this.from;
  }
  /**
  @internal
  */
  static find(e, t, i, n) {
    let r = -1;
    for (let s = 0; s < e.length; s++) {
      let o = e[s];
      if (o.from <= t && o.to >= t) {
        if (o.level == i)
          return s;
        (r < 0 || (n != 0 ? n < 0 ? o.from < t : o.to > t : e[r].level > o.level)) && (r = s);
      }
    }
    if (r < 0)
      throw new RangeError("Index out of range");
    return r;
  }
};
var ie = [];
function jP(O, e) {
  let t = O.length, i = e == la ? 1 : 2, n = e == la ? 2 : 1;
  if (!O || i == 1 && !_P.test(O))
    return gQ(t);
  for (let s = 0, o = i, a = i; s < t; s++) {
    let l = RP(O.charCodeAt(s));
    l == 512 ? l = o : l == 8 && a == 4 && (l = 16), ie[s] = l == 4 ? 2 : l, l & 7 && (a = l), o = l;
  }
  for (let s = 0, o = i, a = i; s < t; s++) {
    let l = ie[s];
    if (l == 128)
      s < t - 1 && o == ie[s + 1] && o & 24 ? l = ie[s] = o : ie[s] = 256;
    else if (l == 64) {
      let h2 = s + 1;
      for (; h2 < t && ie[h2] == 64; )
        h2++;
      let u = s && o == 8 || h2 < t && ie[h2] == 8 ? a == 1 ? 1 : 8 : 256;
      for (let f = s; f < h2; f++)
        ie[f] = u;
      s = h2 - 1;
    } else
      l == 8 && a == 1 && (ie[s] = 1);
    o = l, l & 7 && (a = l);
  }
  for (let s = 0, o = 0, a = 0, l, h2, u; s < t; s++)
    if (h2 = ca[l = O.charCodeAt(s)])
      if (h2 < 0) {
        for (let f = o - 3; f >= 0; f -= 3)
          if (dt[f + 1] == -h2) {
            let d = dt[f + 2], Q = d & 2 ? i : d & 4 ? d & 1 ? n : i : 0;
            Q && (ie[s] = ie[dt[f]] = Q), o = f;
            break;
          }
      } else {
        if (dt.length == 189)
          break;
        dt[o++] = s, dt[o++] = l, dt[o++] = a;
      }
    else if ((u = ie[s]) == 2 || u == 1) {
      let f = u == i;
      a = f ? 0 : 1;
      for (let d = o - 3; d >= 0; d -= 3) {
        let Q = dt[d + 2];
        if (Q & 2)
          break;
        if (f)
          dt[d + 2] |= 2;
        else {
          if (Q & 4)
            break;
          dt[d + 2] |= 4;
        }
      }
    }
  for (let s = 0; s < t; s++)
    if (ie[s] == 256) {
      let o = s + 1;
      for (; o < t && ie[o] == 256; )
        o++;
      let a = (s ? ie[s - 1] : i) == 1, l = (o < t ? ie[o] : i) == 1, h2 = a == l ? a ? 1 : 2 : i;
      for (let u = s; u < o; u++)
        ie[u] = h2;
      s = o - 1;
    }
  let r = [];
  if (i == 1)
    for (let s = 0; s < t; ) {
      let o = s, a = ie[s++] != 1;
      for (; s < t && a == (ie[s] != 1); )
        s++;
      if (a)
        for (let l = s; l > o; ) {
          let h2 = l, u = ie[--l] != 2;
          for (; l > o && u == (ie[l - 1] != 2); )
            l--;
          r.push(new EO(l, h2, u ? 2 : 1));
        }
      else
        r.push(new EO(o, s, 0));
    }
  else
    for (let s = 0; s < t; ) {
      let o = s, a = ie[s++] == 2;
      for (; s < t && a == (ie[s] == 2); )
        s++;
      r.push(new EO(o, s, a ? 1 : 2));
    }
  return r;
}
function gQ(O) {
  return [new EO(0, O, 0)];
}
var SQ = "";
function CP(O, e, t, i, n) {
  var r;
  let s = i.head - O.from, o = -1;
  if (s == 0) {
    if (!n || !O.length)
      return null;
    e[0].level != t && (s = e[0].side(false, t), o = 0);
  } else if (s == O.length) {
    if (n)
      return null;
    let f = e[e.length - 1];
    f.level != t && (s = f.side(true, t), o = e.length - 1);
  }
  o < 0 && (o = EO.find(e, s, (r = i.bidiLevel) !== null && r !== void 0 ? r : -1, i.assoc));
  let a = e[o];
  s == a.side(n, t) && (a = e[o += n ? 1 : -1], s = a.side(!n, t));
  let l = n == (a.dir == t), h2 = ve(O.text, s, l);
  if (SQ = O.text.slice(Math.min(s, h2), Math.max(s, h2)), h2 != a.side(n, t))
    return S.cursor(h2 + O.from, l ? -1 : 1, a.level);
  let u = o == (n ? e.length - 1 : 0) ? null : e[o + (n ? 1 : -1)];
  return !u && a.level != t ? S.cursor(n ? O.to : O.from, n ? -1 : 1, t) : u && u.level < a.level ? S.cursor(u.side(!n, t) + O.from, n ? 1 : -1, u.level) : S.cursor(h2 + O.from, n ? -1 : 1, a.level);
}
var Mt = "￿";
var PQ = class {
  constructor(e, t) {
    this.points = e, this.text = "", this.lineSeparator = t.facet(I.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += Mt;
  }
  readRange(e, t) {
    if (!e)
      return this;
    let i = e.parentNode;
    for (let n = e; ; ) {
      this.findPointBefore(i, n), this.readNode(n);
      let r = n.nextSibling;
      if (r == t)
        break;
      let s = J.get(n), o = J.get(r);
      (s && o ? s.breakAfter : (s ? s.breakAfter : Kc(n)) || Kc(r) && (n.nodeName != "BR" || n.cmIgnore)) && this.lineBreak(), n = r;
    }
    return this.findPointBefore(i, t), this;
  }
  readTextNode(e) {
    let t = e.nodeValue;
    for (let i of this.points)
      i.node == e && (i.pos = this.text.length + Math.min(i.offset, t.length));
    for (let i = 0, n = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let r = -1, s = 1, o;
      if (this.lineSeparator ? (r = t.indexOf(this.lineSeparator, i), s = this.lineSeparator.length) : (o = n.exec(t)) && (r = o.index, s = o[0].length), this.append(t.slice(i, r < 0 ? t.length : r)), r < 0)
        break;
      if (this.lineBreak(), s > 1)
        for (let a of this.points)
          a.node == e && a.pos > this.text.length && (a.pos -= s - 1);
      i = r + s;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let t = J.get(e), i = t && t.overrideDOMText;
    if (i != null) {
      this.findPointInside(e, i.length);
      for (let n = i.iter(); !n.next().done; )
        n.lineBreak ? this.lineBreak() : this.append(n.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, t) {
    for (let i of this.points)
      i.node == e && e.childNodes[i.offset] == t && (i.pos = this.text.length);
  }
  findPointInside(e, t) {
    for (let i of this.points)
      (e.nodeType == 3 ? i.node == e : e.contains(i.node)) && (i.pos = this.text.length + Math.min(t, i.offset));
  }
};
function Kc(O) {
  return O.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(O.nodeName);
}
var Jc = class {
  constructor(e, t) {
    this.node = e, this.offset = t, this.pos = -1;
  }
};
var eh = class extends J {
  constructor(e) {
    super(), this.view = e, this.compositionDeco = V.none, this.decorations = [], this.dynamicDecorationMap = [], this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = false, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new ke()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Xt(0, 0, 0, e.state.doc.length)], 0);
  }
  get length() {
    return this.view.state.doc.length;
  }
  // Update the document view to a given state. scrollIntoView can be
  // used as a hint to compute a new viewport that includes that
  // position, if we know the editor is going to scroll that position
  // into view.
  update(e) {
    let t = e.changedRanges;
    this.minWidth > 0 && t.length && (t.every(({ fromA: s, toA: o }) => o < this.minWidthFrom || s > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.view.inputState.composing < 0 ? this.compositionDeco = V.none : (e.transactions.length || this.dirty) && (this.compositionDeco = IP(this.view, e.changes)), (Y.ie || Y.chrome) && !this.compositionDeco.size && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = true);
    let i = this.decorations, n = this.updateDeco(), r = MP(i, n, e.changes);
    return t = Xt.extendWithRanges(t, r), this.dirty == 0 && t.length == 0 ? false : (this.updateInner(t, e.startState.doc.length), e.transactions.length && (this.lastUpdate = Date.now()), true);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, t) {
    this.view.viewState.mustMeasureContent = true, this.updateChildren(e, t);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let r = Y.chrome || Y.ios ? { node: i.selectionRange.focusNode, written: false } : void 0;
      this.sync(this.view, r), this.dirty = 0, r && (r.written || i.selectionRange.focusNode != r.node) && (this.forceSelection = true), this.dom.style.height = "";
    });
    let n = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let r of this.children)
        r instanceof mO && r.widget instanceof th && n.push(r.dom);
    i.updateGaps(n);
  }
  updateChildren(e, t) {
    let i = this.childCursor(t);
    for (let n = e.length - 1; ; n--) {
      let r = n >= 0 ? e[n] : null;
      if (!r)
        break;
      let { fromA: s, toA: o, fromB: a, toB: l } = r, { content: h2, breakAtStart: u, openStart: f, openEnd: d } = $l.build(this.view.state.doc, a, l, this.decorations, this.dynamicDecorationMap), { i: Q, off: $ } = i.findPos(o, 1), { i: p, off: m } = i.findPos(s, -1);
      Kd(this, p, m, Q, $, h2, u, f, d);
    }
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = false, t = false) {
    if ((e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange(), !(t || this.mayControlSelection()))
      return;
    let i = this.forceSelection;
    this.forceSelection = false;
    let n = this.view.state.selection.main, r = this.domAtPos(n.anchor), s = n.empty ? r : this.domAtPos(n.head);
    if (Y.gecko && n.empty && GP(r)) {
      let a = document.createTextNode("");
      this.view.observer.ignore(() => r.node.insertBefore(a, r.node.childNodes[r.offset] || null)), r = s = new be(a, 0), i = true;
    }
    let o = this.view.observer.selectionRange;
    (i || !o.focusNode || !br(r.node, r.offset, o.anchorNode, o.anchorOffset) || !br(s.node, s.offset, o.focusNode, o.focusOffset)) && (this.view.observer.ignore(() => {
      Y.android && Y.chrome && this.dom.contains(o.focusNode) && LP(o.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: true }));
      let a = xr(this.view.root);
      if (a)
        if (n.empty) {
          if (Y.gecko) {
            let l = AP(r.node, r.offset);
            if (l && l != 3) {
              let h2 = XQ(r.node, r.offset, l == 1 ? 1 : -1);
              h2 && (r = new be(h2, l == 1 ? 0 : h2.nodeValue.length));
            }
          }
          a.collapse(r.node, r.offset), n.bidiLevel != null && o.cursorBidiLevel != null && (o.cursorBidiLevel = n.bidiLevel);
        } else if (a.extend) {
          a.collapse(r.node, r.offset);
          try {
            a.extend(s.node, s.offset);
          } catch {
          }
        } else {
          let l = document.createRange();
          n.anchor > n.head && ([r, s] = [s, r]), l.setEnd(s.node, s.offset), l.setStart(r.node, r.offset), a.removeAllRanges(), a.addRange(l);
        }
    }), this.view.observer.setSelectionRange(r, s)), this.impreciseAnchor = r.precise ? null : new be(o.anchorNode, o.anchorOffset), this.impreciseHead = s.precise ? null : new be(o.focusNode, o.focusOffset);
  }
  enforceCursorAssoc() {
    if (this.compositionDeco.size)
      return;
    let { view: e } = this, t = e.state.selection.main, i = xr(e.root), { anchorNode: n, anchorOffset: r } = e.observer.selectionRange;
    if (!i || !t.empty || !t.assoc || !i.modify)
      return;
    let s = ke.find(this, t.head);
    if (!s)
      return;
    let o = s.posAtStart;
    if (t.head == o || t.head == o + s.length)
      return;
    let a = this.coordsAt(t.head, -1), l = this.coordsAt(t.head, 1);
    if (!a || !l || a.bottom > l.top)
      return;
    let h2 = this.domAtPos(t.head + t.assoc);
    i.collapse(h2.node, h2.offset), i.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let u = e.observer.selectionRange;
    e.docView.posFromDOM(u.anchorNode, u.anchorOffset) != t.from && i.collapse(n, r);
  }
  mayControlSelection() {
    let e = this.view.root.activeElement;
    return e == this.dom || rr(this.dom, this.view.observer.selectionRange) && !(e && this.dom.contains(e));
  }
  nearest(e) {
    for (let t = e; t; ) {
      let i = J.get(t);
      if (i && i.rootView == this)
        return i;
      t = t.parentNode;
    }
    return null;
  }
  posFromDOM(e, t) {
    let i = this.nearest(e);
    if (!i)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return i.localPosFromDOM(e, t) + i.posAtStart;
  }
  domAtPos(e) {
    let { i: t, off: i } = this.childCursor().findPos(e, -1);
    for (; t < this.children.length - 1; ) {
      let n = this.children[t];
      if (i < n.length || n instanceof ke)
        break;
      t++, i = 0;
    }
    return this.children[t].domAtPos(i);
  }
  coordsAt(e, t) {
    for (let i = this.length, n = this.children.length - 1; ; n--) {
      let r = this.children[n], s = i - r.breakAfter - r.length;
      if (e > s || e == s && r.type != F.WidgetBefore && r.type != F.WidgetAfter && (!n || t == 2 || this.children[n - 1].breakAfter || this.children[n - 1].type == F.WidgetBefore && t > -2))
        return r.coordsAt(e - s, t);
      i = s;
    }
  }
  measureVisibleLineHeights(e) {
    let t = [], { from: i, to: n } = e, r = this.view.contentDOM.clientWidth, s = r > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, o = -1, a = this.view.textDirection == ne.LTR;
    for (let l = 0, h2 = 0; h2 < this.children.length; h2++) {
      let u = this.children[h2], f = l + u.length;
      if (f > n)
        break;
      if (l >= i) {
        let d = u.dom.getBoundingClientRect();
        if (t.push(d.height), s) {
          let Q = u.dom.lastChild, $ = Q ? Ei(Q) : [];
          if ($.length) {
            let p = $[$.length - 1], m = a ? p.right - d.left : d.right - p.left;
            m > o && (o = m, this.minWidth = r, this.minWidthFrom = l, this.minWidthTo = f);
          }
        }
      }
      l = f + u.breakAfter;
    }
    return t;
  }
  textDirectionAt(e) {
    let { i: t } = this.childPos(e, 1);
    return getComputedStyle(this.children[t].dom).direction == "rtl" ? ne.RTL : ne.LTR;
  }
  measureTextSize() {
    for (let n of this.children)
      if (n instanceof ke) {
        let r = n.measureTextSize();
        if (r)
          return r;
      }
    let e = document.createElement("div"), t, i;
    return e.className = "cm-line", e.style.width = "99999px", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let n = Ei(e.firstChild)[0];
      t = e.getBoundingClientRect().height, i = n ? n.width / 27 : 7, e.remove();
    }), { lineHeight: t, charWidth: i };
  }
  childCursor(e = this.length) {
    let t = this.children.length;
    return t && (e -= this.children[--t].length), new Hd(this.children, e, t);
  }
  computeBlockGapDeco() {
    let e = [], t = this.view.viewState;
    for (let i = 0, n = 0; ; n++) {
      let r = n == t.viewports.length ? null : t.viewports[n], s = r ? r.from - 1 : this.length;
      if (s > i) {
        let o = t.lineBlockAt(s).bottom - t.lineBlockAt(i).top;
        e.push(V.replace({
          widget: new th(o),
          block: true,
          inclusive: true,
          isBlockGap: true
        }).range(i, s));
      }
      if (!r)
        break;
      i = r.to + 1;
    }
    return V.set(e);
  }
  updateDeco() {
    let e = this.view.state.facet(Di).map((t, i) => (this.dynamicDecorationMap[i] = typeof t == "function") ? t(this.view) : t);
    for (let t = e.length; t < e.length + 3; t++)
      this.dynamicDecorationMap[t] = false;
    return this.decorations = [
      ...e,
      this.compositionDeco,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(e) {
    let { range: t } = e, i = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1), n;
    if (!i)
      return;
    !t.empty && (n = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, n.left),
      top: Math.min(i.top, n.top),
      right: Math.max(i.right, n.right),
      bottom: Math.max(i.bottom, n.bottom)
    });
    let r = 0, s = 0, o = 0, a = 0;
    for (let h2 of this.view.state.facet(pQ).map((u) => u(this.view)))
      if (h2) {
        let { left: u, right: f, top: d, bottom: Q } = h2;
        u != null && (r = Math.max(r, u)), f != null && (s = Math.max(s, f)), d != null && (o = Math.max(o, d)), Q != null && (a = Math.max(a, Q));
      }
    let l = {
      left: i.left - r,
      top: i.top - o,
      right: i.right + s,
      bottom: i.bottom + a
    };
    xP(this.view.scrollDOM, l, t.head < t.anchor ? -1 : 1, e.x, e.y, e.xMargin, e.yMargin, this.view.textDirection == ne.LTR);
  }
};
function GP(O) {
  return O.node.nodeType == 1 && O.node.firstChild && (O.offset == 0 || O.node.childNodes[O.offset - 1].contentEditable == "false") && (O.offset == O.node.childNodes.length || O.node.childNodes[O.offset].contentEditable == "false");
}
var th = class extends wt {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", true;
  }
  get estimatedHeight() {
    return this.height;
  }
};
function yQ(O) {
  let e = O.observer.selectionRange, t = e.focusNode && XQ(e.focusNode, e.focusOffset, 0);
  if (!t)
    return null;
  let i = O.docView.nearest(t);
  if (!i)
    return null;
  if (i instanceof ke) {
    let n = t;
    for (; n.parentNode != i.dom; )
      n = n.parentNode;
    let r = n.previousSibling;
    for (; r && !J.get(r); )
      r = r.previousSibling;
    let s = r ? J.get(r).posAtEnd : i.posAtStart;
    return { from: s, to: s, node: n, text: t };
  } else {
    for (; ; ) {
      let { parent: r } = i;
      if (!r)
        return null;
      if (r instanceof ke)
        break;
      i = r;
    }
    let n = i.posAtStart;
    return { from: n, to: n + i.length, node: i.dom, text: t };
  }
}
function IP(O, e) {
  let t = yQ(O);
  if (!t)
    return V.none;
  let { from: i, to: n, node: r, text: s } = t, o = e.mapPos(i, 1), a = Math.max(o, e.mapPos(n, -1)), { state: l } = O, h2 = r.nodeType == 3 ? r.nodeValue : new PQ([], l).readRange(r.firstChild, null).text;
  if (a - o < h2.length)
    if (l.doc.sliceString(o, Math.min(l.doc.length, o + h2.length), Mt) == h2)
      a = o + h2.length;
    else if (l.doc.sliceString(Math.max(0, a - h2.length), a, Mt) == h2)
      o = a - h2.length;
    else
      return V.none;
  else if (l.doc.sliceString(o, a, Mt) != h2)
    return V.none;
  let u = J.get(r);
  return u instanceof OQ ? u = u.widget.topView : u && (u.parent = null), V.set(V.replace({ widget: new EP(r, s, u), inclusive: true }).range(o, a));
}
var EP = class extends wt {
  constructor(e, t, i) {
    super(), this.top = e, this.text = t, this.topView = i;
  }
  eq(e) {
    return this.top == e.top && this.text == e.text;
  }
  toDOM() {
    return this.top;
  }
  ignoreEvent() {
    return false;
  }
  get customView() {
    return OQ;
  }
};
function XQ(O, e, t) {
  for (; ; ) {
    if (O.nodeType == 3)
      return O;
    if (O.nodeType == 1 && e > 0 && t <= 0)
      O = O.childNodes[e - 1], e = Ai(O);
    else if (O.nodeType == 1 && e < O.childNodes.length && t >= 0)
      O = O.childNodes[e], e = 0;
    else
      return null;
  }
}
function AP(O, e) {
  return O.nodeType != 1 ? 0 : (e && O.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < O.childNodes.length && O.childNodes[e].contentEditable == "false" ? 2 : 0);
}
var DP = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, t) {
    oa(e, t, this.changes);
  }
  comparePoint(e, t) {
    oa(e, t, this.changes);
  }
};
function MP(O, e, t) {
  let i = new DP();
  return L.compare(O, e, t, i), i.changes;
}
function LP(O, e) {
  for (let t = O; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == "false")
      return true;
  return false;
}
function BP(O, e, t = 1) {
  let i = O.charCategorizer(e), n = O.doc.lineAt(e), r = e - n.from;
  if (n.length == 0)
    return S.cursor(e);
  r == 0 ? t = 1 : r == n.length && (t = -1);
  let s = r, o = r;
  t < 0 ? s = ve(n.text, r, false) : o = ve(n.text, r);
  let a = i(n.text.slice(s, o));
  for (; s > 0; ) {
    let l = ve(n.text, s, false);
    if (i(n.text.slice(l, s)) != a)
      break;
    s = l;
  }
  for (; o < n.length; ) {
    let l = ve(n.text, o);
    if (i(n.text.slice(o, l)) != a)
      break;
    o = l;
  }
  return S.range(s + n.from, o + n.from);
}
function NP(O, e) {
  return e.left > O ? e.left - O : Math.max(0, O - e.right);
}
function FP(O, e) {
  return e.top > O ? e.top - O : Math.max(0, O - e.bottom);
}
function js(O, e) {
  return O.top < e.bottom - 1 && O.bottom > e.top + 1;
}
function Oh(O, e) {
  return e < O.top ? { top: e, left: O.left, right: O.right, bottom: O.bottom } : O;
}
function ih(O, e) {
  return e > O.bottom ? { top: O.top, left: O.left, right: O.right, bottom: e } : O;
}
function ha(O, e, t) {
  let i, n, r, s, o = false, a, l, h2, u;
  for (let Q = O.firstChild; Q; Q = Q.nextSibling) {
    let $ = Ei(Q);
    for (let p = 0; p < $.length; p++) {
      let m = $[p];
      n && js(n, m) && (m = Oh(ih(m, n.bottom), n.top));
      let g = NP(e, m), b = FP(t, m);
      if (g == 0 && b == 0)
        return Q.nodeType == 3 ? nh(Q, e, t) : ha(Q, e, t);
      if (!i || s > b || s == b && r > g) {
        i = Q, n = m, r = g, s = b;
        let y = b ? t < m.top ? -1 : 1 : g ? e < m.left ? -1 : 1 : 0;
        o = !y || (y > 0 ? p < $.length - 1 : p > 0);
      }
      g == 0 ? t > m.bottom && (!h2 || h2.bottom < m.bottom) ? (a = Q, h2 = m) : t < m.top && (!u || u.top > m.top) && (l = Q, u = m) : h2 && js(h2, m) ? h2 = ih(h2, m.bottom) : u && js(u, m) && (u = Oh(u, m.top));
    }
  }
  if (h2 && h2.bottom >= t ? (i = a, n = h2) : u && u.top <= t && (i = l, n = u), !i)
    return { node: O, offset: 0 };
  let f = Math.max(n.left, Math.min(n.right, e));
  if (i.nodeType == 3)
    return nh(i, f, t);
  if (o && i.contentEditable != "false")
    return ha(i, f, t);
  let d = Array.prototype.indexOf.call(O.childNodes, i) + (e >= (n.left + n.right) / 2 ? 1 : 0);
  return { node: O, offset: d };
}
function nh(O, e, t) {
  let i = O.nodeValue.length, n = -1, r = 1e9, s = 0;
  for (let o = 0; o < i; o++) {
    let a = LO(O, o, o + 1).getClientRects();
    for (let l = 0; l < a.length; l++) {
      let h2 = a[l];
      if (h2.top == h2.bottom)
        continue;
      s || (s = e - h2.left);
      let u = (h2.top > t ? h2.top - t : t - h2.bottom) - 1;
      if (h2.left - 1 <= e && h2.right + 1 >= e && u < r) {
        let f = e >= (h2.left + h2.right) / 2, d = f;
        if ((Y.chrome || Y.gecko) && LO(O, o).getBoundingClientRect().left == h2.right && (d = !f), u <= 0)
          return { node: O, offset: o + (d ? 1 : 0) };
        n = o + (d ? 1 : 0), r = u;
      }
    }
  }
  return { node: O, offset: n > -1 ? n : s > 0 ? O.nodeValue.length : 0 };
}
function xQ(O, { x: e, y: t }, i, n = -1) {
  var r;
  let s = O.contentDOM.getBoundingClientRect(), o = s.top + O.viewState.paddingTop, a, { docHeight: l } = O.viewState, h2 = t - o;
  if (h2 < 0)
    return 0;
  if (h2 > l)
    return O.state.doc.length;
  for (let m = O.defaultLineHeight / 2, g = false; a = O.elementAtHeight(h2), a.type != F.Text; )
    for (; h2 = n > 0 ? a.bottom + m : a.top - m, !(h2 >= 0 && h2 <= l); ) {
      if (g)
        return i ? null : 0;
      g = true, n = -n;
    }
  t = o + h2;
  let u = a.from;
  if (u < O.viewport.from)
    return O.viewport.from == 0 ? 0 : i ? null : rh(O, s, a, e, t);
  if (u > O.viewport.to)
    return O.viewport.to == O.state.doc.length ? O.state.doc.length : i ? null : rh(O, s, a, e, t);
  let f = O.dom.ownerDocument, d = O.root.elementFromPoint ? O.root : f, Q = d.elementFromPoint(e, t);
  Q && !O.contentDOM.contains(Q) && (Q = null), Q || (e = Math.max(s.left + 1, Math.min(s.right - 1, e)), Q = d.elementFromPoint(e, t), Q && !O.contentDOM.contains(Q) && (Q = null));
  let $, p = -1;
  if (Q && ((r = O.docView.nearest(Q)) === null || r === void 0 ? void 0 : r.isEditable) != false) {
    if (f.caretPositionFromPoint) {
      let m = f.caretPositionFromPoint(e, t);
      m && ({ offsetNode: $, offset: p } = m);
    } else if (f.caretRangeFromPoint) {
      let m = f.caretRangeFromPoint(e, t);
      m && ({ startContainer: $, startOffset: p } = m, (!O.contentDOM.contains($) || Y.safari && HP($, p, e) || Y.chrome && KP($, p, e)) && ($ = void 0));
    }
  }
  if (!$ || !O.docView.dom.contains($)) {
    let m = ke.find(O.docView, u);
    if (!m)
      return h2 > a.top + a.height / 2 ? a.to : a.from;
    ({ node: $, offset: p } = ha(m.dom, e, t));
  }
  return O.docView.posFromDOM($, p);
}
function rh(O, e, t, i, n) {
  let r = Math.round((i - e.left) * O.defaultCharacterWidth);
  if (O.lineWrapping && t.height > O.defaultLineHeight * 1.5) {
    let o = Math.floor((n - t.top) / O.defaultLineHeight);
    r += o * O.viewState.heightOracle.lineLength;
  }
  let s = O.state.sliceDoc(t.from, t.to);
  return t.from + Ho(s, r, O.state.tabSize);
}
function HP(O, e, t) {
  let i;
  if (O.nodeType != 3 || e != (i = O.nodeValue.length))
    return false;
  for (let n = O.nextSibling; n; n = n.nextSibling)
    if (n.nodeType != 1 || n.nodeName != "BR")
      return false;
  return LO(O, i - 1, i).getBoundingClientRect().left > t;
}
function KP(O, e, t) {
  if (e != 0)
    return false;
  for (let n = O; ; ) {
    let r = n.parentNode;
    if (!r || r.nodeType != 1 || r.firstChild != n)
      return false;
    if (r.classList.contains("cm-line"))
      break;
    n = r;
  }
  let i = O.nodeType == 1 ? O.getBoundingClientRect() : LO(O, 0, Math.max(O.nodeValue.length, 1)).getBoundingClientRect();
  return t - i.left > 5;
}
function JP(O, e, t, i) {
  let n = O.state.doc.lineAt(e.head), r = !i || !O.lineWrapping ? null : O.coordsAtPos(e.assoc < 0 && e.head > n.from ? e.head - 1 : e.head);
  if (r) {
    let a = O.dom.getBoundingClientRect(), l = O.textDirectionAt(n.from), h2 = O.posAtCoords({
      x: t == (l == ne.LTR) ? a.right - 1 : a.left + 1,
      y: (r.top + r.bottom) / 2
    });
    if (h2 != null)
      return S.cursor(h2, t ? -1 : 1);
  }
  let s = ke.find(O.docView, e.head), o = s ? t ? s.posAtEnd : s.posAtStart : t ? n.to : n.from;
  return S.cursor(o, t ? -1 : 1);
}
function sh(O, e, t, i) {
  let n = O.state.doc.lineAt(e.head), r = O.bidiSpans(n), s = O.textDirectionAt(n.from);
  for (let o = e, a = null; ; ) {
    let l = CP(n, r, s, o, t), h2 = SQ;
    if (!l) {
      if (n.number == (t ? O.state.doc.lines : 1))
        return o;
      h2 = `
`, n = O.state.doc.line(n.number + (t ? 1 : -1)), r = O.bidiSpans(n), l = S.cursor(t ? n.from : n.to);
    }
    if (a) {
      if (!a(h2))
        return o;
    } else {
      if (!i)
        return l;
      a = i(h2);
    }
    o = l;
  }
}
function ey(O, e, t) {
  let i = O.state.charCategorizer(e), n = i(t);
  return (r) => {
    let s = i(r);
    return n == ee.Space && (n = s), n == s;
  };
}
function ty(O, e, t, i) {
  let n = e.head, r = t ? 1 : -1;
  if (n == (t ? O.state.doc.length : 0))
    return S.cursor(n, e.assoc);
  let s = e.goalColumn, o, a = O.contentDOM.getBoundingClientRect(), l = O.coordsAtPos(n), h2 = O.documentTop;
  if (l)
    s == null && (s = l.left - a.left), o = r < 0 ? l.top : l.bottom;
  else {
    let d = O.viewState.lineBlockAt(n);
    s == null && (s = Math.min(a.right - a.left, O.defaultCharacterWidth * (n - d.from))), o = (r < 0 ? d.top : d.bottom) + h2;
  }
  let u = a.left + s, f = i ?? O.defaultLineHeight >> 1;
  for (let d = 0; ; d += 10) {
    let Q = o + (f + d) * r, $ = xQ(O, { x: u, y: Q }, false, r);
    if (Q < a.top || Q > a.bottom || (r < 0 ? $ < n : $ > n))
      return S.cursor($, e.assoc, void 0, s);
  }
}
function Cs(O, e, t) {
  let i = O.state.facet($Q).map((n) => n(O));
  for (; ; ) {
    let n = false;
    for (let r of i)
      r.between(t.from - 1, t.from + 1, (s, o, a) => {
        t.from > s && t.from < o && (t = e.head > t.from ? S.cursor(s, 1) : S.cursor(o, -1), n = true);
      });
    if (!n)
      return t;
  }
}
var Oy = class {
  constructor(e) {
    this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.chromeScrollHack = -1, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.registeredEvents = [], this.customHandlers = [], this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.mouseSelection = null;
    let t = (i, n) => {
      this.ignoreDuringComposition(n) || n.type == "keydown" && this.keydown(e, n) || (this.mustFlushObserver(n) && e.observer.forceFlush(), this.runCustomHandlers(n.type, e, n) ? n.preventDefault() : i(e, n));
    };
    for (let i in Qe) {
      let n = Qe[i];
      e.contentDOM.addEventListener(i, (r) => {
        oh(e, r) && t(n, r);
      }, ua[i]), this.registeredEvents.push(i);
    }
    e.scrollDOM.addEventListener("mousedown", (i) => {
      i.target == e.scrollDOM && i.clientY > e.contentDOM.getBoundingClientRect().bottom && t(Qe.mousedown, i);
    }), Y.chrome && Y.chrome_version == 102 && e.scrollDOM.addEventListener("wheel", () => {
      this.chromeScrollHack < 0 ? e.contentDOM.style.pointerEvents = "none" : window.clearTimeout(this.chromeScrollHack), this.chromeScrollHack = setTimeout(() => {
        this.chromeScrollHack = -1, e.contentDOM.style.pointerEvents = "";
      }, 100);
    }, { passive: true }), this.notifiedFocused = e.hasFocus, Y.safari && e.contentDOM.addEventListener("input", () => null);
  }
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  ensureHandlers(e, t) {
    var i;
    let n;
    this.customHandlers = [];
    for (let r of t)
      if (n = (i = r.update(e).spec) === null || i === void 0 ? void 0 : i.domEventHandlers) {
        this.customHandlers.push({ plugin: r.value, handlers: n });
        for (let s in n)
          this.registeredEvents.indexOf(s) < 0 && s != "scroll" && (this.registeredEvents.push(s), e.contentDOM.addEventListener(s, (o) => {
            oh(e, o) && this.runCustomHandlers(s, e, o) && o.preventDefault();
          }));
      }
  }
  runCustomHandlers(e, t, i) {
    for (let n of this.customHandlers) {
      let r = n.handlers[e];
      if (r)
        try {
          if (r.call(n.plugin, i, t) || i.defaultPrevented)
            return true;
        } catch (s) {
          Ne(t.state, s);
        }
    }
    return false;
  }
  runScrollHandlers(e, t) {
    this.lastScrollTop = e.scrollDOM.scrollTop, this.lastScrollLeft = e.scrollDOM.scrollLeft;
    for (let i of this.customHandlers) {
      let n = i.handlers.scroll;
      if (n)
        try {
          n.call(i.plugin, t, e);
        } catch (r) {
          Ne(e.state, r);
        }
    }
  }
  keydown(e, t) {
    if (this.lastKeyCode = t.keyCode, this.lastKeyTime = Date.now(), t.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return true;
    if (Y.android && Y.chrome && !t.synthetic && (t.keyCode == 13 || t.keyCode == 8))
      return e.observer.delayAndroidKey(t.key, t.keyCode), true;
    let i;
    return Y.ios && !t.synthetic && !t.altKey && !t.metaKey && ((i = bQ.find((n) => n.keyCode == t.keyCode)) && !t.ctrlKey || iy.indexOf(t.key) > -1 && t.ctrlKey && !t.shiftKey) ? (this.pendingIOSKey = i || t, setTimeout(() => this.flushIOSKey(e), 250), true) : false;
  }
  flushIOSKey(e) {
    let t = this.pendingIOSKey;
    return t ? (this.pendingIOSKey = void 0, IO(e.contentDOM, t.key, t.keyCode)) : false;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? true : Y.safari && !Y.ios && Date.now() - this.compositionEndedAt < 100 ? (this.compositionEndedAt = 0, true) : false : false;
  }
  mustFlushObserver(e) {
    return e.type == "keydown" && e.keyCode != 229;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
};
var bQ = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
];
var iy = "dthko";
var wQ = [16, 17, 18, 20, 91, 92, 224, 225];
function Tn(O) {
  return O * 0.7 + 8;
}
var ny = class {
  constructor(e, t, i, n) {
    this.view = e, this.style = i, this.mustSelect = n, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParent = bP(e.contentDOM);
    let r = e.contentDOM.ownerDocument;
    r.addEventListener("mousemove", this.move = this.move.bind(this)), r.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(I.allowMultipleSelections) && ry(e, t), this.dragMove = sy(e, t), this.dragging = oy(e, t) && kQ(t) == 1 ? null : false;
  }
  start(e) {
    this.dragging === false && (e.preventDefault(), this.select(e));
  }
  move(e) {
    var t;
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging !== false)
      return;
    this.select(this.lastEvent = e);
    let i = 0, n = 0, r = ((t = this.scrollParent) === null || t === void 0 ? void 0 : t.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight };
    e.clientX <= r.left ? i = -Tn(r.left - e.clientX) : e.clientX >= r.right && (i = Tn(e.clientX - r.right)), e.clientY <= r.top ? n = -Tn(r.top - e.clientY) : e.clientY >= r.bottom && (n = Tn(e.clientY - r.bottom)), this.setScrollSpeed(i, n);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = null;
  }
  setScrollSpeed(e, t) {
    this.scrollSpeed = { x: e, y: t }, e || t ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === false && this.select(this.lastEvent);
  }
  select(e) {
    let t = this.style.get(e, this.extend, this.multiple);
    (this.mustSelect || !t.eq(this.view.state.selection) || t.main.assoc != this.view.state.selection.main.assoc) && this.view.dispatch({
      selection: t,
      userEvent: "select.pointer"
    }), this.mustSelect = false;
  }
  update(e) {
    e.docChanged && this.dragging && (this.dragging = this.dragging.map(e.changes)), this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
};
function ry(O, e) {
  let t = O.state.facet(aQ);
  return t.length ? t[0](e) : Y.mac ? e.metaKey : e.ctrlKey;
}
function sy(O, e) {
  let t = O.state.facet(lQ);
  return t.length ? t[0](e) : Y.mac ? !e.altKey : !e.ctrlKey;
}
function oy(O, e) {
  let { main: t } = O.state.selection;
  if (t.empty)
    return false;
  let i = xr(O.root);
  if (!i || i.rangeCount == 0)
    return true;
  let n = i.getRangeAt(0).getClientRects();
  for (let r = 0; r < n.length; r++) {
    let s = n[r];
    if (s.left <= e.clientX && s.right >= e.clientX && s.top <= e.clientY && s.bottom >= e.clientY)
      return true;
  }
  return false;
}
function oh(O, e) {
  if (!e.bubbles)
    return true;
  if (e.defaultPrevented)
    return false;
  for (let t = e.target, i; t != O.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || (i = J.get(t)) && i.ignoreEvent(e))
      return false;
  return true;
}
var Qe = /* @__PURE__ */ Object.create(null);
var ua = /* @__PURE__ */ Object.create(null);
var TQ = Y.ie && Y.ie_version < 15 || Y.ios && Y.webkit_version < 604;
function ay(O) {
  let e = O.dom.parentNode;
  if (!e)
    return;
  let t = e.appendChild(document.createElement("textarea"));
  t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => {
    O.focus(), t.remove(), WQ(O, t.value);
  }, 50);
}
function WQ(O, e) {
  let { state: t } = O, i, n = 1, r = t.toText(e), s = r.lines == t.selection.ranges.length;
  if (fa != null && t.selection.ranges.every((a) => a.empty) && fa == r.toString()) {
    let a = -1;
    i = t.changeByRange((l) => {
      let h2 = t.doc.lineAt(l.from);
      if (h2.from == a)
        return { range: l };
      a = h2.from;
      let u = t.toText((s ? r.line(n++).text : e) + t.lineBreak);
      return {
        changes: { from: h2.from, insert: u },
        range: S.cursor(l.from + u.length)
      };
    });
  } else
    s ? i = t.changeByRange((a) => {
      let l = r.line(n++);
      return {
        changes: { from: a.from, to: a.to, insert: l.text },
        range: S.cursor(a.from + l.length)
      };
    }) : i = t.replaceSelection(r);
  O.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: true
  });
}
Qe.keydown = (O, e) => {
  O.inputState.setSelectionOrigin("select"), e.keyCode == 27 ? O.inputState.lastEscPress = Date.now() : wQ.indexOf(e.keyCode) < 0 && (O.inputState.lastEscPress = 0);
};
Qe.touchstart = (O, e) => {
  O.inputState.lastTouchTime = Date.now(), O.inputState.setSelectionOrigin("select.pointer");
};
Qe.touchmove = (O) => {
  O.inputState.setSelectionOrigin("select.pointer");
};
ua.touchstart = ua.touchmove = { passive: true };
Qe.mousedown = (O, e) => {
  if (O.observer.flush(), O.inputState.lastTouchTime > Date.now() - 2e3)
    return;
  let t = null;
  for (let i of O.state.facet(cQ))
    if (t = i(O, e), t)
      break;
  if (!t && e.button == 0 && (t = hy(O, e)), t) {
    let i = O.root.activeElement != O.contentDOM;
    O.inputState.startMouseSelection(new ny(O, e, t, i)), i && O.observer.ignore(() => Nd(O.contentDOM)), O.inputState.mouseSelection && O.inputState.mouseSelection.start(e);
  }
};
function ah(O, e, t, i) {
  if (i == 1)
    return S.cursor(e, t);
  if (i == 2)
    return BP(O.state, e, t);
  {
    let n = ke.find(O.docView, e), r = O.state.doc.lineAt(n ? n.posAtEnd : e), s = n ? n.posAtStart : r.from, o = n ? n.posAtEnd : r.to;
    return o < O.state.doc.length && o == r.to && o++, S.range(s, o);
  }
}
var vQ = (O, e) => O >= e.top && O <= e.bottom;
var lh = (O, e, t) => vQ(e, t) && O >= t.left && O <= t.right;
function ly(O, e, t, i) {
  let n = ke.find(O.docView, e);
  if (!n)
    return 1;
  let r = e - n.posAtStart;
  if (r == 0)
    return 1;
  if (r == n.length)
    return -1;
  let s = n.coordsAt(r, -1);
  if (s && lh(t, i, s))
    return -1;
  let o = n.coordsAt(r, 1);
  return o && lh(t, i, o) ? 1 : s && vQ(i, s) ? -1 : 1;
}
function ch(O, e) {
  let t = O.posAtCoords({ x: e.clientX, y: e.clientY }, false);
  return { pos: t, bias: ly(O, t, e.clientX, e.clientY) };
}
var cy = Y.ie && Y.ie_version <= 11;
var hh = null;
var uh = 0;
var fh = 0;
function kQ(O) {
  if (!cy)
    return O.detail;
  let e = hh, t = fh;
  return hh = O, fh = Date.now(), uh = !e || t > Date.now() - 400 && Math.abs(e.clientX - O.clientX) < 2 && Math.abs(e.clientY - O.clientY) < 2 ? (uh + 1) % 3 : 1;
}
function hy(O, e) {
  let t = ch(O, e), i = kQ(e), n = O.state.selection;
  return {
    update(r) {
      r.docChanged && (t.pos = r.changes.mapPos(t.pos), n = n.map(r.changes));
    },
    get(r, s, o) {
      let a = ch(O, r), l = ah(O, a.pos, a.bias, i);
      if (t.pos != a.pos && !s) {
        let h2 = ah(O, t.pos, t.bias, i), u = Math.min(h2.from, l.from), f = Math.max(h2.to, l.to);
        l = u < l.from ? S.range(u, f) : S.range(f, u);
      }
      return s ? n.replaceRange(n.main.extend(l.from, l.to)) : o && n.ranges.length > 1 && n.ranges.some((h2) => h2.eq(l)) ? uy(n, l) : o ? n.addRange(l) : S.create([l]);
    }
  };
}
function uy(O, e) {
  for (let t = 0; ; t++)
    if (O.ranges[t].eq(e))
      return S.create(O.ranges.slice(0, t).concat(O.ranges.slice(t + 1)), O.mainIndex == t ? 0 : O.mainIndex - (O.mainIndex > t ? 1 : 0));
}
Qe.dragstart = (O, e) => {
  let { selection: { main: t } } = O.state, { mouseSelection: i } = O.inputState;
  i && (i.dragging = t), e.dataTransfer && (e.dataTransfer.setData("Text", O.state.sliceDoc(t.from, t.to)), e.dataTransfer.effectAllowed = "copyMove");
};
function dh(O, e, t, i) {
  if (!t)
    return;
  let n = O.posAtCoords({ x: e.clientX, y: e.clientY }, false);
  e.preventDefault();
  let { mouseSelection: r } = O.inputState, s = i && r && r.dragging && r.dragMove ? { from: r.dragging.from, to: r.dragging.to } : null, o = { from: n, insert: t }, a = O.state.changes(s ? [s, o] : o);
  O.focus(), O.dispatch({
    changes: a,
    selection: { anchor: a.mapPos(n, -1), head: a.mapPos(n, 1) },
    userEvent: s ? "move.drop" : "input.drop"
  });
}
Qe.drop = (O, e) => {
  if (!e.dataTransfer)
    return;
  if (O.state.readOnly)
    return e.preventDefault();
  let t = e.dataTransfer.files;
  if (t && t.length) {
    e.preventDefault();
    let i = Array(t.length), n = 0, r = () => {
      ++n == t.length && dh(O, e, i.filter((s) => s != null).join(O.state.lineBreak), false);
    };
    for (let s = 0; s < t.length; s++) {
      let o = new FileReader();
      o.onerror = r, o.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(o.result) || (i[s] = o.result), r();
      }, o.readAsText(t[s]);
    }
  } else
    dh(O, e, e.dataTransfer.getData("Text"), true);
};
Qe.paste = (O, e) => {
  if (O.state.readOnly)
    return e.preventDefault();
  O.observer.flush();
  let t = TQ ? null : e.clipboardData;
  t ? (WQ(O, t.getData("text/plain")), e.preventDefault()) : ay(O);
};
function fy(O, e) {
  let t = O.dom.parentNode;
  if (!t)
    return;
  let i = t.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = e, i.focus(), i.selectionEnd = e.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), O.focus();
  }, 50);
}
function dy(O) {
  let e = [], t = [], i = false;
  for (let n of O.selection.ranges)
    n.empty || (e.push(O.sliceDoc(n.from, n.to)), t.push(n));
  if (!e.length) {
    let n = -1;
    for (let { from: r } of O.selection.ranges) {
      let s = O.doc.lineAt(r);
      s.number > n && (e.push(s.text), t.push({ from: s.from, to: Math.min(O.doc.length, s.to + 1) })), n = s.number;
    }
    i = true;
  }
  return { text: e.join(O.lineBreak), ranges: t, linewise: i };
}
var fa = null;
Qe.copy = Qe.cut = (O, e) => {
  let { text: t, ranges: i, linewise: n } = dy(O.state);
  if (!t && !n)
    return;
  fa = n ? t : null;
  let r = TQ ? null : e.clipboardData;
  r ? (e.preventDefault(), r.clearData(), r.setData("text/plain", t)) : fy(O, t), e.type == "cut" && !O.state.readOnly && O.dispatch({
    changes: i,
    scrollIntoView: true,
    userEvent: "delete.cut"
  });
};
function YQ(O) {
  setTimeout(() => {
    O.hasFocus != O.inputState.notifiedFocused && O.update([]);
  }, 10);
}
Qe.focus = (O) => {
  O.inputState.lastFocusTime = Date.now(), !O.scrollDOM.scrollTop && (O.inputState.lastScrollTop || O.inputState.lastScrollLeft) && (O.scrollDOM.scrollTop = O.inputState.lastScrollTop, O.scrollDOM.scrollLeft = O.inputState.lastScrollLeft), YQ(O);
};
Qe.blur = (O) => {
  O.observer.clearSelectionRange(), YQ(O);
};
Qe.compositionstart = Qe.compositionupdate = (O) => {
  O.inputState.compositionFirstChange == null && (O.inputState.compositionFirstChange = true), O.inputState.composing < 0 && (O.inputState.composing = 0);
};
Qe.compositionend = (O) => {
  O.inputState.composing = -1, O.inputState.compositionEndedAt = Date.now(), O.inputState.compositionFirstChange = null, Y.chrome && Y.android && O.observer.flushSoon(), setTimeout(() => {
    O.inputState.composing < 0 && O.docView.compositionDeco.size && O.update([]);
  }, 50);
};
Qe.contextmenu = (O) => {
  O.inputState.lastContextMenu = Date.now();
};
Qe.beforeinput = (O, e) => {
  var t;
  let i;
  if (Y.chrome && Y.android && (i = bQ.find((n) => n.inputType == e.inputType)) && (O.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let n = ((t = window.visualViewport) === null || t === void 0 ? void 0 : t.height) || 0;
    setTimeout(() => {
      var r;
      (((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0) > n + 10 && O.hasFocus && (O.contentDOM.blur(), O.focus());
    }, 100);
  }
};
var Qh = ["pre-wrap", "normal", "pre-line", "break-spaces"];
var Qy = class {
  constructor(e) {
    this.lineWrapping = e, this.doc = D.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.lineLength = 30, this.heightChanged = false;
  }
  heightForGap(e, t) {
    let i = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (i += Math.ceil((t - e - i * this.lineLength * 0.5) / this.lineLength)), this.lineHeight * i;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return Qh.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let t = false;
    for (let i = 0; i < e.length; i++) {
      let n = e[i];
      n < 0 ? i++ : this.heightSamples[Math.floor(n * 10)] || (t = true, this.heightSamples[Math.floor(n * 10)] = true);
    }
    return t;
  }
  refresh(e, t, i, n, r) {
    let s = Qh.indexOf(e) > -1, o = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != s;
    if (this.lineWrapping = s, this.lineHeight = t, this.charWidth = i, this.lineLength = n, o) {
      this.heightSamples = {};
      for (let a = 0; a < r.length; a++) {
        let l = r[a];
        l < 0 ? a++ : this.heightSamples[Math.floor(l * 10)] = true;
      }
    }
    return o;
  }
};
var $y = class {
  constructor(e, t) {
    this.from = e, this.heights = t, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
};
var Lt = class {
  /**
  @internal
  */
  constructor(e, t, i, n, r) {
    this.from = e, this.length = t, this.top = i, this.height = n, this.type = r;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  @internal
  */
  join(e) {
    let t = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(e.type) ? e.type : [e]);
    return new Lt(this.from, this.length + e.length, this.top, this.height + e.height, t);
  }
};
var H = function(O) {
  return O[O.ByPos = 0] = "ByPos", O[O.ByHeight = 1] = "ByHeight", O[O.ByPosNoHeight = 2] = "ByPosNoHeight", O;
}(H || (H = {}));
var sr = 1e-3;
var Ye = class {
  constructor(e, t, i = 2) {
    this.length = e, this.height = t, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e, t) {
    this.height != t && (Math.abs(this.height - t) > sr && (e.heightChanged = true), this.height = t);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, t, i) {
    return Ye.of(i);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, t) {
    t.push(this);
  }
  decomposeRight(e, t) {
    t.push(this);
  }
  applyChanges(e, t, i, n) {
    let r = this;
    for (let s = n.length - 1; s >= 0; s--) {
      let { fromA: o, toA: a, fromB: l, toB: h2 } = n[s], u = r.lineAt(o, H.ByPosNoHeight, t, 0, 0), f = u.to >= a ? u : r.lineAt(a, H.ByPosNoHeight, t, 0, 0);
      for (h2 += f.to - a, a = f.to; s > 0 && u.from <= n[s - 1].toA; )
        o = n[s - 1].fromA, l = n[s - 1].fromB, s--, o < u.from && (u = r.lineAt(o, H.ByPosNoHeight, t, 0, 0));
      l += u.from - o, o = u.from;
      let d = ml.build(i, e, l, h2);
      r = r.replace(o, a, d);
    }
    return r.updateHeight(i, 0);
  }
  static empty() {
    return new Ae(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let t = 0, i = e.length, n = 0, r = 0;
    for (; ; )
      if (t == i)
        if (n > r * 2) {
          let o = e[t - 1];
          o.break ? e.splice(--t, 1, o.left, null, o.right) : e.splice(--t, 1, o.left, o.right), i += 1 + o.break, n -= o.size;
        } else if (r > n * 2) {
          let o = e[i];
          o.break ? e.splice(i, 1, o.left, null, o.right) : e.splice(i, 1, o.left, o.right), i += 2 + o.break, r -= o.size;
        } else
          break;
      else if (n < r) {
        let o = e[t++];
        o && (n += o.size);
      } else {
        let o = e[--i];
        o && (r += o.size);
      }
    let s = 0;
    return e[t - 1] == null ? (s = 1, t--) : e[t] == null && (s = 1, i++), new py(Ye.of(e.slice(0, t)), s, Ye.of(e.slice(i)));
  }
};
Ye.prototype.size = 1;
var ZQ = class extends Ye {
  constructor(e, t, i) {
    super(e, t), this.type = i;
  }
  blockAt(e, t, i, n) {
    return new Lt(n, this.length, i, this.height, this.type);
  }
  lineAt(e, t, i, n, r) {
    return this.blockAt(0, i, n, r);
  }
  forEachLine(e, t, i, n, r, s) {
    e <= r + this.length && t >= r && s(this.blockAt(0, i, n, r));
  }
  updateHeight(e, t = 0, i = false, n) {
    return n && n.from <= t && n.more && this.setHeight(e, n.heights[n.index++]), this.outdated = false, this;
  }
  toString() {
    return `block(${this.length})`;
  }
};
var Ae = class extends ZQ {
  constructor(e, t) {
    super(e, t, F.Text), this.collapsed = 0, this.widgetHeight = 0;
  }
  replace(e, t, i) {
    let n = i[0];
    return i.length == 1 && (n instanceof Ae || n instanceof Se && n.flags & 4) && Math.abs(this.length - n.length) < 10 ? (n instanceof Se ? n = new Ae(n.length, this.height) : n.height = this.height, this.outdated || (n.outdated = false), n) : Ye.of(i);
  }
  updateHeight(e, t = 0, i = false, n) {
    return n && n.from <= t && n.more ? this.setHeight(e, n.heights[n.index++]) : (i || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed))), this.outdated = false, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
};
var Se = class extends Ye {
  constructor(e) {
    super(e, 0);
  }
  lines(e, t) {
    let i = e.lineAt(t).number, n = e.lineAt(t + this.length).number;
    return { firstLine: i, lastLine: n, lineHeight: this.height / (n - i + 1) };
  }
  blockAt(e, t, i, n) {
    let { firstLine: r, lastLine: s, lineHeight: o } = this.lines(t, n), a = Math.max(0, Math.min(s - r, Math.floor((e - i) / o))), { from: l, length: h2 } = t.line(r + a);
    return new Lt(l, h2, i + o * a, o, F.Text);
  }
  lineAt(e, t, i, n, r) {
    if (t == H.ByHeight)
      return this.blockAt(e, i, n, r);
    if (t == H.ByPosNoHeight) {
      let { from: u, to: f } = i.lineAt(e);
      return new Lt(u, f - u, 0, 0, F.Text);
    }
    let { firstLine: s, lineHeight: o } = this.lines(i, r), { from: a, length: l, number: h2 } = i.lineAt(e);
    return new Lt(a, l, n + o * (h2 - s), o, F.Text);
  }
  forEachLine(e, t, i, n, r, s) {
    let { firstLine: o, lineHeight: a } = this.lines(i, r);
    for (let l = Math.max(e, r), h2 = Math.min(r + this.length, t); l <= h2; ) {
      let u = i.lineAt(l);
      l == e && (n += a * (u.number - o)), s(new Lt(u.from, u.length, n, a, F.Text)), n += a, l = u.to + 1;
    }
  }
  replace(e, t, i) {
    let n = this.length - t;
    if (n > 0) {
      let r = i[i.length - 1];
      r instanceof Se ? i[i.length - 1] = new Se(r.length + n) : i.push(null, new Se(n - 1));
    }
    if (e > 0) {
      let r = i[0];
      r instanceof Se ? i[0] = new Se(e + r.length) : i.unshift(new Se(e - 1), null);
    }
    return Ye.of(i);
  }
  decomposeLeft(e, t) {
    t.push(new Se(e - 1), null);
  }
  decomposeRight(e, t) {
    t.push(null, new Se(this.length - e - 1));
  }
  updateHeight(e, t = 0, i = false, n) {
    let r = t + this.length;
    if (n && n.from <= t + this.length && n.more) {
      let s = [], o = Math.max(t, n.from), a = -1, l = e.heightChanged;
      for (n.from > t && s.push(new Se(n.from - t - 1).updateHeight(e, t)); o <= r && n.more; ) {
        let u = e.doc.lineAt(o).length;
        s.length && s.push(null);
        let f = n.heights[n.index++];
        a == -1 ? a = f : Math.abs(f - a) >= sr && (a = -2);
        let d = new Ae(u, f);
        d.outdated = false, s.push(d), o += u + 1;
      }
      o <= r && s.push(null, new Se(r - o).updateHeight(e, o));
      let h2 = Ye.of(s);
      return e.heightChanged = l || a < 0 || Math.abs(h2.height - this.height) >= sr || Math.abs(a - this.lines(e.doc, t).lineHeight) >= sr, h2;
    } else
      (i || this.outdated) && (this.setHeight(e, e.heightForGap(t, t + this.length)), this.outdated = false);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
};
var py = class extends Ye {
  constructor(e, t, i) {
    super(e.length + t + i.length, e.height + i.height, t | (e.outdated || i.outdated ? 2 : 0)), this.left = e, this.right = i, this.size = e.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, t, i, n) {
    let r = i + this.left.height;
    return e < r ? this.left.blockAt(e, t, i, n) : this.right.blockAt(e, t, r, n + this.left.length + this.break);
  }
  lineAt(e, t, i, n, r) {
    let s = n + this.left.height, o = r + this.left.length + this.break, a = t == H.ByHeight ? e < s : e < o, l = a ? this.left.lineAt(e, t, i, n, r) : this.right.lineAt(e, t, i, s, o);
    if (this.break || (a ? l.to < o : l.from > o))
      return l;
    let h2 = t == H.ByPosNoHeight ? H.ByPosNoHeight : H.ByPos;
    return a ? l.join(this.right.lineAt(o, h2, i, s, o)) : this.left.lineAt(o, h2, i, n, r).join(l);
  }
  forEachLine(e, t, i, n, r, s) {
    let o = n + this.left.height, a = r + this.left.length + this.break;
    if (this.break)
      e < a && this.left.forEachLine(e, t, i, n, r, s), t >= a && this.right.forEachLine(e, t, i, o, a, s);
    else {
      let l = this.lineAt(a, H.ByPos, i, n, r);
      e < l.from && this.left.forEachLine(e, l.from - 1, i, n, r, s), l.to >= e && l.from <= t && s(l), t > l.to && this.right.forEachLine(l.to + 1, t, i, o, a, s);
    }
  }
  replace(e, t, i) {
    let n = this.left.length + this.break;
    if (t < n)
      return this.balanced(this.left.replace(e, t, i), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - n, t - n, i));
    let r = [];
    e > 0 && this.decomposeLeft(e, r);
    let s = r.length;
    for (let o of i)
      r.push(o);
    if (e > 0 && $h(r, s - 1), t < this.length) {
      let o = r.length;
      this.decomposeRight(t, r), $h(r, o);
    }
    return Ye.of(r);
  }
  decomposeLeft(e, t) {
    let i = this.left.length;
    if (e <= i)
      return this.left.decomposeLeft(e, t);
    t.push(this.left), this.break && (i++, e >= i && t.push(null)), e > i && this.right.decomposeLeft(e - i, t);
  }
  decomposeRight(e, t) {
    let i = this.left.length, n = i + this.break;
    if (e >= n)
      return this.right.decomposeRight(e - n, t);
    e < i && this.left.decomposeRight(e, t), this.break && e < n && t.push(null), t.push(this.right);
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size ? Ye.of(this.break ? [e, null, t] : [e, t]) : (this.left = e, this.right = t, this.height = e.height + t.height, this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break + t.length, this);
  }
  updateHeight(e, t = 0, i = false, n) {
    let { left: r, right: s } = this, o = t + r.length + this.break, a = null;
    return n && n.from <= t + r.length && n.more ? a = r = r.updateHeight(e, t, i, n) : r.updateHeight(e, t, i), n && n.from <= o + s.length && n.more ? a = s = s.updateHeight(e, o, i, n) : s.updateHeight(e, o, i), a ? this.balanced(r, s) : (this.height = this.left.height + this.right.height, this.outdated = false, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
};
function $h(O, e) {
  let t, i;
  O[e] == null && (t = O[e - 1]) instanceof Se && (i = O[e + 1]) instanceof Se && O.splice(e - 1, 3, new Se(t.length + 1 + i.length));
}
var my = 5;
var ml = class {
  constructor(e, t) {
    this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let i = Math.min(t, this.lineEnd), n = this.nodes[this.nodes.length - 1];
      n instanceof Ae ? n.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new Ae(i - this.pos, -1)), this.writtenTo = i, t > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = t;
  }
  point(e, t, i) {
    if (e < t || i.heightRelevant) {
      let n = i.widget ? i.widget.estimatedHeight : 0;
      n < 0 && (n = this.oracle.lineHeight);
      let r = t - e;
      i.block ? this.addBlock(new ZQ(r, n, i.type)) : (r || n >= my) && this.addLineDeco(n, r);
    } else
      t > e && this.span(e, t);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Ae(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, t) {
    let i = new Se(t - e);
    return this.oracle.doc.lineAt(e).to == t && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof Ae)
      return e;
    let t = new Ae(0, -1);
    return this.nodes.push(t), t;
  }
  addBlock(e) {
    this.enterLine(), e.type == F.WidgetAfter && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, e.type != F.WidgetBefore && (this.covering = e);
  }
  addLineDeco(e, t) {
    let i = this.ensureLine();
    i.length += t, i.collapsed += t, i.widgetHeight = Math.max(i.widgetHeight, e), this.writtenTo = this.pos = this.pos + t;
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(t instanceof Ae) && !this.isCovered ? this.nodes.push(new Ae(0, -1)) : (this.writtenTo < this.pos || t == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = e;
    for (let n of this.nodes)
      n instanceof Ae && n.updateHeight(this.oracle, i), i += n ? n.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, t, i, n) {
    let r = new ml(i, e);
    return L.spans(t, i, n, r, 0), r.finish(i);
  }
};
function gy(O, e, t) {
  let i = new Sy();
  return L.compare(O, e, t, i, 0), i.changes;
}
var Sy = class {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, t, i, n) {
    (e < t || i && i.heightRelevant || n && n.heightRelevant) && oa(e, t, this.changes, 5);
  }
};
function Py(O, e) {
  let t = O.getBoundingClientRect(), i = O.ownerDocument, n = i.defaultView || window, r = Math.max(0, t.left), s = Math.min(n.innerWidth, t.right), o = Math.max(0, t.top), a = Math.min(n.innerHeight, t.bottom);
  for (let l = O.parentNode; l && l != i.body; )
    if (l.nodeType == 1) {
      let h2 = l, u = window.getComputedStyle(h2);
      if ((h2.scrollHeight > h2.clientHeight || h2.scrollWidth > h2.clientWidth) && u.overflow != "visible") {
        let f = h2.getBoundingClientRect();
        r = Math.max(r, f.left), s = Math.min(s, f.right), o = Math.max(o, f.top), a = l == O.parentNode ? f.bottom : Math.min(a, f.bottom);
      }
      l = u.position == "absolute" || u.position == "fixed" ? h2.offsetParent : h2.parentNode;
    } else if (l.nodeType == 11)
      l = l.host;
    else
      break;
  return {
    left: r - t.left,
    right: Math.max(r, s) - t.left,
    top: o - (t.top + e),
    bottom: Math.max(o, a) - (t.top + e)
  };
}
function yy(O, e) {
  let t = O.getBoundingClientRect();
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  };
}
var Gs = class {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.size = i;
  }
  static same(e, t) {
    if (e.length != t.length)
      return false;
    for (let i = 0; i < e.length; i++) {
      let n = e[i], r = t[i];
      if (n.from != r.from || n.to != r.to || n.size != r.size)
        return false;
    }
    return true;
  }
  draw(e) {
    return V.replace({ widget: new Xy(this.size, e) }).range(this.from, this.to);
  }
};
var Xy = class extends wt {
  constructor(e, t) {
    super(), this.size = e, this.vertical = t;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
};
var ph = class {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = true, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scaler = mh, this.scrollTarget = null, this.printing = false, this.mustMeasureContent = true, this.defaultTextDirection = ne.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = false;
    let t = e.facet(pl).some((i) => typeof i != "function" && i.class == "cm-lineWrapping");
    this.heightOracle = new Qy(t), this.stateDeco = e.facet(Di).filter((i) => typeof i != "function"), this.heightMap = Ye.empty().applyChanges(this.stateDeco, D.empty, this.heightOracle.setDoc(e.doc), [new Xt(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = V.set(this.lineGaps.map((i) => i.draw(false))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: t } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let n = i ? t.head : t.anchor;
      if (!e.some(({ from: r, to: s }) => n >= r && n <= s)) {
        let { from: r, to: s } = this.lineBlockAt(n);
        e.push(new Wn(r, s));
      }
    }
    this.viewports = e.sort((i, n) => i.from - n.from), this.scaler = this.heightMap.height <= 7e6 ? mh : new wy(this.heightOracle.doc, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, (e) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e : bi(e, this.scaler));
    });
  }
  update(e, t = null) {
    this.state = e.state;
    let i = this.stateDeco;
    this.stateDeco = this.state.facet(Di).filter((l) => typeof l != "function");
    let n = e.changedRanges, r = Xt.extendWithRanges(n, gy(i, this.stateDeco, e ? e.changes : fe.empty(this.state.doc.length))), s = this.heightMap.height;
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), r), this.heightMap.height != s && (e.flags |= 2);
    let o = r.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (t && (t.range.head < o.from || t.range.head > o.to) || !this.viewportIsAppropriate(o)) && (o = this.getViewport(0, t));
    let a = !e.changes.empty || e.flags & 2 || o.from != this.viewport.from || o.to != this.viewport.to;
    this.viewport = o, this.updateForViewport(), a && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(dQ) && (this.mustEnforceCursorAssoc = true);
  }
  measure(e) {
    let t = e.contentDOM, i = window.getComputedStyle(t), n = this.heightOracle, r = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? ne.RTL : ne.LTR;
    let s = this.heightOracle.mustRefreshForWrapping(r), o = s || this.mustMeasureContent || this.contentDOMHeight != t.clientHeight;
    this.contentDOMHeight = t.clientHeight, this.mustMeasureContent = false;
    let a = 0, l = 0, h2 = parseInt(i.paddingTop) || 0, u = parseInt(i.paddingBottom) || 0;
    (this.paddingTop != h2 || this.paddingBottom != u) && (this.paddingTop = h2, this.paddingBottom = u, a |= 10), this.editorWidth != e.scrollDOM.clientWidth && (n.lineWrapping && (o = true), this.editorWidth = e.scrollDOM.clientWidth, a |= 8);
    let f = (this.printing ? yy : Py)(t, this.paddingTop), d = f.top - this.pixelViewport.top, Q = f.bottom - this.pixelViewport.bottom;
    this.pixelViewport = f;
    let $ = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if ($ != this.inView && (this.inView = $, $ && (o = true)), !this.inView && !this.scrollTarget)
      return 0;
    let p = t.clientWidth;
    if ((this.contentDOMWidth != p || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = p, this.editorHeight = e.scrollDOM.clientHeight, a |= 8), o) {
      let g = e.docView.measureVisibleLineHeights(this.viewport);
      if (n.mustRefreshForHeights(g) && (s = true), s || n.lineWrapping && Math.abs(p - this.contentDOMWidth) > n.charWidth) {
        let { lineHeight: b, charWidth: y } = e.docView.measureTextSize();
        s = b > 0 && n.refresh(r, b, y, p / y, g), s && (e.docView.minWidth = 0, a |= 8);
      }
      d > 0 && Q > 0 ? l = Math.max(d, Q) : d < 0 && Q < 0 && (l = Math.min(d, Q)), n.heightChanged = false;
      for (let b of this.viewports) {
        let y = b.from == this.viewport.from ? g : e.docView.measureVisibleLineHeights(b);
        this.heightMap = (s ? Ye.empty().applyChanges(this.stateDeco, D.empty, this.heightOracle, [new Xt(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(n, 0, s, new $y(b.from, y));
      }
      n.heightChanged && (a |= 2);
    }
    let m = !this.viewportIsAppropriate(this.viewport, l) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return m && (this.viewport = this.getViewport(l, this.scrollTarget)), this.updateForViewport(), (a & 2 || m) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) && this.updateLineGaps(this.ensureLineGaps(s ? [] : this.lineGaps, e)), a |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = false, e.docView.enforceCursorAssoc()), a;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, t) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), n = this.heightMap, r = this.state.doc, { visibleTop: s, visibleBottom: o } = this, a = new Wn(n.lineAt(s - i * 1e3, H.ByHeight, r, 0, 0).from, n.lineAt(o + (1 - i) * 1e3, H.ByHeight, r, 0, 0).to);
    if (t) {
      let { head: l } = t.range;
      if (l < a.from || l > a.to) {
        let h2 = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), u = n.lineAt(l, H.ByPos, r, 0, 0), f;
        t.y == "center" ? f = (u.top + u.bottom) / 2 - h2 / 2 : t.y == "start" || t.y == "nearest" && l < a.from ? f = u.top : f = u.bottom - h2, a = new Wn(n.lineAt(f - 1e3 / 2, H.ByHeight, r, 0, 0).from, n.lineAt(f + h2 + 1e3 / 2, H.ByHeight, r, 0, 0).to);
      }
    }
    return a;
  }
  mapViewport(e, t) {
    let i = t.mapPos(e.from, -1), n = t.mapPos(e.to, 1);
    return new Wn(this.heightMap.lineAt(i, H.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(n, H.ByPos, this.state.doc, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: t }, i = 0) {
    if (!this.inView)
      return true;
    let { top: n } = this.heightMap.lineAt(e, H.ByPos, this.state.doc, 0, 0), { bottom: r } = this.heightMap.lineAt(t, H.ByPos, this.state.doc, 0, 0), { visibleTop: s, visibleBottom: o } = this;
    return (e == 0 || n <= s - Math.max(10, Math.min(
      -i,
      250
      /* VP.MaxCoverMargin */
    ))) && (t == this.state.doc.length || r >= o + Math.max(10, Math.min(
      i,
      250
      /* VP.MaxCoverMargin */
    ))) && n > s - 2 * 1e3 && r < o + 2 * 1e3;
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty)
      return e;
    let i = [];
    for (let n of e)
      t.touchesRange(n.from, n.to) || i.push(new Gs(t.mapPos(n.from), t.mapPos(n.to), n.size));
    return i;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, t) {
    let i = this.heightOracle.lineWrapping, n = i ? 1e4 : 2e3, r = n >> 1, s = n << 1;
    if (this.defaultTextDirection != ne.LTR && !i)
      return [];
    let o = [], a = (l, h2, u, f) => {
      if (h2 - l < r)
        return;
      let d = this.state.selection.main, Q = [d.from];
      d.empty || Q.push(d.to);
      for (let p of Q)
        if (p > l && p < h2) {
          a(l, p - 10, u, f), a(p + 10, h2, u, f);
          return;
        }
      let $ = by(e, (p) => p.from >= u.from && p.to <= u.to && Math.abs(p.from - l) < r && Math.abs(p.to - h2) < r && !Q.some((m) => p.from < m && p.to > m));
      if (!$) {
        if (h2 < u.to && t && i && t.visibleRanges.some((p) => p.from <= h2 && p.to >= h2)) {
          let p = t.moveToLineBoundary(S.cursor(h2), false, true).head;
          p > l && (h2 = p);
        }
        $ = new Gs(l, h2, this.gapSize(u, l, h2, f));
      }
      o.push($);
    };
    for (let l of this.viewportLines) {
      if (l.length < s)
        continue;
      let h2 = xy(l.from, l.to, this.stateDeco);
      if (h2.total < s)
        continue;
      let u = this.scrollTarget ? this.scrollTarget.range.head : null, f, d;
      if (i) {
        let Q = n / this.heightOracle.lineLength * this.heightOracle.lineHeight, $, p;
        if (u != null) {
          let m = kn(h2, u), g = ((this.visibleBottom - this.visibleTop) / 2 + Q) / l.height;
          $ = m - g, p = m + g;
        } else
          $ = (this.visibleTop - l.top - Q) / l.height, p = (this.visibleBottom - l.top + Q) / l.height;
        f = vn(h2, $), d = vn(h2, p);
      } else {
        let Q = h2.total * this.heightOracle.charWidth, $ = n * this.heightOracle.charWidth, p, m;
        if (u != null) {
          let g = kn(h2, u), b = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + $) / Q;
          p = g - b, m = g + b;
        } else
          p = (this.pixelViewport.left - $) / Q, m = (this.pixelViewport.right + $) / Q;
        f = vn(h2, p), d = vn(h2, m);
      }
      f > l.from && a(l.from, f, l, h2), d < l.to && a(d, l.to, l, h2);
    }
    return o;
  }
  gapSize(e, t, i, n) {
    let r = kn(n, i) - kn(n, t);
    return this.heightOracle.lineWrapping ? e.height * r : n.total * this.heightOracle.charWidth * r;
  }
  updateLineGaps(e) {
    Gs.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = V.set(e.map((t) => t.draw(this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let t = [];
    L.spans(e, this.viewport.from, this.viewport.to, {
      span(n, r) {
        t.push({ from: n, to: r });
      },
      point() {
      }
    }, 20);
    let i = t.length != this.visibleRanges.length || this.visibleRanges.some((n, r) => n.from != t[r].from || n.to != t[r].to);
    return this.visibleRanges = t, i ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t) => t.from <= e && t.to >= e) || bi(this.heightMap.lineAt(e, H.ByPos, this.state.doc, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return bi(this.heightMap.lineAt(this.scaler.fromDOM(e), H.ByHeight, this.state.doc, 0, 0), this.scaler);
  }
  elementAtHeight(e) {
    return bi(this.heightMap.blockAt(this.scaler.fromDOM(e), this.state.doc, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
};
var Wn = class {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
};
function xy(O, e, t) {
  let i = [], n = O, r = 0;
  return L.spans(t, O, e, {
    span() {
    },
    point(s, o) {
      s > n && (i.push({ from: n, to: s }), r += s - n), n = o;
    }
  }, 20), n < e && (i.push({ from: n, to: e }), r += e - n), { total: r, ranges: i };
}
function vn({ total: O, ranges: e }, t) {
  if (t <= 0)
    return e[0].from;
  if (t >= 1)
    return e[e.length - 1].to;
  let i = Math.floor(O * t);
  for (let n = 0; ; n++) {
    let { from: r, to: s } = e[n], o = s - r;
    if (i <= o)
      return r + i;
    i -= o;
  }
}
function kn(O, e) {
  let t = 0;
  for (let { from: i, to: n } of O.ranges) {
    if (e <= n) {
      t += e - i;
      break;
    }
    t += n - i;
  }
  return t / O.total;
}
function by(O, e) {
  for (let t of O)
    if (e(t))
      return t;
}
var mh = {
  toDOM(O) {
    return O;
  },
  fromDOM(O) {
    return O;
  },
  scale: 1
};
var wy = class {
  constructor(e, t, i) {
    let n = 0, r = 0, s = 0;
    this.viewports = i.map(({ from: o, to: a }) => {
      let l = t.lineAt(o, H.ByPos, e, 0, 0).top, h2 = t.lineAt(a, H.ByPos, e, 0, 0).bottom;
      return n += h2 - l, { from: o, to: a, top: l, bottom: h2, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - n) / (t.height - n);
    for (let o of this.viewports)
      o.domTop = s + (o.top - r) * this.scale, s = o.domBottom = o.domTop + (o.bottom - o.top), r = o.bottom;
  }
  toDOM(e) {
    for (let t = 0, i = 0, n = 0; ; t++) {
      let r = t < this.viewports.length ? this.viewports[t] : null;
      if (!r || e < r.top)
        return n + (e - i) * this.scale;
      if (e <= r.bottom)
        return r.domTop + (e - r.top);
      i = r.bottom, n = r.domBottom;
    }
  }
  fromDOM(e) {
    for (let t = 0, i = 0, n = 0; ; t++) {
      let r = t < this.viewports.length ? this.viewports[t] : null;
      if (!r || e < r.domTop)
        return i + (e - n) / this.scale;
      if (e <= r.domBottom)
        return r.top + (e - r.domTop);
      i = r.bottom, n = r.domBottom;
    }
  }
};
function bi(O, e) {
  if (e.scale == 1)
    return O;
  let t = e.toDOM(O.top), i = e.toDOM(O.bottom);
  return new Lt(O.from, O.length, t, i - t, Array.isArray(O.type) ? O.type.map((n) => bi(n, e)) : O.type);
}
var Yn = q.define({ combine: (O) => O.join(" ") });
var da = q.define({ combine: (O) => O.indexOf(true) > -1 });
var Qa = tO.newName();
var qQ = tO.newName();
var zQ = tO.newName();
var UQ = { "&light": "." + qQ, "&dark": "." + zQ };
function $a(O, e, t) {
  return new tO(e, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (n) => {
        if (n == "&")
          return O;
        if (!t || !t[n])
          throw new RangeError(`Unsupported selector: ${n}`);
        return t[n];
      }) : O + " " + i;
    }
  });
}
var Ty = $a("." + Qa, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    boxSizing: "border-box",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused .cm-cursor": {
    display: "block"
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    left: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, UQ);
var Wy = class {
  constructor(e, t, i, n) {
    this.typeOver = n, this.bounds = null, this.text = "";
    let { impreciseHead: r, impreciseAnchor: s } = e.docView;
    if (e.state.readOnly && t > -1)
      this.newSel = null;
    else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, i, 0))) {
      let o = r || s ? [] : ky(e), a = new PQ(o, e.state);
      a.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = a.text, this.newSel = Yy(o, this.bounds.from);
    } else {
      let o = e.observer.selectionRange, a = r && r.node == o.focusNode && r.offset == o.focusOffset || !MO(e.contentDOM, o.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(o.focusNode, o.focusOffset), l = s && s.node == o.anchorNode && s.offset == o.anchorOffset || !MO(e.contentDOM, o.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(o.anchorNode, o.anchorOffset);
      this.newSel = S.single(l, a);
    }
  }
};
function VQ(O, e) {
  let t, { newSel: i } = e, n = O.state.selection.main;
  if (e.bounds) {
    let { from: r, to: s } = e.bounds, o = n.from, a = null;
    (O.inputState.lastKeyCode === 8 && O.inputState.lastKeyTime > Date.now() - 100 || Y.android && e.text.length < s - r) && (o = n.to, a = "end");
    let l = vy(O.state.doc.sliceString(r, s, Mt), e.text, o - r, a);
    l && (Y.chrome && O.inputState.lastKeyCode == 13 && l.toB == l.from + 2 && e.text.slice(l.from, l.toB) == Mt + Mt && l.toB--, t = {
      from: r + l.from,
      to: r + l.toA,
      insert: D.of(e.text.slice(l.from, l.toB).split(Mt))
    });
  } else
    i && (!O.hasFocus && O.state.facet(as) || i.main.eq(n)) && (i = null);
  if (!t && !i)
    return false;
  if (!t && e.typeOver && !n.empty && i && i.main.empty ? t = { from: n.from, to: n.to, insert: O.state.doc.slice(n.from, n.to) } : t && t.from >= n.from && t.to <= n.to && (t.from != n.from || t.to != n.to) && n.to - n.from - (t.to - t.from) <= 4 ? t = {
    from: n.from,
    to: n.to,
    insert: O.state.doc.slice(n.from, t.from).append(t.insert).append(O.state.doc.slice(t.to, n.to))
  } : (Y.mac || Y.android) && t && t.from == t.to && t.from == n.head - 1 && /^\. ?$/.test(t.insert.toString()) ? (i && t.insert.length == 2 && (i = S.single(i.main.anchor - 1, i.main.head - 1)), t = { from: n.from, to: n.to, insert: D.of([" "]) }) : Y.chrome && t && t.from == t.to && t.from == n.head && t.insert.toString() == `
 ` && O.lineWrapping && (i && (i = S.single(i.main.anchor - 1, i.main.head - 1)), t = { from: n.from, to: n.to, insert: D.of([" "]) }), t) {
    let r = O.state;
    if (Y.ios && O.inputState.flushIOSKey(O) || Y.android && (t.from == n.from && t.to == n.to && t.insert.length == 1 && t.insert.lines == 2 && IO(O.contentDOM, "Enter", 13) || t.from == n.from - 1 && t.to == n.to && t.insert.length == 0 && IO(O.contentDOM, "Backspace", 8) || t.from == n.from && t.to == n.to + 1 && t.insert.length == 0 && IO(O.contentDOM, "Delete", 46)))
      return true;
    let s = t.insert.toString();
    if (O.state.facet(uQ).some((l) => l(O, t.from, t.to, s)))
      return true;
    O.inputState.composing >= 0 && O.inputState.composing++;
    let o;
    if (t.from >= n.from && t.to <= n.to && t.to - t.from >= (n.to - n.from) / 3 && (!i || i.main.empty && i.main.from == t.from + t.insert.length) && O.inputState.composing < 0) {
      let l = n.from < t.from ? r.sliceDoc(n.from, t.from) : "", h2 = n.to > t.to ? r.sliceDoc(t.to, n.to) : "";
      o = r.replaceSelection(O.state.toText(l + t.insert.sliceString(0, void 0, O.state.lineBreak) + h2));
    } else {
      let l = r.changes(t), h2 = i && !r.selection.main.eq(i.main) && i.main.to <= l.newLength ? i.main : void 0;
      if (r.selection.ranges.length > 1 && O.inputState.composing >= 0 && t.to <= n.to && t.to >= n.to - 10) {
        let u = O.state.sliceDoc(t.from, t.to), f = yQ(O) || O.state.doc.lineAt(n.head), d = n.to - t.to, Q = n.to - n.from;
        o = r.changeByRange(($) => {
          if ($.from == n.from && $.to == n.to)
            return { changes: l, range: h2 || $.map(l) };
          let p = $.to - d, m = p - u.length;
          if ($.to - $.from != Q || O.state.sliceDoc(m, p) != u || // Unfortunately, there's no way to make multiple
          // changes in the same node work without aborting
          // composition, so cursors in the composition range are
          // ignored.
          f && $.to >= f.from && $.from <= f.to)
            return { range: $ };
          let g = r.changes({ from: m, to: p, insert: t.insert }), b = $.to - n.to;
          return {
            changes: g,
            range: h2 ? S.range(Math.max(0, h2.anchor + b), Math.max(0, h2.head + b)) : $.map(g)
          };
        });
      } else
        o = {
          changes: l,
          selection: h2 && r.selection.replaceRange(h2)
        };
    }
    let a = "input.type";
    return O.composing && (a += ".compose", O.inputState.compositionFirstChange && (a += ".start", O.inputState.compositionFirstChange = false)), O.dispatch(o, { scrollIntoView: true, userEvent: a }), true;
  } else if (i && !i.main.eq(n)) {
    let r = false, s = "select";
    return O.inputState.lastSelectionTime > Date.now() - 50 && (O.inputState.lastSelectionOrigin == "select" && (r = true), s = O.inputState.lastSelectionOrigin), O.dispatch({ selection: i, scrollIntoView: r, userEvent: s }), true;
  } else
    return false;
}
function vy(O, e, t, i) {
  let n = Math.min(O.length, e.length), r = 0;
  for (; r < n && O.charCodeAt(r) == e.charCodeAt(r); )
    r++;
  if (r == n && O.length == e.length)
    return null;
  let s = O.length, o = e.length;
  for (; s > 0 && o > 0 && O.charCodeAt(s - 1) == e.charCodeAt(o - 1); )
    s--, o--;
  if (i == "end") {
    let a = Math.max(0, r - Math.min(s, o));
    t -= s + a - r;
  }
  if (s < r && O.length < e.length) {
    let a = t <= r && t >= s ? r - t : 0;
    r -= a, o = r + (o - s), s = r;
  } else if (o < r) {
    let a = t <= r && t >= o ? r - t : 0;
    r -= a, s = r + (s - o), o = r;
  }
  return { from: r, toA: s, toB: o };
}
function ky(O) {
  let e = [];
  if (O.root.activeElement != O.contentDOM)
    return e;
  let { anchorNode: t, anchorOffset: i, focusNode: n, focusOffset: r } = O.observer.selectionRange;
  return t && (e.push(new Jc(t, i)), (n != t || r != i) && e.push(new Jc(n, r))), e;
}
function Yy(O, e) {
  if (O.length == 0)
    return null;
  let t = O[0].pos, i = O.length == 2 ? O[1].pos : t;
  return t > -1 && i > -1 ? S.single(t + e, i + e) : null;
}
var Zy = {
  childList: true,
  characterData: true,
  subtree: true,
  attributes: true,
  characterDataOldValue: true
};
var Is = Y.ie && Y.ie_version <= 11;
var qy = class {
  constructor(e) {
    this.view = e, this.active = false, this.selectionRange = new wP(), this.selectionChanged = false, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.resizeContent = null, this.intersecting = false, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((t) => {
      for (let i of t)
        this.queue.push(i);
      (Y.ie && Y.ie_version <= 11 || Y.ios && e.composing) && t.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), Is && (this.onCharData = (t) => {
      this.queue.push({
        target: t.target,
        type: "characterData",
        oldValue: t.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var t;
      ((t = this.view.docView) === null || t === void 0 ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM), this.resizeContent = new ResizeObserver(() => this.view.requestMeasure()), this.resizeContent.observe(e.contentDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((t) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t.length > 0 && t[t.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, {}), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t) => {
      t.length > 0 && t[t.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runScrollHandlers(this.view, e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(false), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = true, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = false, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, i) => t != e[i]))) {
      this.gapIntersection.disconnect();
      for (let t of e)
        this.gapIntersection.observe(t);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let t = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, n = this.selectionRange;
    if (i.state.facet(as) ? i.root.activeElement != this.dom : !rr(i.dom, n))
      return;
    let r = n.anchorNode && i.docView.nearest(n.anchorNode);
    if (r && r.ignoreEvent(e)) {
      t || (this.selectionChanged = false);
      return;
    }
    (Y.ie && Y.ie_version <= 11 || Y.android && Y.chrome) && !i.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    n.focusNode && br(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset) ? this.flushSoon() : this.flush(false);
  }
  readSelectionRange() {
    let { view: e } = this, t = Y.safari && e.root.nodeType == 11 && yP(this.dom.ownerDocument) == this.dom && zy(this.view) || xr(e.root);
    if (!t || this.selectionRange.eq(t))
      return false;
    let i = rr(this.dom, t);
    return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && WP(this.dom, t) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), false) : (this.selectionRange.setRange(t), i && (this.selectionChanged = true), true);
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = false;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, t = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == i ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = t)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, Zy), Is && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = true);
  }
  stop() {
    this.active && (this.active = false, this.observer.disconnect(), Is && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = false;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, t) {
    var i;
    if (!this.delayedAndroidKey) {
      let n = () => {
        let r = this.delayedAndroidKey;
        r && (this.clearDelayedAndroidKey(), !this.flush() && r.force && IO(this.dom, r.key, r.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(n);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: t,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  processRecords() {
    let e = this.queue;
    for (let r of this.observer.takeRecords())
      e.push(r);
    e.length && (this.queue = []);
    let t = -1, i = -1, n = false;
    for (let r of e) {
      let s = this.readMutation(r);
      s && (s.typeOver && (n = true), t == -1 ? { from: t, to: i } = s : (t = Math.min(s.from, t), i = Math.max(s.to, i)));
    }
    return { from: t, to: i, typeOver: n };
  }
  readChange() {
    let { from: e, to: t, typeOver: i } = this.processRecords(), n = this.selectionChanged && rr(this.dom, this.selectionRange);
    return e < 0 && !n ? null : (e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = false, new Wy(this.view, e, t, i));
  }
  // Apply pending changes, if any
  flush(e = true) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return false;
    e && this.readSelectionRange();
    let t = this.readChange();
    if (!t)
      return false;
    let i = this.view.state, n = VQ(this.view, t);
    return this.view.state == i && this.view.update([]), n;
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target);
    if (!t || t.ignoreMutation(e))
      return null;
    if (t.markDirty(e.type == "attributes"), e.type == "attributes" && (t.dirty |= 4), e.type == "childList") {
      let i = gh(t, e.previousSibling || e.target.previousSibling, -1), n = gh(t, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: i ? t.posAfter(i) : t.posAtStart,
        to: n ? t.posBefore(n) : t.posAtEnd,
        typeOver: false
      };
    } else
      return e.type == "characterData" ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var e, t, i, n;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (t = this.gapIntersection) === null || t === void 0 || t.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect(), (n = this.resizeContent) === null || n === void 0 || n.disconnect();
    for (let r of this.scrollTargets)
      r.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
};
function gh(O, e, t) {
  for (; e; ) {
    let i = J.get(e);
    if (i && i.parent == O)
      return i;
    let n = e.parentNode;
    e = n != O.dom ? n : t > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function zy(O) {
  let e = null;
  function t(a) {
    a.preventDefault(), a.stopImmediatePropagation(), e = a.getTargetRanges()[0];
  }
  if (O.contentDOM.addEventListener("beforeinput", t, true), O.dom.ownerDocument.execCommand("indent"), O.contentDOM.removeEventListener("beforeinput", t, true), !e)
    return null;
  let i = e.startContainer, n = e.startOffset, r = e.endContainer, s = e.endOffset, o = O.docView.domAtPos(O.state.selection.main.anchor);
  return br(o.node, o.offset, r, s) && ([i, n, r, s] = [r, s, i, n]), { anchorNode: i, anchorOffset: n, focusNode: r, focusOffset: s };
}
var k = class {
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = false, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.style.cssText = "position: fixed; top: -10000px", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), this._dispatch = e.dispatch || ((t) => this.update([t])), this.dispatch = this.dispatch.bind(this), this._root = e.root || TP(e.parent) || document, this.viewState = new ph(e.state || I.create(e)), this.plugins = this.state.facet(Xi).map((t) => new _s(t));
    for (let t of this.plugins)
      t.update(this);
    this.observer = new qy(this), this.inputState = new Oy(this), this.inputState.ensureHandlers(this, this.plugins), this.docView = new eh(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), e.parent && e.parent.appendChild(this.dom);
  }
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  dispatch(...e) {
    this._dispatch(e.length == 1 && e[0] instanceof de ? e[0] : this.state.update(...e));
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let t = false, i = false, n, r = this.state;
    for (let l of e) {
      if (l.startState != r)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      r = l.state;
    }
    if (this.destroyed) {
      this.viewState.state = r;
      return;
    }
    let s = this.observer.delayedAndroidKey, o = null;
    if (s ? (this.observer.clearDelayedAndroidKey(), o = this.observer.readChange(), (o && !this.state.doc.eq(r.doc) || !this.state.selection.eq(r.selection)) && (o = null)) : this.observer.clear(), r.facet(I.phrases) != this.state.facet(I.phrases))
      return this.setState(r);
    n = Wr.create(this, r, e);
    let a = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let l of e) {
        if (a && (a = a.map(l.changes)), l.scrollIntoView) {
          let { main: h2 } = l.state.selection;
          a = new Tr(h2.empty ? h2 : S.cursor(h2.head, h2.head > h2.anchor ? -1 : 1));
        }
        for (let h2 of l.effects)
          h2.is(Hc) && (a = h2.value);
      }
      this.viewState.update(n, a), this.bidiCache = vr.update(this.bidiCache, n.changes), n.empty || (this.updatePlugins(n), this.inputState.update(n)), t = this.docView.update(n), this.state.facet(xi) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(t, e.some((l) => l.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (n.startState.facet(Yn) != n.state.facet(Yn) && (this.viewState.mustMeasureContent = true), (t || i || a || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !n.empty)
      for (let l of this.state.facet(aa))
        l(n);
    o && !VQ(this, o) && s.force && IO(this.contentDOM, s.key, s.keyCode);
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let t = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new ph(e), this.plugins = e.facet(Xi).map((i) => new _s(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView = new eh(this), this.inputState.ensureHandlers(this, this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    t && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let t = e.startState.facet(Xi), i = e.state.facet(Xi);
    if (t != i) {
      let n = [];
      for (let r of i) {
        let s = t.indexOf(r);
        if (s < 0)
          n.push(new _s(r));
        else {
          let o = this.plugins[s];
          o.mustUpdate = e, n.push(o);
        }
      }
      for (let r of this.plugins)
        r.mustUpdate != e && r.destroy(this);
      this.plugins = n, this.pluginMap.clear(), this.inputState.ensureHandlers(this, this.plugins);
    } else
      for (let n of this.plugins)
        n.mustUpdate = e;
    for (let n = 0; n < this.plugins.length; n++)
      this.plugins[n].update(this);
  }
  /**
  @internal
  */
  measure(e = true) {
    if (this.destroyed)
      return;
    this.measureScheduled > -1 && cancelAnimationFrame(this.measureScheduled), this.measureScheduled = 0, e && this.observer.forceFlush();
    let t = null, { scrollHeight: i, scrollTop: n, clientHeight: r } = this.scrollDOM, s = n > i - r - 4 ? i : n;
    try {
      for (let o = 0; ; o++) {
        this.updateState = 1;
        let a = this.viewport, l = this.viewState.lineBlockAtHeight(s), h2 = this.viewState.measure(this);
        if (!h2 && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (o > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let u = [];
        h2 & 4 || ([this.measureRequests, u] = [u, this.measureRequests]);
        let f = u.map((p) => {
          try {
            return p.read(this);
          } catch (m) {
            return Ne(this.state, m), Sh;
          }
        }), d = Wr.create(this, this.state, []), Q = false, $ = false;
        d.flags |= h2, t ? t.flags |= h2 : t = d, this.updateState = 2, d.empty || (this.updatePlugins(d), this.inputState.update(d), this.updateAttrs(), Q = this.docView.update(d));
        for (let p = 0; p < u.length; p++)
          if (f[p] != Sh)
            try {
              let m = u[p];
              m.write && m.write(f[p], this);
            } catch (m) {
              Ne(this.state, m);
            }
        if (this.viewState.editorHeight)
          if (this.viewState.scrollTarget)
            this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, $ = true;
          else {
            let p = this.viewState.lineBlockAt(l.from).top - l.top;
            (p > 1 || p < -1) && (this.scrollDOM.scrollTop += p, $ = true);
          }
        if (Q && this.docView.updateSelection(true), this.viewport.from == a.from && this.viewport.to == a.to && !$ && this.measureRequests.length == 0)
          break;
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (t && !t.empty)
      for (let o of this.state.facet(aa))
        o(t);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return Qa + " " + (this.state.facet(da) ? zQ : qQ) + " " + this.state.facet(Yn);
  }
  updateAttrs() {
    let e = Ph(this, QQ, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), t = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(as) ? "true" : "false",
      class: "cm-content",
      style: `${Y.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (t["aria-readonly"] = "true"), Ph(this, pl, t);
    let i = this.observer.ignore(() => {
      let n = sa(this.contentDOM, this.contentAttrs, t), r = sa(this.dom, this.editorAttrs, e);
      return n || r;
    });
    return this.editorAttrs = e, this.contentAttrs = t, i;
  }
  showAnnouncements(e) {
    let t = true;
    for (let i of e)
      for (let n of i.effects)
        if (n.is(k.announce)) {
          t && (this.announceDOM.textContent = ""), t = false;
          let r = this.announceDOM.appendChild(document.createElement("div"));
          r.textContent = n.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(xi), tO.mount(this.root, this.styleModules.concat(Ty).reverse());
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(false);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let t = this.pluginMap.get(e);
    return (t === void 0 || t && t.spec != e) && this.pluginMap.set(e, t = this.plugins.find((i) => i.spec == e) || null), t && t.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, t, i) {
    return Cs(this, e, sh(this, e, t, i));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, t) {
    return Cs(this, e, sh(this, e, t, (i) => ey(this, e.head, i)));
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, t, i = true) {
    return JP(this, e, t, i);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, t, i) {
    return Cs(this, e, ty(this, e, t, i));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t);
  }
  posAtCoords(e, t = true) {
    return this.readMeasured(), xQ(this, e, t);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, t = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(e, t);
    if (!i || i.left == i.right)
      return i;
    let n = this.state.doc.lineAt(e), r = this.bidiSpans(n), s = r[EO.find(r, e - n.from, -1, t)];
    return fl(i, s.dir == ne.LTR == t > 0);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(fQ) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > Uy)
      return gQ(e.length);
    let t = this.textDirectionAt(e.from);
    for (let n of this.bidiCache)
      if (n.from == e.from && n.dir == t)
        return n.order;
    let i = jP(e.text, t);
    return this.bidiCache.push(new vr(e.from, e.to, t, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || Y.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      Nd(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && cancelAnimationFrame(this.measureScheduled), this.destroyed = true;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, t = {}) {
    return Hc.of(new Tr(typeof e == "number" ? S.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return se.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, t) {
    let i = tO.newName(), n = [Yn.of(i), xi.of($a(`.${i}`, e))];
    return t && t.dark && n.push(da.of(true)), n;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return rO.lowest(xi.of($a("." + Qa, e, UQ)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var t;
    let i = e.querySelector(".cm-content"), n = i && J.get(i) || J.get(e);
    return ((t = n == null ? void 0 : n.rootView) === null || t === void 0 ? void 0 : t.view) || null;
  }
};
k.styleModule = xi;
k.inputHandler = uQ;
k.perLineTextDirection = fQ;
k.exceptionSink = hQ;
k.updateListener = aa;
k.editable = as;
k.mouseSelectionStyle = cQ;
k.dragMovesSelection = lQ;
k.clickAddsSelectionRange = aQ;
k.decorations = Di;
k.atomicRanges = $Q;
k.scrollMargins = pQ;
k.darkTheme = da;
k.contentAttributes = pl;
k.editorAttributes = QQ;
k.lineWrapping = k.contentAttributes.of({ class: "cm-lineWrapping" });
k.announce = j.define();
var Uy = 4096;
var Sh = {};
var vr = class {
  constructor(e, t, i, n) {
    this.from = e, this.to = t, this.dir = i, this.order = n;
  }
  static update(e, t) {
    if (t.empty)
      return e;
    let i = [], n = e.length ? e[e.length - 1].dir : ne.LTR;
    for (let r = Math.max(0, e.length - 10); r < e.length; r++) {
      let s = e[r];
      s.dir == n && !t.touchesRange(s.from, s.to) && i.push(new vr(t.mapPos(s.from, 1), t.mapPos(s.to, -1), s.dir, s.order));
    }
    return i;
  }
};
function Ph(O, e, t) {
  for (let i = O.state.facet(e), n = i.length - 1; n >= 0; n--) {
    let r = i[n], s = typeof r == "function" ? r(O) : r;
    s && ra(s, t);
  }
  return t;
}
var Vy = Y.mac ? "mac" : Y.windows ? "win" : Y.linux ? "linux" : "key";
function Ry(O, e) {
  const t = O.split(/-(?!$)/);
  let i = t[t.length - 1];
  i == "Space" && (i = " ");
  let n, r, s, o;
  for (let a = 0; a < t.length - 1; ++a) {
    const l = t[a];
    if (/^(cmd|meta|m)$/i.test(l))
      o = true;
    else if (/^a(lt)?$/i.test(l))
      n = true;
    else if (/^(c|ctrl|control)$/i.test(l))
      r = true;
    else if (/^s(hift)?$/i.test(l))
      s = true;
    else if (/^mod$/i.test(l))
      e == "mac" ? o = true : r = true;
    else
      throw new Error("Unrecognized modifier name: " + l);
  }
  return n && (i = "Alt-" + i), r && (i = "Ctrl-" + i), o && (i = "Meta-" + i), s && (i = "Shift-" + i), i;
}
function Zn(O, e, t) {
  return e.altKey && (O = "Alt-" + O), e.ctrlKey && (O = "Ctrl-" + O), e.metaKey && (O = "Meta-" + O), t !== false && e.shiftKey && (O = "Shift-" + O), O;
}
var _y = rO.default(k.domEventHandlers({
  keydown(O, e) {
    return _Q(RQ(e.state), O, e, "editor");
  }
}));
var ii = q.define({ enables: _y });
var yh = /* @__PURE__ */ new WeakMap();
function RQ(O) {
  let e = O.facet(ii), t = yh.get(e);
  return t || yh.set(e, t = Gy(e.reduce((i, n) => i.concat(n), []))), t;
}
function jy(O, e, t) {
  return _Q(RQ(O.state), e, O, t);
}
var Et = null;
var Cy = 4e3;
function Gy(O, e = Vy) {
  let t = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), n = (s, o) => {
    let a = i[s];
    if (a == null)
      i[s] = o;
    else if (a != o)
      throw new Error("Key binding " + s + " is used both as a regular binding and as a multi-stroke prefix");
  }, r = (s, o, a, l) => {
    var h2, u;
    let f = t[s] || (t[s] = /* @__PURE__ */ Object.create(null)), d = o.split(/ (?!$)/).map((p) => Ry(p, e));
    for (let p = 1; p < d.length; p++) {
      let m = d.slice(0, p).join(" ");
      n(m, true), f[m] || (f[m] = {
        preventDefault: true,
        run: [(g) => {
          let b = Et = { view: g, prefix: m, scope: s };
          return setTimeout(() => {
            Et == b && (Et = null);
          }, Cy), true;
        }]
      });
    }
    let Q = d.join(" ");
    n(Q, false);
    let $ = f[Q] || (f[Q] = { preventDefault: false, run: ((u = (h2 = f._any) === null || h2 === void 0 ? void 0 : h2.run) === null || u === void 0 ? void 0 : u.slice()) || [] });
    a && $.run.push(a), l && ($.preventDefault = true);
  };
  for (let s of O) {
    let o = s.scope ? s.scope.split(" ") : ["editor"];
    if (s.any)
      for (let l of o) {
        let h2 = t[l] || (t[l] = /* @__PURE__ */ Object.create(null));
        h2._any || (h2._any = { preventDefault: false, run: [] });
        for (let u in h2)
          h2[u].run.push(s.any);
      }
    let a = s[e] || s.key;
    if (a)
      for (let l of o)
        r(l, a, s.run, s.preventDefault), s.shift && r(l, "Shift-" + a, s.shift, s.preventDefault);
  }
  return t;
}
function _Q(O, e, t, i) {
  let n = PP(e), r = Pe(n, 0), s = De(r) == n.length && n != " ", o = "", a = false;
  Et && Et.view == t && Et.scope == i && (o = Et.prefix + " ", (a = wQ.indexOf(e.keyCode) < 0) && (Et = null));
  let l = /* @__PURE__ */ new Set(), h2 = (Q) => {
    if (Q) {
      for (let $ of Q.run)
        if (!l.has($) && (l.add($), $(t, e)))
          return true;
      Q.preventDefault && (a = true);
    }
    return false;
  }, u = O[i], f, d;
  if (u) {
    if (h2(u[o + Zn(n, e, !s)]))
      return true;
    if (s && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
    !(Y.windows && e.ctrlKey && e.altKey) && (f = OO[e.keyCode]) && f != n) {
      if (h2(u[o + Zn(f, e, true)]))
        return true;
      if (e.shiftKey && (d = Ii[e.keyCode]) != n && d != f && h2(u[o + Zn(d, e, false)]))
        return true;
    } else if (s && e.shiftKey && h2(u[o + Zn(n, e, true)]))
      return true;
    if (h2(u._any))
      return true;
  }
  return a;
}
var fn = class {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, t, i, n, r) {
    this.className = e, this.left = t, this.top = i, this.width = n, this.height = r;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, t) {
    return t.className != this.className ? false : (this.adjust(e), true);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, t, i) {
    if (i.empty) {
      let n = e.coordsAtPos(i.head, i.assoc || 1);
      if (!n)
        return [];
      let r = jQ(e);
      return [new fn(t, n.left - r.left, n.top - r.top, null, n.bottom - n.top)];
    } else
      return Iy(e, t, i);
  }
};
function jQ(O) {
  let e = O.scrollDOM.getBoundingClientRect();
  return { left: (O.textDirection == ne.LTR ? e.left : e.right - O.scrollDOM.clientWidth) - O.scrollDOM.scrollLeft, top: e.top - O.scrollDOM.scrollTop };
}
function Xh(O, e, t) {
  let i = S.cursor(e);
  return {
    from: Math.max(t.from, O.moveToLineBoundary(i, false, true).from),
    to: Math.min(t.to, O.moveToLineBoundary(i, true, true).from),
    type: F.Text
  };
}
function xh(O, e) {
  let t = O.lineBlockAt(e);
  if (Array.isArray(t.type)) {
    for (let i of t.type)
      if (i.to > e || i.to == e && (i.to == t.to || i.type == F.Text))
        return i;
  }
  return t;
}
function Iy(O, e, t) {
  if (t.to <= O.viewport.from || t.from >= O.viewport.to)
    return [];
  let i = Math.max(t.from, O.viewport.from), n = Math.min(t.to, O.viewport.to), r = O.textDirection == ne.LTR, s = O.contentDOM, o = s.getBoundingClientRect(), a = jQ(O), l = window.getComputedStyle(s.firstChild), h2 = o.left + parseInt(l.paddingLeft) + Math.min(0, parseInt(l.textIndent)), u = o.right - parseInt(l.paddingRight), f = xh(O, i), d = xh(O, n), Q = f.type == F.Text ? f : null, $ = d.type == F.Text ? d : null;
  if (O.lineWrapping && (Q && (Q = Xh(O, i, Q)), $ && ($ = Xh(O, n, $))), Q && $ && Q.from == $.from)
    return m(g(t.from, t.to, Q));
  {
    let y = Q ? g(t.from, null, Q) : b(f, false), w = $ ? g(null, t.to, $) : b(d, true), P = [];
    return (Q || f).to < ($ || d).from - 1 ? P.push(p(h2, y.bottom, u, w.top)) : y.bottom < w.top && O.elementAtHeight((y.bottom + w.top) / 2).type == F.Text && (y.bottom = w.top = (y.bottom + w.top) / 2), m(y).concat(P).concat(m(w));
  }
  function p(y, w, P, z) {
    return new fn(
      e,
      y - a.left,
      w - a.top - 0.01,
      P - y,
      z - w + 0.01
      /* C.Epsilon */
    );
  }
  function m({ top: y, bottom: w, horizontal: P }) {
    let z = [];
    for (let A = 0; A < P.length; A += 2)
      z.push(p(P[A], y, P[A + 1], w));
    return z;
  }
  function g(y, w, P) {
    let z = 1e9, A = -1e9, C = [];
    function X(v, G, Oe, oe, ft) {
      let ge = O.coordsAtPos(v, v == P.to ? -2 : 2), ae = O.coordsAtPos(Oe, Oe == P.from ? 2 : -2);
      z = Math.min(ge.top, ae.top, z), A = Math.max(ge.bottom, ae.bottom, A), ft == ne.LTR ? C.push(r && G ? h2 : ge.left, r && oe ? u : ae.right) : C.push(!r && oe ? h2 : ae.left, !r && G ? u : ge.right);
    }
    let W = y ?? P.from, R = w ?? P.to;
    for (let v of O.visibleRanges)
      if (v.to > W && v.from < R)
        for (let G = Math.max(v.from, W), Oe = Math.min(v.to, R); ; ) {
          let oe = O.state.doc.lineAt(G);
          for (let ft of O.bidiSpans(oe)) {
            let ge = ft.from + oe.from, ae = ft.to + oe.from;
            if (ge >= Oe)
              break;
            ae > G && X(Math.max(ge, G), y == null && ge <= W, Math.min(ae, Oe), w == null && ae >= R, ft.dir);
          }
          if (G = oe.to + 1, G >= Oe)
            break;
        }
    return C.length == 0 && X(W, y == null, R, w == null, O.textDirection), { top: z, bottom: A, horizontal: C };
  }
  function b(y, w) {
    let P = o.top + (w ? y.top : y.bottom);
    return { top: P, bottom: P, horizontal: [] };
  }
}
function Ey(O, e) {
  return O.constructor == e.constructor && O.eq(e);
}
var Ay = class {
  constructor(e, t) {
    this.view = e, this.layer = t, this.drawn = [], this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), t.above && this.dom.classList.add("cm-layer-above"), t.class && this.dom.classList.add(t.class), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), t.mount && t.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(or) != e.state.facet(or) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && e.view.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let t = 0, i = e.facet(or);
    for (; t < i.length && i[t] != this.layer; )
      t++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - t);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((t, i) => !Ey(t, this.drawn[i]))) {
      let t = this.dom.firstChild, i = 0;
      for (let n of e)
        n.update && t && n.constructor && this.drawn[i].constructor && n.update(t, this.drawn[i]) ? (t = t.nextSibling, i++) : this.dom.insertBefore(n.draw(), t);
      for (; t; ) {
        let n = t.nextSibling;
        t.remove(), t = n;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
};
var or = q.define();
function CQ(O) {
  return [
    se.define((e) => new Ay(e, O)),
    or.of(O)
  ];
}
var GQ = !Y.ios;
var Mi = q.define({
  combine(O) {
    return bt(O, {
      cursorBlinkRate: 1200,
      drawRangeCursor: true
    }, {
      cursorBlinkRate: (e, t) => Math.min(e, t),
      drawRangeCursor: (e, t) => e || t
    });
  }
});
function Dy(O = {}) {
  return [
    Mi.of(O),
    My,
    Ly,
    By,
    dQ.of(true)
  ];
}
function IQ(O) {
  return O.startState.facet(Mi) != O.state.facet(Mi);
}
var My = CQ({
  above: true,
  markers(O) {
    let { state: e } = O, t = e.facet(Mi), i = [];
    for (let n of e.selection.ranges) {
      let r = n == e.selection.main;
      if (n.empty ? !r || GQ : t.drawRangeCursor) {
        let s = r ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", o = n.empty ? n : S.cursor(n.head, n.head > n.anchor ? -1 : 1);
        for (let a of fn.forRange(O, s, o))
          i.push(a);
      }
    }
    return i;
  },
  update(O, e) {
    O.transactions.some((i) => i.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let t = IQ(O);
    return t && bh(O.state, e), O.docChanged || O.selectionSet || t;
  },
  mount(O, e) {
    bh(e.state, O);
  },
  class: "cm-cursorLayer"
});
function bh(O, e) {
  e.style.animationDuration = O.facet(Mi).cursorBlinkRate + "ms";
}
var Ly = CQ({
  above: false,
  markers(O) {
    return O.state.selection.ranges.map((e) => e.empty ? [] : fn.forRange(O, "cm-selectionBackground", e)).reduce((e, t) => e.concat(t));
  },
  update(O, e) {
    return O.docChanged || O.selectionSet || O.viewportChanged || IQ(O);
  },
  class: "cm-selectionLayer"
});
var EQ = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
GQ && (EQ[".cm-line"].caretColor = "transparent !important");
var By = rO.highest(k.theme(EQ));
var AQ = j.define({
  map(O, e) {
    return O == null ? null : e.mapPos(O);
  }
});
var wi = me.define({
  create() {
    return null;
  },
  update(O, e) {
    return O != null && (O = e.changes.mapPos(O)), e.effects.reduce((t, i) => i.is(AQ) ? i.value : t, O);
  }
});
var Ny = se.fromClass(class {
  constructor(O) {
    this.view = O, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(O) {
    var e;
    let t = O.state.field(wi);
    t == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (O.startState.field(wi) != t || O.docChanged || O.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let O = this.view.state.field(wi), e = O != null && this.view.coordsAtPos(O);
    if (!e)
      return null;
    let t = this.view.scrollDOM.getBoundingClientRect();
    return {
      left: e.left - t.left + this.view.scrollDOM.scrollLeft,
      top: e.top - t.top + this.view.scrollDOM.scrollTop,
      height: e.bottom - e.top
    };
  }
  drawCursor(O) {
    this.cursor && (O ? (this.cursor.style.left = O.left + "px", this.cursor.style.top = O.top + "px", this.cursor.style.height = O.height + "px") : this.cursor.style.left = "-100000px");
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(O) {
    this.view.state.field(wi) != O && this.view.dispatch({ effects: AQ.of(O) });
  }
}, {
  eventHandlers: {
    dragover(O) {
      this.setDropPos(this.view.posAtCoords({ x: O.clientX, y: O.clientY }));
    },
    dragleave(O) {
      (O.target == this.view.contentDOM || !this.view.contentDOM.contains(O.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function Fy() {
  return [wi, Ny];
}
function wh(O, e, t, i, n) {
  e.lastIndex = 0;
  for (let r = O.iterRange(t, i), s = t, o; !r.next().done; s += r.value.length)
    if (!r.lineBreak)
      for (; o = e.exec(r.value); )
        n(s + o.index, o);
}
function Hy(O, e) {
  let t = O.visibleRanges;
  if (t.length == 1 && t[0].from == O.viewport.from && t[0].to == O.viewport.to)
    return t;
  let i = [];
  for (let { from: n, to: r } of t)
    n = Math.max(O.state.doc.lineAt(n).from, n - e), r = Math.min(O.state.doc.lineAt(r).to, r + e), i.length && i[i.length - 1].to >= n ? i[i.length - 1].to = r : i.push({ from: n, to: r });
  return i;
}
var Ky = class {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: t, decoration: i, decorate: n, boundary: r, maxLength: s = 1e3 } = e;
    if (!t.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = t, n)
      this.addMatch = (o, a, l, h2) => n(h2, l, l + o[0].length, o, a);
    else if (typeof i == "function")
      this.addMatch = (o, a, l, h2) => {
        let u = i(o, a, l);
        u && h2(l, l + o[0].length, u);
      };
    else if (i)
      this.addMatch = (o, a, l, h2) => h2(l, l + o[0].length, i);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = r, this.maxLength = s;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let t = new eO(), i = t.add.bind(t);
    for (let { from: n, to: r } of Hy(e, this.maxLength))
      wh(e.state.doc, this.regexp, n, r, (s, o) => this.addMatch(o, e, s, i));
    return t.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, t) {
    let i = 1e9, n = -1;
    return e.docChanged && e.changes.iterChanges((r, s, o, a) => {
      a > e.view.viewport.from && o < e.view.viewport.to && (i = Math.min(o, i), n = Math.max(a, n));
    }), e.viewportChanged || n - i > 1e3 ? this.createDeco(e.view) : n > -1 ? this.updateRange(e.view, t.map(e.changes), i, n) : t;
  }
  updateRange(e, t, i, n) {
    for (let r of e.visibleRanges) {
      let s = Math.max(r.from, i), o = Math.min(r.to, n);
      if (o > s) {
        let a = e.state.doc.lineAt(s), l = a.to < o ? e.state.doc.lineAt(o) : a, h2 = Math.max(r.from, a.from), u = Math.min(r.to, l.to);
        if (this.boundary) {
          for (; s > a.from; s--)
            if (this.boundary.test(a.text[s - 1 - a.from])) {
              h2 = s;
              break;
            }
          for (; o < l.to; o++)
            if (this.boundary.test(l.text[o - l.from])) {
              u = o;
              break;
            }
        }
        let f = [], d, Q = ($, p, m) => f.push(m.range($, p));
        if (a == l)
          for (this.regexp.lastIndex = h2 - a.from; (d = this.regexp.exec(a.text)) && d.index < u - a.from; )
            this.addMatch(d, e, d.index + a.from, Q);
        else
          wh(e.state.doc, this.regexp, h2, u, ($, p) => this.addMatch(p, e, $, Q));
        t = t.update({ filterFrom: h2, filterTo: u, filter: ($, p) => $ < h2 || p > u, add: f });
      }
    }
    return t;
  }
};
var pa = /x/.unicode != null ? "gu" : "g";
var Jy = new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`, pa);
var eX = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
var Es = null;
function tX() {
  var O;
  if (Es == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    Es = ((O = e.tabSize) !== null && O !== void 0 ? O : e.MozTabSize) != null;
  }
  return Es || false;
}
var ar = q.define({
  combine(O) {
    let e = bt(O, {
      render: null,
      specialChars: Jy,
      addSpecialChars: null
    });
    return (e.replaceTabs = !tX()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, pa)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, pa)), e;
  }
});
function OX(O = {}) {
  return [ar.of(O), iX()];
}
var Th = null;
function iX() {
  return Th || (Th = se.fromClass(class {
    constructor(O) {
      this.view = O, this.decorations = V.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(O.state.facet(ar)), this.decorations = this.decorator.createDeco(O);
    }
    makeDecorator(O) {
      return new Ky({
        regexp: O.specialChars,
        decoration: (e, t, i) => {
          let { doc: n } = t.state, r = Pe(e[0], 0);
          if (r == 9) {
            let s = n.lineAt(i), o = t.state.tabSize, a = hn(s.text, o, i - s.from);
            return V.replace({ widget: new oX((o - a % o) * this.view.defaultCharacterWidth) });
          }
          return this.decorationCache[r] || (this.decorationCache[r] = V.replace({ widget: new sX(O, r) }));
        },
        boundary: O.replaceTabs ? void 0 : /[^]/
      });
    }
    update(O) {
      let e = O.state.facet(ar);
      O.startState.facet(ar) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(O.view)) : this.decorations = this.decorator.updateDeco(O, this.decorations);
    }
  }, {
    decorations: (O) => O.decorations
  }));
}
var nX = "•";
function rX(O) {
  return O >= 32 ? nX : O == 10 ? "␤" : String.fromCharCode(9216 + O);
}
var sX = class extends wt {
  constructor(e, t) {
    super(), this.options = e, this.code = t;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let t = rX(this.code), i = e.state.phrase("Control character") + " " + (eX[this.code] || "0x" + this.code.toString(16)), n = this.options.render && this.options.render(this.code, i, t);
    if (n)
      return n;
    let r = document.createElement("span");
    return r.textContent = t, r.title = i, r.setAttribute("aria-label", i), r.className = "cm-specialChar", r;
  }
  ignoreEvent() {
    return false;
  }
};
var oX = class extends wt {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return false;
  }
};
function aX() {
  return cX;
}
var lX = V.line({ class: "cm-activeLine" });
var cX = se.fromClass(class {
  constructor(O) {
    this.decorations = this.getDeco(O);
  }
  update(O) {
    (O.docChanged || O.selectionSet) && (this.decorations = this.getDeco(O.view));
  }
  getDeco(O) {
    let e = -1, t = [];
    for (let i of O.state.selection.ranges) {
      let n = O.lineBlockAt(i.head);
      n.from > e && (t.push(lX.range(n.from)), e = n.from);
    }
    return V.set(t);
  }
}, {
  decorations: (O) => O.decorations
});
var hX = class extends wt {
  constructor(e) {
    super(), this.content = e;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.className = "cm-placeholder", e.style.pointerEvents = "none", e.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : this.content), typeof this.content == "string" ? e.setAttribute("aria-label", "placeholder " + this.content) : e.setAttribute("aria-hidden", "true"), e;
  }
  ignoreEvent() {
    return false;
  }
};
function uX(O) {
  return se.fromClass(class {
    constructor(e) {
      this.view = e, this.placeholder = V.set([V.widget({ widget: new hX(O), side: 1 }).range(0)]);
    }
    get decorations() {
      return this.view.state.doc.length ? V.none : this.placeholder;
    }
  }, { decorations: (e) => e.decorations });
}
var ma = 2e3;
function fX(O, e, t) {
  let i = Math.min(e.line, t.line), n = Math.max(e.line, t.line), r = [];
  if (e.off > ma || t.off > ma || e.col < 0 || t.col < 0) {
    let s = Math.min(e.off, t.off), o = Math.max(e.off, t.off);
    for (let a = i; a <= n; a++) {
      let l = O.doc.line(a);
      l.length <= o && r.push(S.range(l.from + s, l.to + o));
    }
  } else {
    let s = Math.min(e.col, t.col), o = Math.max(e.col, t.col);
    for (let a = i; a <= n; a++) {
      let l = O.doc.line(a), h2 = Ho(l.text, s, O.tabSize, true);
      if (h2 < 0)
        r.push(S.cursor(l.to));
      else {
        let u = Ho(l.text, o, O.tabSize);
        r.push(S.range(l.from + h2, l.from + u));
      }
    }
  }
  return r;
}
function dX(O, e) {
  let t = O.coordsAtPos(O.viewport.from);
  return t ? Math.round(Math.abs((t.left - e) / O.defaultCharacterWidth)) : -1;
}
function Wh(O, e) {
  let t = O.posAtCoords({ x: e.clientX, y: e.clientY }, false), i = O.state.doc.lineAt(t), n = t - i.from, r = n > ma ? -1 : n == i.length ? dX(O, e.clientX) : hn(i.text, O.state.tabSize, t - i.from);
  return { line: i.number, col: r, off: n };
}
function QX(O, e) {
  let t = Wh(O, e), i = O.state.selection;
  return t ? {
    update(n) {
      if (n.docChanged) {
        let r = n.changes.mapPos(n.startState.doc.line(t.line).from), s = n.state.doc.lineAt(r);
        t = { line: s.number, col: t.col, off: Math.min(t.off, s.length) }, i = i.map(n.changes);
      }
    },
    get(n, r, s) {
      let o = Wh(O, n);
      if (!o)
        return i;
      let a = fX(O.state, t, o);
      return a.length ? s ? S.create(a.concat(i.ranges)) : S.create(a) : i;
    }
  } : null;
}
function $X(O) {
  let e = (O == null ? void 0 : O.eventFilter) || ((t) => t.altKey && t.button == 0);
  return k.mouseSelectionStyle.of((t, i) => e(i) ? QX(t, i) : null);
}
var pX = {
  Alt: [18, (O) => O.altKey],
  Control: [17, (O) => O.ctrlKey],
  Shift: [16, (O) => O.shiftKey],
  Meta: [91, (O) => O.metaKey]
};
var mX = { style: "cursor: crosshair" };
function gX(O = {}) {
  let [e, t] = pX[O.key || "Alt"], i = se.fromClass(class {
    constructor(n) {
      this.view = n, this.isDown = false;
    }
    set(n) {
      this.isDown != n && (this.isDown = n, this.view.update([]));
    }
  }, {
    eventHandlers: {
      keydown(n) {
        this.set(n.keyCode == e || t(n));
      },
      keyup(n) {
        (n.keyCode == e || !t(n)) && this.set(false);
      },
      mousemove(n) {
        this.set(t(n));
      }
    }
  });
  return [
    i,
    k.contentAttributes.of((n) => {
      var r;
      return !((r = n.plugin(i)) === null || r === void 0) && r.isDown ? mX : null;
    })
  ];
}
var qn = "-10000px";
var DQ = class {
  constructor(e, t, i) {
    this.facet = t, this.createTooltipView = i, this.input = e.state.facet(t), this.tooltips = this.input.filter((n) => n), this.tooltipViews = this.tooltips.map(i);
  }
  update(e) {
    var t;
    let i = e.state.facet(this.facet), n = i.filter((s) => s);
    if (i === this.input) {
      for (let s of this.tooltipViews)
        s.update && s.update(e);
      return false;
    }
    let r = [];
    for (let s = 0; s < n.length; s++) {
      let o = n[s], a = -1;
      if (o) {
        for (let l = 0; l < this.tooltips.length; l++) {
          let h2 = this.tooltips[l];
          h2 && h2.create == o.create && (a = l);
        }
        if (a < 0)
          r[s] = this.createTooltipView(o);
        else {
          let l = r[s] = this.tooltipViews[a];
          l.update && l.update(e);
        }
      }
    }
    for (let s of this.tooltipViews)
      r.indexOf(s) < 0 && (s.dom.remove(), (t = s.destroy) === null || t === void 0 || t.call(s));
    return this.input = i, this.tooltips = n, this.tooltipViews = r, true;
  }
};
function SX(O) {
  let { win: e } = O;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
var As = q.define({
  combine: (O) => {
    var e, t, i;
    return {
      position: Y.ios ? "absolute" : ((e = O.find((n) => n.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((t = O.find((n) => n.parent)) === null || t === void 0 ? void 0 : t.parent) || null,
      tooltipSpace: ((i = O.find((n) => n.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || SX
    };
  }
});
var vh = /* @__PURE__ */ new WeakMap();
var MQ = se.fromClass(class {
  constructor(O) {
    this.view = O, this.inView = true, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = O.state.facet(As);
    this.position = e.position, this.parent = e.parent, this.classes = O.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.manager = new DQ(O, gl, (t) => this.createTooltip(t)), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((t) => {
      Date.now() > this.lastTransaction - 50 && t.length > 0 && t[t.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), O.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let O of this.manager.tooltipViews)
        this.intersectionObserver.observe(O.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(O) {
    O.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(O);
    e && this.observeIntersection();
    let t = e || O.geometryChanged, i = O.state.facet(As);
    if (i.position != this.position) {
      this.position = i.position;
      for (let n of this.manager.tooltipViews)
        n.dom.style.position = this.position;
      t = true;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let n of this.manager.tooltipViews)
        this.container.appendChild(n.dom);
      t = true;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    t && this.maybeMeasure();
  }
  createTooltip(O) {
    let e = O.create(this.view);
    if (e.dom.classList.add("cm-tooltip"), O.arrow && !e.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let t = document.createElement("div");
      t.className = "cm-tooltip-arrow", e.dom.appendChild(t);
    }
    return e.dom.style.position = this.position, e.dom.style.top = qn, this.container.appendChild(e.dom), e.mount && e.mount(this.view), e;
  }
  destroy() {
    var O, e;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let t of this.manager.tooltipViews)
      t.dom.remove(), (O = t.destroy) === null || O === void 0 || O.call(t);
    (e = this.intersectionObserver) === null || e === void 0 || e.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let O = this.view.dom.getBoundingClientRect();
    return {
      editor: O,
      parent: this.parent ? this.container.getBoundingClientRect() : O,
      pos: this.manager.tooltips.map((e, t) => {
        let i = this.manager.tooltipViews[t];
        return i.getCoords ? i.getCoords(e.pos) : this.view.coordsAtPos(e.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: e }) => e.getBoundingClientRect()),
      space: this.view.state.facet(As).tooltipSpace(this.view)
    };
  }
  writeMeasure(O) {
    var e;
    let { editor: t, space: i } = O, n = [];
    for (let r = 0; r < this.manager.tooltips.length; r++) {
      let s = this.manager.tooltips[r], o = this.manager.tooltipViews[r], { dom: a } = o, l = O.pos[r], h2 = O.size[r];
      if (!l || l.bottom <= Math.max(t.top, i.top) || l.top >= Math.min(t.bottom, i.bottom) || l.right < Math.max(t.left, i.left) - 0.1 || l.left > Math.min(t.right, i.right) + 0.1) {
        a.style.top = qn;
        continue;
      }
      let u = s.arrow ? o.dom.querySelector(".cm-tooltip-arrow") : null, f = u ? 7 : 0, d = h2.right - h2.left, Q = (e = vh.get(o)) !== null && e !== void 0 ? e : h2.bottom - h2.top, $ = o.offset || yX, p = this.view.textDirection == ne.LTR, m = h2.width > i.right - i.left ? p ? i.left : i.right - h2.width : p ? Math.min(l.left - (u ? 14 : 0) + $.x, i.right - d) : Math.max(i.left, l.left - d + (u ? 14 : 0) - $.x), g = !!s.above;
      !s.strictSide && (g ? l.top - (h2.bottom - h2.top) - $.y < i.top : l.bottom + (h2.bottom - h2.top) + $.y > i.bottom) && g == i.bottom - l.bottom > l.top - i.top && (g = !g);
      let b = (g ? l.top - i.top : i.bottom - l.bottom) - f;
      if (b < Q && o.resize !== false) {
        if (b < this.view.defaultLineHeight) {
          a.style.top = qn;
          continue;
        }
        vh.set(o, Q), a.style.height = (Q = b) + "px";
      } else
        a.style.height && (a.style.height = "");
      let y = g ? l.top - Q - f - $.y : l.bottom + f + $.y, w = m + d;
      if (o.overlap !== true)
        for (let P of n)
          P.left < w && P.right > m && P.top < y + Q && P.bottom > y && (y = g ? P.top - Q - 2 - f : P.bottom + f + 2);
      this.position == "absolute" ? (a.style.top = y - O.parent.top + "px", a.style.left = m - O.parent.left + "px") : (a.style.top = y + "px", a.style.left = m + "px"), u && (u.style.left = `${l.left + (p ? $.x : -$.x) - (m + 14 - 7)}px`), o.overlap !== true && n.push({ left: m, top: y, right: w, bottom: y + Q }), a.classList.toggle("cm-tooltip-above", g), a.classList.toggle("cm-tooltip-below", !g), o.positioned && o.positioned(O.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let O of this.manager.tooltipViews)
        O.dom.style.top = qn;
  }
}, {
  eventHandlers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
var PX = k.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: `${7}px`,
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: `${7}px solid transparent`,
      borderRight: `${7}px solid transparent`
    },
    ".cm-tooltip-above &": {
      bottom: `-${7}px`,
      "&:before": {
        borderTop: `${7}px solid #bbb`
      },
      "&:after": {
        borderTop: `${7}px solid #f5f5f5`,
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: `-${7}px`,
      "&:before": {
        borderBottom: `${7}px solid #bbb`
      },
      "&:after": {
        borderBottom: `${7}px solid #f5f5f5`,
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
});
var yX = { x: 0, y: 0 };
var gl = q.define({
  enables: [MQ, PX]
});
var kr = q.define();
var Sl = class {
  constructor(e) {
    this.view = e, this.mounted = false, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new DQ(e, kr, (t) => this.createHostedView(t));
  }
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new Sl(e);
  }
  createHostedView(e) {
    let t = e.create(this.view);
    return t.dom.classList.add("cm-tooltip-section"), this.dom.appendChild(t.dom), this.mounted && t.mount && t.mount(this.view), t;
  }
  mount(e) {
    for (let t of this.manager.tooltipViews)
      t.mount && t.mount(e);
    this.mounted = true;
  }
  positioned(e) {
    for (let t of this.manager.tooltipViews)
      t.positioned && t.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
};
var XX = gl.compute([kr], (O) => {
  let e = O.facet(kr).filter((t) => t);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((t) => t.pos)),
    end: Math.max(...e.filter((t) => t.end != null).map((t) => t.end)),
    create: Sl.create,
    above: e[0].above,
    arrow: e.some((t) => t.arrow)
  };
});
var xX = class {
  constructor(e, t, i, n, r) {
    this.view = e, this.source = t, this.field = i, this.setHover = n, this.hoverTime = r, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { lastMove: e } = this, t = this.view.contentDOM.contains(e.target) ? this.view.posAtCoords(e) : null;
    if (t == null)
      return;
    let i = this.view.coordsAtPos(t);
    if (i == null || e.y < i.top || e.y > i.bottom || e.x < i.left - this.view.defaultCharacterWidth || e.x > i.right + this.view.defaultCharacterWidth)
      return;
    let n = this.view.bidiSpans(this.view.state.doc.lineAt(t)).find((o) => o.from <= t && o.to >= t), r = n && n.dir == ne.RTL ? -1 : 1, s = this.source(this.view, t, e.x < i.left ? -r : r);
    if (s != null && s.then) {
      let o = this.pending = { pos: t };
      s.then((a) => {
        this.pending == o && (this.pending = null, a && this.view.dispatch({ effects: this.setHover.of(a) }));
      }, (a) => Ne(this.view.state, a, "hover tooltip"));
    } else
      s && this.view.dispatch({ effects: this.setHover.of(s) });
  }
  mousemove(e) {
    var t;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let i = this.active;
    if (i && !kh(this.lastMove.target) || this.pending) {
      let { pos: n } = i || this.pending, r = (t = i == null ? void 0 : i.end) !== null && t !== void 0 ? t : n;
      (n == r ? this.view.posAtCoords(this.lastMove) != n : !bX(
        this.view,
        n,
        r,
        e.clientX,
        e.clientY,
        6
        /* Hover.MaxDist */
      )) && (this.view.dispatch({ effects: this.setHover.of(null) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1, this.active && !kh(e.relatedTarget) && this.view.dispatch({ effects: this.setHover.of(null) });
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
};
function kh(O) {
  for (let e = O; e; e = e.parentNode)
    if (e.nodeType == 1 && e.classList.contains("cm-tooltip"))
      return true;
  return false;
}
function bX(O, e, t, i, n, r) {
  let s = document.createRange(), o = O.domAtPos(e), a = O.domAtPos(t);
  s.setEnd(a.node, a.offset), s.setStart(o.node, o.offset);
  let l = s.getClientRects();
  s.detach();
  for (let h2 = 0; h2 < l.length; h2++) {
    let u = l[h2];
    if (Math.max(u.top - n, n - u.bottom, u.left - i, i - u.right) <= r)
      return true;
  }
  return false;
}
function wX(O, e = {}) {
  let t = j.define(), i = me.define({
    create() {
      return null;
    },
    update(n, r) {
      if (n && (e.hideOnChange && (r.docChanged || r.selection) || e.hideOn && e.hideOn(r, n)))
        return null;
      if (n && r.docChanged) {
        let s = r.changes.mapPos(n.pos, -1, Xe.TrackDel);
        if (s == null)
          return null;
        let o = Object.assign(/* @__PURE__ */ Object.create(null), n);
        o.pos = s, n.end != null && (o.end = r.changes.mapPos(n.end)), n = o;
      }
      for (let s of r.effects)
        s.is(t) && (n = s.value), s.is(WX) && (n = null);
      return n;
    },
    provide: (n) => kr.from(n)
  });
  return [
    i,
    se.define((n) => new xX(
      n,
      O,
      i,
      t,
      e.hoverTime || 300
      /* Hover.Time */
    )),
    XX
  ];
}
function TX(O, e) {
  let t = O.plugin(MQ);
  if (!t)
    return null;
  let i = t.manager.tooltips.indexOf(e);
  return i < 0 ? null : t.manager.tooltipViews[i];
}
var WX = j.define();
var Yh = q.define({
  combine(O) {
    let e, t;
    for (let i of O)
      e = e || i.topContainer, t = t || i.bottomContainer;
    return { topContainer: e, bottomContainer: t };
  }
});
function Li(O, e) {
  let t = O.plugin(LQ), i = t ? t.specs.indexOf(e) : -1;
  return i > -1 ? t.panels[i] : null;
}
var LQ = se.fromClass(class {
  constructor(O) {
    this.input = O.state.facet(Bi), this.specs = this.input.filter((t) => t), this.panels = this.specs.map((t) => t(O));
    let e = O.state.facet(Yh);
    this.top = new zn(O, true, e.topContainer), this.bottom = new zn(O, false, e.bottomContainer), this.top.sync(this.panels.filter((t) => t.top)), this.bottom.sync(this.panels.filter((t) => !t.top));
    for (let t of this.panels)
      t.dom.classList.add("cm-panel"), t.mount && t.mount();
  }
  update(O) {
    let e = O.state.facet(Yh);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new zn(O.view, true, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new zn(O.view, false, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let t = O.state.facet(Bi);
    if (t != this.input) {
      let i = t.filter((a) => a), n = [], r = [], s = [], o = [];
      for (let a of i) {
        let l = this.specs.indexOf(a), h2;
        l < 0 ? (h2 = a(O.view), o.push(h2)) : (h2 = this.panels[l], h2.update && h2.update(O)), n.push(h2), (h2.top ? r : s).push(h2);
      }
      this.specs = i, this.panels = n, this.top.sync(r), this.bottom.sync(s);
      for (let a of o)
        a.dom.classList.add("cm-panel"), a.mount && a.mount();
    } else
      for (let i of this.panels)
        i.update && i.update(O);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (O) => k.scrollMargins.of((e) => {
    let t = e.plugin(O);
    return t && { top: t.top.scrollMargin(), bottom: t.bottom.scrollMargin() };
  })
});
var zn = class {
  constructor(e, t, i) {
    this.view = e, this.top = t, this.container = i, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let t of this.panels)
      t.destroy && e.indexOf(t) < 0 && t.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let t = this.container || this.view.dom;
      t.insertBefore(this.dom, this.top ? t.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let t of this.panels)
      if (t.dom.parentNode == this.dom) {
        for (; e != t.dom; )
          e = Zh(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(t.dom, e);
    for (; e; )
      e = Zh(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
};
function Zh(O) {
  let e = O.nextSibling;
  return O.remove(), e;
}
var Bi = q.define({
  enables: LQ
});
var Ut = class extends PO {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return false;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
};
Ut.prototype.elementClass = "";
Ut.prototype.toDOM = void 0;
Ut.prototype.mapMode = Xe.TrackBefore;
Ut.prototype.startSide = Ut.prototype.endSide = -1;
Ut.prototype.point = true;
var lr = q.define();
var vX = {
  class: "",
  renderEmptyElements: false,
  elementStyle: "",
  markers: () => L.empty,
  lineMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
};
var Zi = q.define();
function kX(O) {
  return [BQ(), Zi.of(Object.assign(Object.assign({}, vX), O))];
}
var ga = q.define({
  combine: (O) => O.some((e) => e)
});
function BQ(O) {
  let e = [
    YX
  ];
  return O && O.fixed === false && e.push(ga.of(true)), e;
}
var YX = se.fromClass(class {
  constructor(O) {
    this.view = O, this.prevViewport = O.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight + "px", this.gutters = O.state.facet(Zi).map((e) => new zh(O, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !O.state.facet(ga), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(false), O.scrollDOM.insertBefore(this.dom, O.contentDOM);
  }
  update(O) {
    if (this.updateGutters(O)) {
      let e = this.prevViewport, t = O.view.viewport, i = Math.min(e.to, t.to) - Math.max(e.from, t.from);
      this.syncGutters(i < (t.to - t.from) * 0.8);
    }
    O.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(ga) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = O.view.viewport;
  }
  syncGutters(O) {
    let e = this.dom.nextSibling;
    O && this.dom.remove();
    let t = L.iter(this.view.state.facet(lr), this.view.viewport.from), i = [], n = this.gutters.map((r) => new ZX(r, this.view.viewport, -this.view.documentPadding.top));
    for (let r of this.view.viewportLineBlocks) {
      let s;
      if (Array.isArray(r.type)) {
        for (let o of r.type)
          if (o.type == F.Text) {
            s = o;
            break;
          }
      } else
        s = r.type == F.Text ? r : void 0;
      if (s) {
        i.length && (i = []), NQ(t, i, r.from);
        for (let o of n)
          o.line(this.view, s, i);
      }
    }
    for (let r of n)
      r.finish();
    O && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(O) {
    let e = O.startState.facet(Zi), t = O.state.facet(Zi), i = O.docChanged || O.heightChanged || O.viewportChanged || !L.eq(O.startState.facet(lr), O.state.facet(lr), O.view.viewport.from, O.view.viewport.to);
    if (e == t)
      for (let n of this.gutters)
        n.update(O) && (i = true);
    else {
      i = true;
      let n = [];
      for (let r of t) {
        let s = e.indexOf(r);
        s < 0 ? n.push(new zh(this.view, r)) : (this.gutters[s].update(O), n.push(this.gutters[s]));
      }
      for (let r of this.gutters)
        r.dom.remove(), n.indexOf(r) < 0 && r.destroy();
      for (let r of n)
        this.dom.appendChild(r.dom);
      this.gutters = n;
    }
    return i;
  }
  destroy() {
    for (let O of this.gutters)
      O.destroy();
    this.dom.remove();
  }
}, {
  provide: (O) => k.scrollMargins.of((e) => {
    let t = e.plugin(O);
    return !t || t.gutters.length == 0 || !t.fixed ? null : e.textDirection == ne.LTR ? { left: t.dom.offsetWidth } : { right: t.dom.offsetWidth };
  })
});
function qh(O) {
  return Array.isArray(O) ? O : [O];
}
function NQ(O, e, t) {
  for (; O.value && O.from <= t; )
    O.from == t && e.push(O.value), O.next();
}
var ZX = class {
  constructor(e, t, i) {
    this.gutter = e, this.height = i, this.i = 0, this.cursor = L.iter(e.markers, t.from);
  }
  line(e, t, i) {
    let n = [];
    NQ(this.cursor, n, t.from), i.length && (n = n.concat(i));
    let r = this.gutter.config.lineMarker(e, t, n);
    r && n.unshift(r);
    let s = this.gutter;
    if (n.length == 0 && !s.config.renderEmptyElements)
      return;
    let o = t.top - this.height;
    if (this.i == s.elements.length) {
      let a = new FQ(e, t.height, o, n);
      s.elements.push(a), s.dom.appendChild(a.dom);
    } else
      s.elements[this.i].update(e, t.height, o, n);
    this.height = t.bottom, this.i++;
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop();
      e.dom.removeChild(t.dom), t.destroy();
    }
  }
};
var zh = class {
  constructor(e, t) {
    this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let i in t.domEventHandlers)
      this.dom.addEventListener(i, (n) => {
        let r = n.target, s;
        if (r != this.dom && this.dom.contains(r)) {
          for (; r.parentNode != this.dom; )
            r = r.parentNode;
          let a = r.getBoundingClientRect();
          s = (a.top + a.bottom) / 2;
        } else
          s = n.clientY;
        let o = e.lineBlockAtHeight(s - e.documentTop);
        t.domEventHandlers[i](e, o, n) && n.preventDefault();
      });
    this.markers = qh(t.markers(e)), t.initialSpacer && (this.spacer = new FQ(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let t = this.markers;
    if (this.markers = qh(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let n = this.config.updateSpacer(this.spacer.markers[0], e);
      n != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [n]);
    }
    let i = e.view.viewport;
    return !L.eq(this.markers, t, i.from, i.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : false);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
};
var FQ = class {
  constructor(e, t, i, n) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, t, i, n);
  }
  update(e, t, i, n) {
    this.height != t && (this.dom.style.height = (this.height = t) + "px"), this.above != i && (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""), qX(this.markers, n) || this.setMarkers(e, n);
  }
  setMarkers(e, t) {
    let i = "cm-gutterElement", n = this.dom.firstChild;
    for (let r = 0, s = 0; ; ) {
      let o = s, a = r < t.length ? t[r++] : null, l = false;
      if (a) {
        let h2 = a.elementClass;
        h2 && (i += " " + h2);
        for (let u = s; u < this.markers.length; u++)
          if (this.markers[u].compare(a)) {
            o = u, l = true;
            break;
          }
      } else
        o = this.markers.length;
      for (; s < o; ) {
        let h2 = this.markers[s++];
        if (h2.toDOM) {
          h2.destroy(n);
          let u = n.nextSibling;
          n.remove(), n = u;
        }
      }
      if (!a)
        break;
      a.toDOM && (l ? n = n.nextSibling : this.dom.insertBefore(a.toDOM(e), n)), l && s++;
    }
    this.dom.className = i, this.markers = t;
  }
  destroy() {
    this.setMarkers(null, []);
  }
};
function qX(O, e) {
  if (O.length != e.length)
    return false;
  for (let t = 0; t < O.length; t++)
    if (!O[t].compare(e[t]))
      return false;
  return true;
}
var zX = q.define();
var RO = q.define({
  combine(O) {
    return bt(O, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, t) {
        let i = Object.assign({}, e);
        for (let n in t) {
          let r = i[n], s = t[n];
          i[n] = r ? (o, a, l) => r(o, a, l) || s(o, a, l) : s;
        }
        return i;
      }
    });
  }
});
var Ds = class extends Ut {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
};
function Ms(O, e) {
  return O.state.facet(RO).formatNumber(e, O.state);
}
var UX = Zi.compute([RO], (O) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: false,
  markers(e) {
    return e.state.facet(zX);
  },
  lineMarker(e, t, i) {
    return i.some((n) => n.toDOM) ? null : new Ds(Ms(e, e.state.doc.lineAt(t.from).number));
  },
  lineMarkerChange: (e) => e.startState.facet(RO) != e.state.facet(RO),
  initialSpacer(e) {
    return new Ds(Ms(e, Uh(e.state.doc.lines)));
  },
  updateSpacer(e, t) {
    let i = Ms(t.view, Uh(t.view.state.doc.lines));
    return i == e.number ? e : new Ds(i);
  },
  domEventHandlers: O.facet(RO).domEventHandlers
}));
function VX(O = {}) {
  return [
    RO.of(O),
    BQ(),
    UX
  ];
}
function Uh(O) {
  let e = 9;
  for (; e < O; )
    e = e * 10 + 9;
  return e;
}
var RX = new class extends Ut {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}();
var _X = lr.compute(["selection"], (O) => {
  let e = [], t = -1;
  for (let i of O.selection.ranges) {
    let n = O.doc.lineAt(i.head).from;
    n > t && (t = n, e.push(RX.range(n)));
  }
  return L.of(e);
});
function jX() {
  return _X;
}
var HQ = 1024;
var CX = 0;
var Ke = class {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
};
var _ = class {
  /// Create a new node prop type.
  constructor(e = {}) {
    this.id = CX++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /// This is meant to be used with
  /// [`NodeSet.extend`](#common.NodeSet.extend) or
  /// [`LRParser.configure`](#lr.ParserConfig.props) to compute
  /// prop values for each node type in the set. Takes a [match
  /// object](#common.NodeType^match) or function that returns undefined
  /// if the node type doesn't get this prop, and the prop's value if
  /// it does.
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = ue.match(e)), (t) => {
      let i = e(t);
      return i === void 0 ? null : [this, i];
    };
  }
};
_.closedBy = new _({ deserialize: (O) => O.split(" ") });
_.openedBy = new _({ deserialize: (O) => O.split(" ") });
_.group = new _({ deserialize: (O) => O.split(" ") });
_.contextHash = new _({ perNode: true });
_.lookAhead = new _({ perNode: true });
_.mounted = new _({ perNode: true });
var GX = class {
  constructor(e, t, i) {
    this.tree = e, this.overlay = t, this.parser = i;
  }
};
var IX = /* @__PURE__ */ Object.create(null);
var ue = class {
  /// @internal
  constructor(e, t, i, n = 0) {
    this.name = e, this.props = t, this.id = i, this.flags = n;
  }
  /// Define a node type.
  static define(e) {
    let t = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : IX, i = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), n = new ue(e.name || "", t, e.id, i);
    if (e.props) {
      for (let r of e.props)
        if (Array.isArray(r) || (r = r(n)), r) {
          if (r[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          t[r[0].id] = r[1];
        }
    }
    return n;
  }
  /// Retrieves a node prop for this type. Will return `undefined` if
  /// the prop isn't present on this node.
  prop(e) {
    return this.props[e.id];
  }
  /// True when this is the top node of a grammar.
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /// True when this node is produced by a skip rule.
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /// Indicates whether this is an error node.
  get isError() {
    return (this.flags & 4) > 0;
  }
  /// When true, this node type doesn't correspond to a user-declared
  /// named node, for example because it is used to cache repetition.
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /// Returns true when this node's name or one of its
  /// [groups](#common.NodeProp^group) matches the given string.
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return true;
      let t = this.prop(_.group);
      return t ? t.indexOf(e) > -1 : false;
    }
    return this.id == e;
  }
  /// Create a function from node types to arbitrary values by
  /// specifying an object whose property names are node or
  /// [group](#common.NodeProp^group) names. Often useful with
  /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  /// names, separated by spaces, in a single property name to map
  /// multiple node names to a single value.
  static match(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let i in e)
      for (let n of i.split(" "))
        t[n] = e[i];
    return (i) => {
      for (let n = i.prop(_.group), r = -1; r < (n ? n.length : 0); r++) {
        let s = t[r < 0 ? i.name : n[r]];
        if (s)
          return s;
      }
    };
  }
};
ue.none = new ue(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
var ni = class {
  /// Create a set with the given types. The `id` property of each
  /// type should correspond to its position within the array.
  constructor(e) {
    this.types = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].id != t)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /// Create a copy of this set with some node properties added. The
  /// arguments to this method can be created with
  /// [`NodeProp.add`](#common.NodeProp.add).
  extend(...e) {
    let t = [];
    for (let i of this.types) {
      let n = null;
      for (let r of e) {
        let s = r(i);
        s && (n || (n = Object.assign({}, i.props)), n[s[0].id] = s[1]);
      }
      t.push(n ? new ue(i.name, n, i.id, i.flags) : i);
    }
    return new ni(t);
  }
};
var Un = /* @__PURE__ */ new WeakMap();
var Vh = /* @__PURE__ */ new WeakMap();
var K;
(function(O) {
  O[O.ExcludeBuffers = 1] = "ExcludeBuffers", O[O.IncludeAnonymous = 2] = "IncludeAnonymous", O[O.IgnoreMounts = 4] = "IgnoreMounts", O[O.IgnoreOverlays = 8] = "IgnoreOverlays";
})(K || (K = {}));
var E = class {
  /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  constructor(e, t, i, n, r) {
    if (this.type = e, this.children = t, this.positions = i, this.length = n, this.props = null, r && r.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [s, o] of r)
        this.props[typeof s == "number" ? s : s.id] = o;
    }
  }
  /// @internal
  toString() {
    let e = this.prop(_.mounted);
    if (e && !e.overlay)
      return e.tree.toString();
    let t = "";
    for (let i of this.children) {
      let n = i.toString();
      n && (t && (t += ","), t += n);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t;
  }
  /// Get a [tree cursor](#common.TreeCursor) positioned at the top of
  /// the tree. Mode can be used to [control](#common.IterMode) which
  /// nodes the cursor visits.
  cursor(e = 0) {
    return new Ni(this.topNode, e);
  }
  /// Get a [tree cursor](#common.TreeCursor) pointing into this tree
  /// at the given position and side (see
  /// [`moveTo`](#common.TreeCursor.moveTo).
  cursorAt(e, t = 0, i = 0) {
    let n = Un.get(this) || this.topNode, r = new Ni(n);
    return r.moveTo(e, t), Un.set(this, r._tree), r;
  }
  /// Get a [syntax node](#common.SyntaxNode) object for the top of the
  /// tree.
  get topNode() {
    return new et(this, 0, 0, null);
  }
  /// Get the [syntax node](#common.SyntaxNode) at the given position.
  /// If `side` is -1, this will move into nodes that end at the
  /// position. If 1, it'll move into nodes that start at the
  /// position. With 0, it'll only enter nodes that cover the position
  /// from both sides.
  ///
  /// Note that this will not enter
  /// [overlays](#common.MountedTree.overlay), and you often want
  /// [`resolveInner`](#common.Tree.resolveInner) instead.
  resolve(e, t = 0) {
    let i = NO(Un.get(this) || this.topNode, e, t, false);
    return Un.set(this, i), i;
  }
  /// Like [`resolve`](#common.Tree.resolve), but will enter
  /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  /// pointing into the innermost overlaid tree at the given position
  /// (with parent links going through all parent structure, including
  /// the host trees).
  resolveInner(e, t = 0) {
    let i = NO(Vh.get(this) || this.topNode, e, t, true);
    return Vh.set(this, i), i;
  }
  /// Iterate over the tree and its children, calling `enter` for any
  /// node that touches the `from`/`to` region (if given) before
  /// running over such a node's children, and `leave` (if given) when
  /// leaving the node. When `enter` returns `false`, that node will
  /// not have its children iterated over (or `leave` called).
  iterate(e) {
    let { enter: t, leave: i, from: n = 0, to: r = this.length } = e;
    for (let s = this.cursor((e.mode || 0) | K.IncludeAnonymous); ; ) {
      let o = false;
      if (s.from <= r && s.to >= n && (s.type.isAnonymous || t(s) !== false)) {
        if (s.firstChild())
          continue;
        o = true;
      }
      for (; o && i && !s.type.isAnonymous && i(s), !s.nextSibling(); ) {
        if (!s.parent())
          return;
        o = true;
      }
    }
  }
  /// Get the value of the given [node prop](#common.NodeProp) for this
  /// node. Works with both per-node and per-type props.
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /// Returns the node's [per-node props](#common.NodeProp.perNode) in a
  /// format that can be passed to the [`Tree`](#common.Tree)
  /// constructor.
  get propValues() {
    let e = [];
    if (this.props)
      for (let t in this.props)
        e.push([+t, this.props[t]]);
    return e;
  }
  /// Balance the direct children of this tree, producing a copy of
  /// which may have children grouped into subtrees with type
  /// [`NodeType.none`](#common.NodeType^none).
  balance(e = {}) {
    return this.children.length <= 8 ? this : Xl(ue.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, i, n) => new E(this.type, t, i, n, this.propValues), e.makeTree || ((t, i, n) => new E(ue.none, t, i, n)));
  }
  /// Build a tree from a postfix-ordered buffer of node information,
  /// or a cursor over such a buffer.
  static build(e) {
    return AX(e);
  }
};
E.empty = new E(ue.none, [], [], 0);
var Pl = class {
  constructor(e, t) {
    this.buffer = e, this.index = t;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new Pl(this.buffer, this.index);
  }
};
var WO = class {
  /// Create a tree buffer.
  constructor(e, t, i) {
    this.buffer = e, this.length = t, this.set = i;
  }
  /// @internal
  get type() {
    return ue.none;
  }
  /// @internal
  toString() {
    let e = [];
    for (let t = 0; t < this.buffer.length; )
      e.push(this.childString(t)), t = this.buffer[t + 3];
    return e.join(",");
  }
  /// @internal
  childString(e) {
    let t = this.buffer[e], i = this.buffer[e + 3], n = this.set.types[t], r = n.name;
    if (/\W/.test(r) && !n.isError && (r = JSON.stringify(r)), e += 4, i == e)
      return r;
    let s = [];
    for (; e < i; )
      s.push(this.childString(e)), e = this.buffer[e + 3];
    return r + "(" + s.join(",") + ")";
  }
  /// @internal
  findChild(e, t, i, n, r) {
    let { buffer: s } = this, o = -1;
    for (let a = e; a != t && !(KQ(r, n, s[a + 1], s[a + 2]) && (o = a, i > 0)); a = s[a + 3])
      ;
    return o;
  }
  /// @internal
  slice(e, t, i) {
    let n = this.buffer, r = new Uint16Array(t - e), s = 0;
    for (let o = e, a = 0; o < t; ) {
      r[a++] = n[o++], r[a++] = n[o++] - i;
      let l = r[a++] = n[o++] - i;
      r[a++] = n[o++] - e, s = Math.max(s, l);
    }
    return new WO(r, s, this.set);
  }
};
function KQ(O, e, t, i) {
  switch (O) {
    case -2:
      return t < e;
    case -1:
      return i >= e && t < e;
    case 0:
      return t < e && i > e;
    case 1:
      return t <= e && i > e;
    case 2:
      return i > e;
    case 4:
      return true;
  }
}
function JQ(O, e) {
  let t = O.childBefore(e);
  for (; t; ) {
    let i = t.lastChild;
    if (!i || i.to != t.to)
      break;
    i.type.isError && i.from == i.to ? (O = t, t = i.prevSibling) : t = i;
  }
  return O;
}
function NO(O, e, t, i) {
  for (var n; O.from == O.to || (t < 1 ? O.from >= e : O.from > e) || (t > -1 ? O.to <= e : O.to < e); ) {
    let s = !i && O instanceof et && O.index < 0 ? null : O.parent;
    if (!s)
      return O;
    O = s;
  }
  let r = i ? 0 : K.IgnoreOverlays;
  if (i)
    for (let s = O, o = s.parent; o; s = o, o = s.parent)
      s instanceof et && s.index < 0 && ((n = o.enter(e, t, r)) === null || n === void 0 ? void 0 : n.from) != s.from && (O = o);
  for (; ; ) {
    let s = O.enter(e, t, r);
    if (!s)
      return O;
    O = s;
  }
}
var et = class {
  constructor(e, t, i, n) {
    this._tree = e, this.from = t, this.index = i, this._parent = n;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, t, i, n, r = 0) {
    for (let s = this; ; ) {
      for (let { children: o, positions: a } = s._tree, l = t > 0 ? o.length : -1; e != l; e += t) {
        let h2 = o[e], u = a[e] + s.from;
        if (KQ(n, i, u, u + h2.length)) {
          if (h2 instanceof WO) {
            if (r & K.ExcludeBuffers)
              continue;
            let f = h2.findChild(0, h2.buffer.length, t, i - u, n);
            if (f > -1)
              return new gt(new EX(s, h2, e, u), null, f);
          } else if (r & K.IncludeAnonymous || !h2.type.isAnonymous || yl(h2)) {
            let f;
            if (!(r & K.IgnoreMounts) && h2.props && (f = h2.prop(_.mounted)) && !f.overlay)
              return new et(f.tree, u, e, s);
            let d = new et(h2, u, e, s);
            return r & K.IncludeAnonymous || !d.type.isAnonymous ? d : d.nextChild(t < 0 ? h2.children.length - 1 : 0, t, i, n);
          }
        }
      }
      if (r & K.IncludeAnonymous || !s.type.isAnonymous || (s.index >= 0 ? e = s.index + t : e = t < 0 ? -1 : s._parent._tree.children.length, s = s._parent, !s))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, i = 0) {
    let n;
    if (!(i & K.IgnoreOverlays) && (n = this._tree.prop(_.mounted)) && n.overlay) {
      let r = e - this.from;
      for (let { from: s, to: o } of n.overlay)
        if ((t > 0 ? s <= r : s < r) && (t < 0 ? o >= r : o > r))
          return new et(n.tree, n.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, t, i);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  cursor(e = 0) {
    return new Ni(this, e);
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  resolve(e, t = 0) {
    return NO(this, e, t, false);
  }
  resolveInner(e, t = 0) {
    return NO(this, e, t, true);
  }
  enterUnfinishedNodesBefore(e) {
    return JQ(this, e);
  }
  getChild(e, t = null, i = null) {
    let n = Yr(this, e, t, i);
    return n.length ? n[0] : null;
  }
  getChildren(e, t = null, i = null) {
    return Yr(this, e, t, i);
  }
  /// @internal
  toString() {
    return this._tree.toString();
  }
  get node() {
    return this;
  }
  matchContext(e) {
    return Zr(this, e);
  }
};
function Yr(O, e, t, i) {
  let n = O.cursor(), r = [];
  if (!n.firstChild())
    return r;
  if (t != null) {
    for (; !n.type.is(t); )
      if (!n.nextSibling())
        return r;
  }
  for (; ; ) {
    if (i != null && n.type.is(i))
      return r;
    if (n.type.is(e) && r.push(n.node), !n.nextSibling())
      return i == null ? r : [];
  }
}
function Zr(O, e, t = e.length - 1) {
  for (let i = O.parent; t >= 0; i = i.parent) {
    if (!i)
      return false;
    if (!i.type.isAnonymous) {
      if (e[t] && e[t] != i.name)
        return false;
      t--;
    }
  }
  return true;
}
var EX = class {
  constructor(e, t, i, n) {
    this.parent = e, this.buffer = t, this.index = i, this.start = n;
  }
};
var gt = class {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, t, i) {
    this.context = e, this._parent = t, this.index = i, this.type = e.buffer.set.types[e.buffer.buffer[i]];
  }
  child(e, t, i) {
    let { buffer: n } = this.context, r = n.findChild(this.index + 4, n.buffer[this.index + 3], e, t - this.context.start, i);
    return r < 0 ? null : new gt(this.context, this, r);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, i = 0) {
    if (i & K.ExcludeBuffers)
      return null;
    let { buffer: n } = this.context, r = n.findChild(this.index + 4, n.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
    return r < 0 ? null : new gt(this.context, this, r);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, t = e.buffer[this.index + 3];
    return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new gt(this.context, this._parent, t) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, t = this._parent ? this._parent.index + 4 : 0;
    return this.index == t ? this.externalSibling(-1) : new gt(this.context, this._parent, e.findChild(
      t,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  cursor(e = 0) {
    return new Ni(this, e);
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], t = [], { buffer: i } = this.context, n = this.index + 4, r = i.buffer[this.index + 3];
    if (r > n) {
      let s = i.buffer[this.index + 1];
      e.push(i.slice(n, r, s)), t.push(0);
    }
    return new E(this.type, e, t, this.to - this.from);
  }
  resolve(e, t = 0) {
    return NO(this, e, t, false);
  }
  resolveInner(e, t = 0) {
    return NO(this, e, t, true);
  }
  enterUnfinishedNodesBefore(e) {
    return JQ(this, e);
  }
  /// @internal
  toString() {
    return this.context.buffer.childString(this.index);
  }
  getChild(e, t = null, i = null) {
    let n = Yr(this, e, t, i);
    return n.length ? n[0] : null;
  }
  getChildren(e, t = null, i = null) {
    return Yr(this, e, t, i);
  }
  get node() {
    return this;
  }
  matchContext(e) {
    return Zr(this, e);
  }
};
var Ni = class {
  /// Shorthand for `.type.name`.
  get name() {
    return this.type.name;
  }
  /// @internal
  constructor(e, t = 0) {
    if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof et)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let i = e._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, true) : false;
  }
  yieldBuf(e, t) {
    this.index = e;
    let { start: i, buffer: n } = this.buffer;
    return this.type = t || n.set.types[n.buffer[e]], this.from = i + n.buffer[e + 1], this.to = i + n.buffer[e + 2], true;
  }
  yield(e) {
    return e ? e instanceof et ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : false;
  }
  /// @internal
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /// @internal
  enterChild(e, t, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, i, this.mode));
    let { buffer: n } = this.buffer, r = n.findChild(this.index + 4, n.buffer[this.index + 3], e, t - this.buffer.start, i);
    return r < 0 ? false : (this.stack.push(this.index), this.yieldBuf(r));
  }
  /// Move the cursor to this node's first child. When this returns
  /// false, the node has no child, and the cursor has not been moved.
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /// Move the cursor to this node's last child.
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /// Move the cursor to the first child that ends after `pos`.
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /// Move to the last child that starts before `pos`.
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /// Move the cursor to the child around `pos`. If side is -1 the
  /// child may end at that position, when 1 it may start there. This
  /// will also enter [overlaid](#common.MountedTree.overlay)
  /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  /// set to false.
  enter(e, t, i = this.mode) {
    return this.buffer ? i & K.ExcludeBuffers ? false : this.enterChild(1, e, t) : this.yield(this._tree.enter(e, t, i));
  }
  /// Move to the node's parent node, if this isn't the top node.
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & K.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & K.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /// @internal
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : false;
    let { buffer: t } = this.buffer, i = this.stack.length - 1;
    if (e < 0) {
      let n = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != n)
        return this.yieldBuf(t.findChild(
          n,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let n = t.buffer[this.index + 3];
      if (n < (i < 0 ? t.buffer.length : t.buffer[this.stack[i] + 3]))
        return this.yieldBuf(n);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : false;
  }
  /// Move to this node's next sibling, if any.
  nextSibling() {
    return this.sibling(1);
  }
  /// Move to this node's previous sibling, if any.
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let t, i, { buffer: n } = this;
    if (n) {
      if (e > 0) {
        if (this.index < n.buffer.buffer.length)
          return false;
      } else
        for (let r = 0; r < this.index; r++)
          if (n.buffer.buffer[r + 3] < this.index)
            return false;
      ({ index: t, parent: i } = n);
    } else
      ({ index: t, _parent: i } = this._tree);
    for (; i; { index: t, _parent: i } = i)
      if (t > -1)
        for (let r = t + e, s = e < 0 ? -1 : i._tree.children.length; r != s; r += e) {
          let o = i._tree.children[r];
          if (this.mode & K.IncludeAnonymous || o instanceof WO || !o.type.isAnonymous || yl(o))
            return false;
        }
    return true;
  }
  move(e, t) {
    if (t && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return true;
    for (; ; ) {
      if (this.sibling(e))
        return true;
      if (this.atLastNode(e) || !this.parent())
        return false;
    }
  }
  /// Move to the next node in a
  /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  /// traversal, going from a node to its first child or, if the
  /// current node is empty or `enter` is false, its next sibling or
  /// the next sibling of the first parent node that has one.
  next(e = true) {
    return this.move(1, e);
  }
  /// Move to the next node in a last-to-first pre-order traveral. A
  /// node is followed by its last child or, if it has none, its
  /// previous sibling or the previous sibling of the first parent
  /// node that has one.
  prev(e = true) {
    return this.move(-1, e);
  }
  /// Move the cursor to the innermost node that covers `pos`. If
  /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  /// it will enter nodes that start at `pos`.
  moveTo(e, t = 0) {
    for (; (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, t); )
      ;
    return this;
  }
  /// Get a [syntax node](#common.SyntaxNode) at the cursor's current
  /// position.
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, t = null, i = 0;
    if (e && e.context == this.buffer) {
      e:
        for (let n = this.index, r = this.stack.length; r >= 0; ) {
          for (let s = e; s; s = s._parent)
            if (s.index == n) {
              if (n == this.index)
                return s;
              t = s, i = r + 1;
              break e;
            }
          n = this.stack[--r];
        }
    }
    for (let n = i; n < this.stack.length; n++)
      t = new gt(this.buffer, t, this.stack[n]);
    return this.bufferNode = new gt(this.buffer, t, this.index);
  }
  /// Get the [tree](#common.Tree) that represents the current node, if
  /// any. Will return null when the node is in a [tree
  /// buffer](#common.TreeBuffer).
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /// Iterate over the current node and all its descendants, calling
  /// `enter` when entering a node and `leave`, if given, when leaving
  /// one. When `enter` returns `false`, any children of that node are
  /// skipped, and `leave` isn't called for it.
  iterate(e, t) {
    for (let i = 0; ; ) {
      let n = false;
      if (this.type.isAnonymous || e(this) !== false) {
        if (this.firstChild()) {
          i++;
          continue;
        }
        this.type.isAnonymous || (n = true);
      }
      for (; n && t && t(this), n = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!i)
          return;
        this.parent(), i--, n = true;
      }
    }
  }
  /// Test whether the current node matches a given context—a sequence
  /// of direct parent node names. Empty strings in the context array
  /// are treated as wildcards.
  matchContext(e) {
    if (!this.buffer)
      return Zr(this.node, e);
    let { buffer: t } = this.buffer, { types: i } = t.set;
    for (let n = e.length - 1, r = this.stack.length - 1; n >= 0; r--) {
      if (r < 0)
        return Zr(this.node, e, n);
      let s = i[t.buffer[this.stack[r]]];
      if (!s.isAnonymous) {
        if (e[n] && e[n] != s.name)
          return false;
        n--;
      }
    }
    return true;
  }
};
function yl(O) {
  return O.children.some((e) => e instanceof WO || !e.type.isAnonymous || yl(e));
}
function AX(O) {
  var e;
  let { buffer: t, nodeSet: i, maxBufferLength: n = HQ, reused: r = [], minRepeatType: s = i.types.length } = O, o = Array.isArray(t) ? new Pl(t, t.length) : t, a = i.types, l = 0, h2 = 0;
  function u(y, w, P, z, A) {
    let { id: C, start: X, end: W, size: R } = o, v = h2;
    for (; R < 0; )
      if (o.next(), R == -1) {
        let ge = r[C];
        P.push(ge), z.push(X - y);
        return;
      } else if (R == -3) {
        l = C;
        return;
      } else if (R == -4) {
        h2 = C;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${R}`);
    let G = a[C], Oe, oe, ft = X - y;
    if (W - X <= n && (oe = $(o.pos - w, A))) {
      let ge = new Uint16Array(oe.size - oe.skip), ae = o.pos - oe.size, Wt = ge.length;
      for (; o.pos > ae; )
        Wt = p(oe.start, ge, Wt);
      Oe = new WO(ge, W - oe.start, i), ft = oe.start - y;
    } else {
      let ge = o.pos - R;
      o.next();
      let ae = [], Wt = [], lO = C >= s ? C : -1, vO = 0, Pn = W;
      for (; o.pos > ge; )
        lO >= 0 && o.id == lO && o.size >= 0 ? (o.end <= Pn - n && (d(ae, Wt, X, vO, o.end, Pn, lO, v), vO = ae.length, Pn = o.end), o.next()) : u(X, ge, ae, Wt, lO);
      if (lO >= 0 && vO > 0 && vO < ae.length && d(ae, Wt, X, vO, X, Pn, lO, v), ae.reverse(), Wt.reverse(), lO > -1 && vO > 0) {
        let fc = f(G);
        Oe = Xl(G, ae, Wt, 0, ae.length, 0, W - X, fc, fc);
      } else
        Oe = Q(G, ae, Wt, W - X, v - W);
    }
    P.push(Oe), z.push(ft);
  }
  function f(y) {
    return (w, P, z) => {
      let A = 0, C = w.length - 1, X, W;
      if (C >= 0 && (X = w[C]) instanceof E) {
        if (!C && X.type == y && X.length == z)
          return X;
        (W = X.prop(_.lookAhead)) && (A = P[C] + X.length + W);
      }
      return Q(y, w, P, z, A);
    };
  }
  function d(y, w, P, z, A, C, X, W) {
    let R = [], v = [];
    for (; y.length > z; )
      R.push(y.pop()), v.push(w.pop() + P - A);
    y.push(Q(i.types[X], R, v, C - A, W - C)), w.push(A - P);
  }
  function Q(y, w, P, z, A = 0, C) {
    if (l) {
      let X = [_.contextHash, l];
      C = C ? [X].concat(C) : [X];
    }
    if (A > 25) {
      let X = [_.lookAhead, A];
      C = C ? [X].concat(C) : [X];
    }
    return new E(y, w, P, z, C);
  }
  function $(y, w) {
    let P = o.fork(), z = 0, A = 0, C = 0, X = P.end - n, W = { size: 0, start: 0, skip: 0 };
    e:
      for (let R = P.pos - y; P.pos > R; ) {
        let v = P.size;
        if (P.id == w && v >= 0) {
          W.size = z, W.start = A, W.skip = C, C += 4, z += 4, P.next();
          continue;
        }
        let G = P.pos - v;
        if (v < 0 || G < R || P.start < X)
          break;
        let Oe = P.id >= s ? 4 : 0, oe = P.start;
        for (P.next(); P.pos > G; ) {
          if (P.size < 0)
            if (P.size == -3)
              Oe += 4;
            else
              break e;
          else
            P.id >= s && (Oe += 4);
          P.next();
        }
        A = oe, z += v, C += Oe;
      }
    return (w < 0 || z == y) && (W.size = z, W.start = A, W.skip = C), W.size > 4 ? W : void 0;
  }
  function p(y, w, P) {
    let { id: z, start: A, end: C, size: X } = o;
    if (o.next(), X >= 0 && z < s) {
      let W = P;
      if (X > 4) {
        let R = o.pos - (X - 4);
        for (; o.pos > R; )
          P = p(y, w, P);
      }
      w[--P] = W, w[--P] = C - y, w[--P] = A - y, w[--P] = z;
    } else
      X == -3 ? l = z : X == -4 && (h2 = z);
    return P;
  }
  let m = [], g = [];
  for (; o.pos > 0; )
    u(O.start || 0, O.bufferStart || 0, m, g, -1);
  let b = (e = O.length) !== null && e !== void 0 ? e : m.length ? g[0] + m[0].length : 0;
  return new E(a[O.topID], m.reverse(), g.reverse(), b);
}
var Rh = /* @__PURE__ */ new WeakMap();
function cr(O, e) {
  if (!O.isAnonymous || e instanceof WO || e.type != O)
    return 1;
  let t = Rh.get(e);
  if (t == null) {
    t = 1;
    for (let i of e.children) {
      if (i.type != O || !(i instanceof E)) {
        t = 1;
        break;
      }
      t += cr(O, i);
    }
    Rh.set(e, t);
  }
  return t;
}
function Xl(O, e, t, i, n, r, s, o, a) {
  let l = 0;
  for (let Q = i; Q < n; Q++)
    l += cr(O, e[Q]);
  let h2 = Math.ceil(
    l * 1.5 / 8
    /* Balance.BranchFactor */
  ), u = [], f = [];
  function d(Q, $, p, m, g) {
    for (let b = p; b < m; ) {
      let y = b, w = $[b], P = cr(O, Q[b]);
      for (b++; b < m; b++) {
        let z = cr(O, Q[b]);
        if (P + z >= h2)
          break;
        P += z;
      }
      if (b == y + 1) {
        if (P > h2) {
          let z = Q[y];
          d(z.children, z.positions, 0, z.children.length, $[y] + g);
          continue;
        }
        u.push(Q[y]);
      } else {
        let z = $[b - 1] + Q[b - 1].length - w;
        u.push(Xl(O, Q, $, y, b, w, z, null, a));
      }
      f.push(w + g - r);
    }
  }
  return d(e, t, i, n, 0), (o || a)(u, f, s);
}
var e$ = class {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, t, i) {
    let n = this.map.get(e);
    n || this.map.set(e, n = /* @__PURE__ */ new Map()), n.set(t, i);
  }
  getBuffer(e, t) {
    let i = this.map.get(e);
    return i && i.get(t);
  }
  /// Set the value for this syntax node.
  set(e, t) {
    e instanceof gt ? this.setBuffer(e.context.buffer, e.index, t) : e instanceof et && this.map.set(e.tree, t);
  }
  /// Retrieve value for this syntax node, if it exists in the map.
  get(e) {
    return e instanceof gt ? this.getBuffer(e.context.buffer, e.index) : e instanceof et ? this.map.get(e.tree) : void 0;
  }
  /// Set the value for the node that a cursor currently points to.
  cursorSet(e, t) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, t) : this.map.set(e.tree, t);
  }
  /// Retrieve the value for the node that a cursor currently points
  /// to.
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
};
var qt = class {
  /// Construct a tree fragment. You'll usually want to use
  /// [`addTree`](#common.TreeFragment^addTree) and
  /// [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  /// calling this directly.
  constructor(e, t, i, n, r = false, s = false) {
    this.from = e, this.to = t, this.tree = i, this.offset = n, this.open = (r ? 1 : 0) | (s ? 2 : 0);
  }
  /// Whether the start of the fragment represents the start of a
  /// parse, or the end of a change. (In the second case, it may not
  /// be safe to reuse some nodes at the start, depending on the
  /// parsing algorithm.)
  get openStart() {
    return (this.open & 1) > 0;
  }
  /// Whether the end of the fragment represents the end of a
  /// full-document parse, or the start of a change.
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /// Create a set of fragments from a freshly parsed tree, or update
  /// an existing set of fragments by replacing the ones that overlap
  /// with a tree with content from the new tree. When `partial` is
  /// true, the parse is treated as incomplete, and the resulting
  /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  /// true.
  static addTree(e, t = [], i = false) {
    let n = [new qt(0, e.length, e, 0, false, i)];
    for (let r of t)
      r.to > e.length && n.push(r);
    return n;
  }
  /// Apply a set of edits to an array of fragments, removing or
  /// splitting fragments as necessary to remove edited ranges, and
  /// adjusting offsets for fragments that moved.
  static applyChanges(e, t, i = 128) {
    if (!t.length)
      return e;
    let n = [], r = 1, s = e.length ? e[0] : null;
    for (let o = 0, a = 0, l = 0; ; o++) {
      let h2 = o < t.length ? t[o] : null, u = h2 ? h2.fromA : 1e9;
      if (u - a >= i)
        for (; s && s.from < u; ) {
          let f = s;
          if (a >= f.from || u <= f.to || l) {
            let d = Math.max(f.from, a) - l, Q = Math.min(f.to, u) - l;
            f = d >= Q ? null : new qt(d, Q, f.tree, f.offset + l, o > 0, !!h2);
          }
          if (f && n.push(f), s.to > u)
            break;
          s = r < e.length ? e[r++] : null;
        }
      if (!h2)
        break;
      a = h2.toA, l = h2.toA - h2.toB;
    }
    return n;
  }
};
var ls = class {
  /// Start a parse, returning a [partial parse](#common.PartialParse)
  /// object. [`fragments`](#common.TreeFragment) can be passed in to
  /// make the parse incremental.
  ///
  /// By default, the entire input is parsed. You can pass `ranges`,
  /// which should be a sorted array of non-empty, non-overlapping
  /// ranges, to parse only those ranges. The tree returned in that
  /// case will start at `ranges[0].from`.
  startParse(e, t, i) {
    return typeof e == "string" && (e = new DX(e)), i = i ? i.length ? i.map((n) => new Ke(n.from, n.to)) : [new Ke(0, 0)] : [new Ke(0, e.length)], this.createParse(e, t || [], i);
  }
  /// Run a full parse, returning the resulting tree.
  parse(e, t, i) {
    let n = this.startParse(e, t, i);
    for (; ; ) {
      let r = n.advance();
      if (r)
        return r;
    }
  }
};
var DX = class {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return false;
  }
  read(e, t) {
    return this.string.slice(e, t);
  }
};
function xl(O) {
  return (e, t, i, n) => new LX(e, O, t, i, n);
}
var _h = class {
  constructor(e, t, i, n, r) {
    this.parser = e, this.parse = t, this.overlay = i, this.target = n, this.ranges = r;
  }
};
var MX = class {
  constructor(e, t, i, n, r, s, o) {
    this.parser = e, this.predicate = t, this.mounts = i, this.index = n, this.start = r, this.target = s, this.prev = o, this.depth = 0, this.ranges = [];
  }
};
var Sa = new _({ perNode: true });
var LX = class {
  constructor(e, t, i, n, r) {
    this.nest = t, this.input = i, this.fragments = n, this.ranges = r, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let i = this.baseParse.advance();
      if (!i)
        return null;
      if (this.baseParse = null, this.baseTree = i, this.startInner(), this.stoppedAt != null)
        for (let n of this.inner)
          n.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let i = this.baseTree;
      return this.stoppedAt != null && (i = new E(i.type, i.children, i.positions, i.length, i.propValues.concat([[Sa, this.stoppedAt]]))), i;
    }
    let e = this.inner[this.innerDone], t = e.parse.advance();
    if (t) {
      this.innerDone++;
      let i = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      i[_.mounted.id] = new GX(t, e.overlay, e.parser), e.target.props = i;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let t = this.innerDone; t < this.inner.length; t++)
      this.inner[t].ranges[0].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let t = this.innerDone; t < this.inner.length; t++)
        this.inner[t].parse.stopAt(e);
  }
  startInner() {
    let e = new FX(this.fragments), t = null, i = null, n = new Ni(new et(this.baseTree, this.ranges[0].from, 0, null), K.IncludeAnonymous | K.IgnoreMounts);
    e:
      for (let r, s; this.stoppedAt == null || n.from < this.stoppedAt; ) {
        let o = true, a;
        if (e.hasNode(n)) {
          if (t) {
            let l = t.mounts.find((h2) => h2.frag.from <= n.from && h2.frag.to >= n.to && h2.mount.overlay);
            if (l)
              for (let h2 of l.mount.overlay) {
                let u = h2.from + l.pos, f = h2.to + l.pos;
                u >= n.from && f <= n.to && !t.ranges.some((d) => d.from < f && d.to > u) && t.ranges.push({ from: u, to: f });
              }
          }
          o = false;
        } else if (i && (s = BX(i.ranges, n.from, n.to)))
          o = s != 2;
        else if (!n.type.isAnonymous && n.from < n.to && (r = this.nest(n, this.input))) {
          n.tree || NX(n);
          let l = e.findMounts(n.from, r.parser);
          if (typeof r.overlay == "function")
            t = new MX(r.parser, r.overlay, l, this.inner.length, n.from, n.tree, t);
          else {
            let h2 = Gh(this.ranges, r.overlay || [new Ke(n.from, n.to)]);
            h2.length && this.inner.push(new _h(r.parser, r.parser.startParse(this.input, Ih(l, h2), h2), r.overlay ? r.overlay.map((u) => new Ke(u.from - n.from, u.to - n.from)) : null, n.tree, h2)), r.overlay ? h2.length && (i = { ranges: h2, depth: 0, prev: i }) : o = false;
          }
        } else
          t && (a = t.predicate(n)) && (a === true && (a = new Ke(n.from, n.to)), a.from < a.to && t.ranges.push(a));
        if (o && n.firstChild())
          t && t.depth++, i && i.depth++;
        else
          for (; !n.nextSibling(); ) {
            if (!n.parent())
              break e;
            if (t && !--t.depth) {
              let l = Gh(this.ranges, t.ranges);
              l.length && this.inner.splice(t.index, 0, new _h(t.parser, t.parser.startParse(this.input, Ih(t.mounts, l), l), t.ranges.map((h2) => new Ke(h2.from - t.start, h2.to - t.start)), t.target, l)), t = t.prev;
            }
            i && !--i.depth && (i = i.prev);
          }
      }
  }
};
function BX(O, e, t) {
  for (let i of O) {
    if (i.from >= t)
      break;
    if (i.to > e)
      return i.from <= e && i.to >= t ? 2 : 1;
  }
  return 0;
}
function jh(O, e, t, i, n, r) {
  if (e < t) {
    let s = O.buffer[e + 1];
    i.push(O.slice(e, t, s)), n.push(s - r);
  }
}
function NX(O) {
  let { node: e } = O, t = 0;
  do
    O.parent(), t++;
  while (!O.tree);
  let i = 0, n = O.tree, r = 0;
  for (; r = n.positions[i] + O.from, !(r <= e.from && r + n.children[i].length >= e.to); i++)
    ;
  let s = n.children[i], o = s.buffer;
  function a(l, h2, u, f, d) {
    let Q = l;
    for (; o[Q + 2] + r <= e.from; )
      Q = o[Q + 3];
    let $ = [], p = [];
    jh(s, l, Q, $, p, f);
    let m = o[Q + 1], g = o[Q + 2], b = m + r == e.from && g + r == e.to && o[Q] == e.type.id;
    return $.push(b ? e.toTree() : a(Q + 4, o[Q + 3], s.set.types[o[Q]], m, g - m)), p.push(m - f), jh(s, o[Q + 3], h2, $, p, f), new E(u, $, p, d);
  }
  n.children[i] = a(0, o.length, ue.none, 0, s.length);
  for (let l = 0; l <= t; l++)
    O.childAfter(e.from);
}
var Ch = class {
  constructor(e, t) {
    this.offset = t, this.done = false, this.cursor = e.cursor(K.IncludeAnonymous | K.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: t } = this, i = e - this.offset;
    for (; !this.done && t.from < i; )
      t.to >= e && t.enter(i, 1, K.IgnoreOverlays | K.ExcludeBuffers) || t.next(false) || (this.done = true);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let t = this.cursor.tree; ; ) {
        if (t == e.tree)
          return true;
        if (t.children.length && t.positions[0] == 0 && t.children[0] instanceof E)
          t = t.children[0];
        else
          break;
      }
    return false;
  }
};
var FX = class {
  constructor(e) {
    var t;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let i = this.curFrag = e[0];
      this.curTo = (t = i.tree.prop(Sa)) !== null && t !== void 0 ? t : i.to, this.inner = new Ch(i.tree, -i.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let t = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = t.tree.prop(Sa)) !== null && e !== void 0 ? e : t.to, this.inner = new Ch(t.tree, -t.offset);
    }
  }
  findMounts(e, t) {
    var i;
    let n = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let r = this.inner.cursor.node; r; r = r.parent) {
        let s = (i = r.tree) === null || i === void 0 ? void 0 : i.prop(_.mounted);
        if (s && s.parser == t)
          for (let o = this.fragI; o < this.fragments.length; o++) {
            let a = this.fragments[o];
            if (a.from >= r.to)
              break;
            a.tree == this.curFrag.tree && n.push({
              frag: a,
              pos: r.from - a.offset,
              mount: s
            });
          }
      }
    }
    return n;
  }
};
function Gh(O, e) {
  let t = null, i = e;
  for (let n = 1, r = 0; n < O.length; n++) {
    let s = O[n - 1].to, o = O[n].from;
    for (; r < i.length; r++) {
      let a = i[r];
      if (a.from >= o)
        break;
      a.to <= s || (t || (i = t = e.slice()), a.from < s ? (t[r] = new Ke(a.from, s), a.to > o && t.splice(r + 1, 0, new Ke(o, a.to))) : a.to > o ? t[r--] = new Ke(o, a.to) : t.splice(r--, 1));
    }
  }
  return i;
}
function HX(O, e, t, i) {
  let n = 0, r = 0, s = false, o = false, a = -1e9, l = [];
  for (; ; ) {
    let h2 = n == O.length ? 1e9 : s ? O[n].to : O[n].from, u = r == e.length ? 1e9 : o ? e[r].to : e[r].from;
    if (s != o) {
      let f = Math.max(a, t), d = Math.min(h2, u, i);
      f < d && l.push(new Ke(f, d));
    }
    if (a = Math.min(h2, u), a == 1e9)
      break;
    h2 == a && (s ? (s = false, n++) : s = true), u == a && (o ? (o = false, r++) : o = true);
  }
  return l;
}
function Ih(O, e) {
  let t = [];
  for (let { pos: i, mount: n, frag: r } of O) {
    let s = i + (n.overlay ? n.overlay[0].from : 0), o = s + n.tree.length, a = Math.max(r.from, s), l = Math.min(r.to, o);
    if (n.overlay) {
      let h2 = n.overlay.map((f) => new Ke(f.from + i, f.to + i)), u = HX(e, h2, a, l);
      for (let f = 0, d = a; ; f++) {
        let Q = f == u.length, $ = Q ? l : u[f].from;
        if ($ > d && t.push(new qt(d, $, n.tree, -s, r.from >= d || r.openStart, r.to <= $ || r.openEnd)), Q)
          break;
        d = u[f].to;
      }
    } else
      t.push(new qt(a, l, n.tree, -s, r.from >= s || r.openStart, r.to <= o || r.openEnd));
  }
  return t;
}
var KX = 0;
var at = class {
  /// @internal
  constructor(e, t, i) {
    this.set = e, this.base = t, this.modified = i, this.id = KX++;
  }
  /// Define a new tag. If `parent` is given, the tag is treated as a
  /// sub-tag of that parent, and
  /// [highlighters](#highlight.tagHighlighter) that don't mention
  /// this tag will try to fall back to the parent tag (or grandparent
  /// tag, etc).
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let t = new at([], null, []);
    if (t.set.push(t), e)
      for (let i of e.set)
        t.set.push(i);
    return t;
  }
  /// Define a tag _modifier_, which is a function that, given a tag,
  /// will return a tag that is a subtag of the original. Applying the
  /// same modifier to a twice tag will return the same value (`m1(t1)
  /// == m1(t1)`) and applying multiple modifiers will, regardless or
  /// order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  ///
  /// When multiple modifiers are applied to a given base tag, each
  /// smaller set of modifiers is registered as a parent, so that for
  /// example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  /// `m1(m3(t1)`, and so on.
  static defineModifier() {
    let e = new qr();
    return (t) => t.modified.indexOf(e) > -1 ? t : qr.get(t.base || t, t.modified.concat(e).sort((i, n) => i.id - n.id));
  }
};
var JX = 0;
var qr = class {
  constructor() {
    this.instances = [], this.id = JX++;
  }
  static get(e, t) {
    if (!t.length)
      return e;
    let i = t[0].instances.find((o) => o.base == e && ex(t, o.modified));
    if (i)
      return i;
    let n = [], r = new at(n, e, t);
    for (let o of t)
      o.instances.push(r);
    let s = tx(t);
    for (let o of e.set)
      if (!o.modified.length)
        for (let a of s)
          n.push(qr.get(o, a));
    return r;
  }
};
function ex(O, e) {
  return O.length == e.length && O.every((t, i) => t == e[i]);
}
function tx(O) {
  let e = [[]];
  for (let t = 0; t < O.length; t++)
    for (let i = 0, n = e.length; i < n; i++)
      e.push(e[i].concat(O[t]));
  return e.sort((t, i) => i.length - t.length);
}
function ze(O) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in O) {
    let i = O[t];
    Array.isArray(i) || (i = [i]);
    for (let n of t.split(" "))
      if (n) {
        let r = [], s = 2, o = n;
        for (let u = 0; ; ) {
          if (o == "..." && u > 0 && u + 3 == n.length) {
            s = 1;
            break;
          }
          let f = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(o);
          if (!f)
            throw new RangeError("Invalid path: " + n);
          if (r.push(f[0] == "*" ? "" : f[0][0] == '"' ? JSON.parse(f[0]) : f[0]), u += f[0].length, u == n.length)
            break;
          let d = n[u++];
          if (u == n.length && d == "!") {
            s = 0;
            break;
          }
          if (d != "/")
            throw new RangeError("Invalid path: " + n);
          o = n.slice(u);
        }
        let a = r.length - 1, l = r[a];
        if (!l)
          throw new RangeError("Invalid path: " + n);
        let h2 = new zr(i, s, a > 0 ? r.slice(0, a) : null);
        e[l] = h2.sort(e[l]);
      }
  }
  return t$.add(e);
}
var t$ = new _();
var zr = class {
  constructor(e, t, i, n) {
    this.tags = e, this.mode = t, this.context = i, this.next = n;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
zr.empty = new zr([], 2, null);
function O$(O, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let r of O)
    if (!Array.isArray(r.tag))
      t[r.tag.id] = r.class;
    else
      for (let s of r.tag)
        t[s.id] = r.class;
  let { scope: i, all: n = null } = e || {};
  return {
    style: (r) => {
      let s = n;
      for (let o of r)
        for (let a of o.set) {
          let l = t[a.id];
          if (l) {
            s = s ? s + " " + l : l;
            break;
          }
        }
      return s;
    },
    scope: i
  };
}
function Ox(O, e) {
  let t = null;
  for (let i of O) {
    let n = i.style(e);
    n && (t = t ? t + " " + n : n);
  }
  return t;
}
function ix(O, e, t, i = 0, n = O.length) {
  let r = new nx(i, Array.isArray(e) ? e : [e], t);
  r.highlightRange(O.cursor(), i, n, "", r.highlighters), r.flush(n);
}
var nx = class {
  constructor(e, t, i) {
    this.at = e, this.highlighters = t, this.span = i, this.class = "";
  }
  startSpan(e, t) {
    t != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = t);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, t, i, n, r) {
    let { type: s, from: o, to: a } = e;
    if (o >= i || a <= t)
      return;
    s.isTop && (r = this.highlighters.filter((d) => !d.scope || d.scope(s)));
    let l = n, h2 = rx(e) || zr.empty, u = Ox(r, h2.tags);
    if (u && (l && (l += " "), l += u, h2.mode == 1 && (n += (n ? " " : "") + u)), this.startSpan(e.from, l), h2.opaque)
      return;
    let f = e.tree && e.tree.prop(_.mounted);
    if (f && f.overlay) {
      let d = e.node.enter(f.overlay[0].from + o, 1), Q = this.highlighters.filter((p) => !p.scope || p.scope(f.tree.type)), $ = e.firstChild();
      for (let p = 0, m = o; ; p++) {
        let g = p < f.overlay.length ? f.overlay[p] : null, b = g ? g.from + o : a, y = Math.max(t, m), w = Math.min(i, b);
        if (y < w && $)
          for (; e.from < w && (this.highlightRange(e, y, w, n, r), this.startSpan(Math.min(w, e.to), l), !(e.to >= b || !e.nextSibling())); )
            ;
        if (!g || b > i)
          break;
        m = g.to + o, m > t && (this.highlightRange(d.cursor(), Math.max(t, g.from + o), Math.min(i, m), n, Q), this.startSpan(m, l));
      }
      $ && e.parent();
    } else if (e.firstChild()) {
      do
        if (!(e.to <= t)) {
          if (e.from >= i)
            break;
          this.highlightRange(e, t, i, n, r), this.startSpan(Math.min(i, e.to), l);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
};
function rx(O) {
  let e = O.type.prop(t$);
  for (; e && e.context && !O.matchContext(e.context); )
    e = e.next;
  return e || null;
}
var T = at.define;
var Vn = T();
var Gt = T();
var Eh = T(Gt);
var Ah = T(Gt);
var It = T();
var Rn = T(It);
var Ls = T(It);
var pt = T();
var cO = T(pt);
var Qt = T();
var $t = T();
var Pa = T();
var ui = T(Pa);
var _n = T();
var c = {
  /// A comment.
  comment: Vn,
  /// A line [comment](#highlight.tags.comment).
  lineComment: T(Vn),
  /// A block [comment](#highlight.tags.comment).
  blockComment: T(Vn),
  /// A documentation [comment](#highlight.tags.comment).
  docComment: T(Vn),
  /// Any kind of identifier.
  name: Gt,
  /// The [name](#highlight.tags.name) of a variable.
  variableName: T(Gt),
  /// A type [name](#highlight.tags.name).
  typeName: Eh,
  /// A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  tagName: T(Eh),
  /// A property or field [name](#highlight.tags.name).
  propertyName: Ah,
  /// An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  attributeName: T(Ah),
  /// The [name](#highlight.tags.name) of a class.
  className: T(Gt),
  /// A label [name](#highlight.tags.name).
  labelName: T(Gt),
  /// A namespace [name](#highlight.tags.name).
  namespace: T(Gt),
  /// The [name](#highlight.tags.name) of a macro.
  macroName: T(Gt),
  /// A literal value.
  literal: It,
  /// A string [literal](#highlight.tags.literal).
  string: Rn,
  /// A documentation [string](#highlight.tags.string).
  docString: T(Rn),
  /// A character literal (subtag of [string](#highlight.tags.string)).
  character: T(Rn),
  /// An attribute value (subtag of [string](#highlight.tags.string)).
  attributeValue: T(Rn),
  /// A number [literal](#highlight.tags.literal).
  number: Ls,
  /// An integer [number](#highlight.tags.number) literal.
  integer: T(Ls),
  /// A floating-point [number](#highlight.tags.number) literal.
  float: T(Ls),
  /// A boolean [literal](#highlight.tags.literal).
  bool: T(It),
  /// Regular expression [literal](#highlight.tags.literal).
  regexp: T(It),
  /// An escape [literal](#highlight.tags.literal), for example a
  /// backslash escape in a string.
  escape: T(It),
  /// A color [literal](#highlight.tags.literal).
  color: T(It),
  /// A URL [literal](#highlight.tags.literal).
  url: T(It),
  /// A language keyword.
  keyword: Qt,
  /// The [keyword](#highlight.tags.keyword) for the self or this
  /// object.
  self: T(Qt),
  /// The [keyword](#highlight.tags.keyword) for null.
  null: T(Qt),
  /// A [keyword](#highlight.tags.keyword) denoting some atomic value.
  atom: T(Qt),
  /// A [keyword](#highlight.tags.keyword) that represents a unit.
  unit: T(Qt),
  /// A modifier [keyword](#highlight.tags.keyword).
  modifier: T(Qt),
  /// A [keyword](#highlight.tags.keyword) that acts as an operator.
  operatorKeyword: T(Qt),
  /// A control-flow related [keyword](#highlight.tags.keyword).
  controlKeyword: T(Qt),
  /// A [keyword](#highlight.tags.keyword) that defines something.
  definitionKeyword: T(Qt),
  /// A [keyword](#highlight.tags.keyword) related to defining or
  /// interfacing with modules.
  moduleKeyword: T(Qt),
  /// An operator.
  operator: $t,
  /// An [operator](#highlight.tags.operator) that dereferences something.
  derefOperator: T($t),
  /// Arithmetic-related [operator](#highlight.tags.operator).
  arithmeticOperator: T($t),
  /// Logical [operator](#highlight.tags.operator).
  logicOperator: T($t),
  /// Bit [operator](#highlight.tags.operator).
  bitwiseOperator: T($t),
  /// Comparison [operator](#highlight.tags.operator).
  compareOperator: T($t),
  /// [Operator](#highlight.tags.operator) that updates its operand.
  updateOperator: T($t),
  /// [Operator](#highlight.tags.operator) that defines something.
  definitionOperator: T($t),
  /// Type-related [operator](#highlight.tags.operator).
  typeOperator: T($t),
  /// Control-flow [operator](#highlight.tags.operator).
  controlOperator: T($t),
  /// Program or markup punctuation.
  punctuation: Pa,
  /// [Punctuation](#highlight.tags.punctuation) that separates
  /// things.
  separator: T(Pa),
  /// Bracket-style [punctuation](#highlight.tags.punctuation).
  bracket: ui,
  /// Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  /// tokens).
  angleBracket: T(ui),
  /// Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  /// tokens).
  squareBracket: T(ui),
  /// Parentheses (usually `(` and `)` tokens). Subtag of
  /// [bracket](#highlight.tags.bracket).
  paren: T(ui),
  /// Braces (usually `{` and `}` tokens). Subtag of
  /// [bracket](#highlight.tags.bracket).
  brace: T(ui),
  /// Content, for example plain text in XML or markup documents.
  content: pt,
  /// [Content](#highlight.tags.content) that represents a heading.
  heading: cO,
  /// A level 1 [heading](#highlight.tags.heading).
  heading1: T(cO),
  /// A level 2 [heading](#highlight.tags.heading).
  heading2: T(cO),
  /// A level 3 [heading](#highlight.tags.heading).
  heading3: T(cO),
  /// A level 4 [heading](#highlight.tags.heading).
  heading4: T(cO),
  /// A level 5 [heading](#highlight.tags.heading).
  heading5: T(cO),
  /// A level 6 [heading](#highlight.tags.heading).
  heading6: T(cO),
  /// A prose separator (such as a horizontal rule).
  contentSeparator: T(pt),
  /// [Content](#highlight.tags.content) that represents a list.
  list: T(pt),
  /// [Content](#highlight.tags.content) that represents a quote.
  quote: T(pt),
  /// [Content](#highlight.tags.content) that is emphasized.
  emphasis: T(pt),
  /// [Content](#highlight.tags.content) that is styled strong.
  strong: T(pt),
  /// [Content](#highlight.tags.content) that is part of a link.
  link: T(pt),
  /// [Content](#highlight.tags.content) that is styled as code or
  /// monospace.
  monospace: T(pt),
  /// [Content](#highlight.tags.content) that has a strike-through
  /// style.
  strikethrough: T(pt),
  /// Inserted text in a change-tracking format.
  inserted: T(),
  /// Deleted text.
  deleted: T(),
  /// Changed text.
  changed: T(),
  /// An invalid or unsyntactic element.
  invalid: T(),
  /// Metadata or meta-instruction.
  meta: _n,
  /// [Metadata](#highlight.tags.meta) that applies to the entire
  /// document.
  documentMeta: T(_n),
  /// [Metadata](#highlight.tags.meta) that annotates or adds
  /// attributes to a given syntactic element.
  annotation: T(_n),
  /// Processing instruction or preprocessor directive. Subtag of
  /// [meta](#highlight.tags.meta).
  processingInstruction: T(_n),
  /// [Modifier](#highlight.Tag^defineModifier) that indicates that a
  /// given element is being defined. Expected to be used with the
  /// various [name](#highlight.tags.name) tags.
  definition: at.defineModifier(),
  /// [Modifier](#highlight.Tag^defineModifier) that indicates that
  /// something is constant. Mostly expected to be used with
  /// [variable names](#highlight.tags.variableName).
  constant: at.defineModifier(),
  /// [Modifier](#highlight.Tag^defineModifier) used to indicate that
  /// a [variable](#highlight.tags.variableName) or [property
  /// name](#highlight.tags.propertyName) is being called or defined
  /// as a function.
  function: at.defineModifier(),
  /// [Modifier](#highlight.Tag^defineModifier) that can be applied to
  /// [names](#highlight.tags.name) to indicate that they belong to
  /// the language's standard environment.
  standard: at.defineModifier(),
  /// [Modifier](#highlight.Tag^defineModifier) that indicates a given
  /// [names](#highlight.tags.name) is local to some scope.
  local: at.defineModifier(),
  /// A generic variant [modifier](#highlight.Tag^defineModifier) that
  /// can be used to tag language-specific alternative variants of
  /// some common tag. It is recommended for themes to define special
  /// forms of at least the [string](#highlight.tags.string) and
  /// [variable name](#highlight.tags.variableName) tags, since those
  /// come up a lot.
  special: at.defineModifier()
};
O$([
  { tag: c.link, class: "tok-link" },
  { tag: c.heading, class: "tok-heading" },
  { tag: c.emphasis, class: "tok-emphasis" },
  { tag: c.strong, class: "tok-strong" },
  { tag: c.keyword, class: "tok-keyword" },
  { tag: c.atom, class: "tok-atom" },
  { tag: c.bool, class: "tok-bool" },
  { tag: c.url, class: "tok-url" },
  { tag: c.labelName, class: "tok-labelName" },
  { tag: c.inserted, class: "tok-inserted" },
  { tag: c.deleted, class: "tok-deleted" },
  { tag: c.literal, class: "tok-literal" },
  { tag: c.string, class: "tok-string" },
  { tag: c.number, class: "tok-number" },
  { tag: [c.regexp, c.escape, c.special(c.string)], class: "tok-string2" },
  { tag: c.variableName, class: "tok-variableName" },
  { tag: c.local(c.variableName), class: "tok-variableName tok-local" },
  { tag: c.definition(c.variableName), class: "tok-variableName tok-definition" },
  { tag: c.special(c.variableName), class: "tok-variableName2" },
  { tag: c.definition(c.propertyName), class: "tok-propertyName tok-definition" },
  { tag: c.typeName, class: "tok-typeName" },
  { tag: c.namespace, class: "tok-namespace" },
  { tag: c.className, class: "tok-className" },
  { tag: c.macroName, class: "tok-macroName" },
  { tag: c.propertyName, class: "tok-propertyName" },
  { tag: c.operator, class: "tok-operator" },
  { tag: c.comment, class: "tok-comment" },
  { tag: c.meta, class: "tok-meta" },
  { tag: c.invalid, class: "tok-invalid" },
  { tag: c.punctuation, class: "tok-punctuation" }
]);
var Bs;
var XO = new _();
function bl(O) {
  return q.define({
    combine: O ? (e) => e.concat(O) : void 0
  });
}
var Le = class {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, t, i = [], n = "") {
    this.data = e, this.name = n, I.prototype.hasOwnProperty("tree") || Object.defineProperty(I.prototype, "tree", { get() {
      return B(this);
    } }), this.parser = t, this.extension = [
      nO.of(this),
      I.languageData.of((r, s, o) => r.facet(Dh(r, s, o)))
    ].concat(i);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, t, i = -1) {
    return Dh(e, t, i) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let t = e.facet(nO);
    if ((t == null ? void 0 : t.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let i = [], n = (r, s) => {
      if (r.prop(XO) == this.data) {
        i.push({ from: s, to: s + r.length });
        return;
      }
      let o = r.prop(_.mounted);
      if (o) {
        if (o.tree.prop(XO) == this.data) {
          if (o.overlay)
            for (let a of o.overlay)
              i.push({ from: a.from + s, to: a.to + s });
          else
            i.push({ from: s, to: s + r.length });
          return;
        } else if (o.overlay) {
          let a = i.length;
          if (n(o.tree, o.overlay[0].from + s), i.length > a)
            return;
        }
      }
      for (let a = 0; a < r.children.length; a++) {
        let l = r.children[a];
        l instanceof E && n(l, r.positions[a] + s);
      }
    };
    return n(B(e), 0), i;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return true;
  }
};
Le.setState = j.define();
function Dh(O, e, t) {
  let i = O.facet(nO);
  if (!i)
    return null;
  let n = i.data;
  if (i.allowsNesting)
    for (let r = B(O).topNode; r; r = r.enter(e, t, K.ExcludeBuffers))
      n = r.type.prop(XO) || n;
  return n;
}
var Ze = class extends Le {
  constructor(e, t, i) {
    super(e, t, [], i), this.parser = t;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let t = bl(e.languageData);
    return new Ze(t, e.parser.configure({
      props: [XO.add((i) => i.isTop ? t : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, t) {
    return new Ze(this.data, this.parser.configure(e), t || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
};
function B(O) {
  let e = O.field(Le.state, false);
  return e ? e.tree : E.empty;
}
var sx = class {
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return true;
  }
  read(e, t) {
    let i = this.cursorPos - this.string.length;
    return e < i || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - i, t - i);
  }
};
var fi = null;
var xO = class {
  constructor(e, t, i = [], n, r, s, o, a) {
    this.parser = e, this.state = t, this.fragments = i, this.tree = n, this.treeLen = r, this.viewport = s, this.skipped = o, this.scheduleOn = a, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new xO(e, t, [], E.empty, 0, i, [], null);
  }
  startParse() {
    return this.parser.startParse(new sx(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != E.empty && this.isDone(t ?? this.state.doc.length) ? (this.takeTree(), true) : this.withContext(() => {
      var i;
      if (typeof e == "number") {
        let n = Date.now() + e;
        e = () => Date.now() > n;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let n = this.parse.advance();
        if (n)
          if (this.fragments = this.withoutTempSkipped(qt.addTree(n, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = n, this.parse = null, this.treeLen < (t ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return true;
        if (e())
          return false;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped(qt.addTree(this.tree, this.fragments, true)), this.parse = null);
  }
  withContext(e) {
    let t = fi;
    fi = this;
    try {
      return e();
    } finally {
      fi = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = Mh(e, t.from, t.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, t) {
    let { fragments: i, tree: n, treeLen: r, viewport: s, skipped: o } = this;
    if (this.takeTree(), !e.empty) {
      let a = [];
      if (e.iterChangedRanges((l, h2, u, f) => a.push({ fromA: l, toA: h2, fromB: u, toB: f })), i = qt.applyChanges(i, a), n = E.empty, r = 0, s = { from: e.mapPos(s.from, -1), to: e.mapPos(s.to, 1) }, this.skipped.length) {
        o = [];
        for (let l of this.skipped) {
          let h2 = e.mapPos(l.from, 1), u = e.mapPos(l.to, -1);
          h2 < u && o.push({ from: h2, to: u });
        }
      }
    }
    return new xO(this.parser, t, i, n, r, s, o, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return false;
    this.viewport = e;
    let t = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: n, to: r } = this.skipped[i];
      n < e.to && r > e.from && (this.fragments = Mh(this.fragments, n, r), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= t ? false : (this.reset(), true);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends ls {
      createParse(t, i, n) {
        let r = n[0].from, s = n[n.length - 1].to;
        return {
          parsedPos: r,
          advance() {
            let a = fi;
            if (a) {
              for (let l of n)
                a.tempSkipped.push(l);
              e && (a.scheduleOn = a.scheduleOn ? Promise.all([a.scheduleOn, e]) : e);
            }
            return this.parsedPos = s, new E(ue.none, [], [], s - r);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return fi;
  }
};
function Mh(O, e, t) {
  return qt.applyChanges(O, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
var FO = class {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), i = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, i) || t.takeTree(), new FO(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), i = xO.create(e.facet(nO).parser, e, { from: 0, to: t });
    return i.work(20, t) || i.takeTree(), new FO(i);
  }
};
Le.state = me.define({
  create: FO.init,
  update(O, e) {
    for (let t of e.effects)
      if (t.is(Le.setState))
        return t.value;
    return e.startState.facet(nO) != e.state.facet(nO) ? FO.init(e.state) : O.apply(e);
  }
});
var i$ = (O) => {
  let e = setTimeout(
    () => O(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (i$ = (O) => {
  let e = -1, t = setTimeout(
    () => {
      e = requestIdleCallback(O, {
        timeout: 500 - 100
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
var Ns = typeof navigator < "u" && (!((Bs = navigator.scheduling) === null || Bs === void 0) && Bs.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
var ox = se.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field(Le.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), e.docChanged && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field(Le.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = i$(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: n } } = this.view, r = i.field(Le.state);
    if (r.tree == r.context.tree && r.context.isDone(
      n + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let s = Date.now() + Math.min(this.chunkBudget, 100, e && !Ns ? Math.max(25, e.timeRemaining() - 5) : 1e9), o = r.context.treeLen < n && i.doc.length > n + 1e3, a = r.context.work(() => Ns && Ns() || Date.now() > s, n + (o ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (a || this.chunkBudget <= 0) && (r.context.takeTree(), this.view.dispatch({ effects: Le.setState.of(new FO(r.context)) })), this.chunkBudget > 0 && !(a && !o) && this.scheduleWork(), this.checkAsyncSchedule(r.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => Ne(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
});
var nO = q.define({
  combine(O) {
    return O.length ? O[0] : null;
  },
  enables: (O) => [
    Le.state,
    ox,
    k.contentAttributes.compute([O], (e) => {
      let t = e.facet(O);
      return t && t.name ? { "data-language": t.name } : {};
    })
  ]
});
var je = class {
  /**
  Create a language support object.
  */
  constructor(e, t = []) {
    this.language = e, this.support = t, this.extension = [e, t];
  }
};
var Ur = class {
  constructor(e, t, i, n, r, s = void 0) {
    this.name = e, this.alias = t, this.extensions = i, this.filename = n, this.loadFunc = r, this.support = s, this.loading = null;
  }
  /**
  Start loading the the language. Will return a promise that
  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
  object when the language successfully loads.
  */
  load() {
    return this.loading || (this.loading = this.loadFunc().then((e) => this.support = e, (e) => {
      throw this.loading = null, e;
    }));
  }
  /**
  Create a language description.
  */
  static of(e) {
    let { load: t, support: i } = e;
    if (!t) {
      if (!i)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      t = () => Promise.resolve(i);
    }
    return new Ur(e.name, (e.alias || []).concat(e.name).map((n) => n.toLowerCase()), e.extensions || [], e.filename, t, i);
  }
  /**
  Look for a language in the given array of descriptions that
  matches the filename. Will first match
  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
  and return the first language that matches.
  */
  static matchFilename(e, t) {
    for (let n of e)
      if (n.filename && n.filename.test(t))
        return n;
    let i = /\.([^.]+)$/.exec(t);
    if (i) {
      for (let n of e)
        if (n.extensions.indexOf(i[1]) > -1)
          return n;
    }
    return null;
  }
  /**
  Look for a language whose name or alias matches the the given
  name (case-insensitively). If `fuzzy` is true, and no direct
  matchs is found, this'll also search for a language whose name
  or alias occurs in the string (for names shorter than three
  characters, only when surrounded by non-word characters).
  */
  static matchLanguageName(e, t, i = true) {
    t = t.toLowerCase();
    for (let n of e)
      if (n.alias.some((r) => r == t))
        return n;
    if (i)
      for (let n of e)
        for (let r of n.alias) {
          let s = t.indexOf(r);
          if (s > -1 && (r.length > 2 || !/\w/.test(t[s - 1]) && !/\w/.test(t[s + r.length])))
            return n;
        }
    return null;
  }
};
var n$ = q.define();
var dn = q.define({
  combine: (O) => {
    if (!O.length)
      return "  ";
    let e = O[0];
    if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(O[0]));
    return e;
  }
});
function bO(O) {
  let e = O.facet(dn);
  return e.charCodeAt(0) == 9 ? O.tabSize * e.length : e.length;
}
function Fi(O, e) {
  let t = "", i = O.tabSize, n = O.facet(dn)[0];
  if (n == "	") {
    for (; e >= i; )
      t += "	", e -= i;
    n = " ";
  }
  for (let r = 0; r < e; r++)
    t += n;
  return t;
}
function wl(O, e) {
  O instanceof I && (O = new cs(O));
  for (let i of O.state.facet(n$)) {
    let n = i(O, e);
    if (n !== void 0)
      return n;
  }
  let t = B(O.state);
  return t ? ax(O, t, e) : null;
}
var cs = class {
  /**
  Create an indent context.
  */
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = bO(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, t = 1) {
    let i = this.state.doc.lineAt(e), { simulateBreak: n, simulateDoubleBreak: r } = this.options;
    return n != null && n >= i.from && n <= i.to ? r && n == e ? { text: "", from: e } : (t < 0 ? n < e : n <= e) ? { text: i.text.slice(n - i.from), from: n } : { text: i.text.slice(0, n - i.from), from: i.from } : i;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: i, from: n } = this.lineAt(e, t);
    return i.slice(e - n, Math.min(i.length, e + 100 - n));
  }
  /**
  Find the column for the given position.
  */
  column(e, t = 1) {
    let { text: i, from: n } = this.lineAt(e, t), r = this.countColumn(i, e - n), s = this.options.overrideIndentation ? this.options.overrideIndentation(n) : -1;
    return s > -1 && (r += s - this.countColumn(i, i.search(/\S|$/))), r;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, t = e.length) {
    return hn(e, this.state.tabSize, t);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, t = 1) {
    let { text: i, from: n } = this.lineAt(e, t), r = this.options.overrideIndentation;
    if (r) {
      let s = r(n);
      if (s > -1)
        return s;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
};
var Ce = new _();
function ax(O, e, t) {
  return r$(e.resolveInner(t).enterUnfinishedNodesBefore(t), t, O);
}
function lx(O) {
  return O.pos == O.options.simulateBreak && O.options.simulateDoubleBreak;
}
function cx(O) {
  let e = O.type.prop(Ce);
  if (e)
    return e;
  let t = O.firstChild, i;
  if (t && (i = t.type.prop(_.closedBy))) {
    let n = O.lastChild, r = n && i.indexOf(n.name) > -1;
    return (s) => s$(s, true, 1, void 0, r && !lx(s) ? n.from : void 0);
  }
  return O.parent == null ? hx : null;
}
function r$(O, e, t) {
  for (; O; O = O.parent) {
    let i = cx(O);
    if (i)
      return i(Tl.create(t, e, O));
  }
  return null;
}
function hx() {
  return 0;
}
var Tl = class extends cs {
  constructor(e, t, i) {
    super(e.state, e.options), this.base = e, this.pos = t, this.node = i;
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new Tl(e, t, i);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    let e = this.state.doc.lineAt(this.node.from);
    for (; ; ) {
      let t = this.node.resolve(e.from);
      for (; t.parent && t.parent.from == t.from; )
        t = t.parent;
      if (ux(t, this.node))
        break;
      e = this.state.doc.lineAt(t.from);
    }
    return this.lineIndent(e.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    let e = this.node.parent;
    return e ? r$(e, this.pos, this.base) : 0;
  }
};
function ux(O, e) {
  for (let t = e; t; t = t.parent)
    if (O == t)
      return true;
  return false;
}
function fx(O) {
  let e = O.node, t = e.childAfter(e.from), i = e.lastChild;
  if (!t)
    return null;
  let n = O.options.simulateBreak, r = O.state.doc.lineAt(t.from), s = n == null || n <= r.from ? r.to : Math.min(r.to, n);
  for (let o = t.to; ; ) {
    let a = e.childAfter(o);
    if (!a || a == i)
      return null;
    if (!a.type.isSkipped)
      return a.from < s ? t : null;
    o = a.to;
  }
}
function Ft({ closing: O, align: e = true, units: t = 1 }) {
  return (i) => s$(i, e, t, O);
}
function s$(O, e, t, i, n) {
  let r = O.textAfter, s = r.match(/^\s*/)[0].length, o = i && r.slice(s, s + i.length) == i || n == O.pos + s, a = e ? fx(O) : null;
  return a ? o ? O.column(a.from) : O.column(a.to) : O.baseIndent + (o ? 0 : O.unit * t);
}
var Wl = (O) => O.baseIndent;
function $e({ except: O, units: e = 1 } = {}) {
  return (t) => {
    let i = O && O.test(t.textAfter);
    return t.baseIndent + (i ? 0 : e * t.unit);
  };
}
var dx = 200;
function Qx() {
  return I.transactionFilter.of((O) => {
    if (!O.docChanged || !O.isUserEvent("input.type") && !O.isUserEvent("input.complete"))
      return O;
    let e = O.startState.languageDataAt("indentOnInput", O.startState.selection.main.head);
    if (!e.length)
      return O;
    let t = O.newDoc, { head: i } = O.newSelection.main, n = t.lineAt(i);
    if (i > n.from + dx)
      return O;
    let r = t.sliceString(n.from, i);
    if (!e.some((l) => l.test(r)))
      return O;
    let { state: s } = O, o = -1, a = [];
    for (let { head: l } of s.selection.ranges) {
      let h2 = s.doc.lineAt(l);
      if (h2.from == o)
        continue;
      o = h2.from;
      let u = wl(s, h2.from);
      if (u == null)
        continue;
      let f = /^\s*/.exec(h2.text)[0], d = Fi(s, u);
      f != d && a.push({ from: h2.from, to: h2.from + f.length, insert: d });
    }
    return a.length ? [O, { changes: a, sequential: true }] : O;
  });
}
var $x = q.define();
var Ge = new _();
function _t(O) {
  let e = O.firstChild, t = O.lastChild;
  return e && e.to < t.from ? { from: e.to, to: t.type.isError ? O.to : t.from } : null;
}
function px(O, e, t) {
  let i = B(O);
  if (i.length < t)
    return null;
  let n = i.resolveInner(t, 1), r = null;
  for (let s = n; s; s = s.parent) {
    if (s.to <= t || s.from > t)
      continue;
    if (r && s.from < e)
      break;
    let o = s.type.prop(Ge);
    if (o && (s.to < i.length - 50 || i.length == O.doc.length || !mx(s))) {
      let a = o(s, O);
      a && a.from <= t && a.from >= e && a.to > t && (r = a);
    }
  }
  return r;
}
function mx(O) {
  let e = O.lastChild;
  return e && e.to == O.to && e.type.isError;
}
function Vr(O, e, t) {
  for (let i of O.facet($x)) {
    let n = i(O, e, t);
    if (n)
      return n;
  }
  return px(O, e, t);
}
function o$(O, e) {
  let t = e.mapPos(O.from, 1), i = e.mapPos(O.to, -1);
  return t >= i ? void 0 : { from: t, to: i };
}
var hs = j.define({ map: o$ });
var Qn = j.define({ map: o$ });
function a$(O) {
  let e = [];
  for (let { head: t } of O.state.selection.ranges)
    e.some((i) => i.from <= t && i.to >= t) || e.push(O.lineBlockAt(t));
  return e;
}
var wO = me.define({
  create() {
    return V.none;
  },
  update(O, e) {
    O = O.map(e.changes);
    for (let t of e.effects)
      t.is(hs) && !gx(O, t.value.from, t.value.to) ? O = O.update({ add: [Lh.range(t.value.from, t.value.to)] }) : t.is(Qn) && (O = O.update({
        filter: (i, n) => t.value.from != i || t.value.to != n,
        filterFrom: t.value.from,
        filterTo: t.value.to
      }));
    if (e.selection) {
      let t = false, { head: i } = e.selection.main;
      O.between(i, i, (n, r) => {
        n < i && r > i && (t = true);
      }), t && (O = O.update({
        filterFrom: i,
        filterTo: i,
        filter: (n, r) => r <= i || n >= i
      }));
    }
    return O;
  },
  provide: (O) => k.decorations.from(O),
  toJSON(O, e) {
    let t = [];
    return O.between(0, e.doc.length, (i, n) => {
      t.push(i, n);
    }), t;
  },
  fromJSON(O) {
    if (!Array.isArray(O) || O.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let t = 0; t < O.length; ) {
      let i = O[t++], n = O[t++];
      if (typeof i != "number" || typeof n != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(Lh.range(i, n));
    }
    return V.set(e, true);
  }
});
function Rr(O, e, t) {
  var i;
  let n = null;
  return (i = O.field(wO, false)) === null || i === void 0 || i.between(e, t, (r, s) => {
    (!n || n.from > r) && (n = { from: r, to: s });
  }), n;
}
function gx(O, e, t) {
  let i = false;
  return O.between(e, e, (n, r) => {
    n == e && r == t && (i = true);
  }), i;
}
function l$(O, e) {
  return O.field(wO, false) ? e : e.concat(j.appendConfig.of(u$()));
}
var Sx = (O) => {
  for (let e of a$(O)) {
    let t = Vr(O.state, e.from, e.to);
    if (t)
      return O.dispatch({ effects: l$(O.state, [hs.of(t), c$(O, t)]) }), true;
  }
  return false;
};
var Px = (O) => {
  if (!O.state.field(wO, false))
    return false;
  let e = [];
  for (let t of a$(O)) {
    let i = Rr(O.state, t.from, t.to);
    i && e.push(Qn.of(i), c$(O, i, false));
  }
  return e.length && O.dispatch({ effects: e }), e.length > 0;
};
function c$(O, e, t = true) {
  let i = O.state.doc.lineAt(e.from).number, n = O.state.doc.lineAt(e.to).number;
  return k.announce.of(`${O.state.phrase(t ? "Folded lines" : "Unfolded lines")} ${i} ${O.state.phrase("to")} ${n}.`);
}
var yx = (O) => {
  let { state: e } = O, t = [];
  for (let i = 0; i < e.doc.length; ) {
    let n = O.lineBlockAt(i), r = Vr(e, n.from, n.to);
    r && t.push(hs.of(r)), i = (r ? O.lineBlockAt(r.to) : n).to + 1;
  }
  return t.length && O.dispatch({ effects: l$(O.state, t) }), !!t.length;
};
var Xx = (O) => {
  let e = O.state.field(wO, false);
  if (!e || !e.size)
    return false;
  let t = [];
  return e.between(0, O.state.doc.length, (i, n) => {
    t.push(Qn.of({ from: i, to: n }));
  }), O.dispatch({ effects: t }), true;
};
var xx = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: Sx },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: Px },
  { key: "Ctrl-Alt-[", run: yx },
  { key: "Ctrl-Alt-]", run: Xx }
];
var bx = {
  placeholderDOM: null,
  placeholderText: "…"
};
var h$ = q.define({
  combine(O) {
    return bt(O, bx);
  }
});
function u$(O) {
  let e = [wO, Wx];
  return O && e.push(h$.of(O)), e;
}
var Lh = V.replace({ widget: new class extends wt {
  toDOM(O) {
    let { state: e } = O, t = e.facet(h$), i = (r) => {
      let s = O.lineBlockAt(O.posAtDOM(r.target)), o = Rr(O.state, s.from, s.to);
      o && O.dispatch({ effects: Qn.of(o) }), r.preventDefault();
    };
    if (t.placeholderDOM)
      return t.placeholderDOM(O, i);
    let n = document.createElement("span");
    return n.textContent = t.placeholderText, n.setAttribute("aria-label", e.phrase("folded code")), n.title = e.phrase("unfold"), n.className = "cm-foldPlaceholder", n.onclick = i, n;
  }
}() });
var wx = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => false
};
var Fs = class extends Ut {
  constructor(e, t) {
    super(), this.config = e, this.open = t;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let t = document.createElement("span");
    return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t;
  }
};
function Tx(O = {}) {
  let e = Object.assign(Object.assign({}, wx), O), t = new Fs(e, true), i = new Fs(e, false), n = se.fromClass(class {
    constructor(s) {
      this.from = s.viewport.from, this.markers = this.buildMarkers(s);
    }
    update(s) {
      (s.docChanged || s.viewportChanged || s.startState.facet(nO) != s.state.facet(nO) || s.startState.field(wO, false) != s.state.field(wO, false) || B(s.startState) != B(s.state) || e.foldingChanged(s)) && (this.markers = this.buildMarkers(s.view));
    }
    buildMarkers(s) {
      let o = new eO();
      for (let a of s.viewportLineBlocks) {
        let l = Rr(s.state, a.from, a.to) ? i : Vr(s.state, a.from, a.to) ? t : null;
        l && o.add(a.from, a.from, l);
      }
      return o.finish();
    }
  }), { domEventHandlers: r } = e;
  return [
    n,
    kX({
      class: "cm-foldGutter",
      markers(s) {
        var o;
        return ((o = s.plugin(n)) === null || o === void 0 ? void 0 : o.markers) || L.empty;
      },
      initialSpacer() {
        return new Fs(e, false);
      },
      domEventHandlers: Object.assign(Object.assign({}, r), { click: (s, o, a) => {
        if (r.click && r.click(s, o, a))
          return true;
        let l = Rr(s.state, o.from, o.to);
        if (l)
          return s.dispatch({ effects: Qn.of(l) }), true;
        let h2 = Vr(s.state, o.from, o.to);
        return h2 ? (s.dispatch({ effects: hs.of(h2) }), true) : false;
      } })
    }),
    u$()
  ];
}
var Wx = k.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
var ri = class {
  constructor(e, t) {
    this.specs = e;
    let i;
    function n(o) {
      let a = tO.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + a] = o, a;
    }
    const r = typeof t.all == "string" ? t.all : t.all ? n(t.all) : void 0, s = t.scope;
    this.scope = s instanceof Le ? (o) => o.prop(XO) == s.data : s ? (o) => o == s : void 0, this.style = O$(e.map((o) => ({
      tag: o.tag,
      class: o.class || n(Object.assign({}, o, { tag: null }))
    })), {
      all: r
    }).style, this.module = i ? new tO(i) : null, this.themeType = t.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, t) {
    return new ri(e, t || {});
  }
};
var ya = q.define();
var f$ = q.define({
  combine(O) {
    return O.length ? [O[0]] : null;
  }
});
function Hs(O) {
  let e = O.facet(ya);
  return e.length ? e : O.facet(f$);
}
function vl(O, e) {
  let t = [kx], i;
  return O instanceof ri && (O.module && t.push(k.styleModule.of(O.module)), i = O.themeType), e != null && e.fallback ? t.push(f$.of(O)) : i ? t.push(ya.computeN([k.darkTheme], (n) => n.facet(k.darkTheme) == (i == "dark") ? [O] : [])) : t.push(ya.of(O)), t;
}
var vx = class {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = B(e.state), this.decorations = this.buildDeco(e, Hs(e.state));
  }
  update(e) {
    let t = B(e.state), i = Hs(e.state), n = i != Hs(e.startState);
    t.length < e.view.viewport.to && !n && t.type == this.tree.type ? this.decorations = this.decorations.map(e.changes) : (t != this.tree || e.viewportChanged || n) && (this.tree = t, this.decorations = this.buildDeco(e.view, i));
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return V.none;
    let i = new eO();
    for (let { from: n, to: r } of e.visibleRanges)
      ix(this.tree, t, (s, o, a) => {
        i.add(s, o, this.markCache[a] || (this.markCache[a] = V.mark({ class: a })));
      }, n, r);
    return i.finish();
  }
};
var kx = rO.high(se.fromClass(vx, {
  decorations: (O) => O.decorations
}));
var Yx = ri.define([
  {
    tag: c.meta,
    color: "#404740"
  },
  {
    tag: c.link,
    textDecoration: "underline"
  },
  {
    tag: c.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: c.emphasis,
    fontStyle: "italic"
  },
  {
    tag: c.strong,
    fontWeight: "bold"
  },
  {
    tag: c.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: c.keyword,
    color: "#708"
  },
  {
    tag: [c.atom, c.bool, c.url, c.contentSeparator, c.labelName],
    color: "#219"
  },
  {
    tag: [c.literal, c.inserted],
    color: "#164"
  },
  {
    tag: [c.string, c.deleted],
    color: "#a11"
  },
  {
    tag: [c.regexp, c.escape, c.special(c.string)],
    color: "#e40"
  },
  {
    tag: c.definition(c.variableName),
    color: "#00f"
  },
  {
    tag: c.local(c.variableName),
    color: "#30a"
  },
  {
    tag: [c.typeName, c.namespace],
    color: "#085"
  },
  {
    tag: c.className,
    color: "#167"
  },
  {
    tag: [c.special(c.variableName), c.macroName],
    color: "#256"
  },
  {
    tag: c.definition(c.propertyName),
    color: "#00c"
  },
  {
    tag: c.comment,
    color: "#940"
  },
  {
    tag: c.invalid,
    color: "#f00"
  }
]);
var Zx = k.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
});
var d$ = 1e4;
var Q$ = "()[]{}";
var $$ = q.define({
  combine(O) {
    return bt(O, {
      afterCursor: true,
      brackets: Q$,
      maxScanDistance: d$,
      renderMatch: Ux
    });
  }
});
var qx = V.mark({ class: "cm-matchingBracket" });
var zx = V.mark({ class: "cm-nonmatchingBracket" });
function Ux(O) {
  let e = [], t = O.matched ? qx : zx;
  return e.push(t.range(O.start.from, O.start.to)), O.end && e.push(t.range(O.end.from, O.end.to)), e;
}
var Vx = me.define({
  create() {
    return V.none;
  },
  update(O, e) {
    if (!e.docChanged && !e.selection)
      return O;
    let t = [], i = e.state.facet($$);
    for (let n of e.state.selection.ranges) {
      if (!n.empty)
        continue;
      let r = St(e.state, n.head, -1, i) || n.head > 0 && St(e.state, n.head - 1, 1, i) || i.afterCursor && (St(e.state, n.head, 1, i) || n.head < e.state.doc.length && St(e.state, n.head + 1, -1, i));
      r && (t = t.concat(i.renderMatch(r, e.state)));
    }
    return V.set(t, true);
  },
  provide: (O) => k.decorations.from(O)
});
var Rx = [
  Vx,
  Zx
];
function _x(O = {}) {
  return [$$.of(O), Rx];
}
var kl = new _();
function Xa(O, e, t) {
  let i = O.prop(e < 0 ? _.openedBy : _.closedBy);
  if (i)
    return i;
  if (O.name.length == 1) {
    let n = t.indexOf(O.name);
    if (n > -1 && n % 2 == (e < 0 ? 1 : 0))
      return [t[n + e]];
  }
  return null;
}
function xa(O) {
  let e = O.type.prop(kl);
  return e ? e(O.node) : O;
}
function St(O, e, t, i = {}) {
  let n = i.maxScanDistance || d$, r = i.brackets || Q$, s = B(O), o = s.resolveInner(e, t);
  for (let a = o; a; a = a.parent) {
    let l = Xa(a.type, t, r);
    if (l && a.from < a.to) {
      let h2 = xa(a);
      if (h2 && (t > 0 ? e >= h2.from && e < h2.to : e > h2.from && e <= h2.to))
        return jx(O, e, t, a, h2, l, r);
    }
  }
  return Cx(O, e, t, s, o.type, n, r);
}
function jx(O, e, t, i, n, r, s) {
  let o = i.parent, a = { from: n.from, to: n.to }, l = 0, h2 = o == null ? void 0 : o.cursor();
  if (h2 && (t < 0 ? h2.childBefore(i.from) : h2.childAfter(i.to)))
    do
      if (t < 0 ? h2.to <= i.from : h2.from >= i.to) {
        if (l == 0 && r.indexOf(h2.type.name) > -1 && h2.from < h2.to) {
          let u = xa(h2);
          return { start: a, end: u ? { from: u.from, to: u.to } : void 0, matched: true };
        } else if (Xa(h2.type, t, s))
          l++;
        else if (Xa(h2.type, -t, s)) {
          if (l == 0) {
            let u = xa(h2);
            return {
              start: a,
              end: u && u.from < u.to ? { from: u.from, to: u.to } : void 0,
              matched: false
            };
          }
          l--;
        }
      }
    while (t < 0 ? h2.prevSibling() : h2.nextSibling());
  return { start: a, matched: false };
}
function Cx(O, e, t, i, n, r, s) {
  let o = t < 0 ? O.sliceDoc(e - 1, e) : O.sliceDoc(e, e + 1), a = s.indexOf(o);
  if (a < 0 || a % 2 == 0 != t > 0)
    return null;
  let l = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, h2 = O.doc.iterRange(e, t > 0 ? O.doc.length : 0), u = 0;
  for (let f = 0; !h2.next().done && f <= r; ) {
    let d = h2.value;
    t < 0 && (f += d.length);
    let Q = e + f * t;
    for (let $ = t > 0 ? 0 : d.length - 1, p = t > 0 ? d.length : -1; $ != p; $ += t) {
      let m = s.indexOf(d[$]);
      if (!(m < 0 || i.resolveInner(Q + $, 1).type != n))
        if (m % 2 == 0 == t > 0)
          u++;
        else {
          if (u == 1)
            return { start: l, end: { from: Q + $, to: Q + $ + 1 }, matched: m >> 1 == a >> 1 };
          u--;
        }
    }
    t > 0 && (f += d.length);
  }
  return h2.done ? { start: l, matched: false } : null;
}
function Bh(O, e, t, i = 0, n = 0) {
  e == null && (e = O.search(/[^\s\u00a0]/), e == -1 && (e = O.length));
  let r = n;
  for (let s = i; s < e; s++)
    O.charCodeAt(s) == 9 ? r += t - r % t : r++;
  return r;
}
var p$ = class {
  /**
  Create a stream.
  */
  constructor(e, t, i, n) {
    this.string = e, this.tabSize = t, this.indentUnit = i, this.overrideIndent = n, this.pos = 0, this.start = 0, this.lastColumnPos = 0, this.lastColumnValue = 0;
  }
  /**
  True if we are at the end of the line.
  */
  eol() {
    return this.pos >= this.string.length;
  }
  /**
  True if we are at the start of the line.
  */
  sol() {
    return this.pos == 0;
  }
  /**
  Get the next code unit after the current position, or undefined
  if we're at the end of the line.
  */
  peek() {
    return this.string.charAt(this.pos) || void 0;
  }
  /**
  Read the next code unit and advance `this.pos`.
  */
  next() {
    if (this.pos < this.string.length)
      return this.string.charAt(this.pos++);
  }
  /**
  Match the next character against the given string, regular
  expression, or predicate. Consume and return it if it matches.
  */
  eat(e) {
    let t = this.string.charAt(this.pos), i;
    if (typeof e == "string" ? i = t == e : i = t && (e instanceof RegExp ? e.test(t) : e(t)), i)
      return ++this.pos, t;
  }
  /**
  Continue matching characters that match the given string,
  regular expression, or predicate function. Return true if any
  characters were consumed.
  */
  eatWhile(e) {
    let t = this.pos;
    for (; this.eat(e); )
      ;
    return this.pos > t;
  }
  /**
  Consume whitespace ahead of `this.pos`. Return true if any was
  found.
  */
  eatSpace() {
    let e = this.pos;
    for (; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
      ++this.pos;
    return this.pos > e;
  }
  /**
  Move to the end of the line.
  */
  skipToEnd() {
    this.pos = this.string.length;
  }
  /**
  Move to directly before the given character, if found on the
  current line.
  */
  skipTo(e) {
    let t = this.string.indexOf(e, this.pos);
    if (t > -1)
      return this.pos = t, true;
  }
  /**
  Move back `n` characters.
  */
  backUp(e) {
    this.pos -= e;
  }
  /**
  Get the column position at `this.pos`.
  */
  column() {
    return this.lastColumnPos < this.start && (this.lastColumnValue = Bh(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue;
  }
  /**
  Get the indentation column of the current line.
  */
  indentation() {
    var e;
    return (e = this.overrideIndent) !== null && e !== void 0 ? e : Bh(this.string, null, this.tabSize);
  }
  /**
  Match the input against the given string or regular expression
  (which should start with a `^`). Return true or the regexp match
  if it matches.
  
  Unless `consume` is set to `false`, this will move `this.pos`
  past the matched text.
  
  When matching a string `caseInsensitive` can be set to true to
  make the match case-insensitive.
  */
  match(e, t, i) {
    if (typeof e == "string") {
      let n = (s) => i ? s.toLowerCase() : s, r = this.string.substr(this.pos, e.length);
      return n(r) == n(e) ? (t !== false && (this.pos += e.length), true) : null;
    } else {
      let n = this.string.slice(this.pos).match(e);
      return n && n.index > 0 ? null : (n && t !== false && (this.pos += n[0].length), n);
    }
  }
  /**
  Get the current token.
  */
  current() {
    return this.string.slice(this.start, this.pos);
  }
};
function Gx(O) {
  return {
    name: O.name || "",
    token: O.token,
    blankLine: O.blankLine || (() => {
    }),
    startState: O.startState || (() => true),
    copyState: O.copyState || Ix,
    indent: O.indent || (() => null),
    languageData: O.languageData || {},
    tokenTable: O.tokenTable || Zl
  };
}
function Ix(O) {
  if (typeof O != "object")
    return O;
  let e = {};
  for (let t in O) {
    let i = O[t];
    e[t] = i instanceof Array ? i.slice() : i;
  }
  return e;
}
var Nh = /* @__PURE__ */ new WeakMap();
var le = class extends Le {
  constructor(e) {
    let t = bl(e.languageData), i = Gx(e), n, r = new class extends ls {
      createParse(s, o, a) {
        return new Ax(n, s, o, a);
      }
    }();
    super(t, r, [n$.of((s, o) => this.getIndent(s, o))], e.name), this.topNode = Lx(t), n = this, this.streamParser = i, this.stateAfter = new _({ perNode: true }), this.tokenTable = e.tokenTable ? new P$(i.tokenTable) : Mx;
  }
  /**
  Define a stream language.
  */
  static define(e) {
    return new le(e);
  }
  getIndent(e, t) {
    let i = B(e.state), n = i.resolve(t);
    for (; n && n.type != this.topNode; )
      n = n.parent;
    if (!n)
      return null;
    let r, { overrideIndentation: s } = e.options;
    s && (r = Nh.get(e.state), r != null && r < t - 1e4 && (r = void 0));
    let o = Yl(this, i, 0, n.from, r ?? t), a, l;
    if (o ? (l = o.state, a = o.pos + 1) : (l = this.streamParser.startState(e.unit), a = 0), t - a > 1e4)
      return null;
    for (; a < t; ) {
      let u = e.state.doc.lineAt(a), f = Math.min(t, u.to);
      if (u.length) {
        let d = s ? s(u.from) : -1, Q = new p$(u.text, e.state.tabSize, e.unit, d < 0 ? void 0 : d);
        for (; Q.pos < f - u.from; )
          g$(this.streamParser.token, Q, l);
      } else
        this.streamParser.blankLine(l, e.unit);
      if (f == t)
        break;
      a = u.to + 1;
    }
    let h2 = e.lineAt(t);
    return s && r == null && Nh.set(e.state, h2.from), this.streamParser.indent(l, /^\s*(.*)/.exec(h2.text)[1], e);
  }
  get allowsNesting() {
    return false;
  }
};
function Yl(O, e, t, i, n) {
  let r = t >= i && t + e.length <= n && e.prop(O.stateAfter);
  if (r)
    return { state: O.streamParser.copyState(r), pos: t + e.length };
  for (let s = e.children.length - 1; s >= 0; s--) {
    let o = e.children[s], a = t + e.positions[s], l = o instanceof E && a < n && Yl(O, o, a, i, n);
    if (l)
      return l;
  }
  return null;
}
function m$(O, e, t, i, n) {
  if (n && t <= 0 && i >= e.length)
    return e;
  !n && e.type == O.topNode && (n = true);
  for (let r = e.children.length - 1; r >= 0; r--) {
    let s = e.positions[r], o = e.children[r], a;
    if (s < i && o instanceof E) {
      if (!(a = m$(O, o, t - s, i - s, n)))
        break;
      return n ? new E(e.type, e.children.slice(0, r).concat(a), e.positions.slice(0, r + 1), s + a.length) : a;
    }
  }
  return null;
}
function Ex(O, e, t, i) {
  for (let n of e) {
    let r = n.from + (n.openStart ? 25 : 0), s = n.to - (n.openEnd ? 25 : 0), o = r <= t && s > t && Yl(O, n.tree, 0 - n.offset, t, s), a;
    if (o && (a = m$(O, n.tree, t + n.offset, o.pos + n.offset, false)))
      return { state: o.state, tree: a };
  }
  return { state: O.streamParser.startState(i ? bO(i) : 4), tree: E.empty };
}
var Ax = class {
  constructor(e, t, i, n) {
    this.lang = e, this.input = t, this.fragments = i, this.ranges = n, this.stoppedAt = null, this.chunks = [], this.chunkPos = [], this.chunk = [], this.chunkReused = void 0, this.rangeIndex = 0, this.to = n[n.length - 1].to;
    let r = xO.get(), s = n[0].from, { state: o, tree: a } = Ex(e, i, s, r == null ? void 0 : r.state);
    this.state = o, this.parsedPos = this.chunkStart = s + a.length;
    for (let l = 0; l < a.children.length; l++)
      this.chunks.push(a.children[l]), this.chunkPos.push(a.positions[l]);
    r && this.parsedPos < r.viewport.from - 1e5 && (this.state = this.lang.streamParser.startState(bO(r.state)), r.skipUntilInView(this.parsedPos, r.viewport.from), this.parsedPos = r.viewport.from), this.moveRangeIndex();
  }
  advance() {
    let e = xO.get(), t = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt), i = Math.min(
      t,
      this.chunkStart + 2048
      /* C.ChunkSize */
    );
    for (e && (i = Math.min(i, e.viewport.to)); this.parsedPos < i; )
      this.parseLine(e);
    return this.chunkStart < this.parsedPos && this.finishChunk(), this.parsedPos >= t ? this.finish() : e && this.parsedPos >= e.viewport.to ? (e.skipUntilInView(this.parsedPos, t), this.finish()) : null;
  }
  stopAt(e) {
    this.stoppedAt = e;
  }
  lineAfter(e) {
    let t = this.input.chunk(e);
    if (this.input.lineChunks)
      t == `
` && (t = "");
    else {
      let i = t.indexOf(`
`);
      i > -1 && (t = t.slice(0, i));
    }
    return e + t.length <= this.to ? t : t.slice(0, this.to - e);
  }
  nextLine() {
    let e = this.parsedPos, t = this.lineAfter(e), i = e + t.length;
    for (let n = this.rangeIndex; ; ) {
      let r = this.ranges[n].to;
      if (r >= i || (t = t.slice(0, r - (i - t.length)), n++, n == this.ranges.length))
        break;
      let s = this.ranges[n].from, o = this.lineAfter(s);
      t += o, i = s + o.length;
    }
    return { line: t, end: i };
  }
  skipGapsTo(e, t, i) {
    for (; ; ) {
      let n = this.ranges[this.rangeIndex].to, r = e + t;
      if (i > 0 ? n > r : n >= r)
        break;
      let s = this.ranges[++this.rangeIndex].from;
      t += s - n;
    }
    return t;
  }
  moveRangeIndex() {
    for (; this.ranges[this.rangeIndex].to < this.parsedPos; )
      this.rangeIndex++;
  }
  emitToken(e, t, i, n, r) {
    if (this.ranges.length > 1) {
      r = this.skipGapsTo(t, r, 1), t += r;
      let s = this.chunk.length;
      r = this.skipGapsTo(i, r, -1), i += r, n += this.chunk.length - s;
    }
    return this.chunk.push(e, t, i, n), r;
  }
  parseLine(e) {
    let { line: t, end: i } = this.nextLine(), n = 0, { streamParser: r } = this.lang, s = new p$(t, e ? e.state.tabSize : 4, e ? bO(e.state) : 2);
    if (s.eol())
      r.blankLine(this.state, s.indentUnit);
    else
      for (; !s.eol(); ) {
        let o = g$(r.token, s, this.state);
        if (o && (n = this.emitToken(this.lang.tokenTable.resolve(o), this.parsedPos + s.start, this.parsedPos + s.pos, 4, n)), s.start > 1e4)
          break;
      }
    this.parsedPos = i, this.moveRangeIndex(), this.parsedPos < this.to && this.parsedPos++;
  }
  finishChunk() {
    let e = E.build({
      buffer: this.chunk,
      start: this.chunkStart,
      length: this.parsedPos - this.chunkStart,
      nodeSet: Dx,
      topID: 0,
      maxBufferLength: 2048,
      reused: this.chunkReused
    });
    e = new E(e.type, e.children, e.positions, e.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]), this.chunks.push(e), this.chunkPos.push(this.chunkStart - this.ranges[0].from), this.chunk = [], this.chunkReused = void 0, this.chunkStart = this.parsedPos;
  }
  finish() {
    return new E(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
  }
};
function g$(O, e, t) {
  e.start = e.pos;
  for (let i = 0; i < 10; i++) {
    let n = O(e, t);
    if (e.pos > e.start)
      return n;
  }
  throw new Error("Stream parser failed to advance stream.");
}
var Zl = /* @__PURE__ */ Object.create(null);
var Hi = [ue.none];
var Dx = new ni(Hi);
var Fh = [];
var S$ = /* @__PURE__ */ Object.create(null);
for (let [O, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  S$[O] = y$(Zl, e);
var P$ = class {
  constructor(e) {
    this.extra = e, this.table = Object.assign(/* @__PURE__ */ Object.create(null), S$);
  }
  resolve(e) {
    return e ? this.table[e] || (this.table[e] = y$(this.extra, e)) : 0;
  }
};
var Mx = new P$(Zl);
function Ks(O, e) {
  Fh.indexOf(O) > -1 || (Fh.push(O), console.warn(e));
}
function y$(O, e) {
  let t = null;
  for (let r of e.split(".")) {
    let s = O[r] || c[r];
    s ? typeof s == "function" ? t ? t = s(t) : Ks(r, `Modifier ${r} used at start of tag`) : t ? Ks(r, `Tag ${r} used as modifier`) : t = s : Ks(r, `Unknown highlighting tag ${r}`);
  }
  if (!t)
    return 0;
  let i = e.replace(/ /g, "_"), n = ue.define({
    id: Hi.length,
    name: i,
    props: [ze({ [i]: t })]
  });
  return Hi.push(n), n.id;
}
function Lx(O) {
  let e = ue.define({ id: Hi.length, name: "Document", props: [XO.add(() => O)] });
  return Hi.push(e), e;
}
var Bx = (O) => {
  let e = zl(O.state);
  return e.line ? Nx(O) : e.block ? Hx(O) : false;
};
function ql(O, e) {
  return ({ state: t, dispatch: i }) => {
    if (t.readOnly)
      return false;
    let n = O(e, t);
    return n ? (i(t.update(n)), true) : false;
  };
}
var Nx = ql(
  eb,
  0
  /* CommentOption.Toggle */
);
var Fx = ql(
  X$,
  0
  /* CommentOption.Toggle */
);
var Hx = ql(
  (O, e) => X$(O, e, Jx(e)),
  0
  /* CommentOption.Toggle */
);
function zl(O, e = O.selection.main.head) {
  let t = O.languageDataAt("commentTokens", e);
  return t.length ? t[0] : {};
}
var di = 50;
function Kx(O, { open: e, close: t }, i, n) {
  let r = O.sliceDoc(i - di, i), s = O.sliceDoc(n, n + di), o = /\s*$/.exec(r)[0].length, a = /^\s*/.exec(s)[0].length, l = r.length - o;
  if (r.slice(l - e.length, l) == e && s.slice(a, a + t.length) == t)
    return {
      open: { pos: i - o, margin: o && 1 },
      close: { pos: n + a, margin: a && 1 }
    };
  let h2, u;
  n - i <= 2 * di ? h2 = u = O.sliceDoc(i, n) : (h2 = O.sliceDoc(i, i + di), u = O.sliceDoc(n - di, n));
  let f = /^\s*/.exec(h2)[0].length, d = /\s*$/.exec(u)[0].length, Q = u.length - d - t.length;
  return h2.slice(f, f + e.length) == e && u.slice(Q, Q + t.length) == t ? {
    open: {
      pos: i + f + e.length,
      margin: /\s/.test(h2.charAt(f + e.length)) ? 1 : 0
    },
    close: {
      pos: n - d - t.length,
      margin: /\s/.test(u.charAt(Q - 1)) ? 1 : 0
    }
  } : null;
}
function Jx(O) {
  let e = [];
  for (let t of O.selection.ranges) {
    let i = O.doc.lineAt(t.from), n = t.to <= i.to ? i : O.doc.lineAt(t.to), r = e.length - 1;
    r >= 0 && e[r].to > i.from ? e[r].to = n.to : e.push({ from: i.from, to: n.to });
  }
  return e;
}
function X$(O, e, t = e.selection.ranges) {
  let i = t.map((r) => zl(e, r.from).block);
  if (!i.every((r) => r))
    return null;
  let n = t.map((r, s) => Kx(e, i[s], r.from, r.to));
  if (O != 2 && !n.every((r) => r))
    return { changes: e.changes(t.map((r, s) => n[s] ? [] : [{ from: r.from, insert: i[s].open + " " }, { from: r.to, insert: " " + i[s].close }])) };
  if (O != 1 && n.some((r) => r)) {
    let r = [];
    for (let s = 0, o; s < n.length; s++)
      if (o = n[s]) {
        let a = i[s], { open: l, close: h2 } = o;
        r.push({ from: l.pos - a.open.length, to: l.pos + l.margin }, { from: h2.pos - h2.margin, to: h2.pos + a.close.length });
      }
    return { changes: r };
  }
  return null;
}
function eb(O, e, t = e.selection.ranges) {
  let i = [], n = -1;
  for (let { from: r, to: s } of t) {
    let o = i.length, a = 1e9;
    for (let l = r; l <= s; ) {
      let h2 = e.doc.lineAt(l);
      if (h2.from > n && (r == s || s > h2.from)) {
        n = h2.from;
        let u = zl(e, l).line;
        if (!u)
          continue;
        let f = /^\s*/.exec(h2.text)[0].length, d = f == h2.length, Q = h2.text.slice(f, f + u.length) == u ? f : -1;
        f < h2.text.length && f < a && (a = f), i.push({ line: h2, comment: Q, token: u, indent: f, empty: d, single: false });
      }
      l = h2.to + 1;
    }
    if (a < 1e9)
      for (let l = o; l < i.length; l++)
        i[l].indent < i[l].line.text.length && (i[l].indent = a);
    i.length == o + 1 && (i[o].single = true);
  }
  if (O != 2 && i.some((r) => r.comment < 0 && (!r.empty || r.single))) {
    let r = [];
    for (let { line: o, token: a, indent: l, empty: h2, single: u } of i)
      (u || !h2) && r.push({ from: o.from + l, insert: a + " " });
    let s = e.changes(r);
    return { changes: s, selection: e.selection.map(s, 1) };
  } else if (O != 1 && i.some((r) => r.comment >= 0)) {
    let r = [];
    for (let { line: s, comment: o, token: a } of i)
      if (o >= 0) {
        let l = s.from + o, h2 = l + a.length;
        s.text[h2 - s.from] == " " && h2++, r.push({ from: l, to: h2 });
      }
    return { changes: r };
  }
  return null;
}
var ba = sO.define();
var tb = sO.define();
var Ob = q.define();
var x$ = q.define({
  combine(O) {
    return bt(O, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, t) => t
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, t) => (i, n) => e(i, n) || t(i, n)
    });
  }
});
function ib(O) {
  let e = 0;
  return O.iterChangedRanges((t, i) => e = i), e;
}
var b$ = me.define({
  create() {
    return Pt.empty;
  },
  update(O, e) {
    let t = e.state.facet(x$), i = e.annotation(ba);
    if (i) {
      let a = e.docChanged ? S.single(ib(e.changes)) : void 0, l = _e.fromTransaction(e, a), h2 = i.side, u = h2 == 0 ? O.undone : O.done;
      return l ? u = _r(u, u.length, t.minDepth, l) : u = W$(u, e.startState.selection), new Pt(h2 == 0 ? i.rest : u, h2 == 0 ? u : i.rest);
    }
    let n = e.annotation(tb);
    if ((n == "full" || n == "before") && (O = O.isolate()), e.annotation(de.addToHistory) === false)
      return e.changes.empty ? O : O.addMapping(e.changes.desc);
    let r = _e.fromTransaction(e), s = e.annotation(de.time), o = e.annotation(de.userEvent);
    return r ? O = O.addChanges(r, s, o, t, e) : e.selection && (O = O.addSelection(e.startState.selection, s, o, t.newGroupDelay)), (n == "full" || n == "after") && (O = O.isolate()), O;
  },
  toJSON(O) {
    return { done: O.done.map((e) => e.toJSON()), undone: O.undone.map((e) => e.toJSON()) };
  },
  fromJSON(O) {
    return new Pt(O.done.map(_e.fromJSON), O.undone.map(_e.fromJSON));
  }
});
function nb(O = {}) {
  return [
    b$,
    x$.of(O),
    k.domEventHandlers({
      beforeinput(e, t) {
        let i = e.inputType == "historyUndo" ? w$ : e.inputType == "historyRedo" ? wa : null;
        return i ? (e.preventDefault(), i(t)) : false;
      }
    })
  ];
}
function us(O, e) {
  return function({ state: t, dispatch: i }) {
    if (!e && t.readOnly)
      return false;
    let n = t.field(b$, false);
    if (!n)
      return false;
    let r = n.pop(O, t, e);
    return r ? (i(r), true) : false;
  };
}
var w$ = us(0, false);
var wa = us(1, false);
var rb = us(0, true);
var sb = us(1, true);
var _e = class {
  constructor(e, t, i, n, r) {
    this.changes = e, this.effects = t, this.mapped = i, this.startSelection = n, this.selectionsAfter = r;
  }
  setSelAfter(e) {
    return new _e(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, t, i;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (t = this.mapped) === null || t === void 0 ? void 0 : t.toJSON(),
      startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(),
      selectionsAfter: this.selectionsAfter.map((n) => n.toJSON())
    };
  }
  static fromJSON(e) {
    return new _e(e.changes && fe.fromJSON(e.changes), [], e.mapped && yt.fromJSON(e.mapped), e.startSelection && S.fromJSON(e.startSelection), e.selectionsAfter.map(S.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, t) {
    let i = Je;
    for (let n of e.startState.facet(Ob)) {
      let r = n(e);
      r.length && (i = i.concat(r));
    }
    return !i.length && e.changes.empty ? null : new _e(e.changes.invert(e.startState.doc), i, void 0, t || e.startState.selection, Je);
  }
  static selection(e) {
    return new _e(void 0, Je, void 0, void 0, e);
  }
};
function _r(O, e, t, i) {
  let n = e + 1 > t + 20 ? e - t - 1 : 0, r = O.slice(n, e);
  return r.push(i), r;
}
function ob(O, e) {
  let t = [], i = false;
  return O.iterChangedRanges((n, r) => t.push(n, r)), e.iterChangedRanges((n, r, s, o) => {
    for (let a = 0; a < t.length; ) {
      let l = t[a++], h2 = t[a++];
      o >= l && s <= h2 && (i = true);
    }
  }), i;
}
function ab(O, e) {
  return O.ranges.length == e.ranges.length && O.ranges.filter((t, i) => t.empty != e.ranges[i].empty).length === 0;
}
function T$(O, e) {
  return O.length ? e.length ? O.concat(e) : O : e;
}
var Je = [];
var lb = 200;
function W$(O, e) {
  if (O.length) {
    let t = O[O.length - 1], i = t.selectionsAfter.slice(Math.max(0, t.selectionsAfter.length - lb));
    return i.length && i[i.length - 1].eq(e) ? O : (i.push(e), _r(O, O.length - 1, 1e9, t.setSelAfter(i)));
  } else
    return [_e.selection([e])];
}
function cb(O) {
  let e = O[O.length - 1], t = O.slice();
  return t[O.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), t;
}
function Js(O, e) {
  if (!O.length)
    return O;
  let t = O.length, i = Je;
  for (; t; ) {
    let n = hb(O[t - 1], e, i);
    if (n.changes && !n.changes.empty || n.effects.length) {
      let r = O.slice(0, t);
      return r[t - 1] = n, r;
    } else
      e = n.mapped, t--, i = n.selectionsAfter;
  }
  return i.length ? [_e.selection(i)] : Je;
}
function hb(O, e, t) {
  let i = T$(O.selectionsAfter.length ? O.selectionsAfter.map((o) => o.map(e)) : Je, t);
  if (!O.changes)
    return _e.selection(i);
  let n = O.changes.map(e), r = e.mapDesc(O.changes, true), s = O.mapped ? O.mapped.composeDesc(r) : r;
  return new _e(n, j.mapEffects(O.effects, e), s, O.startSelection.map(r), i);
}
var ub = /^(input\.type|delete)($|\.)/;
var Pt = class {
  constructor(e, t, i = 0, n = void 0) {
    this.done = e, this.undone = t, this.prevTime = i, this.prevUserEvent = n;
  }
  isolate() {
    return this.prevTime ? new Pt(this.done, this.undone) : this;
  }
  addChanges(e, t, i, n, r) {
    let s = this.done, o = s[s.length - 1];
    return o && o.changes && !o.changes.empty && e.changes && (!i || ub.test(i)) && (!o.selectionsAfter.length && t - this.prevTime < n.newGroupDelay && n.joinToEvent(r, ob(o.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    i == "input.type.compose") ? s = _r(s, s.length - 1, n.minDepth, new _e(e.changes.compose(o.changes), T$(e.effects, o.effects), o.mapped, o.startSelection, Je)) : s = _r(s, s.length, n.minDepth, e), new Pt(s, Je, t, i);
  }
  addSelection(e, t, i, n) {
    let r = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Je;
    return r.length > 0 && t - this.prevTime < n && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && ab(r[r.length - 1], e) ? this : new Pt(W$(this.done, e), this.undone, t, i);
  }
  addMapping(e) {
    return new Pt(Js(this.done, e), Js(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, t, i) {
    let n = e == 0 ? this.done : this.undone;
    if (n.length == 0)
      return null;
    let r = n[n.length - 1];
    if (i && r.selectionsAfter.length)
      return t.update({
        selection: r.selectionsAfter[r.selectionsAfter.length - 1],
        annotations: ba.of({ side: e, rest: cb(n) }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: true
      });
    if (r.changes) {
      let s = n.length == 1 ? Je : n.slice(0, n.length - 1);
      return r.mapped && (s = Js(s, r.mapped)), t.update({
        changes: r.changes,
        selection: r.startSelection,
        effects: r.effects,
        annotations: ba.of({ side: e, rest: s }),
        filter: false,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: true
      });
    } else
      return null;
  }
};
Pt.empty = new Pt(Je, Je);
var fb = [
  { key: "Mod-z", run: w$, preventDefault: true },
  { key: "Mod-y", mac: "Mod-Shift-z", run: wa, preventDefault: true },
  { linux: "Ctrl-Shift-z", run: wa, preventDefault: true },
  { key: "Mod-u", run: rb, preventDefault: true },
  { key: "Alt-u", mac: "Mod-Shift-u", run: sb, preventDefault: true }
];
function si(O, e) {
  return S.create(O.ranges.map(e), O.mainIndex);
}
function Tt(O, e) {
  return O.update({ selection: e, scrollIntoView: true, userEvent: "select" });
}
function ut({ state: O, dispatch: e }, t) {
  let i = si(O.selection, t);
  return i.eq(O.selection) ? false : (e(Tt(O, i)), true);
}
function fs(O, e) {
  return S.cursor(e ? O.to : O.from);
}
function v$(O, e) {
  return ut(O, (t) => t.empty ? O.moveByChar(t, e) : fs(t, e));
}
function we(O) {
  return O.textDirectionAt(O.state.selection.main.head) == ne.LTR;
}
var k$ = (O) => v$(O, !we(O));
var Y$ = (O) => v$(O, we(O));
function Z$(O, e) {
  return ut(O, (t) => t.empty ? O.moveByGroup(t, e) : fs(t, e));
}
var db = (O) => Z$(O, !we(O));
var Qb = (O) => Z$(O, we(O));
function $b(O, e, t) {
  if (e.type.prop(t))
    return true;
  let i = e.to - e.from;
  return i && (i > 2 || /[^\s,.;:]/.test(O.sliceDoc(e.from, e.to))) || e.firstChild;
}
function ds(O, e, t) {
  let i = B(O).resolveInner(e.head), n = t ? _.closedBy : _.openedBy;
  for (let a = e.head; ; ) {
    let l = t ? i.childAfter(a) : i.childBefore(a);
    if (!l)
      break;
    $b(O, l, n) ? i = l : a = t ? l.to : l.from;
  }
  let r = i.type.prop(n), s, o;
  return r && (s = t ? St(O, i.from, 1) : St(O, i.to, -1)) && s.matched ? o = t ? s.end.to : s.end.from : o = t ? i.to : i.from, S.cursor(o, t ? -1 : 1);
}
var pb = (O) => ut(O, (e) => ds(O.state, e, !we(O)));
var mb = (O) => ut(O, (e) => ds(O.state, e, we(O)));
function q$(O, e) {
  return ut(O, (t) => {
    if (!t.empty)
      return fs(t, e);
    let i = O.moveVertically(t, e);
    return i.head != t.head ? i : O.moveToLineBoundary(t, e);
  });
}
var z$ = (O) => q$(O, false);
var U$ = (O) => q$(O, true);
function V$(O) {
  return Math.max(O.defaultLineHeight, Math.min(O.dom.clientHeight, innerHeight) - 5);
}
function R$(O, e) {
  let { state: t } = O, i = si(t.selection, (o) => o.empty ? O.moveVertically(o, e, V$(O)) : fs(o, e));
  if (i.eq(t.selection))
    return false;
  let n = O.coordsAtPos(t.selection.main.head), r = O.scrollDOM.getBoundingClientRect(), s;
  return n && n.top > r.top && n.bottom < r.bottom && n.top - r.top <= O.scrollDOM.scrollHeight - O.scrollDOM.scrollTop - O.scrollDOM.clientHeight && (s = k.scrollIntoView(i.main.head, { y: "start", yMargin: n.top - r.top })), O.dispatch(Tt(t, i), { effects: s }), true;
}
var Hh = (O) => R$(O, false);
var Ta = (O) => R$(O, true);
function oO(O, e, t) {
  let i = O.lineBlockAt(e.head), n = O.moveToLineBoundary(e, t);
  if (n.head == e.head && n.head != (t ? i.to : i.from) && (n = O.moveToLineBoundary(e, t, false)), !t && n.head == i.from && i.length) {
    let r = /^\s*/.exec(O.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    r && e.head != i.from + r && (n = S.cursor(i.from + r));
  }
  return n;
}
var gb = (O) => ut(O, (e) => oO(O, e, true));
var Sb = (O) => ut(O, (e) => oO(O, e, false));
var Pb = (O) => ut(O, (e) => oO(O, e, !we(O)));
var yb = (O) => ut(O, (e) => oO(O, e, we(O)));
var Xb = (O) => ut(O, (e) => S.cursor(O.lineBlockAt(e.head).from, 1));
var xb = (O) => ut(O, (e) => S.cursor(O.lineBlockAt(e.head).to, -1));
function bb(O, e, t) {
  let i = false, n = si(O.selection, (r) => {
    let s = St(O, r.head, -1) || St(O, r.head, 1) || r.head > 0 && St(O, r.head - 1, 1) || r.head < O.doc.length && St(O, r.head + 1, -1);
    if (!s || !s.end)
      return r;
    i = true;
    let o = s.start.from == r.head ? s.end.to : s.end.from;
    return t ? S.range(r.anchor, o) : S.cursor(o);
  });
  return i ? (e(Tt(O, n)), true) : false;
}
var wb = ({ state: O, dispatch: e }) => bb(O, e, false);
function Ot(O, e) {
  let t = si(O.state.selection, (i) => {
    let n = e(i);
    return S.range(i.anchor, n.head, n.goalColumn, n.bidiLevel || void 0);
  });
  return t.eq(O.state.selection) ? false : (O.dispatch(Tt(O.state, t)), true);
}
function _$(O, e) {
  return Ot(O, (t) => O.moveByChar(t, e));
}
var j$ = (O) => _$(O, !we(O));
var C$ = (O) => _$(O, we(O));
function G$(O, e) {
  return Ot(O, (t) => O.moveByGroup(t, e));
}
var Tb = (O) => G$(O, !we(O));
var Wb = (O) => G$(O, we(O));
var vb = (O) => Ot(O, (e) => ds(O.state, e, !we(O)));
var kb = (O) => Ot(O, (e) => ds(O.state, e, we(O)));
function I$(O, e) {
  return Ot(O, (t) => O.moveVertically(t, e));
}
var E$ = (O) => I$(O, false);
var A$ = (O) => I$(O, true);
function D$(O, e) {
  return Ot(O, (t) => O.moveVertically(t, e, V$(O)));
}
var Kh = (O) => D$(O, false);
var Jh = (O) => D$(O, true);
var Yb = (O) => Ot(O, (e) => oO(O, e, true));
var Zb = (O) => Ot(O, (e) => oO(O, e, false));
var qb = (O) => Ot(O, (e) => oO(O, e, !we(O)));
var zb = (O) => Ot(O, (e) => oO(O, e, we(O)));
var Ub = (O) => Ot(O, (e) => S.cursor(O.lineBlockAt(e.head).from));
var Vb = (O) => Ot(O, (e) => S.cursor(O.lineBlockAt(e.head).to));
var eu = ({ state: O, dispatch: e }) => (e(Tt(O, { anchor: 0 })), true);
var tu = ({ state: O, dispatch: e }) => (e(Tt(O, { anchor: O.doc.length })), true);
var Ou = ({ state: O, dispatch: e }) => (e(Tt(O, { anchor: O.selection.main.anchor, head: 0 })), true);
var iu = ({ state: O, dispatch: e }) => (e(Tt(O, { anchor: O.selection.main.anchor, head: O.doc.length })), true);
var Rb = ({ state: O, dispatch: e }) => (e(O.update({ selection: { anchor: 0, head: O.doc.length }, userEvent: "select" })), true);
var _b = ({ state: O, dispatch: e }) => {
  let t = $s(O).map(({ from: i, to: n }) => S.range(i, Math.min(n + 1, O.doc.length)));
  return e(O.update({ selection: S.create(t), userEvent: "select" })), true;
};
var jb = ({ state: O, dispatch: e }) => {
  let t = si(O.selection, (i) => {
    var n;
    let r = B(O).resolveInner(i.head, 1);
    for (; !(r.from < i.from && r.to >= i.to || r.to > i.to && r.from <= i.from || !(!((n = r.parent) === null || n === void 0) && n.parent)); )
      r = r.parent;
    return S.range(r.to, r.from);
  });
  return e(Tt(O, t)), true;
};
var Cb = ({ state: O, dispatch: e }) => {
  let t = O.selection, i = null;
  return t.ranges.length > 1 ? i = S.create([t.main]) : t.main.empty || (i = S.create([S.cursor(t.main.head)])), i ? (e(Tt(O, i)), true) : false;
};
function Qs(O, e) {
  if (O.state.readOnly)
    return false;
  let t = "delete.selection", { state: i } = O, n = i.changeByRange((r) => {
    let { from: s, to: o } = r;
    if (s == o) {
      let a = e(s);
      a < s ? (t = "delete.backward", a = jn(O, a, false)) : a > s && (t = "delete.forward", a = jn(O, a, true)), s = Math.min(s, a), o = Math.max(o, a);
    } else
      s = jn(O, s, false), o = jn(O, o, true);
    return s == o ? { range: r } : { changes: { from: s, to: o }, range: S.cursor(s) };
  });
  return n.changes.empty ? false : (O.dispatch(i.update(n, {
    scrollIntoView: true,
    userEvent: t,
    effects: t == "delete.selection" ? k.announce.of(i.phrase("Selection deleted")) : void 0
  })), true);
}
function jn(O, e, t) {
  if (O instanceof k)
    for (let i of O.state.facet(k.atomicRanges).map((n) => n(O)))
      i.between(e, e, (n, r) => {
        n < e && r > e && (e = t ? r : n);
      });
  return e;
}
var M$ = (O, e) => Qs(O, (t) => {
  let { state: i } = O, n = i.doc.lineAt(t), r, s;
  if (!e && t > n.from && t < n.from + 200 && !/[^ \t]/.test(r = n.text.slice(0, t - n.from))) {
    if (r[r.length - 1] == "	")
      return t - 1;
    let o = hn(r, i.tabSize), a = o % bO(i) || bO(i);
    for (let l = 0; l < a && r[r.length - 1 - l] == " "; l++)
      t--;
    s = t;
  } else
    s = ve(n.text, t - n.from, e, e) + n.from, s == t && n.number != (e ? i.doc.lines : 1) && (s += e ? 1 : -1);
  return s;
});
var Wa = (O) => M$(O, false);
var L$ = (O) => M$(O, true);
var B$ = (O, e) => Qs(O, (t) => {
  let i = t, { state: n } = O, r = n.doc.lineAt(i), s = n.charCategorizer(i);
  for (let o = null; ; ) {
    if (i == (e ? r.to : r.from)) {
      i == t && r.number != (e ? n.doc.lines : 1) && (i += e ? 1 : -1);
      break;
    }
    let a = ve(r.text, i - r.from, e) + r.from, l = r.text.slice(Math.min(i, a) - r.from, Math.max(i, a) - r.from), h2 = s(l);
    if (o != null && h2 != o)
      break;
    (l != " " || i != t) && (o = h2), i = a;
  }
  return i;
});
var N$ = (O) => B$(O, false);
var Gb = (O) => B$(O, true);
var F$ = (O) => Qs(O, (e) => {
  let t = O.lineBlockAt(e).to;
  return e < t ? t : Math.min(O.state.doc.length, e + 1);
});
var Ib = (O) => Qs(O, (e) => {
  let t = O.lineBlockAt(e).from;
  return e > t ? t : Math.max(0, e - 1);
});
var Eb = ({ state: O, dispatch: e }) => {
  if (O.readOnly)
    return false;
  let t = O.changeByRange((i) => ({
    changes: { from: i.from, to: i.to, insert: D.of(["", ""]) },
    range: S.cursor(i.from)
  }));
  return e(O.update(t, { scrollIntoView: true, userEvent: "input" })), true;
};
var Ab = ({ state: O, dispatch: e }) => {
  if (O.readOnly)
    return false;
  let t = O.changeByRange((i) => {
    if (!i.empty || i.from == 0 || i.from == O.doc.length)
      return { range: i };
    let n = i.from, r = O.doc.lineAt(n), s = n == r.from ? n - 1 : ve(r.text, n - r.from, false) + r.from, o = n == r.to ? n + 1 : ve(r.text, n - r.from, true) + r.from;
    return {
      changes: { from: s, to: o, insert: O.doc.slice(n, o).append(O.doc.slice(s, n)) },
      range: S.cursor(o)
    };
  });
  return t.changes.empty ? false : (e(O.update(t, { scrollIntoView: true, userEvent: "move.character" })), true);
};
function $s(O) {
  let e = [], t = -1;
  for (let i of O.selection.ranges) {
    let n = O.doc.lineAt(i.from), r = O.doc.lineAt(i.to);
    if (!i.empty && i.to == r.from && (r = O.doc.lineAt(i.to - 1)), t >= n.number) {
      let s = e[e.length - 1];
      s.to = r.to, s.ranges.push(i);
    } else
      e.push({ from: n.from, to: r.to, ranges: [i] });
    t = r.number + 1;
  }
  return e;
}
function H$(O, e, t) {
  if (O.readOnly)
    return false;
  let i = [], n = [];
  for (let r of $s(O)) {
    if (t ? r.to == O.doc.length : r.from == 0)
      continue;
    let s = O.doc.lineAt(t ? r.to + 1 : r.from - 1), o = s.length + 1;
    if (t) {
      i.push({ from: r.to, to: s.to }, { from: r.from, insert: s.text + O.lineBreak });
      for (let a of r.ranges)
        n.push(S.range(Math.min(O.doc.length, a.anchor + o), Math.min(O.doc.length, a.head + o)));
    } else {
      i.push({ from: s.from, to: r.from }, { from: r.to, insert: O.lineBreak + s.text });
      for (let a of r.ranges)
        n.push(S.range(a.anchor - o, a.head - o));
    }
  }
  return i.length ? (e(O.update({
    changes: i,
    scrollIntoView: true,
    selection: S.create(n, O.selection.mainIndex),
    userEvent: "move.line"
  })), true) : false;
}
var Db = ({ state: O, dispatch: e }) => H$(O, e, false);
var Mb = ({ state: O, dispatch: e }) => H$(O, e, true);
function K$(O, e, t) {
  if (O.readOnly)
    return false;
  let i = [];
  for (let n of $s(O))
    t ? i.push({ from: n.from, insert: O.doc.slice(n.from, n.to) + O.lineBreak }) : i.push({ from: n.to, insert: O.lineBreak + O.doc.slice(n.from, n.to) });
  return e(O.update({ changes: i, scrollIntoView: true, userEvent: "input.copyline" })), true;
}
var Lb = ({ state: O, dispatch: e }) => K$(O, e, false);
var Bb = ({ state: O, dispatch: e }) => K$(O, e, true);
var Nb = (O) => {
  if (O.state.readOnly)
    return false;
  let { state: e } = O, t = e.changes($s(e).map(({ from: n, to: r }) => (n > 0 ? n-- : r < e.doc.length && r++, { from: n, to: r }))), i = si(e.selection, (n) => O.moveVertically(n, true)).map(t);
  return O.dispatch({ changes: t, selection: i, scrollIntoView: true, userEvent: "delete.line" }), true;
};
function Fb(O, e) {
  if (/\(\)|\[\]|\{\}/.test(O.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let t = B(O).resolveInner(e), i = t.childBefore(e), n = t.childAfter(e), r;
  return i && n && i.to <= e && n.from >= e && (r = i.type.prop(_.closedBy)) && r.indexOf(n.name) > -1 && O.doc.lineAt(i.to).from == O.doc.lineAt(n.from).from ? { from: i.to, to: n.from } : null;
}
var Hb = J$(false);
var Kb = J$(true);
function J$(O) {
  return ({ state: e, dispatch: t }) => {
    if (e.readOnly)
      return false;
    let i = e.changeByRange((n) => {
      let { from: r, to: s } = n, o = e.doc.lineAt(r), a = !O && r == s && Fb(e, r);
      O && (r = s = (s <= o.to ? o : e.doc.lineAt(s)).to);
      let l = new cs(e, { simulateBreak: r, simulateDoubleBreak: !!a }), h2 = wl(l, r);
      for (h2 == null && (h2 = /^\s*/.exec(e.doc.lineAt(r).text)[0].length); s < o.to && /\s/.test(o.text[s - o.from]); )
        s++;
      a ? { from: r, to: s } = a : r > o.from && r < o.from + 100 && !/\S/.test(o.text.slice(0, r)) && (r = o.from);
      let u = ["", Fi(e, h2)];
      return a && u.push(Fi(e, l.lineIndent(o.from, -1))), {
        changes: { from: r, to: s, insert: D.of(u) },
        range: S.cursor(r + 1 + u[1].length)
      };
    });
    return t(e.update(i, { scrollIntoView: true, userEvent: "input" })), true;
  };
}
function Ul(O, e) {
  let t = -1;
  return O.changeByRange((i) => {
    let n = [];
    for (let s = i.from; s <= i.to; ) {
      let o = O.doc.lineAt(s);
      o.number > t && (i.empty || i.to > o.from) && (e(o, n, i), t = o.number), s = o.to + 1;
    }
    let r = O.changes(n);
    return {
      changes: n,
      range: S.range(r.mapPos(i.anchor, 1), r.mapPos(i.head, 1))
    };
  });
}
var Jb = ({ state: O, dispatch: e }) => {
  if (O.readOnly)
    return false;
  let t = /* @__PURE__ */ Object.create(null), i = new cs(O, { overrideIndentation: (r) => {
    let s = t[r];
    return s ?? -1;
  } }), n = Ul(O, (r, s, o) => {
    let a = wl(i, r.from);
    if (a == null)
      return;
    /\S/.test(r.text) || (a = 0);
    let l = /^\s*/.exec(r.text)[0], h2 = Fi(O, a);
    (l != h2 || o.from < r.from + l.length) && (t[r.from] = a, s.push({ from: r.from, to: r.from + l.length, insert: h2 }));
  });
  return n.changes.empty || e(O.update(n, { userEvent: "indent" })), true;
};
var ep = ({ state: O, dispatch: e }) => O.readOnly ? false : (e(O.update(Ul(O, (t, i) => {
  i.push({ from: t.from, insert: O.facet(dn) });
}), { userEvent: "input.indent" })), true);
var tp = ({ state: O, dispatch: e }) => O.readOnly ? false : (e(O.update(Ul(O, (t, i) => {
  let n = /^\s*/.exec(t.text)[0];
  if (!n)
    return;
  let r = hn(n, O.tabSize), s = 0, o = Fi(O, Math.max(0, r - bO(O)));
  for (; s < n.length && s < o.length && n.charCodeAt(s) == o.charCodeAt(s); )
    s++;
  i.push({ from: t.from + s, to: t.from + n.length, insert: o.slice(s) });
}), { userEvent: "delete.dedent" })), true);
var e1 = [
  { key: "Ctrl-b", run: k$, shift: j$, preventDefault: true },
  { key: "Ctrl-f", run: Y$, shift: C$ },
  { key: "Ctrl-p", run: z$, shift: E$ },
  { key: "Ctrl-n", run: U$, shift: A$ },
  { key: "Ctrl-a", run: Xb, shift: Ub },
  { key: "Ctrl-e", run: xb, shift: Vb },
  { key: "Ctrl-d", run: L$ },
  { key: "Ctrl-h", run: Wa },
  { key: "Ctrl-k", run: F$ },
  { key: "Ctrl-Alt-h", run: N$ },
  { key: "Ctrl-o", run: Eb },
  { key: "Ctrl-t", run: Ab },
  { key: "Ctrl-v", run: Ta }
];
var t1 = [
  { key: "ArrowLeft", run: k$, shift: j$, preventDefault: true },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: db, shift: Tb, preventDefault: true },
  { mac: "Cmd-ArrowLeft", run: Pb, shift: qb, preventDefault: true },
  { key: "ArrowRight", run: Y$, shift: C$, preventDefault: true },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: Qb, shift: Wb, preventDefault: true },
  { mac: "Cmd-ArrowRight", run: yb, shift: zb, preventDefault: true },
  { key: "ArrowUp", run: z$, shift: E$, preventDefault: true },
  { mac: "Cmd-ArrowUp", run: eu, shift: Ou },
  { mac: "Ctrl-ArrowUp", run: Hh, shift: Kh },
  { key: "ArrowDown", run: U$, shift: A$, preventDefault: true },
  { mac: "Cmd-ArrowDown", run: tu, shift: iu },
  { mac: "Ctrl-ArrowDown", run: Ta, shift: Jh },
  { key: "PageUp", run: Hh, shift: Kh },
  { key: "PageDown", run: Ta, shift: Jh },
  { key: "Home", run: Sb, shift: Zb, preventDefault: true },
  { key: "Mod-Home", run: eu, shift: Ou },
  { key: "End", run: gb, shift: Yb, preventDefault: true },
  { key: "Mod-End", run: tu, shift: iu },
  { key: "Enter", run: Hb },
  { key: "Mod-a", run: Rb },
  { key: "Backspace", run: Wa, shift: Wa },
  { key: "Delete", run: L$ },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: N$ },
  { key: "Mod-Delete", mac: "Alt-Delete", run: Gb },
  { mac: "Mod-Backspace", run: Ib },
  { mac: "Mod-Delete", run: F$ }
].concat(e1.map((O) => ({ mac: O.key, run: O.run, shift: O.shift })));
var O1 = [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: pb, shift: vb },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: mb, shift: kb },
  { key: "Alt-ArrowUp", run: Db },
  { key: "Shift-Alt-ArrowUp", run: Lb },
  { key: "Alt-ArrowDown", run: Mb },
  { key: "Shift-Alt-ArrowDown", run: Bb },
  { key: "Escape", run: Cb },
  { key: "Mod-Enter", run: Kb },
  { key: "Alt-l", mac: "Ctrl-l", run: _b },
  { key: "Mod-i", run: jb, preventDefault: true },
  { key: "Mod-[", run: tp },
  { key: "Mod-]", run: ep },
  { key: "Mod-Alt-\\", run: Jb },
  { key: "Shift-Mod-k", run: Nb },
  { key: "Shift-Mod-\\", run: wb },
  { key: "Mod-/", run: Bx },
  { key: "Alt-A", run: Fx }
].concat(t1);
var i1 = { key: "Tab", run: ep, shift: tp };
function N() {
  var O = arguments[0];
  typeof O == "string" && (O = document.createElement(O));
  var e = 1, t = arguments[1];
  if (t && typeof t == "object" && t.nodeType == null && !Array.isArray(t)) {
    for (var i in t)
      if (Object.prototype.hasOwnProperty.call(t, i)) {
        var n = t[i];
        typeof n == "string" ? O.setAttribute(i, n) : n != null && (O[i] = n);
      }
    e++;
  }
  for (; e < arguments.length; e++)
    Op(O, arguments[e]);
  return O;
}
function Op(O, e) {
  if (typeof e == "string")
    O.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null)
      O.appendChild(e);
    else if (Array.isArray(e))
      for (var t = 0; t < e.length; t++)
        Op(O, e[t]);
    else
      throw new RangeError("Unsupported child node: " + e);
}
var nu = typeof String.prototype.normalize == "function" ? (O) => O.normalize("NFKD") : (O) => O;
var HO = class {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, t, i = 0, n = e.length, r, s) {
    this.test = s, this.value = { from: 0, to: 0 }, this.done = false, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(i, n), this.bufferStart = i, this.normalize = r ? (o) => r(nu(o)) : nu, this.query = this.normalize(t);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Pe(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = true, this;
      let t = ll(e), i = this.bufferStart + this.bufferPos;
      this.bufferPos += De(e);
      let n = this.normalize(t);
      for (let r = 0, s = i; ; r++) {
        let o = n.charCodeAt(r), a = this.match(o, s);
        if (a)
          return this.value = a, this;
        if (r == n.length - 1)
          break;
        s == i && r < t.length && t.charCodeAt(r) == o && s++;
      }
    }
  }
  match(e, t) {
    let i = null;
    for (let n = 0; n < this.matches.length; n += 2) {
      let r = this.matches[n], s = false;
      this.query.charCodeAt(r) == e && (r == this.query.length - 1 ? i = { from: this.matches[n + 1], to: t + 1 } : (this.matches[n]++, s = true)), s || (this.matches.splice(n, 2), n -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: t, to: t + 1 } : this.matches.push(1, t)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferPos) && (i = null), i;
  }
};
typeof Symbol < "u" && (HO.prototype[Symbol.iterator] = function() {
  return this;
});
var ip = { from: -1, to: -1, match: /.*/.exec("") };
var Vl = "gm" + (/x/.unicode == null ? "" : "u");
var np = class {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, t, i, n = 0, r = e.length) {
    if (this.text = e, this.to = r, this.curLine = "", this.done = false, this.value = ip, /\\[sWDnr]|\n|\r|\[\^/.test(t))
      return new rp(e, t, i, n, r);
    this.re = new RegExp(t, Vl + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.iter = e.iter();
    let s = e.lineAt(n);
    this.curLineStart = s.from, this.matchPos = jr(e, n), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let t = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (t) {
        let i = this.curLineStart + t.index, n = i + t[0].length;
        if (this.matchPos = jr(this.text, n + (i == n ? 1 : 0)), i == this.curLineStart + this.curLine.length && this.nextLine(), (i < n || i > this.value.to) && (!this.test || this.test(i, n, t)))
          return this.value = { from: i, to: n, match: t }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = true, this;
    }
  }
};
var eo = /* @__PURE__ */ new WeakMap();
var AO = class {
  constructor(e, t) {
    this.from = e, this.text = t;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, t, i) {
    let n = eo.get(e);
    if (!n || n.from >= i || n.to <= t) {
      let o = new AO(t, e.sliceString(t, i));
      return eo.set(e, o), o;
    }
    if (n.from == t && n.to == i)
      return n;
    let { text: r, from: s } = n;
    return s > t && (r = e.sliceString(t, s) + r, s = t), n.to < i && (r += e.sliceString(n.to, i)), eo.set(e, new AO(s, r)), new AO(t, r.slice(t - s, i - s));
  }
};
var rp = class {
  constructor(e, t, i, n, r) {
    this.text = e, this.to = r, this.done = false, this.value = ip, this.matchPos = jr(e, n), this.re = new RegExp(t, Vl + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.flat = AO.get(e, n, this.chunkEnd(
      n + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, t = this.re.exec(this.flat.text);
      if (t && !t[0] && t.index == e && (this.re.lastIndex = e + 1, t = this.re.exec(this.flat.text)), t) {
        let i = this.flat.from + t.index, n = i + t[0].length;
        if ((this.flat.to >= this.to || t.index + t[0].length <= this.flat.text.length - 10) && (!this.test || this.test(i, n, t)))
          return this.value = { from: i, to: n, match: t }, this.matchPos = jr(this.text, n + (i == n ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = true, this;
      this.flat = AO.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
};
typeof Symbol < "u" && (np.prototype[Symbol.iterator] = rp.prototype[Symbol.iterator] = function() {
  return this;
});
function n1(O) {
  try {
    return new RegExp(O, Vl), true;
  } catch {
    return false;
  }
}
function jr(O, e) {
  if (e >= O.length)
    return e;
  let t = O.lineAt(e), i;
  for (; e < t.to && (i = t.text.charCodeAt(e - t.from)) >= 56320 && i < 57344; )
    e++;
  return e;
}
function va(O) {
  let e = N("input", { class: "cm-textfield", name: "line" }), t = N("form", {
    class: "cm-gotoLine",
    onkeydown: (n) => {
      n.keyCode == 27 ? (n.preventDefault(), O.dispatch({ effects: Cr.of(false) }), O.focus()) : n.keyCode == 13 && (n.preventDefault(), i());
    },
    onsubmit: (n) => {
      n.preventDefault(), i();
    }
  }, N("label", O.state.phrase("Go to line"), ": ", e), " ", N("button", { class: "cm-button", type: "submit" }, O.state.phrase("go")));
  function i() {
    let n = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(e.value);
    if (!n)
      return;
    let { state: r } = O, s = r.doc.lineAt(r.selection.main.head), [, o, a, l, h2] = n, u = l ? +l.slice(1) : 0, f = a ? +a : s.number;
    if (a && h2) {
      let Q = f / 100;
      o && (Q = Q * (o == "-" ? -1 : 1) + s.number / r.doc.lines), f = Math.round(r.doc.lines * Q);
    } else
      a && o && (f = f * (o == "-" ? -1 : 1) + s.number);
    let d = r.doc.line(Math.max(1, Math.min(r.doc.lines, f)));
    O.dispatch({
      effects: Cr.of(false),
      selection: S.cursor(d.from + Math.max(0, Math.min(u, d.length))),
      scrollIntoView: true
    }), O.focus();
  }
  return { dom: t };
}
var Cr = j.define();
var ru = me.define({
  create() {
    return true;
  },
  update(O, e) {
    for (let t of e.effects)
      t.is(Cr) && (O = t.value);
    return O;
  },
  provide: (O) => Bi.from(O, (e) => e ? va : null)
});
var r1 = (O) => {
  let e = Li(O, va);
  if (!e) {
    let t = [Cr.of(true)];
    O.state.field(ru, false) == null && t.push(j.appendConfig.of([ru, s1])), O.dispatch({ effects: t }), e = Li(O, va);
  }
  return e && e.dom.querySelector("input").focus(), true;
};
var s1 = k.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
});
var o1 = {
  highlightWordAroundCursor: false,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: false
};
var sp = q.define({
  combine(O) {
    return bt(O, o1, {
      highlightWordAroundCursor: (e, t) => e || t,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function a1(O) {
  let e = [f1, u1];
  return O && e.push(sp.of(O)), e;
}
var l1 = V.mark({ class: "cm-selectionMatch" });
var c1 = V.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function su(O, e, t, i) {
  return (t == 0 || O(e.sliceDoc(t - 1, t)) != ee.Word) && (i == e.doc.length || O(e.sliceDoc(i, i + 1)) != ee.Word);
}
function h1(O, e, t, i) {
  return O(e.sliceDoc(t, t + 1)) == ee.Word && O(e.sliceDoc(i - 1, i)) == ee.Word;
}
var u1 = se.fromClass(class {
  constructor(O) {
    this.decorations = this.getDeco(O);
  }
  update(O) {
    (O.selectionSet || O.docChanged || O.viewportChanged) && (this.decorations = this.getDeco(O.view));
  }
  getDeco(O) {
    let e = O.state.facet(sp), { state: t } = O, i = t.selection;
    if (i.ranges.length > 1)
      return V.none;
    let n = i.main, r, s = null;
    if (n.empty) {
      if (!e.highlightWordAroundCursor)
        return V.none;
      let a = t.wordAt(n.head);
      if (!a)
        return V.none;
      s = t.charCategorizer(n.head), r = t.sliceDoc(a.from, a.to);
    } else {
      let a = n.to - n.from;
      if (a < e.minSelectionLength || a > 200)
        return V.none;
      if (e.wholeWords) {
        if (r = t.sliceDoc(n.from, n.to), s = t.charCategorizer(n.head), !(su(s, t, n.from, n.to) && h1(s, t, n.from, n.to)))
          return V.none;
      } else if (r = t.sliceDoc(n.from, n.to).trim(), !r)
        return V.none;
    }
    let o = [];
    for (let a of O.visibleRanges) {
      let l = new HO(t.doc, r, a.from, a.to);
      for (; !l.next().done; ) {
        let { from: h2, to: u } = l.value;
        if ((!s || su(s, t, h2, u)) && (n.empty && h2 <= n.from && u >= n.to ? o.push(c1.range(h2, u)) : (h2 >= n.to || u <= n.from) && o.push(l1.range(h2, u)), o.length > e.maxMatches))
          return V.none;
      }
    }
    return V.set(o);
  }
}, {
  decorations: (O) => O.decorations
});
var f1 = k.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
});
var d1 = ({ state: O, dispatch: e }) => {
  let { selection: t } = O, i = S.create(t.ranges.map((n) => O.wordAt(n.head) || S.cursor(n.head)), t.mainIndex);
  return i.eq(t) ? false : (e(O.update({ selection: i })), true);
};
function Q1(O, e) {
  let { main: t, ranges: i } = O.selection, n = O.wordAt(t.head), r = n && n.from == t.from && n.to == t.to;
  for (let s = false, o = new HO(O.doc, e, i[i.length - 1].to); ; )
    if (o.next(), o.done) {
      if (s)
        return null;
      o = new HO(O.doc, e, 0, Math.max(0, i[i.length - 1].from - 1)), s = true;
    } else {
      if (s && i.some((a) => a.from == o.value.from))
        continue;
      if (r) {
        let a = O.wordAt(o.value.from);
        if (!a || a.from != o.value.from || a.to != o.value.to)
          continue;
      }
      return o.value;
    }
}
var $1 = ({ state: O, dispatch: e }) => {
  let { ranges: t } = O.selection;
  if (t.some((r) => r.from === r.to))
    return d1({ state: O, dispatch: e });
  let i = O.sliceDoc(t[0].from, t[0].to);
  if (O.selection.ranges.some((r) => O.sliceDoc(r.from, r.to) != i))
    return false;
  let n = Q1(O, i);
  return n ? (e(O.update({
    selection: O.selection.addRange(S.range(n.from, n.to), false),
    effects: k.scrollIntoView(n.to)
  })), true) : false;
};
var Rl = q.define({
  combine(O) {
    return bt(O, {
      top: false,
      caseSensitive: false,
      literal: false,
      wholeWord: false,
      createPanel: (e) => new W1(e)
    });
  }
});
var op = class {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || n1(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (t, i) => i == "n" ? `
` : i == "r" ? "\r" : i == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new S1(this) : new m1(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, t = 0, i) {
    let n = e.doc ? e : I.create({ doc: e });
    return i == null && (i = n.doc.length), this.regexp ? UO(this, n, t, i) : zO(this, n, t, i);
  }
};
var ap = class {
  constructor(e) {
    this.spec = e;
  }
};
function zO(O, e, t, i) {
  return new HO(e.doc, O.unquoted, t, i, O.caseSensitive ? void 0 : (n) => n.toLowerCase(), O.wholeWord ? p1(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function p1(O, e) {
  return (t, i, n, r) => ((r > t || r + n.length < i) && (r = Math.max(0, t - 2), n = O.sliceString(r, Math.min(O.length, i + 2))), (e(Gr(n, t - r)) != ee.Word || e(Ir(n, t - r)) != ee.Word) && (e(Ir(n, i - r)) != ee.Word || e(Gr(n, i - r)) != ee.Word));
}
var m1 = class extends ap {
  constructor(e) {
    super(e);
  }
  nextMatch(e, t, i) {
    let n = zO(this.spec, e, i, e.doc.length).nextOverlapping();
    return n.done && (n = zO(this.spec, e, 0, t).nextOverlapping()), n.done ? null : n.value;
  }
  // Searching in reverse is, rather than implementing inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, t, i) {
    for (let n = i; ; ) {
      let r = Math.max(t, n - 1e4 - this.spec.unquoted.length), s = zO(this.spec, e, r, n), o = null;
      for (; !s.nextOverlapping().done; )
        o = s.value;
      if (o)
        return o;
      if (r == t)
        return null;
      n -= 1e4;
    }
  }
  prevMatch(e, t, i) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, t) {
    let i = zO(this.spec, e, 0, e.doc.length), n = [];
    for (; !i.next().done; ) {
      if (n.length >= t)
        return null;
      n.push(i.value);
    }
    return n;
  }
  highlight(e, t, i, n) {
    let r = zO(this.spec, e, Math.max(0, t - this.spec.unquoted.length), Math.min(i + this.spec.unquoted.length, e.doc.length));
    for (; !r.next().done; )
      n(r.value.from, r.value.to);
  }
};
function UO(O, e, t, i) {
  return new np(e.doc, O.search, {
    ignoreCase: !O.caseSensitive,
    test: O.wholeWord ? g1(e.charCategorizer(e.selection.main.head)) : void 0
  }, t, i);
}
function Gr(O, e) {
  return O.slice(ve(O, e, false), e);
}
function Ir(O, e) {
  return O.slice(e, ve(O, e));
}
function g1(O) {
  return (e, t, i) => !i[0].length || (O(Gr(i.input, i.index)) != ee.Word || O(Ir(i.input, i.index)) != ee.Word) && (O(Ir(i.input, i.index + i[0].length)) != ee.Word || O(Gr(i.input, i.index + i[0].length)) != ee.Word);
}
var S1 = class extends ap {
  nextMatch(e, t, i) {
    let n = UO(this.spec, e, i, e.doc.length).next();
    return n.done && (n = UO(this.spec, e, 0, t).next()), n.done ? null : n.value;
  }
  prevMatchInRange(e, t, i) {
    for (let n = 1; ; n++) {
      let r = Math.max(
        t,
        i - n * 1e4
        /* FindPrev.ChunkSize */
      ), s = UO(this.spec, e, r, i), o = null;
      for (; !s.next().done; )
        o = s.value;
      if (o && (r == t || o.from > r + 10))
        return o;
      if (r == t)
        return null;
    }
  }
  prevMatch(e, t, i) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace.replace(/\$([$&\d+])/g, (t, i) => i == "$" ? "$" : i == "&" ? e.match[0] : i != "0" && +i < e.match.length ? e.match[i] : t));
  }
  matchAll(e, t) {
    let i = UO(this.spec, e, 0, e.doc.length), n = [];
    for (; !i.next().done; ) {
      if (n.length >= t)
        return null;
      n.push(i.value);
    }
    return n;
  }
  highlight(e, t, i, n) {
    let r = UO(this.spec, e, Math.max(
      0,
      t - 250
      /* RegExp.HighlightMargin */
    ), Math.min(i + 250, e.doc.length));
    for (; !r.next().done; )
      n(r.value.from, r.value.to);
  }
};
var Ki = j.define();
var _l = j.define();
var Ht = me.define({
  create(O) {
    return new to(ka(O).create(), null);
  },
  update(O, e) {
    for (let t of e.effects)
      t.is(Ki) ? O = new to(t.value.create(), O.panel) : t.is(_l) && (O = new to(O.query, t.value ? jl : null));
    return O;
  },
  provide: (O) => Bi.from(O, (e) => e.panel)
});
var to = class {
  constructor(e, t) {
    this.query = e, this.panel = t;
  }
};
var P1 = V.mark({ class: "cm-searchMatch" });
var y1 = V.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
var X1 = se.fromClass(class {
  constructor(O) {
    this.view = O, this.decorations = this.highlight(O.state.field(Ht));
  }
  update(O) {
    let e = O.state.field(Ht);
    (e != O.startState.field(Ht) || O.docChanged || O.selectionSet || O.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: O, panel: e }) {
    if (!e || !O.spec.valid)
      return V.none;
    let { view: t } = this, i = new eO();
    for (let n = 0, r = t.visibleRanges, s = r.length; n < s; n++) {
      let { from: o, to: a } = r[n];
      for (; n < s - 1 && a > r[n + 1].from - 2 * 250; )
        a = r[++n].to;
      O.highlight(t.state, o, a, (l, h2) => {
        let u = t.state.selection.ranges.some((f) => f.from == l && f.to == h2);
        i.add(l, h2, u ? y1 : P1);
      });
    }
    return i.finish();
  }
}, {
  decorations: (O) => O.decorations
});
function $n(O) {
  return (e) => {
    let t = e.state.field(Ht, false);
    return t && t.query.spec.valid ? O(e, t) : lp(e);
  };
}
var Er = $n((O, { query: e }) => {
  let { to: t } = O.state.selection.main, i = e.nextMatch(O.state, t, t);
  return i ? (O.dispatch({
    selection: { anchor: i.from, head: i.to },
    scrollIntoView: true,
    effects: Cl(O, i),
    userEvent: "select.search"
  }), true) : false;
});
var Ar = $n((O, { query: e }) => {
  let { state: t } = O, { from: i } = t.selection.main, n = e.prevMatch(t, i, i);
  return n ? (O.dispatch({
    selection: { anchor: n.from, head: n.to },
    scrollIntoView: true,
    effects: Cl(O, n),
    userEvent: "select.search"
  }), true) : false;
});
var x1 = $n((O, { query: e }) => {
  let t = e.matchAll(O.state, 1e3);
  return !t || !t.length ? false : (O.dispatch({
    selection: S.create(t.map((i) => S.range(i.from, i.to))),
    userEvent: "select.search.matches"
  }), true);
});
var b1 = ({ state: O, dispatch: e }) => {
  let t = O.selection;
  if (t.ranges.length > 1 || t.main.empty)
    return false;
  let { from: i, to: n } = t.main, r = [], s = 0;
  for (let o = new HO(O.doc, O.sliceDoc(i, n)); !o.next().done; ) {
    if (r.length > 1e3)
      return false;
    o.value.from == i && (s = r.length), r.push(S.range(o.value.from, o.value.to));
  }
  return e(O.update({
    selection: S.create(r, s),
    userEvent: "select.search.matches"
  })), true;
};
var ou = $n((O, { query: e }) => {
  let { state: t } = O, { from: i, to: n } = t.selection.main;
  if (t.readOnly)
    return false;
  let r = e.nextMatch(t, i, i);
  if (!r)
    return false;
  let s = [], o, a, l = [];
  if (r.from == i && r.to == n && (a = t.toText(e.getReplacement(r)), s.push({ from: r.from, to: r.to, insert: a }), r = e.nextMatch(t, r.from, r.to), l.push(k.announce.of(t.phrase("replaced match on line $", t.doc.lineAt(i).number) + "."))), r) {
    let h2 = s.length == 0 || s[0].from >= r.to ? 0 : r.to - r.from - a.length;
    o = { anchor: r.from - h2, head: r.to - h2 }, l.push(Cl(O, r));
  }
  return O.dispatch({
    changes: s,
    selection: o,
    scrollIntoView: !!o,
    effects: l,
    userEvent: "input.replace"
  }), true;
});
var w1 = $n((O, { query: e }) => {
  if (O.state.readOnly)
    return false;
  let t = e.matchAll(O.state, 1e9).map((n) => {
    let { from: r, to: s } = n;
    return { from: r, to: s, insert: e.getReplacement(n) };
  });
  if (!t.length)
    return false;
  let i = O.state.phrase("replaced $ matches", t.length) + ".";
  return O.dispatch({
    changes: t,
    effects: k.announce.of(i),
    userEvent: "input.replace.all"
  }), true;
});
function jl(O) {
  return O.state.facet(Rl).createPanel(O);
}
function ka(O, e) {
  var t, i, n, r;
  let s = O.selection.main, o = s.empty || s.to > s.from + 100 ? "" : O.sliceDoc(s.from, s.to);
  if (e && !o)
    return e;
  let a = O.facet(Rl);
  return new op({
    search: ((t = e == null ? void 0 : e.literal) !== null && t !== void 0 ? t : a.literal) ? o : o.replace(/\n/g, "\\n"),
    caseSensitive: (i = e == null ? void 0 : e.caseSensitive) !== null && i !== void 0 ? i : a.caseSensitive,
    literal: (n = e == null ? void 0 : e.literal) !== null && n !== void 0 ? n : a.literal,
    wholeWord: (r = e == null ? void 0 : e.wholeWord) !== null && r !== void 0 ? r : a.wholeWord
  });
}
var lp = (O) => {
  let e = O.state.field(Ht, false);
  if (e && e.panel) {
    let t = Li(O, jl);
    if (!t)
      return false;
    let i = t.dom.querySelector("[main-field]");
    if (i && i != O.root.activeElement) {
      let n = ka(O.state, e.query.spec);
      n.valid && O.dispatch({ effects: Ki.of(n) }), i.focus(), i.select();
    }
  } else
    O.dispatch({ effects: [
      _l.of(true),
      e ? Ki.of(ka(O.state, e.query.spec)) : j.appendConfig.of(k1)
    ] });
  return true;
};
var cp = (O) => {
  let e = O.state.field(Ht, false);
  if (!e || !e.panel)
    return false;
  let t = Li(O, jl);
  return t && t.dom.contains(O.root.activeElement) && O.focus(), O.dispatch({ effects: _l.of(false) }), true;
};
var T1 = [
  { key: "Mod-f", run: lp, scope: "editor search-panel" },
  { key: "F3", run: Er, shift: Ar, scope: "editor search-panel", preventDefault: true },
  { key: "Mod-g", run: Er, shift: Ar, scope: "editor search-panel", preventDefault: true },
  { key: "Escape", run: cp, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: b1 },
  { key: "Alt-g", run: r1 },
  { key: "Mod-d", run: $1, preventDefault: true }
];
var W1 = class {
  constructor(e) {
    this.view = e;
    let t = this.query = e.state.field(Ht).query.spec;
    this.commit = this.commit.bind(this), this.searchField = N("input", {
      value: t.search,
      placeholder: Ie(e, "Find"),
      "aria-label": Ie(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = N("input", {
      value: t.replace,
      placeholder: Ie(e, "Replace"),
      "aria-label": Ie(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = N("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: t.caseSensitive,
      onchange: this.commit
    }), this.reField = N("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: t.regexp,
      onchange: this.commit
    }), this.wordField = N("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: t.wholeWord,
      onchange: this.commit
    });
    function i(n, r, s) {
      return N("button", { class: "cm-button", name: n, onclick: r, type: "button" }, s);
    }
    this.dom = N("div", { onkeydown: (n) => this.keydown(n), class: "cm-search" }, [
      this.searchField,
      i("next", () => Er(e), [Ie(e, "next")]),
      i("prev", () => Ar(e), [Ie(e, "previous")]),
      i("select", () => x1(e), [Ie(e, "all")]),
      N("label", null, [this.caseField, Ie(e, "match case")]),
      N("label", null, [this.reField, Ie(e, "regexp")]),
      N("label", null, [this.wordField, Ie(e, "by word")]),
      ...e.state.readOnly ? [] : [
        N("br"),
        this.replaceField,
        i("replace", () => ou(e), [Ie(e, "replace")]),
        i("replaceAll", () => w1(e), [Ie(e, "replace all")])
      ],
      N("button", {
        name: "close",
        onclick: () => cp(e),
        "aria-label": Ie(e, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let e = new op({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: Ki.of(e) }));
  }
  keydown(e) {
    jy(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? Ar : Er)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), ou(this.view));
  }
  update(e) {
    for (let t of e.transactions)
      for (let i of t.effects)
        i.is(Ki) && !i.value.eq(this.query) && this.setQuery(i.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(Rl).top;
  }
};
function Ie(O, e) {
  return O.state.phrase(e);
}
var Cn = 30;
var Gn = /[\s\.,:;?!]/;
function Cl(O, { from: e, to: t }) {
  let i = O.state.doc.lineAt(e), n = O.state.doc.lineAt(t).to, r = Math.max(i.from, e - Cn), s = Math.min(n, t + Cn), o = O.state.sliceDoc(r, s);
  if (r != i.from) {
    for (let a = 0; a < Cn; a++)
      if (!Gn.test(o[a + 1]) && Gn.test(o[a])) {
        o = o.slice(a);
        break;
      }
  }
  if (s != n) {
    for (let a = o.length - 1; a > o.length - Cn; a--)
      if (!Gn.test(o[a - 1]) && Gn.test(o[a])) {
        o = o.slice(0, a);
        break;
      }
  }
  return k.announce.of(`${O.state.phrase("current match")}. ${o} ${O.state.phrase("on line")} ${i.number}.`);
}
var v1 = k.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
});
var k1 = [
  Ht,
  rO.lowest(X1),
  v1
];
var hp = class {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(e, t, i) {
    this.state = e, this.pos = t, this.explicit = i, this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let t = B(this.state).resolveInner(this.pos, -1);
    for (; t && e.indexOf(t.name) < 0; )
      t = t.parent;
    return t ? {
      from: t.from,
      to: this.pos,
      text: this.state.sliceDoc(t.from, this.pos),
      type: t.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let t = this.state.doc.lineAt(this.pos), i = Math.max(t.from, this.pos - 250), n = t.text.slice(i - t.from, this.pos - t.from), r = n.search(up(e, false));
    return r < 0 ? null : { from: i + r, to: this.pos, text: n.slice(r) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(e, t) {
    e == "abort" && this.abortListeners && this.abortListeners.push(t);
  }
};
function au(O) {
  let e = Object.keys(O).join(""), t = /\w/.test(e);
  return t && (e = e.replace(/\w/g, "")), `[${t ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function Y1(O) {
  let e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null);
  for (let { label: n } of O) {
    e[n[0]] = true;
    for (let r = 1; r < n.length; r++)
      t[n[r]] = true;
  }
  let i = au(e) + au(t) + "*$";
  return [new RegExp("^" + i), new RegExp(i)];
}
function ps(O) {
  let e = O.map((n) => typeof n == "string" ? { label: n } : n), [t, i] = e.every((n) => /^\w+$/.test(n.label)) ? [/\w*$/, /\w+$/] : Y1(e);
  return (n) => {
    let r = n.matchBefore(i);
    return r || n.explicit ? { from: r ? r.from : n.pos, options: e, validFor: t } : null;
  };
}
function Gl(O, e) {
  return (t) => {
    for (let i = B(t.state).resolveInner(t.pos, -1); i; i = i.parent)
      if (O.indexOf(i.name) > -1)
        return null;
    return e(t);
  };
}
var lu = class {
  constructor(e, t, i) {
    this.completion = e, this.source = t, this.match = i;
  }
};
function Kt(O) {
  return O.selection.main.head;
}
function up(O, e) {
  var t;
  let { source: i } = O, n = e && i[0] != "^", r = i[i.length - 1] != "$";
  return !n && !r ? O : new RegExp(`${n ? "^" : ""}(?:${i})${r ? "$" : ""}`, (t = O.flags) !== null && t !== void 0 ? t : O.ignoreCase ? "i" : "");
}
var Z1 = sO.define();
function q1(O, e, t, i) {
  return Object.assign(Object.assign({}, O.changeByRange((n) => {
    if (n == O.selection.main)
      return {
        changes: { from: t, to: i, insert: e },
        range: S.cursor(t + e.length)
      };
    let r = i - t;
    return !n.empty || r && O.sliceDoc(n.from - r, n.from) != O.sliceDoc(t, i) ? { range: n } : {
      changes: { from: n.from - r, to: n.from, insert: e },
      range: S.cursor(n.from - r + e.length)
    };
  })), { userEvent: "input.complete" });
}
function fp(O, e) {
  const t = e.completion.apply || e.completion.label;
  let i = e.source;
  typeof t == "string" ? O.dispatch(Object.assign(Object.assign({}, q1(O.state, t, i.from, i.to)), { annotations: Z1.of(e.completion) })) : t(O, e.completion, i.from, i.to);
}
var cu = /* @__PURE__ */ new WeakMap();
function z1(O) {
  if (!Array.isArray(O))
    return O;
  let e = cu.get(O);
  return e || cu.set(O, e = ps(O)), e;
}
var U1 = class {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [];
    for (let t = 0; t < e.length; ) {
      let i = Pe(e, t), n = De(i);
      this.chars.push(i);
      let r = e.slice(t, t + n), s = r.toUpperCase();
      this.folded.push(Pe(s == r ? r.toLowerCase() : s, 0)), t += n;
    }
    this.astral = e.length != this.chars.length;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return null for no match, and otherwise an array that starts
  // with the match score, followed by any number of `from, to` pairs
  // indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return [0];
    if (e.length < this.pattern.length)
      return null;
    let { chars: t, folded: i, any: n, precise: r, byWord: s } = this;
    if (t.length == 1) {
      let g = Pe(e, 0);
      return g == t[0] ? [0, 0, De(g)] : g == i[0] ? [-200, 0, De(g)] : null;
    }
    let o = e.indexOf(this.pattern);
    if (o == 0)
      return [0, 0, this.pattern.length];
    let a = t.length, l = 0;
    if (o < 0) {
      for (let g = 0, b = Math.min(e.length, 200); g < b && l < a; ) {
        let y = Pe(e, g);
        (y == t[l] || y == i[l]) && (n[l++] = g), g += De(y);
      }
      if (l < a)
        return null;
    }
    let h2 = 0, u = 0, f = false, d = 0, Q = -1, $ = -1, p = /[a-z]/.test(e), m = true;
    for (let g = 0, b = Math.min(e.length, 200), y = 0; g < b && u < a; ) {
      let w = Pe(e, g);
      o < 0 && (h2 < a && w == t[h2] && (r[h2++] = g), d < a && (w == t[d] || w == i[d] ? (d == 0 && (Q = g), $ = g + 1, d++) : d = 0));
      let P, z = w < 255 ? w >= 48 && w <= 57 || w >= 97 && w <= 122 ? 2 : w >= 65 && w <= 90 ? 1 : 0 : (P = ll(w)) != P.toLowerCase() ? 1 : P != P.toUpperCase() ? 2 : 0;
      (!g || z == 1 && p || y == 0 && z != 0) && (t[u] == w || i[u] == w && (f = true) ? s[u++] = g : s.length && (m = false)), y = z, g += De(w);
    }
    return u == a && s[0] == 0 && m ? this.result(-100 + (f ? -200 : 0), s, e) : d == a && Q == 0 ? [-200 - e.length, 0, $] : o > -1 ? [-700 - e.length, o, o + this.pattern.length] : d == a ? [-200 + -700 - e.length, Q, $] : u == a ? this.result(-100 + (f ? -200 : 0) + -700 + (m ? 0 : -1100), s, e) : t.length == 2 ? null : this.result((n[0] ? -700 : 0) + -200 + -1100, n, e);
  }
  result(e, t, i) {
    let n = [e - i.length], r = 1;
    for (let s of t) {
      let o = s + (this.astral ? De(Pe(i, s)) : 1);
      r > 1 && n[r - 1] == s ? n[r - 1] = o : (n[r++] = s, n[r++] = o);
    }
    return n;
  }
};
var tt = q.define({
  combine(O) {
    return bt(O, {
      activateOnTyping: true,
      selectOnOpen: true,
      override: null,
      closeOnBlur: true,
      maxRenderedOptions: 100,
      defaultKeymap: true,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: false,
      icons: true,
      addToOptions: [],
      compareCompletions: (e, t) => e.label.localeCompare(t.label),
      interactionDelay: 75
    }, {
      defaultKeymap: (e, t) => e && t,
      closeOnBlur: (e, t) => e && t,
      icons: (e, t) => e && t,
      tooltipClass: (e, t) => (i) => hu(e(i), t(i)),
      optionClass: (e, t) => (i) => hu(e(i), t(i)),
      addToOptions: (e, t) => e.concat(t)
    });
  }
});
function hu(O, e) {
  return O ? e ? O + " " + e : O : e;
}
function V1(O) {
  let e = O.addToOptions.slice();
  return O.icons && e.push({
    render(t) {
      let i = document.createElement("div");
      return i.classList.add("cm-completionIcon"), t.type && i.classList.add(...t.type.split(/\s+/g).map((n) => "cm-completionIcon-" + n)), i.setAttribute("aria-hidden", "true"), i;
    },
    position: 20
  }), e.push({
    render(t, i, n) {
      let r = document.createElement("span");
      r.className = "cm-completionLabel";
      let { label: s } = t, o = 0;
      for (let a = 1; a < n.length; ) {
        let l = n[a++], h2 = n[a++];
        l > o && r.appendChild(document.createTextNode(s.slice(o, l)));
        let u = r.appendChild(document.createElement("span"));
        u.appendChild(document.createTextNode(s.slice(l, h2))), u.className = "cm-completionMatchedText", o = h2;
      }
      return o < s.length && r.appendChild(document.createTextNode(s.slice(o))), r;
    },
    position: 50
  }, {
    render(t) {
      if (!t.detail)
        return null;
      let i = document.createElement("span");
      return i.className = "cm-completionDetail", i.textContent = t.detail, i;
    },
    position: 80
  }), e.sort((t, i) => t.position - i.position).map((t) => t.render);
}
function uu(O, e, t) {
  if (O <= t)
    return { from: 0, to: O };
  if (e < 0 && (e = 0), e <= O >> 1) {
    let n = Math.floor(e / t);
    return { from: n * t, to: (n + 1) * t };
  }
  let i = Math.floor((O - e) / t);
  return { from: O - (i + 1) * t, to: O - i * t };
}
var R1 = class {
  constructor(e, t) {
    this.view = e, this.stateField = t, this.info = null, this.placeInfo = {
      read: () => this.measureInfo(),
      write: (o) => this.positionInfo(o),
      key: this
    }, this.space = null, this.currentClass = "";
    let i = e.state.field(t), { options: n, selected: r } = i.open, s = e.state.facet(tt);
    this.optionContent = V1(s), this.optionClass = s.optionClass, this.tooltipClass = s.tooltipClass, this.range = uu(n.length, r, s.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (o) => {
      for (let a = o.target, l; a && a != this.dom; a = a.parentNode)
        if (a.nodeName == "LI" && (l = /-(\d+)$/.exec(a.id)) && +l[1] < n.length) {
          fp(e, n[+l[1]]), o.preventDefault();
          return;
        }
    }), this.list = this.dom.appendChild(this.createListBox(n, i.id, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfo);
    });
  }
  mount() {
    this.updateSel();
  }
  update(e) {
    var t, i, n;
    let r = e.state.field(this.stateField), s = e.startState.field(this.stateField);
    this.updateTooltipClass(e.state), r != s && (this.updateSel(), ((t = r.open) === null || t === void 0 ? void 0 : t.disabled) != ((i = s.open) === null || i === void 0 ? void 0 : i.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!(!((n = r.open) === null || n === void 0) && n.disabled)));
  }
  updateTooltipClass(e) {
    let t = this.tooltipClass(e);
    if (t != this.currentClass) {
      for (let i of this.currentClass.split(" "))
        i && this.dom.classList.remove(i);
      for (let i of t.split(" "))
        i && this.dom.classList.add(i);
      this.currentClass = t;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfo);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), t = e.open;
    if ((t.selected > -1 && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = uu(t.options.length, t.selected, this.view.state.facet(tt).maxRenderedOptions), this.list.remove(), this.list = this.dom.appendChild(this.createListBox(t.options, e.id, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfo);
    })), this.updateSelectedOption(t.selected)) {
      this.info && (this.info.remove(), this.info = null);
      let { completion: i } = t.options[t.selected], { info: n } = i;
      if (!n)
        return;
      let r = typeof n == "string" ? document.createTextNode(n) : n(i);
      if (!r)
        return;
      "then" in r ? r.then((s) => {
        s && this.view.state.field(this.stateField, false) == e && this.addInfoPane(s);
      }).catch((s) => Ne(this.view.state, s, "completion info")) : this.addInfoPane(r);
    }
  }
  addInfoPane(e) {
    let t = this.info = document.createElement("div");
    t.className = "cm-tooltip cm-completionInfo", t.appendChild(e), this.dom.appendChild(t), this.view.requestMeasure(this.placeInfo);
  }
  updateSelectedOption(e) {
    let t = null;
    for (let i = this.list.firstChild, n = this.range.from; i; i = i.nextSibling, n++)
      n == e ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), t = i) : i.hasAttribute("aria-selected") && i.removeAttribute("aria-selected");
    return t && j1(this.list, t), t;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let t = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), n = e.getBoundingClientRect(), r = this.space;
    if (!r) {
      let Q = this.dom.ownerDocument.defaultView || window;
      r = { left: 0, top: 0, right: Q.innerWidth, bottom: Q.innerHeight };
    }
    if (n.top > Math.min(r.bottom, t.bottom) - 10 || n.bottom < Math.max(r.top, t.top) + 10)
      return null;
    let s = this.view.textDirection == ne.RTL, o = s, a = false, l, h2 = "", u = "", f = t.left - r.left, d = r.right - t.right;
    if (o && f < Math.min(i.width, d) ? o = false : !o && d < Math.min(i.width, f) && (o = true), i.width <= (o ? f : d))
      h2 = Math.max(r.top, Math.min(n.top, r.bottom - i.height)) - t.top + "px", l = Math.min(400, o ? f : d) + "px";
    else {
      a = true, l = Math.min(
        400,
        (s ? t.right : r.right - t.left) - 30
        /* Info.Margin */
      ) + "px";
      let Q = r.bottom - t.bottom;
      Q >= i.height || Q > t.top ? h2 = n.bottom - t.top + "px" : u = t.bottom - n.top + "px";
    }
    return {
      top: h2,
      bottom: u,
      maxWidth: l,
      class: a ? s ? "left-narrow" : "right-narrow" : o ? "left" : "right"
    };
  }
  positionInfo(e) {
    this.info && (e ? (this.info.style.top = e.top, this.info.style.bottom = e.bottom, this.info.style.maxWidth = e.maxWidth, this.info.className = "cm-tooltip cm-completionInfo cm-completionInfo-" + e.class) : this.info.style.top = "-1e6px");
  }
  createListBox(e, t, i) {
    const n = document.createElement("ul");
    n.id = t, n.setAttribute("role", "listbox"), n.setAttribute("aria-expanded", "true"), n.setAttribute("aria-label", this.view.state.phrase("Completions"));
    for (let r = i.from; r < i.to; r++) {
      let { completion: s, match: o } = e[r];
      const a = n.appendChild(document.createElement("li"));
      a.id = t + "-" + r, a.setAttribute("role", "option");
      let l = this.optionClass(s);
      l && (a.className = l);
      for (let h2 of this.optionContent) {
        let u = h2(s, this.view.state, o);
        u && a.appendChild(u);
      }
    }
    return i.from && n.classList.add("cm-completionListIncompleteTop"), i.to < e.length && n.classList.add("cm-completionListIncompleteBottom"), n;
  }
};
function _1(O) {
  return (e) => new R1(e, O);
}
function j1(O, e) {
  let t = O.getBoundingClientRect(), i = e.getBoundingClientRect();
  i.top < t.top ? O.scrollTop -= t.top - i.top : i.bottom > t.bottom && (O.scrollTop += i.bottom - t.bottom);
}
function fu(O) {
  return (O.boost || 0) * 100 + (O.apply ? 10 : 0) + (O.info ? 5 : 0) + (O.type ? 1 : 0);
}
function C1(O, e) {
  let t = [], i = 0;
  for (let o of O)
    if (o.hasResult())
      if (o.result.filter === false) {
        let a = o.result.getMatch;
        for (let l of o.result.options) {
          let h2 = [1e9 - i++];
          if (a)
            for (let u of a(l))
              h2.push(u);
          t.push(new lu(l, o, h2));
        }
      } else {
        let a = new U1(e.sliceDoc(o.from, o.to)), l;
        for (let h2 of o.result.options)
          (l = a.match(h2.label)) && (h2.boost != null && (l[0] += h2.boost), t.push(new lu(h2, o, l)));
      }
  let n = [], r = null, s = e.facet(tt).compareCompletions;
  for (let o of t.sort((a, l) => l.match[0] - a.match[0] || s(a.completion, l.completion)))
    !r || r.label != o.completion.label || r.detail != o.completion.detail || r.type != null && o.completion.type != null && r.type != o.completion.type || r.apply != o.completion.apply ? n.push(o) : fu(o.completion) > fu(r) && (n[n.length - 1] = o), r = o.completion;
  return n;
}
var _O = class {
  constructor(e, t, i, n, r, s) {
    this.options = e, this.attrs = t, this.tooltip = i, this.timestamp = n, this.selected = r, this.disabled = s;
  }
  setSelected(e, t) {
    return e == this.selected || e >= this.options.length ? this : new _O(this.options, du(t, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, t, i, n, r) {
    let s = C1(e, t);
    if (!s.length)
      return n && e.some(
        (a) => a.state == 1
        /* State.Pending */
      ) ? new _O(n.options, n.attrs, n.tooltip, n.timestamp, n.selected, true) : null;
    let o = t.facet(tt).selectOnOpen ? 0 : -1;
    if (n && n.selected != o && n.selected != -1) {
      let a = n.options[n.selected].completion;
      for (let l = 0; l < s.length; l++)
        if (s[l].completion == a) {
          o = l;
          break;
        }
    }
    return new _O(s, du(i, o), {
      pos: e.reduce((a, l) => l.hasResult() ? Math.min(a, l.from) : a, 1e8),
      create: _1(He),
      above: r.aboveCursor
    }, n ? n.timestamp : Date.now(), o, false);
  }
  map(e) {
    return new _O(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
};
var Dr = class {
  constructor(e, t, i) {
    this.active = e, this.id = t, this.open = i;
  }
  static start() {
    return new Dr(E1, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: t } = e, i = t.facet(tt), r = (i.override || t.languageDataAt("autocomplete", Kt(t)).map(z1)).map((o) => (this.active.find((l) => l.source == o) || new Ue(
      o,
      this.active.some(
        (l) => l.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, i));
    r.length == this.active.length && r.every((o, a) => o == this.active[a]) && (r = this.active);
    let s = this.open;
    s && e.docChanged && (s = s.map(e.changes)), e.selection || r.some((o) => o.hasResult() && e.changes.touchesRange(o.from, o.to)) || !G1(r, this.active) ? s = _O.build(r, t, this.id, s, i) : s && s.disabled && !r.some(
      (o) => o.state == 1
      /* State.Pending */
    ) && (s = null), !s && r.every(
      (o) => o.state != 1
      /* State.Pending */
    ) && r.some((o) => o.hasResult()) && (r = r.map((o) => o.hasResult() ? new Ue(
      o.source,
      0
      /* State.Inactive */
    ) : o));
    for (let o of e.effects)
      o.is(Qp) && (s = s && s.setSelected(o.value, this.id));
    return r == this.active && s == this.open ? this : new Dr(r, this.id, s);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : I1;
  }
};
function G1(O, e) {
  if (O == e)
    return true;
  for (let t = 0, i = 0; ; ) {
    for (; t < O.length && !O[t].hasResult; )
      t++;
    for (; i < e.length && !e[i].hasResult; )
      i++;
    let n = t == O.length, r = i == e.length;
    if (n || r)
      return n == r;
    if (O[t++].result != e[i++].result)
      return false;
  }
}
var I1 = {
  "aria-autocomplete": "list"
};
function du(O, e) {
  let t = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": O
  };
  return e > -1 && (t["aria-activedescendant"] = O + "-" + e), t;
}
var E1 = [];
function Ya(O) {
  return O.isUserEvent("input.type") ? "input" : O.isUserEvent("delete.backward") ? "delete" : null;
}
var Ue = class {
  constructor(e, t, i = -1) {
    this.source = e, this.state = t, this.explicitPos = i;
  }
  hasResult() {
    return false;
  }
  update(e, t) {
    let i = Ya(e), n = this;
    i ? n = n.handleUserEvent(e, i, t) : e.docChanged ? n = n.handleChange(e) : e.selection && n.state != 0 && (n = new Ue(
      n.source,
      0
      /* State.Inactive */
    ));
    for (let r of e.effects)
      if (r.is(Il))
        n = new Ue(n.source, 1, r.value ? Kt(e.state) : -1);
      else if (r.is(Mr))
        n = new Ue(
          n.source,
          0
          /* State.Inactive */
        );
      else if (r.is(dp))
        for (let s of r.value)
          s.source == n.source && (n = s);
    return n;
  }
  handleUserEvent(e, t, i) {
    return t == "delete" || !i.activateOnTyping ? this.map(e.changes) : new Ue(
      this.source,
      1
      /* State.Pending */
    );
  }
  handleChange(e) {
    return e.changes.touchesRange(Kt(e.startState)) ? new Ue(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new Ue(this.source, this.state, e.mapPos(this.explicitPos));
  }
};
var qi = class extends Ue {
  constructor(e, t, i, n, r) {
    super(e, 2, t), this.result = i, this.from = n, this.to = r;
  }
  hasResult() {
    return true;
  }
  handleUserEvent(e, t, i) {
    var n;
    let r = e.changes.mapPos(this.from), s = e.changes.mapPos(this.to, 1), o = Kt(e.state);
    if ((this.explicitPos < 0 ? o <= r : o < this.from) || o > s || t == "delete" && Kt(e.startState) == this.from)
      return new Ue(
        this.source,
        t == "input" && i.activateOnTyping ? 1 : 0
        /* State.Inactive */
      );
    let a = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos), l;
    return A1(this.result.validFor, e.state, r, s) ? new qi(this.source, a, this.result, r, s) : this.result.update && (l = this.result.update(this.result, r, s, new hp(e.state, o, a >= 0))) ? new qi(this.source, a, l, l.from, (n = l.to) !== null && n !== void 0 ? n : Kt(e.state)) : new Ue(this.source, 1, a);
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to) ? new Ue(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty ? this : new qi(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1));
  }
};
function A1(O, e, t, i) {
  if (!O)
    return false;
  let n = e.sliceDoc(t, i);
  return typeof O == "function" ? O(n, t, i, e) : up(O, true).test(n);
}
var Il = j.define();
var Mr = j.define();
var dp = j.define({
  map(O, e) {
    return O.map((t) => t.map(e));
  }
});
var Qp = j.define();
var He = me.define({
  create() {
    return Dr.start();
  },
  update(O, e) {
    return O.update(e);
  },
  provide: (O) => [
    gl.from(O, (e) => e.tooltip),
    k.contentAttributes.from(O, (e) => e.attrs)
  ]
});
function In(O, e = "option") {
  return (t) => {
    let i = t.state.field(He, false);
    if (!i || !i.open || i.open.disabled || Date.now() - i.open.timestamp < t.state.facet(tt).interactionDelay)
      return false;
    let n = 1, r;
    e == "page" && (r = TX(t, i.open.tooltip)) && (n = Math.max(2, Math.floor(r.dom.offsetHeight / r.dom.querySelector("li").offsetHeight) - 1));
    let { length: s } = i.open.options, o = i.open.selected > -1 ? i.open.selected + n * (O ? 1 : -1) : O ? 0 : s - 1;
    return o < 0 ? o = e == "page" ? 0 : s - 1 : o >= s && (o = e == "page" ? s - 1 : 0), t.dispatch({ effects: Qp.of(o) }), true;
  };
}
var D1 = (O) => {
  let e = O.state.field(He, false);
  return O.state.readOnly || !e || !e.open || e.open.selected < 0 || Date.now() - e.open.timestamp < O.state.facet(tt).interactionDelay ? false : (e.open.disabled || fp(O, e.open.options[e.open.selected]), true);
};
var M1 = (O) => O.state.field(He, false) ? (O.dispatch({ effects: Il.of(true) }), true) : false;
var L1 = (O) => {
  let e = O.state.field(He, false);
  return !e || !e.active.some(
    (t) => t.state != 0
    /* State.Inactive */
  ) ? false : (O.dispatch({ effects: Mr.of(null) }), true);
};
var B1 = class {
  constructor(e, t) {
    this.active = e, this.context = t, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
};
var Qu = 50;
var N1 = 50;
var F1 = 1e3;
var H1 = se.fromClass(class {
  constructor(O) {
    this.view = O, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.composing = 0;
    for (let e of O.state.field(He).active)
      e.state == 1 && this.startQuery(e);
  }
  update(O) {
    let e = O.state.field(He);
    if (!O.selectionSet && !O.docChanged && O.startState.field(He) == e)
      return;
    let t = O.transactions.some((i) => (i.selection || i.docChanged) && !Ya(i));
    for (let i = 0; i < this.running.length; i++) {
      let n = this.running[i];
      if (t || n.updates.length + O.transactions.length > N1 && Date.now() - n.time > F1) {
        for (let r of n.context.abortListeners)
          try {
            r();
          } catch (s) {
            Ne(this.view.state, s);
          }
        n.context.abortListeners = null, this.running.splice(i--, 1);
      } else
        n.updates.push(...O.transactions);
    }
    if (this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), this.debounceUpdate = e.active.some((i) => i.state == 1 && !this.running.some((n) => n.active.source == i.source)) ? setTimeout(() => this.startUpdate(), Qu) : -1, this.composing != 0)
      for (let i of O.transactions)
        Ya(i) == "input" ? this.composing = 2 : this.composing == 2 && i.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1;
    let { state: O } = this.view, e = O.field(He);
    for (let t of e.active)
      t.state == 1 && !this.running.some((i) => i.active.source == t.source) && this.startQuery(t);
  }
  startQuery(O) {
    let { state: e } = this.view, t = Kt(e), i = new hp(e, t, O.explicitPos == t), n = new B1(O, i);
    this.running.push(n), Promise.resolve(O.source(i)).then((r) => {
      n.context.aborted || (n.done = r || null, this.scheduleAccept());
    }, (r) => {
      this.view.dispatch({ effects: Mr.of(null) }), Ne(this.view.state, r);
    });
  }
  scheduleAccept() {
    this.running.every((O) => O.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), Qu));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var O;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], t = this.view.state.facet(tt);
    for (let i = 0; i < this.running.length; i++) {
      let n = this.running[i];
      if (n.done === void 0)
        continue;
      if (this.running.splice(i--, 1), n.done) {
        let s = new qi(n.active.source, n.active.explicitPos, n.done, n.done.from, (O = n.done.to) !== null && O !== void 0 ? O : Kt(n.updates.length ? n.updates[0].startState : this.view.state));
        for (let o of n.updates)
          s = s.update(o, t);
        if (s.hasResult()) {
          e.push(s);
          continue;
        }
      }
      let r = this.view.state.field(He).active.find((s) => s.source == n.active.source);
      if (r && r.state == 1)
        if (n.done == null) {
          let s = new Ue(
            n.active.source,
            0
            /* State.Inactive */
          );
          for (let o of n.updates)
            s = s.update(o, t);
          s.state != 1 && e.push(s);
        } else
          this.startQuery(r);
    }
    e.length && this.view.dispatch({ effects: dp.of(e) });
  }
}, {
  eventHandlers: {
    blur() {
      let O = this.view.state.field(He, false);
      O && O.tooltip && this.view.state.facet(tt).closeOnBlur && this.view.dispatch({ effects: Mr.of(null) });
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: Il.of(false) }), 20), this.composing = 0;
    }
  }
});
var $p = k.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer",
        padding: "1px 3px",
        lineHeight: 1.2
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: `${400}px`,
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30}px` },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30}px` },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
var K1 = class {
  constructor(e, t, i, n) {
    this.field = e, this.line = t, this.from = i, this.to = n;
  }
};
var El = class {
  constructor(e, t, i) {
    this.field = e, this.from = t, this.to = i;
  }
  map(e) {
    let t = e.mapPos(this.from, -1, Xe.TrackDel), i = e.mapPos(this.to, 1, Xe.TrackDel);
    return t == null || i == null ? null : new El(this.field, t, i);
  }
};
var Al = class {
  constructor(e, t) {
    this.lines = e, this.fieldPositions = t;
  }
  instantiate(e, t) {
    let i = [], n = [t], r = e.doc.lineAt(t), s = /^\s*/.exec(r.text)[0];
    for (let a of this.lines) {
      if (i.length) {
        let l = s, h2 = /^\t*/.exec(a)[0].length;
        for (let u = 0; u < h2; u++)
          l += e.facet(dn);
        n.push(t + l.length - h2), a = l + a.slice(h2);
      }
      i.push(a), t += a.length + 1;
    }
    let o = this.fieldPositions.map((a) => new El(a.field, n[a.line] + a.from, n[a.line] + a.to));
    return { text: i, ranges: o };
  }
  static parse(e) {
    let t = [], i = [], n = [], r;
    for (let s of e.split(/\r\n?|\n/)) {
      for (; r = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(s); ) {
        let o = r[1] ? +r[1] : null, a = r[2] || r[3] || "", l = -1;
        for (let h2 = 0; h2 < t.length; h2++)
          (o != null ? t[h2].seq == o : a && t[h2].name == a) && (l = h2);
        if (l < 0) {
          let h2 = 0;
          for (; h2 < t.length && (o == null || t[h2].seq != null && t[h2].seq < o); )
            h2++;
          t.splice(h2, 0, { seq: o, name: a }), l = h2;
          for (let u of n)
            u.field >= l && u.field++;
        }
        n.push(new K1(l, i.length, r.index, r.index + a.length)), s = s.slice(0, r.index) + a + s.slice(r.index + r[0].length);
      }
      for (let o; o = /\\([{}])/.exec(s); ) {
        s = s.slice(0, o.index) + o[1] + s.slice(o.index + o[0].length);
        for (let a of n)
          a.line == i.length && a.from > o.index && (a.from--, a.to--);
      }
      i.push(s);
    }
    return new Al(i, n);
  }
};
var J1 = V.widget({ widget: new class extends wt {
  toDOM() {
    let O = document.createElement("span");
    return O.className = "cm-snippetFieldPosition", O;
  }
  ignoreEvent() {
    return false;
  }
}() });
var ew = V.mark({ class: "cm-snippetField" });
var oi = class {
  constructor(e, t) {
    this.ranges = e, this.active = t, this.deco = V.set(e.map((i) => (i.from == i.to ? J1 : ew).range(i.from, i.to)));
  }
  map(e) {
    let t = [];
    for (let i of this.ranges) {
      let n = i.map(e);
      if (!n)
        return null;
      t.push(n);
    }
    return new oi(t, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((t) => this.ranges.some((i) => i.field == this.active && i.from <= t.from && i.to >= t.to));
  }
};
var pn = j.define({
  map(O, e) {
    return O && O.map(e);
  }
});
var tw = j.define();
var Ji = me.define({
  create() {
    return null;
  },
  update(O, e) {
    for (let t of e.effects) {
      if (t.is(pn))
        return t.value;
      if (t.is(tw) && O)
        return new oi(O.ranges, t.value);
    }
    return O && e.docChanged && (O = O.map(e.changes)), O && e.selection && !O.selectionInsideField(e.selection) && (O = null), O;
  },
  provide: (O) => k.decorations.from(O, (e) => e ? e.deco : V.none)
});
function Dl(O, e) {
  return S.create(O.filter((t) => t.field == e).map((t) => S.range(t.from, t.to)));
}
function Ow(O) {
  let e = Al.parse(O);
  return (t, i, n, r) => {
    let { text: s, ranges: o } = e.instantiate(t.state, n), a = {
      changes: { from: n, to: r, insert: D.of(s) },
      scrollIntoView: true
    };
    if (o.length && (a.selection = Dl(o, 0)), o.length > 1) {
      let l = new oi(o, 0), h2 = a.effects = [pn.of(l)];
      t.state.field(Ji, false) === void 0 && h2.push(j.appendConfig.of([Ji, ow, aw, $p]));
    }
    t.dispatch(t.state.update(a));
  };
}
function pp(O) {
  return ({ state: e, dispatch: t }) => {
    let i = e.field(Ji, false);
    if (!i || O < 0 && i.active == 0)
      return false;
    let n = i.active + O, r = O > 0 && !i.ranges.some((s) => s.field == n + O);
    return t(e.update({
      selection: Dl(i.ranges, n),
      effects: pn.of(r ? null : new oi(i.ranges, n))
    })), true;
  };
}
var iw = ({ state: O, dispatch: e }) => O.field(Ji, false) ? (e(O.update({ effects: pn.of(null) })), true) : false;
var nw = pp(1);
var rw = pp(-1);
var sw = [
  { key: "Tab", run: nw, shift: rw },
  { key: "Escape", run: iw }
];
var $u = q.define({
  combine(O) {
    return O.length ? O[0] : sw;
  }
});
var ow = rO.highest(ii.compute([$u], (O) => O.facet($u)));
function ce(O, e) {
  return Object.assign(Object.assign({}, e), { apply: Ow(O) });
}
var aw = k.domEventHandlers({
  mousedown(O, e) {
    let t = e.state.field(Ji, false), i;
    if (!t || (i = e.posAtCoords({ x: O.clientX, y: O.clientY })) == null)
      return false;
    let n = t.ranges.find((r) => r.from <= i && r.to >= i);
    return !n || n.field == t.active ? false : (e.dispatch({
      selection: Dl(t.ranges, n.field),
      effects: pn.of(t.ranges.some((r) => r.field > n.field) ? new oi(t.ranges, n.field) : null)
    }), true);
  }
});
var en = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
};
var pO = j.define({
  map(O, e) {
    let t = e.mapPos(O, -1, Xe.TrackAfter);
    return t ?? void 0;
  }
});
var Ml = j.define({
  map(O, e) {
    return e.mapPos(O);
  }
});
var Ll = new class extends PO {
}();
Ll.startSide = 1;
Ll.endSide = -1;
var mp = me.define({
  create() {
    return L.empty;
  },
  update(O, e) {
    if (e.selection) {
      let t = e.state.doc.lineAt(e.selection.main.head).from, i = e.startState.doc.lineAt(e.startState.selection.main.head).from;
      t != e.changes.mapPos(i, -1) && (O = L.empty);
    }
    O = O.map(e.changes);
    for (let t of e.effects)
      t.is(pO) ? O = O.update({ add: [Ll.range(t.value, t.value + 1)] }) : t.is(Ml) && (O = O.update({ filter: (i) => i != t.value }));
    return O;
  }
});
function lw() {
  return [hw, mp];
}
var Oo = "()[]{}<>";
function gp(O) {
  for (let e = 0; e < Oo.length; e += 2)
    if (Oo.charCodeAt(e) == O)
      return Oo.charAt(e + 1);
  return ll(O < 128 ? O : O + 1);
}
function Sp(O, e) {
  return O.languageDataAt("closeBrackets", e)[0] || en;
}
var cw = typeof navigator == "object" && /Android\b/.test(navigator.userAgent);
var hw = k.inputHandler.of((O, e, t, i) => {
  if ((cw ? O.composing : O.compositionStarted) || O.state.readOnly)
    return false;
  let n = O.state.selection.main;
  if (i.length > 2 || i.length == 2 && De(Pe(i, 0)) == 1 || e != n.from || t != n.to)
    return false;
  let r = dw(O.state, i);
  return r ? (O.dispatch(r), true) : false;
});
var uw = ({ state: O, dispatch: e }) => {
  if (O.readOnly)
    return false;
  let i = Sp(O, O.selection.main.head).brackets || en.brackets, n = null, r = O.changeByRange((s) => {
    if (s.empty) {
      let o = Qw(O.doc, s.head);
      for (let a of i)
        if (a == o && ms(O.doc, s.head) == gp(Pe(a, 0)))
          return {
            changes: { from: s.head - a.length, to: s.head + a.length },
            range: S.cursor(s.head - a.length)
          };
    }
    return { range: n = s };
  });
  return n || e(O.update(r, { scrollIntoView: true, userEvent: "delete.backward" })), !n;
};
var fw = [
  { key: "Backspace", run: uw }
];
function dw(O, e) {
  let t = Sp(O, O.selection.main.head), i = t.brackets || en.brackets;
  for (let n of i) {
    let r = gp(Pe(n, 0));
    if (e == n)
      return r == n ? mw(O, n, i.indexOf(n + n + n) > -1, t) : $w(O, n, r, t.before || en.before);
    if (e == r && Pp(O, O.selection.main.from))
      return pw(O, n, r);
  }
  return null;
}
function Pp(O, e) {
  let t = false;
  return O.field(mp).between(0, O.doc.length, (i) => {
    i == e && (t = true);
  }), t;
}
function ms(O, e) {
  let t = O.sliceString(e, e + 2);
  return t.slice(0, De(Pe(t, 0)));
}
function Qw(O, e) {
  let t = O.sliceString(e - 2, e);
  return De(Pe(t, 0)) == t.length ? t : t.slice(1);
}
function $w(O, e, t, i) {
  let n = null, r = O.changeByRange((s) => {
    if (!s.empty)
      return {
        changes: [{ insert: e, from: s.from }, { insert: t, from: s.to }],
        effects: pO.of(s.to + e.length),
        range: S.range(s.anchor + e.length, s.head + e.length)
      };
    let o = ms(O.doc, s.head);
    return !o || /\s/.test(o) || i.indexOf(o) > -1 ? {
      changes: { insert: e + t, from: s.head },
      effects: pO.of(s.head + e.length),
      range: S.cursor(s.head + e.length)
    } : { range: n = s };
  });
  return n ? null : O.update(r, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function pw(O, e, t) {
  let i = null, n = O.selection.ranges.map((r) => r.empty && ms(O.doc, r.head) == t ? S.cursor(r.head + t.length) : i = r);
  return i ? null : O.update({
    selection: S.create(n, O.selection.mainIndex),
    scrollIntoView: true,
    effects: O.selection.ranges.map(({ from: r }) => Ml.of(r))
  });
}
function mw(O, e, t, i) {
  let n = i.stringPrefixes || en.stringPrefixes, r = null, s = O.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: e, from: o.to }],
        effects: pO.of(o.to + e.length),
        range: S.range(o.anchor + e.length, o.head + e.length)
      };
    let a = o.head, l = ms(O.doc, a), h2;
    if (l == e) {
      if (pu(O, a))
        return {
          changes: { insert: e + e, from: a },
          effects: pO.of(a + e.length),
          range: S.cursor(a + e.length)
        };
      if (Pp(O, a)) {
        let u = t && O.sliceDoc(a, a + e.length * 3) == e + e + e;
        return {
          range: S.cursor(a + e.length * (u ? 3 : 1)),
          effects: Ml.of(a)
        };
      }
    } else {
      if (t && O.sliceDoc(a - 2 * e.length, a) == e + e && (h2 = mu(O, a - 2 * e.length, n)) > -1 && pu(O, h2))
        return {
          changes: { insert: e + e + e + e, from: a },
          effects: pO.of(a + e.length),
          range: S.cursor(a + e.length)
        };
      if (O.charCategorizer(a)(l) != ee.Word && mu(O, a, n) > -1 && !gw(O, a, e, n))
        return {
          changes: { insert: e + e, from: a },
          effects: pO.of(a + e.length),
          range: S.cursor(a + e.length)
        };
    }
    return { range: r = o };
  });
  return r ? null : O.update(s, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function pu(O, e) {
  let t = B(O).resolveInner(e + 1);
  return t.parent && t.from == e;
}
function gw(O, e, t, i) {
  let n = B(O).resolveInner(e, -1), r = i.reduce((s, o) => Math.max(s, o.length), 0);
  for (let s = 0; s < 5; s++) {
    let o = O.sliceDoc(n.from, Math.min(n.to, n.from + t.length + r)), a = o.indexOf(t);
    if (!a || a > -1 && i.indexOf(o.slice(0, a)) > -1) {
      let h2 = n.firstChild;
      for (; h2 && h2.from == n.from && h2.to - h2.from > t.length + a; ) {
        if (O.sliceDoc(h2.to - t.length, h2.to) == t)
          return false;
        h2 = h2.firstChild;
      }
      return true;
    }
    let l = n.to == e && n.parent;
    if (!l)
      break;
    n = l;
  }
  return false;
}
function mu(O, e, t) {
  let i = O.charCategorizer(e);
  if (i(O.sliceDoc(e - 1, e)) != ee.Word)
    return e;
  for (let n of t) {
    let r = e - n.length;
    if (O.sliceDoc(r, e) == n && i(O.sliceDoc(r - 1, r)) != ee.Word)
      return r;
  }
  return -1;
}
function Sw(O = {}) {
  return [
    He,
    tt.of(O),
    H1,
    Pw,
    $p
  ];
}
var yp = [
  { key: "Ctrl-Space", run: M1 },
  { key: "Escape", run: L1 },
  { key: "ArrowDown", run: In(true) },
  { key: "ArrowUp", run: In(false) },
  { key: "PageDown", run: In(true, "page") },
  { key: "PageUp", run: In(false, "page") },
  { key: "Enter", run: D1 }
];
var Pw = rO.highest(ii.computeN([tt], (O) => O.facet(tt).defaultKeymap ? [yp] : []));
var yw = class {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.diagnostic = i;
  }
};
var dO = class {
  constructor(e, t, i) {
    this.diagnostics = e, this.panel = t, this.selected = i;
  }
  static init(e, t, i) {
    let n = e, r = i.facet(jO).markerFilter;
    r && (n = r(n));
    let s = V.set(n.map((o) => o.from == o.to || o.from == o.to - 1 && i.doc.lineAt(o.from).to == o.from ? V.widget({
      widget: new Zw(o),
      diagnostic: o
    }).range(o.from) : V.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + o.severity },
      diagnostic: o
    }).range(o.from, o.to)), true);
    return new dO(s, t, KO(s));
  }
};
function KO(O, e = null, t = 0) {
  let i = null;
  return O.between(t, 1e9, (n, r, { spec: s }) => {
    if (!(e && s.diagnostic != e))
      return i = new yw(n, r, s.diagnostic), false;
  }), i;
}
function Xw(O, e) {
  return !!(O.effects.some((t) => t.is(Bl)) || O.changes.touchesRange(e.pos));
}
function Xp(O, e) {
  return O.field(Be, false) ? e : e.concat(j.appendConfig.of([
    Be,
    k.decorations.compute([Be], (t) => {
      let { selected: i, panel: n } = t.field(Be);
      return !i || !n || i.from == i.to ? V.none : V.set([
        bw.range(i.from, i.to)
      ]);
    }),
    wX(ww, { hideOn: Xw }),
    zw
  ]));
}
function xw(O, e) {
  return {
    effects: Xp(O, [Bl.of(e)])
  };
}
var Bl = j.define();
var Nl = j.define();
var xp = j.define();
var Be = me.define({
  create() {
    return new dO(V.none, null, null);
  },
  update(O, e) {
    if (e.docChanged) {
      let t = O.diagnostics.map(e.changes), i = null;
      if (O.selected) {
        let n = e.changes.mapPos(O.selected.from, 1);
        i = KO(t, O.selected.diagnostic, n) || KO(t, null, n);
      }
      O = new dO(t, O.panel, i);
    }
    for (let t of e.effects)
      t.is(Bl) ? O = dO.init(t.value, O.panel, e.state) : t.is(Nl) ? O = new dO(O.diagnostics, t.value ? gs.open : null, O.selected) : t.is(xp) && (O = new dO(O.diagnostics, O.panel, t.value));
    return O;
  },
  provide: (O) => [
    Bi.from(O, (e) => e.panel),
    k.decorations.from(O, (e) => e.diagnostics)
  ]
});
var bw = V.mark({ class: "cm-lintRange cm-lintRange-active" });
function ww(O, e, t) {
  let { diagnostics: i } = O.state.field(Be), n = [], r = 2e8, s = 0;
  i.between(e - (t < 0 ? 1 : 0), e + (t > 0 ? 1 : 0), (a, l, { spec: h2 }) => {
    e >= a && e <= l && (a == l || (e > a || t > 0) && (e < l || t < 0)) && (n.push(h2.diagnostic), r = Math.min(a, r), s = Math.max(l, s));
  });
  let o = O.state.facet(jO).tooltipFilter;
  return o && (n = o(n)), n.length ? {
    pos: r,
    end: s,
    above: O.state.doc.lineAt(r).to < s,
    create() {
      return { dom: Tw(O, n) };
    }
  } : null;
}
function Tw(O, e) {
  return N("ul", { class: "cm-tooltip-lint" }, e.map((t) => wp(O, t, false)));
}
var Ww = (O) => {
  let e = O.state.field(Be, false);
  (!e || !e.panel) && O.dispatch({ effects: Xp(O.state, [Nl.of(true)]) });
  let t = Li(O, gs.open);
  return t && t.dom.querySelector(".cm-panel-lint ul").focus(), true;
};
var gu = (O) => {
  let e = O.state.field(Be, false);
  return !e || !e.panel ? false : (O.dispatch({ effects: Nl.of(false) }), true);
};
var vw = (O) => {
  let e = O.state.field(Be, false);
  if (!e)
    return false;
  let t = O.state.selection.main, i = e.diagnostics.iter(t.to + 1);
  return !i.value && (i = e.diagnostics.iter(0), !i.value || i.from == t.from && i.to == t.to) ? false : (O.dispatch({ selection: { anchor: i.from, head: i.to }, scrollIntoView: true }), true);
};
var kw = [
  { key: "Mod-Shift-m", run: Ww, preventDefault: true },
  { key: "F8", run: vw }
];
var Yw = se.fromClass(class {
  constructor(O) {
    this.view = O, this.timeout = -1, this.set = true;
    let { delay: e } = O.state.facet(jO);
    this.lintTime = Date.now() + e, this.run = this.run.bind(this), this.timeout = setTimeout(this.run, e);
  }
  run() {
    let O = Date.now();
    if (O < this.lintTime - 10)
      setTimeout(this.run, this.lintTime - O);
    else {
      this.set = false;
      let { state: e } = this.view, { sources: t } = e.facet(jO);
      Promise.all(t.map((i) => Promise.resolve(i(this.view)))).then((i) => {
        let n = i.reduce((r, s) => r.concat(s));
        this.view.state.doc == e.doc && this.view.dispatch(xw(this.view.state, n));
      }, (i) => {
        Ne(this.view.state, i);
      });
    }
  }
  update(O) {
    let e = O.state.facet(jO);
    (O.docChanged || e != O.startState.facet(jO)) && (this.lintTime = Date.now() + e.delay, this.set || (this.set = true, this.timeout = setTimeout(this.run, e.delay)));
  }
  force() {
    this.set && (this.lintTime = Date.now(), this.run());
  }
  destroy() {
    clearTimeout(this.timeout);
  }
});
var jO = q.define({
  combine(O) {
    return Object.assign({ sources: O.map((e) => e.source) }, bt(O.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null
    }));
  },
  enables: Yw
});
function bp(O) {
  let e = [];
  if (O)
    e:
      for (let { name: t } of O) {
        for (let i = 0; i < t.length; i++) {
          let n = t[i];
          if (/[a-zA-Z]/.test(n) && !e.some((r) => r.toLowerCase() == n.toLowerCase())) {
            e.push(n);
            continue e;
          }
        }
        e.push("");
      }
  return e;
}
function wp(O, e, t) {
  var i;
  let n = t ? bp(e.actions) : [];
  return N("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, N("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage() : e.message), (i = e.actions) === null || i === void 0 ? void 0 : i.map((r, s) => {
    let o = (u) => {
      u.preventDefault();
      let f = KO(O.state.field(Be).diagnostics, e);
      f && r.apply(O, f.from, f.to);
    }, { name: a } = r, l = n[s] ? a.indexOf(n[s]) : -1, h2 = l < 0 ? a : [
      a.slice(0, l),
      N("u", a.slice(l, l + 1)),
      a.slice(l + 1)
    ];
    return N("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: o,
      onmousedown: o,
      "aria-label": ` Action: ${a}${l < 0 ? "" : ` (access key "${n[s]})"`}.`
    }, h2);
  }), e.source && N("div", { class: "cm-diagnosticSource" }, e.source));
}
var Zw = class extends wt {
  constructor(e) {
    super(), this.diagnostic = e;
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return N("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
};
var Su = class {
  constructor(e, t) {
    this.diagnostic = t, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = wp(e, t, true), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
};
var gs = class {
  constructor(e) {
    this.view = e, this.items = [];
    let t = (n) => {
      if (n.keyCode == 27)
        gu(this.view), this.view.focus();
      else if (n.keyCode == 38 || n.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (n.keyCode == 40 || n.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (n.keyCode == 36)
        this.moveSelection(0);
      else if (n.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (n.keyCode == 13)
        this.view.focus();
      else if (n.keyCode >= 65 && n.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: r } = this.items[this.selectedIndex], s = bp(r.actions);
        for (let o = 0; o < s.length; o++)
          if (s[o].toUpperCase().charCodeAt(0) == n.keyCode) {
            let a = KO(this.view.state.field(Be).diagnostics, r);
            a && r.actions[o].apply(e, a.from, a.to);
          }
      } else
        return;
      n.preventDefault();
    }, i = (n) => {
      for (let r = 0; r < this.items.length; r++)
        this.items[r].dom.contains(n.target) && this.moveSelection(r);
    };
    this.list = N("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: t,
      onclick: i
    }), this.dom = N("div", { class: "cm-panel-lint" }, this.list, N("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => gu(this.view)
    }, "×")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(Be).selected;
    if (!e)
      return -1;
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].diagnostic == e.diagnostic)
        return t;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: t } = this.view.state.field(Be), i = 0, n = false, r = null;
    for (e.between(0, this.view.state.doc.length, (s, o, { spec: a }) => {
      let l = -1, h2;
      for (let u = i; u < this.items.length; u++)
        if (this.items[u].diagnostic == a.diagnostic) {
          l = u;
          break;
        }
      l < 0 ? (h2 = new Su(this.view, a.diagnostic), this.items.splice(i, 0, h2), n = true) : (h2 = this.items[l], l > i && (this.items.splice(i, l - i), n = true)), t && h2.diagnostic == t.diagnostic ? h2.dom.hasAttribute("aria-selected") || (h2.dom.setAttribute("aria-selected", "true"), r = h2) : h2.dom.hasAttribute("aria-selected") && h2.dom.removeAttribute("aria-selected"), i++;
    }); i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      n = true, this.items.pop();
    this.items.length == 0 && (this.items.push(new Su(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), n = true), r ? (this.list.setAttribute("aria-activedescendant", r.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: r.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: s, panel: o }) => {
        s.top < o.top ? this.list.scrollTop -= o.top - s.top : s.bottom > o.bottom && (this.list.scrollTop += s.bottom - o.bottom);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), n && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function t() {
      let i = e;
      e = i.nextSibling, i.remove();
    }
    for (let i of this.items)
      if (i.dom.parentNode == this.list) {
        for (; e != i.dom; )
          t();
        e = i.dom.nextSibling;
      } else
        this.list.insertBefore(i.dom, e);
    for (; e; )
      t();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let t = this.view.state.field(Be), i = KO(t.diagnostics, this.items[e].diagnostic);
    i && this.view.dispatch({
      selection: { anchor: i.from, head: i.to },
      scrollIntoView: true,
      effects: xp.of(i)
    });
  }
  static open(e) {
    return new gs(e);
  }
};
function qw(O, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(O)}</svg>')`;
}
function io(O) {
  return qw(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${O}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
var zw = k.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: io("#d11") },
  ".cm-lintRange-warning": { backgroundImage: io("orange") },
  ".cm-lintRange-info": { backgroundImage: io("#999") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
var Uw = (() => [
  VX(),
  jX(),
  OX(),
  nb(),
  Tx(),
  Dy(),
  Fy(),
  I.allowMultipleSelections.of(true),
  Qx(),
  vl(Yx, { fallback: true }),
  _x(),
  lw(),
  Sw(),
  $X(),
  gX(),
  aX(),
  a1(),
  ii.of([
    ...fw,
    ...O1,
    ...T1,
    ...fb,
    ...xx,
    ...yp,
    ...kw
  ])
])();
var Vw = Object.freeze({ autofocus: false, disabled: false, indentWithTab: true, tabSize: 2, placeholder: "", autoDestroy: true, extensions: [Uw] });
var Rw = Symbol("vue-codemirror-global-config");
var We;
var _w = function(O) {
  var e = O.onUpdate, t = O.onChange, i = O.onFocus, n = O.onBlur, r = function(s, o) {
    var a = {};
    for (var l in s)
      Object.prototype.hasOwnProperty.call(s, l) && o.indexOf(l) < 0 && (a[l] = s[l]);
    if (s != null && typeof Object.getOwnPropertySymbols == "function") {
      var h2 = 0;
      for (l = Object.getOwnPropertySymbols(s); h2 < l.length; h2++)
        o.indexOf(l[h2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, l[h2]) && (a[l[h2]] = s[l[h2]]);
    }
    return a;
  }(O, ["onUpdate", "onChange", "onFocus", "onBlur"]);
  return I.create({ doc: r.doc, selection: r.selection, extensions: (Array.isArray(r.extensions) ? r.extensions : [r.extensions]).concat([k.updateListener.of(function(s) {
    e(s), s.docChanged && t(s.state.doc.toString(), s), s.focusChanged && (s.view.hasFocus ? i(s) : n(s));
  })]) });
};
var VO = function(O) {
  var e = new cn();
  return { compartment: e, run: function(t) {
    e.get(O.state) ? O.dispatch({ effects: e.reconfigure(t) }) : O.dispatch({ effects: j.appendConfig.of(e.of(t)) });
  } };
};
var Pu = function(O, e) {
  var t = VO(O), i = t.compartment, n = t.run;
  return function(r) {
    var s = i.get(O.state);
    n(r ?? s !== e ? e : []);
  };
};
var En = { type: Boolean, default: void 0 };
var jw = { autofocus: En, disabled: En, indentWithTab: En, tabSize: Number, placeholder: String, style: Object, autoDestroy: En, phrases: Object, root: Object, extensions: Array, selection: Object };
var Cw = { modelValue: { type: String, default: "" } };
var Gw = Object.assign(Object.assign({}, jw), Cw);
(function(O) {
  O.Change = "change", O.Update = "update", O.Focus = "focus", O.Blur = "blur", O.Ready = "ready", O.ModelUpdate = "update:modelValue";
})(We || (We = {}));
var QO = {};
QO[We.Change] = function(O, e) {
  return true;
}, QO[We.Update] = function(O) {
  return true;
}, QO[We.Focus] = function(O) {
  return true;
}, QO[We.Blur] = function(O) {
  return true;
}, QO[We.Ready] = function(O) {
  return true;
};
var Tp = {};
Tp[We.ModelUpdate] = QO[We.Change];
var Iw = Object.assign(Object.assign({}, QO), Tp);
var Ew = defineComponent({ name: "VueCodemirror", props: Object.assign({}, Gw), emits: Object.assign({}, Iw), setup: function(O, e) {
  var t = shallowRef(), i = shallowRef(), n = shallowRef(), r = Object.assign(Object.assign({}, Vw), inject(Rw, {})), s = computed(function() {
    var o = {};
    return Object.keys(toRaw(O)).forEach(function(a) {
      var l;
      a !== "modelValue" && (o[a] = (l = O[a]) !== null && l !== void 0 ? l : r[a]);
    }), o;
  });
  return onMounted(function() {
    var o;
    i.value = _w({ doc: O.modelValue, selection: s.value.selection, extensions: (o = r.extensions) !== null && o !== void 0 ? o : [], onFocus: function(l) {
      return e.emit(We.Focus, l);
    }, onBlur: function(l) {
      return e.emit(We.Blur, l);
    }, onUpdate: function(l) {
      return e.emit(We.Update, l);
    }, onChange: function(l, h2) {
      l !== O.modelValue && (e.emit(We.Change, l, h2), e.emit(We.ModelUpdate, l, h2));
    } }), n.value = function(l) {
      return new k(Object.assign({}, l));
    }({ state: i.value, parent: t.value, root: s.value.root });
    var a = function(l) {
      var h2 = function() {
        return l.state.doc.toString();
      }, u = VO(l).run, f = Pu(l, [k.editable.of(false), I.readOnly.of(true)]), d = Pu(l, ii.of([i1])), Q = VO(l).run, $ = VO(l).run, p = VO(l).run, m = VO(l).run;
      return { focus: function() {
        return l.focus();
      }, getDoc: h2, setDoc: function(g) {
        g !== h2() && l.dispatch({ changes: { from: 0, to: l.state.doc.length, insert: g } });
      }, reExtensions: u, toggleDisabled: f, toggleIndentWithTab: d, setTabSize: function(g) {
        Q([I.tabSize.of(g), dn.of(" ".repeat(g))]);
      }, setPhrases: function(g) {
        $([I.phrases.of(g)]);
      }, setPlaceholder: function(g) {
        p(uX(g));
      }, setStyle: function(g) {
        g === void 0 && (g = {}), m(k.theme({ "&": Object.assign({}, g) }));
      } };
    }(n.value);
    watch(function() {
      return O.modelValue;
    }, function(l) {
      l !== a.getDoc() && a.setDoc(l);
    }), watch(function() {
      return O.extensions;
    }, function(l) {
      return a.reExtensions(l || []);
    }, { immediate: true }), watch(function() {
      return s.value.disabled;
    }, function(l) {
      return a.toggleDisabled(l);
    }, { immediate: true }), watch(function() {
      return s.value.indentWithTab;
    }, function(l) {
      return a.toggleIndentWithTab(l);
    }, { immediate: true }), watch(function() {
      return s.value.tabSize;
    }, function(l) {
      return a.setTabSize(l);
    }, { immediate: true }), watch(function() {
      return s.value.phrases;
    }, function(l) {
      return a.setPhrases(l || {});
    }, { immediate: true }), watch(function() {
      return s.value.placeholder;
    }, function(l) {
      return a.setPlaceholder(l);
    }, { immediate: true }), watch(function() {
      return s.value.style;
    }, function(l) {
      return a.setStyle(l);
    }, { immediate: true }), s.value.autofocus && a.focus(), e.emit(We.Ready, { state: i.value, view: n.value, container: t.value });
  }), onBeforeUnmount(function() {
    s.value.autoDestroy && n.value && function(o) {
      o.destroy();
    }(n.value);
  }), function() {
    return h("div", { class: "v-codemirror", style: { display: "contents" }, ref: t });
  };
} });
var Aw = Ew;
var Lr = class {
  /// @internal
  constructor(e, t, i, n, r, s, o, a, l, h2 = 0, u) {
    this.p = e, this.stack = t, this.state = i, this.reducePos = n, this.pos = r, this.score = s, this.buffer = o, this.bufferBase = a, this.curContext = l, this.lookAhead = h2, this.parent = u;
  }
  /// @internal
  toString() {
    return `[${this.stack.filter((e, t) => t % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /// @internal
  static start(e, t, i = 0) {
    let n = e.parser.context;
    return new Lr(e, [], t, i, i, 0, [], 0, n ? new yu(n, n.start) : null, 0, null);
  }
  /// The stack's current [context](#lr.ContextTracker) value, if
  /// any. Its type will depend on the context tracker's type
  /// parameter, or it will be `null` if there is no context
  /// tracker.
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /// @internal
  pushState(e, t) {
    this.stack.push(this.state, t, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /// @internal
  reduce(e) {
    var t;
    let i = e >> 19, n = e & 65535, { parser: r } = this.p, s = r.dynamicPrecedence(n);
    if (s && (this.score += s), i == 0) {
      this.pushState(r.getGoto(this.state, n, true), this.reducePos), n < r.minRepeatTerm && this.storeNode(n, this.reducePos, this.reducePos, 4, true), this.reduceContext(n, this.reducePos);
      return;
    }
    let o = this.stack.length - (i - 1) * 3 - (e & 262144 ? 6 : 0), a = o ? this.stack[o - 2] : this.p.ranges[0].from, l = this.reducePos - a;
    l >= 2e3 && !(!((t = this.p.parser.nodeSet.types[n]) === null || t === void 0) && t.isAnonymous) && (a == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = l) : this.p.lastBigReductionSize < l && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = a, this.p.lastBigReductionSize = l));
    let h2 = o ? this.stack[o - 1] : 0, u = this.bufferBase + this.buffer.length - h2;
    if (n < r.minRepeatTerm || e & 131072) {
      let f = r.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(n, a, f, u + 4, true);
    }
    if (e & 262144)
      this.state = this.stack[o];
    else {
      let f = this.stack[o - 3];
      this.state = r.getGoto(f, n, true);
    }
    for (; this.stack.length > o; )
      this.stack.pop();
    this.reduceContext(n, a);
  }
  // Shift a value into the buffer
  /// @internal
  storeNode(e, t, i, n = 4, r = false) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let s = this, o = this.buffer.length;
      if (o == 0 && s.parent && (o = s.bufferBase - s.parent.bufferBase, s = s.parent), o > 0 && s.buffer[o - 4] == 0 && s.buffer[o - 1] > -1) {
        if (t == i)
          return;
        if (s.buffer[o - 2] >= t) {
          s.buffer[o - 2] = i;
          return;
        }
      }
    }
    if (!r || this.pos == i)
      this.buffer.push(e, t, i, n);
    else {
      let s = this.buffer.length;
      if (s > 0 && this.buffer[s - 4] != 0)
        for (; s > 0 && this.buffer[s - 2] > i; )
          this.buffer[s] = this.buffer[s - 4], this.buffer[s + 1] = this.buffer[s - 3], this.buffer[s + 2] = this.buffer[s - 2], this.buffer[s + 3] = this.buffer[s - 1], s -= 4, n > 4 && (n -= 4);
      this.buffer[s] = e, this.buffer[s + 1] = t, this.buffer[s + 2] = i, this.buffer[s + 3] = n;
    }
  }
  // Apply a shift action
  /// @internal
  shift(e, t, i) {
    let n = this.pos;
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if (e & 262144)
      this.pos = i, this.shiftContext(t, n), t <= this.p.parser.maxNode && this.buffer.push(t, n, i, 4);
    else {
      let r = e, { parser: s } = this.p;
      (i > this.pos || t <= s.maxNode) && (this.pos = i, s.stateFlag(
        r,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = i)), this.pushState(r, n), this.shiftContext(t, n), t <= s.maxNode && this.buffer.push(t, n, i, 4);
    }
  }
  // Apply an action
  /// @internal
  apply(e, t, i) {
    e & 65536 ? this.reduce(e) : this.shift(e, t, i);
  }
  // Add a prebuilt (reused) node into the buffer.
  /// @internal
  useNode(e, t) {
    let i = this.p.reused.length - 1;
    (i < 0 || this.p.reused[i] != e) && (this.p.reused.push(e), i++);
    let n = this.pos;
    this.reducePos = this.pos = n + e.length, this.pushState(t, n), this.buffer.push(
      i,
      n,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /// @internal
  split() {
    let e = this, t = e.buffer.length;
    for (; t > 0 && e.buffer[t - 2] > e.reducePos; )
      t -= 4;
    let i = e.buffer.slice(t), n = e.bufferBase + t;
    for (; e && n == e.bufferBase; )
      e = e.parent;
    return new Lr(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, n, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /// @internal
  recoverByDelete(e, t) {
    let i = e <= this.p.parser.maxNode;
    i && this.storeNode(e, this.pos, t, 4), this.storeNode(0, this.pos, t, i ? 8 : 4), this.pos = this.reducePos = t, this.score -= 190;
  }
  /// Check if the given term would be able to be shifted (optionally
  /// after some reductions) on this stack. This can be useful for
  /// external tokenizers that want to make sure they only provide a
  /// given token when it applies.
  canShift(e) {
    for (let t = new Dw(this); ; ) {
      let i = this.p.parser.stateSlot(
        t.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(t.state, e);
      if (i == 0)
        return false;
      if (!(i & 65536))
        return true;
      t.reduce(i);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /// @internal
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let t = this.p.parser.nextStates(this.state);
    if (t.length > 4 << 1 || this.stack.length >= 120) {
      let n = [];
      for (let r = 0, s; r < t.length; r += 2)
        (s = t[r + 1]) != this.state && this.p.parser.hasAction(s, e) && n.push(t[r], s);
      if (this.stack.length < 120)
        for (let r = 0; n.length < 4 << 1 && r < t.length; r += 2) {
          let s = t[r + 1];
          n.some((o, a) => a & 1 && o == s) || n.push(t[r], s);
        }
      t = n;
    }
    let i = [];
    for (let n = 0; n < t.length && i.length < 4; n += 2) {
      let r = t[n + 1];
      if (r == this.state)
        continue;
      let s = this.split();
      s.pushState(r, this.pos), s.storeNode(0, s.pos, s.pos, 4, true), s.shiftContext(t[n], this.pos), s.score -= 200, i.push(s);
    }
    return i;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /// @internal
  forceReduce() {
    let e = this.p.parser.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(e & 65536))
      return false;
    let { parser: t } = this.p;
    if (!t.validAction(this.state, e)) {
      let i = e >> 19, n = e & 65535, r = this.stack.length - i * 3;
      if (r < 0 || t.getGoto(this.stack[r], n, false) < 0)
        return false;
      this.storeNode(0, this.reducePos, this.reducePos, 4, true), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(e), true;
  }
  /// @internal
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, true);
        break;
      }
    return this;
  }
  /// Check whether this state has no further actions (assumed to be a direct descendant of the
  /// top state, since any other states must be able to continue
  /// somehow). @internal
  get deadEnd() {
    if (this.stack.length != 3)
      return false;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /// Restart the stack (put it back in its start state). Only safe
  /// when this.stack.length == 3 (state is directly below the top
  /// state). @internal
  restart() {
    this.state = this.stack[0], this.stack.length = 0;
  }
  /// @internal
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return false;
    for (let t = 0; t < this.stack.length; t += 3)
      if (this.stack[t] != e.stack[t])
        return false;
    return true;
  }
  /// Get the parser used by this stack.
  get parser() {
    return this.p.parser;
  }
  /// Test whether a given dialect (by numeric ID, as exported from
  /// the terms file) is enabled.
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  reduceContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  /// @internal
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
  }
  /// @internal
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let t = new yu(this.curContext.tracker, e);
      t.hash != this.curContext.hash && this.emitContext(), this.curContext = t;
    }
  }
  /// @internal
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /// @internal
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
};
var yu = class {
  constructor(e, t) {
    this.tracker = e, this.context = t, this.hash = e.strict ? e.hash(t) : 0;
  }
};
var Xu;
(function(O) {
  O[O.Insert = 200] = "Insert", O[O.Delete = 190] = "Delete", O[O.Reduce = 100] = "Reduce", O[O.MaxNext = 4] = "MaxNext", O[O.MaxInsertStackDepth = 300] = "MaxInsertStackDepth", O[O.DampenInsertStackDepth = 120] = "DampenInsertStackDepth", O[O.MinBigReduction = 2e3] = "MinBigReduction";
})(Xu || (Xu = {}));
var Dw = class {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let t = e & 65535, i = e >> 19;
    i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3;
    let n = this.start.p.parser.getGoto(this.stack[this.base - 3], t, true);
    this.state = n;
  }
};
var Br = class {
  constructor(e, t, i) {
    this.stack = e, this.pos = t, this.index = i, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, t = e.bufferBase + e.buffer.length) {
    return new Br(e, t, t - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new Br(this.stack, this.pos, this.index);
  }
};
function Ti(O, e = Uint16Array) {
  if (typeof O != "string")
    return O;
  let t = null;
  for (let i = 0, n = 0; i < O.length; ) {
    let r = 0;
    for (; ; ) {
      let s = O.charCodeAt(i++), o = false;
      if (s == 126) {
        r = 65535;
        break;
      }
      s >= 92 && s--, s >= 34 && s--;
      let a = s - 32;
      if (a >= 46 && (a -= 46, o = true), r += a, o)
        break;
      r *= 46;
    }
    t ? t[n++] = r : t = new e(r);
  }
  return t;
}
var hr = class {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
};
var xu = new hr();
var Mw = class {
  /// @internal
  constructor(e, t) {
    this.input = e, this.ranges = t, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = xu, this.rangeIndex = 0, this.pos = this.chunkPos = t[0].from, this.range = t[0], this.end = t[t.length - 1].to, this.readNext();
  }
  /// @internal
  resolveOffset(e, t) {
    let i = this.range, n = this.rangeIndex, r = this.pos + e;
    for (; r < i.from; ) {
      if (!n)
        return null;
      let s = this.ranges[--n];
      r -= i.from - s.to, i = s;
    }
    for (; t < 0 ? r > i.to : r >= i.to; ) {
      if (n == this.ranges.length - 1)
        return null;
      let s = this.ranges[++n];
      r += s.from - i.to, i = s;
    }
    return r;
  }
  /// @internal
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let t of this.ranges)
      if (t.to > e)
        return Math.max(e, t.from);
    return this.end;
  }
  /// Look at a code unit near the stream position. `.peek(0)` equals
  /// `.next`, `.peek(-1)` gives you the previous character, and so
  /// on.
  ///
  /// Note that looking around during tokenizing creates dependencies
  /// on potentially far-away content, which may reduce the
  /// effectiveness incremental parsing—when looking forward—or even
  /// cause invalid reparses when looking backward more than 25 code
  /// units, since the library does not track lookbehind.
  peek(e) {
    let t = this.chunkOff + e, i, n;
    if (t >= 0 && t < this.chunk.length)
      i = this.pos + e, n = this.chunk.charCodeAt(t);
    else {
      let r = this.resolveOffset(e, 1);
      if (r == null)
        return -1;
      if (i = r, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
        n = this.chunk2.charCodeAt(i - this.chunk2Pos);
      else {
        let s = this.rangeIndex, o = this.range;
        for (; o.to <= i; )
          o = this.ranges[++s];
        this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > o.to && (this.chunk2 = this.chunk2.slice(0, o.to - i)), n = this.chunk2.charCodeAt(0);
      }
    }
    return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), n;
  }
  /// Accept a token. By default, the end of the token is set to the
  /// current stream position, but you can pass an offset (relative to
  /// the stream position) to change that.
  acceptToken(e, t = 0) {
    let i = t ? this.resolveOffset(t, -1) : this.pos;
    if (i == null || i < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = i;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: t } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = t, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), t = this.pos + e.length;
      this.chunk = t > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /// Move the stream forward N (defaults to 1) code units. Returns
  /// the new value of [`next`](#lr.InputStream.next).
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /// @internal
  reset(e, t) {
    if (t ? (this.token = t, t.start = e, t.lookAhead = e + 1, t.value = t.extended = -1) : this.token = xu, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /// @internal
  read(e, t) {
    if (e >= this.chunkPos && t <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, t - this.chunkPos);
    if (e >= this.chunk2Pos && t <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, t - this.chunk2Pos);
    if (e >= this.range.from && t <= this.range.to)
      return this.input.read(e, t);
    let i = "";
    for (let n of this.ranges) {
      if (n.from >= t)
        break;
      n.to > e && (i += this.input.read(Math.max(n.from, e), Math.min(n.to, t)));
    }
    return i;
  }
};
var DO = class {
  constructor(e, t) {
    this.data = e, this.id = t;
  }
  token(e, t) {
    let { parser: i } = t.p;
    Wp(this.data, e, t, this.id, i.data, i.tokenPrecTable);
  }
};
DO.prototype.contextual = DO.prototype.fallback = DO.prototype.extend = false;
var Za = class {
  constructor(e, t, i) {
    this.precTable = t, this.elseToken = i, this.data = typeof e == "string" ? Ti(e) : e;
  }
  token(e, t) {
    let i = e.pos, n;
    for (; n = e.pos, Wp(this.data, e, t, 0, this.data, this.precTable), !(e.token.value > -1); ) {
      if (this.elseToken == null)
        return;
      if (e.next < 0)
        break;
      e.advance(), e.reset(n + 1, e.token);
    }
    n > i && (e.reset(i, e.token), e.acceptToken(this.elseToken, n - i));
  }
};
Za.prototype.contextual = DO.prototype.fallback = DO.prototype.extend = false;
var te = class {
  /// Create a tokenizer. The first argument is the function that,
  /// given an input stream, scans for the types of tokens it
  /// recognizes at the stream's position, and calls
  /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  /// one.
  constructor(e, t = {}) {
    this.token = e, this.contextual = !!t.contextual, this.fallback = !!t.fallback, this.extend = !!t.extend;
  }
};
function Wp(O, e, t, i, n, r) {
  let s = 0, o = 1 << i, { dialect: a } = t.p.parser;
  e:
    for (; o & O[s]; ) {
      let l = O[s + 1];
      for (let d = s + 3; d < l; d += 2)
        if ((O[d + 1] & o) > 0) {
          let Q = O[d];
          if (a.allows(Q) && (e.token.value == -1 || e.token.value == Q || Lw(Q, e.token.value, n, r))) {
            e.acceptToken(Q);
            break;
          }
        }
      let h2 = e.next, u = 0, f = O[s + 2];
      if (e.next < 0 && f > u && O[l + f * 3 - 3] == 65535 && O[l + f * 3 - 3] == 65535) {
        s = O[l + f * 3 - 1];
        continue e;
      }
      for (; u < f; ) {
        let d = u + f >> 1, Q = l + d + (d << 1), $ = O[Q], p = O[Q + 1] || 65536;
        if (h2 < $)
          f = d;
        else if (h2 >= p)
          u = d + 1;
        else {
          s = O[Q + 2], e.advance();
          continue e;
        }
      }
      break;
    }
}
function bu(O, e, t) {
  for (let i = e, n; (n = O[i]) != 65535; i++)
    if (n == t)
      return i - e;
  return -1;
}
function Lw(O, e, t, i) {
  let n = bu(t, i, e);
  return n < 0 || bu(t, i, O) < n;
}
var nt = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
var no = null;
var wu;
(function(O) {
  O[O.Margin = 25] = "Margin";
})(wu || (wu = {}));
function Tu(O, e, t) {
  let i = O.cursor(K.IncludeAnonymous);
  for (i.moveTo(e); ; )
    if (!(t < 0 ? i.childBefore(e) : i.childAfter(e)))
      for (; ; ) {
        if ((t < 0 ? i.to < e : i.from > e) && !i.type.isError)
          return t < 0 ? Math.max(0, Math.min(
            i.to - 1,
            e - 25
            /* Safety.Margin */
          )) : Math.min(O.length, Math.max(
            i.from + 1,
            e + 25
            /* Safety.Margin */
          ));
        if (t < 0 ? i.prevSibling() : i.nextSibling())
          break;
        if (!i.parent())
          return t < 0 ? 0 : O.length;
      }
}
var Bw = class {
  constructor(e, t) {
    this.fragments = e, this.nodeSet = t, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? Tu(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? Tu(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let t = this.trees.length - 1;
      if (t < 0)
        return this.nextFragment(), null;
      let i = this.trees[t], n = this.index[t];
      if (n == i.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let r = i.children[n], s = this.start[t] + i.positions[n];
      if (s > e)
        return this.nextStart = s, null;
      if (r instanceof E) {
        if (s == e) {
          if (s < this.safeFrom)
            return null;
          let o = s + r.length;
          if (o <= this.safeTo) {
            let a = r.prop(_.lookAhead);
            if (!a || o + a < this.fragment.to)
              return r;
          }
        }
        this.index[t]++, s + r.length >= Math.max(this.safeFrom, e) && (this.trees.push(r), this.start.push(s), this.index.push(0));
      } else
        this.index[t]++, this.nextStart = s + r.length;
    }
  }
};
var Nw = class {
  constructor(e, t) {
    this.stream = t, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((i) => new hr());
  }
  getActions(e) {
    let t = 0, i = null, { parser: n } = e.p, { tokenizers: r } = n, s = n.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), o = e.curContext ? e.curContext.hash : 0, a = 0;
    for (let l = 0; l < r.length; l++) {
      if (!(1 << l & s))
        continue;
      let h2 = r[l], u = this.tokens[l];
      if (!(i && !h2.fallback) && ((h2.contextual || u.start != e.pos || u.mask != s || u.context != o) && (this.updateCachedToken(u, h2, e), u.mask = s, u.context = o), u.lookAhead > u.end + 25 && (a = Math.max(u.lookAhead, a)), u.value != 0)) {
        let f = t;
        if (u.extended > -1 && (t = this.addActions(e, u.extended, u.end, t)), t = this.addActions(e, u.value, u.end, t), !h2.extend && (i = u, t > f))
          break;
      }
    }
    for (; this.actions.length > t; )
      this.actions.pop();
    return a && e.setLookAhead(a), !i && e.pos == this.stream.end && (i = new hr(), i.value = e.p.parser.eofTerm, i.start = i.end = e.pos, t = this.addActions(e, i.value, i.end, t)), this.mainToken = i, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let t = new hr(), { pos: i, p: n } = e;
    return t.start = i, t.end = Math.min(i + 1, n.stream.end), t.value = i == n.stream.end ? n.parser.eofTerm : 0, t;
  }
  updateCachedToken(e, t, i) {
    let n = this.stream.clipPos(i.pos);
    if (t.token(this.stream.reset(n, e), i), e.value > -1) {
      let { parser: r } = i.p;
      for (let s = 0; s < r.specialized.length; s++)
        if (r.specialized[s] == e.value) {
          let o = r.specializers[s](this.stream.read(e.start, e.end), i);
          if (o >= 0 && i.p.parser.dialect.allows(o >> 1)) {
            o & 1 ? e.extended = o >> 1 : e.value = o >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(n + 1);
  }
  putAction(e, t, i, n) {
    for (let r = 0; r < n; r += 3)
      if (this.actions[r] == e)
        return n;
    return this.actions[n++] = e, this.actions[n++] = t, this.actions[n++] = i, n;
  }
  addActions(e, t, i, n) {
    let { state: r } = e, { parser: s } = e.p, { data: o } = s;
    for (let a = 0; a < 2; a++)
      for (let l = s.stateSlot(
        r,
        a ? 2 : 1
        /* ParseState.Actions */
      ); ; l += 3) {
        if (o[l] == 65535)
          if (o[l + 1] == 1)
            l = Yt(o, l + 2);
          else {
            n == 0 && o[l + 1] == 2 && (n = this.putAction(Yt(o, l + 2), t, i, n));
            break;
          }
        o[l] == t && (n = this.putAction(Yt(o, l + 1), t, i, n));
      }
    return n;
  }
};
var Wu;
(function(O) {
  O[O.Distance = 5] = "Distance", O[O.MaxRemainingPerStep = 3] = "MaxRemainingPerStep", O[O.MinBufferLengthPrune = 500] = "MinBufferLengthPrune", O[O.ForceReduceLimit = 10] = "ForceReduceLimit", O[O.CutDepth = 15e3] = "CutDepth", O[O.CutTo = 9e3] = "CutTo", O[O.MaxLeftAssociativeReductionCount = 300] = "MaxLeftAssociativeReductionCount", O[O.MaxStackCount = 12] = "MaxStackCount";
})(Wu || (Wu = {}));
var Fw = class {
  constructor(e, t, i, n) {
    this.parser = e, this.input = t, this.ranges = n, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new Mw(t, n), this.tokens = new Nw(e, this.stream), this.topTerm = e.top[1];
    let { from: r } = n[0];
    this.stacks = [Lr.start(this, e.top[0], r)], this.fragments = i.length && this.stream.end - r > e.bufferLength * 4 ? new Bw(i, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, t = this.minStackPos, i = this.stacks = [], n, r;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [s] = e;
      for (; s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let s = 0; s < e.length; s++) {
      let o = e[s];
      for (; ; ) {
        if (this.tokens.mainToken = null, o.pos > t)
          i.push(o);
        else {
          if (this.advanceStack(o, i, e))
            continue;
          {
            n || (n = [], r = []), n.push(o);
            let a = this.tokens.getMainToken(o);
            r.push(a.value, a.end);
          }
        }
        break;
      }
    }
    if (!i.length) {
      let s = n && Kw(n);
      if (s)
        return this.stackToTree(s);
      if (this.parser.strict)
        throw nt && n && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + t);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && n) {
      let s = this.stoppedAt != null && n[0].pos > this.stoppedAt ? n[0] : this.runRecovery(n, r, i);
      if (s)
        return this.stackToTree(s.forceAll());
    }
    if (this.recovering) {
      let s = this.recovering == 1 ? 1 : this.recovering * 3;
      if (i.length > s)
        for (i.sort((o, a) => a.score - o.score); i.length > s; )
          i.pop();
      i.some((o) => o.reducePos > t) && this.recovering--;
    } else if (i.length > 1) {
      e:
        for (let s = 0; s < i.length - 1; s++) {
          let o = i[s];
          for (let a = s + 1; a < i.length; a++) {
            let l = i[a];
            if (o.sameState(l) || o.buffer.length > 500 && l.buffer.length > 500)
              if ((o.score - l.score || o.buffer.length - l.buffer.length) > 0)
                i.splice(a--, 1);
              else {
                i.splice(s--, 1);
                continue e;
              }
          }
        }
      i.length > 12 && i.splice(
        12,
        i.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = i[0].pos;
    for (let s = 1; s < i.length; s++)
      i[s].pos < this.minStackPos && (this.minStackPos = i[s].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, t, i) {
    let n = e.pos, { parser: r } = this, s = nt ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && n > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let l = e.curContext && e.curContext.tracker.strict, h2 = l ? e.curContext.hash : 0;
      for (let u = this.fragments.nodeAt(n); u; ) {
        let f = this.parser.nodeSet.types[u.type.id] == u.type ? r.getGoto(e.state, u.type.id) : -1;
        if (f > -1 && u.length && (!l || (u.prop(_.contextHash) || 0) == h2))
          return e.useNode(u, f), nt && console.log(s + this.stackID(e) + ` (via reuse of ${r.getName(u.type.id)})`), true;
        if (!(u instanceof E) || u.children.length == 0 || u.positions[0] > 0)
          break;
        let d = u.children[0];
        if (d instanceof E && u.positions[0] == 0)
          u = d;
        else
          break;
      }
    }
    let o = r.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (o > 0)
      return e.reduce(o), nt && console.log(s + this.stackID(e) + ` (via always-reduce ${r.getName(
        o & 65535
        /* Action.ValueMask */
      )})`), true;
    if (e.stack.length >= 15e3)
      for (; e.stack.length > 9e3 && e.forceReduce(); )
        ;
    let a = this.tokens.getActions(e);
    for (let l = 0; l < a.length; ) {
      let h2 = a[l++], u = a[l++], f = a[l++], d = l == a.length || !i, Q = d ? e : e.split();
      if (Q.apply(h2, u, f), nt && console.log(s + this.stackID(Q) + ` (via ${h2 & 65536 ? `reduce of ${r.getName(
        h2 & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${r.getName(u)} @ ${n}${Q == e ? "" : ", split"})`), d)
        return true;
      Q.pos > n ? t.push(Q) : i.push(Q);
    }
    return false;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, t) {
    let i = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return false;
      if (e.pos > i)
        return vu(e, t), true;
    }
  }
  runRecovery(e, t, i) {
    let n = null, r = false;
    for (let s = 0; s < e.length; s++) {
      let o = e[s], a = t[s << 1], l = t[(s << 1) + 1], h2 = nt ? this.stackID(o) + " -> " : "";
      if (o.deadEnd && (r || (r = true, o.restart(), nt && console.log(h2 + this.stackID(o) + " (restarted)"), this.advanceFully(o, i))))
        continue;
      let u = o.split(), f = h2;
      for (let d = 0; u.forceReduce() && d < 10 && (nt && console.log(f + this.stackID(u) + " (via force-reduce)"), !this.advanceFully(u, i)); d++)
        nt && (f = this.stackID(u) + " -> ");
      for (let d of o.recoverByInsert(a))
        nt && console.log(h2 + this.stackID(d) + " (via recover-insert)"), this.advanceFully(d, i);
      this.stream.end > o.pos ? (l == o.pos && (l++, a = 0), o.recoverByDelete(a, l), nt && console.log(h2 + this.stackID(o) + ` (via recover-delete ${this.parser.getName(a)})`), vu(o, i)) : (!n || n.score < o.score) && (n = o);
    }
    return n;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), E.build({
      buffer: Br.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let t = (no || (no = /* @__PURE__ */ new WeakMap())).get(e);
    return t || no.set(e, t = String.fromCodePoint(this.nextStackID++)), t + e;
  }
};
function vu(O, e) {
  for (let t = 0; t < e.length; t++) {
    let i = e[t];
    if (i.pos == O.pos && i.sameState(O)) {
      e[t].score < O.score && (e[t] = O);
      return;
    }
  }
  e.push(O);
}
var Hw = class {
  constructor(e, t, i) {
    this.source = e, this.flags = t, this.disabled = i;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
};
var ro = (O) => O;
var Ss = class {
  /// Define a context tracker.
  constructor(e) {
    this.start = e.start, this.shift = e.shift || ro, this.reduce = e.reduce || ro, this.reuse = e.reuse || ro, this.hash = e.hash || (() => 0), this.strict = e.strict !== false;
  }
};
var qe = class extends ls {
  /// @internal
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (${14})`);
    let t = e.nodeNames.split(" ");
    this.minRepeatTerm = t.length;
    for (let o = 0; o < e.repeatNodeCount; o++)
      t.push("");
    let i = Object.keys(e.topRules).map((o) => e.topRules[o][1]), n = [];
    for (let o = 0; o < t.length; o++)
      n.push([]);
    function r(o, a, l) {
      n[o].push([a, a.deserialize(String(l))]);
    }
    if (e.nodeProps)
      for (let o of e.nodeProps) {
        let a = o[0];
        typeof a == "string" && (a = _[a]);
        for (let l = 1; l < o.length; ) {
          let h2 = o[l++];
          if (h2 >= 0)
            r(h2, a, o[l++]);
          else {
            let u = o[l + -h2];
            for (let f = -h2; f > 0; f--)
              r(o[l++], a, u);
            l++;
          }
        }
      }
    this.nodeSet = new ni(t.map((o, a) => ue.define({
      name: a >= this.minRepeatTerm ? void 0 : o,
      id: a,
      props: n[a],
      top: i.indexOf(a) > -1,
      error: a == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(a) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = false, this.bufferLength = HQ;
    let s = Ti(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let o = 0; o < this.specializerSpecs.length; o++)
      this.specialized[o] = this.specializerSpecs[o].term;
    this.specializers = this.specializerSpecs.map(ku), this.states = Ti(e.states, Uint32Array), this.data = Ti(e.stateData), this.goto = Ti(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((o) => typeof o == "number" ? new DO(s, o) : o), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, t, i) {
    let n = new Fw(this, e, t, i);
    for (let r of this.wrappers)
      n = r(n, e, t, i);
    return n;
  }
  /// Get a goto table entry @internal
  getGoto(e, t, i = false) {
    let n = this.goto;
    if (t >= n[0])
      return -1;
    for (let r = n[t + 1]; ; ) {
      let s = n[r++], o = s & 1, a = n[r++];
      if (o && i)
        return a;
      for (let l = r + (s >> 1); r < l; r++)
        if (n[r] == e)
          return a;
      if (o)
        return -1;
    }
  }
  /// Check if this state has an action for a given terminal @internal
  hasAction(e, t) {
    let i = this.data;
    for (let n = 0; n < 2; n++)
      for (let r = this.stateSlot(
        e,
        n ? 2 : 1
        /* ParseState.Actions */
      ), s; ; r += 3) {
        if ((s = i[r]) == 65535)
          if (i[r + 1] == 1)
            s = i[r = Yt(i, r + 2)];
          else {
            if (i[r + 1] == 2)
              return Yt(i, r + 2);
            break;
          }
        if (s == t || s == 0)
          return Yt(i, r + 1);
      }
    return 0;
  }
  /// @internal
  stateSlot(e, t) {
    return this.states[e * 6 + t];
  }
  /// @internal
  stateFlag(e, t) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & t) > 0;
  }
  /// @internal
  validAction(e, t) {
    if (t == this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ))
      return true;
    for (let i = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = Yt(this.data, i + 2);
        else
          return false;
      if (t == Yt(this.data, i + 1))
        return true;
    }
  }
  /// Get the states that can follow this one through shift actions or
  /// goto jumps. @internal
  nextStates(e) {
    let t = [];
    for (let i = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = Yt(this.data, i + 2);
        else
          break;
      if (!(this.data[i + 2] & 1)) {
        let n = this.data[i + 1];
        t.some((r, s) => s & 1 && r == n) || t.push(this.data[i], n);
      }
    }
    return t;
  }
  /// Configure the parser. Returns a new parser instance that has the
  /// given settings modified. Settings not provided in `config` are
  /// kept from the original parser.
  configure(e) {
    let t = Object.assign(Object.create(qe.prototype), this);
    if (e.props && (t.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let i = this.topRules[e.top];
      if (!i)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      t.top = i;
    }
    return e.tokenizers && (t.tokenizers = this.tokenizers.map((i) => {
      let n = e.tokenizers.find((r) => r.from == i);
      return n ? n.to : i;
    })), e.specializers && (t.specializers = this.specializers.slice(), t.specializerSpecs = this.specializerSpecs.map((i, n) => {
      let r = e.specializers.find((o) => o.from == i.external);
      if (!r)
        return i;
      let s = Object.assign(Object.assign({}, i), { external: r.to });
      return t.specializers[n] = ku(s), s;
    })), e.contextTracker && (t.context = e.contextTracker), e.dialect && (t.dialect = this.parseDialect(e.dialect)), e.strict != null && (t.strict = e.strict), e.wrap && (t.wrappers = t.wrappers.concat(e.wrap)), e.bufferLength != null && (t.bufferLength = e.bufferLength), t;
  }
  /// Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  /// are registered for this parser.
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /// Returns the name associated with a given term. This will only
  /// work for all terms when the parser was generated with the
  /// `--names` option. By default, only the names of tagged terms are
  /// stored.
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /// The eof term id is always allocated directly after the node
  /// types. @internal
  get eofTerm() {
    return this.maxNode + 1;
  }
  /// The type of top node produced by the parser.
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /// @internal
  dynamicPrecedence(e) {
    let t = this.dynamicPrecedences;
    return t == null ? 0 : t[e] || 0;
  }
  /// @internal
  parseDialect(e) {
    let t = Object.keys(this.dialects), i = t.map(() => false);
    if (e)
      for (let r of e.split(" ")) {
        let s = t.indexOf(r);
        s >= 0 && (i[s] = true);
      }
    let n = null;
    for (let r = 0; r < t.length; r++)
      if (!i[r])
        for (let s = this.dialects[t[r]], o; (o = this.data[s++]) != 65535; )
          (n || (n = new Uint8Array(this.maxTerm + 1)))[o] = 1;
    return new Hw(e, i, n);
  }
  /// Used by the output of the parser generator. Not available to
  /// user code. @hide
  static deserialize(e) {
    return new qe(e);
  }
};
function Yt(O, e) {
  return O[e] | O[e + 1] << 16;
}
function Kw(O) {
  let e = null;
  for (let t of O) {
    let i = t.p.stoppedAt;
    (t.pos == t.p.stream.end || i != null && t.pos > i) && t.p.parser.stateFlag(
      t.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < t.score) && (e = t);
  }
  return e;
}
function ku(O) {
  if (O.external) {
    let e = O.extend ? 1 : 0;
    return (t, i) => O.external(t, i) << 1 | e;
  }
  return O.get;
}
var Jw = 54;
var eT = 1;
var tT = 55;
var OT = 2;
var iT = 56;
var nT = 3;
var Nr = 4;
var vp = 5;
var kp = 6;
var Yp = 7;
var Zp = 8;
var rT = 9;
var sT = 10;
var oT = 11;
var so = 57;
var aT = 12;
var Yu = 58;
var lT = 18;
var cT = 20;
var qp = 21;
var hT = 22;
var qa = 24;
var zp = 25;
var uT = 27;
var fT = 30;
var dT = 33;
var Up = 35;
var QT = 36;
var $T = 0;
var pT = {
  area: true,
  base: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true,
  menuitem: true
};
var mT = {
  dd: true,
  li: true,
  optgroup: true,
  option: true,
  p: true,
  rp: true,
  rt: true,
  tbody: true,
  td: true,
  tfoot: true,
  th: true,
  tr: true
};
var Zu = {
  dd: { dd: true, dt: true },
  dt: { dd: true, dt: true },
  li: { li: true },
  option: { option: true, optgroup: true },
  optgroup: { optgroup: true },
  p: {
    address: true,
    article: true,
    aside: true,
    blockquote: true,
    dir: true,
    div: true,
    dl: true,
    fieldset: true,
    footer: true,
    form: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    header: true,
    hgroup: true,
    hr: true,
    menu: true,
    nav: true,
    ol: true,
    p: true,
    pre: true,
    section: true,
    table: true,
    ul: true
  },
  rp: { rp: true, rt: true },
  rt: { rp: true, rt: true },
  tbody: { tbody: true, tfoot: true },
  td: { td: true, th: true },
  tfoot: { tbody: true },
  th: { td: true, th: true },
  thead: { tbody: true, tfoot: true },
  tr: { tr: true }
};
function gT(O) {
  return O == 45 || O == 46 || O == 58 || O >= 65 && O <= 90 || O == 95 || O >= 97 && O <= 122 || O >= 161;
}
function Vp(O) {
  return O == 9 || O == 10 || O == 13 || O == 32;
}
var qu = null;
var zu = null;
var Uu = 0;
function za(O, e) {
  let t = O.pos + e;
  if (Uu == t && zu == O)
    return qu;
  let i = O.peek(e);
  for (; Vp(i); )
    i = O.peek(++e);
  let n = "";
  for (; gT(i); )
    n += String.fromCharCode(i), i = O.peek(++e);
  return zu = O, Uu = t, qu = n ? n.toLowerCase() : i == ST || i == PT ? void 0 : null;
}
var Rp = 60;
var _p = 62;
var jp = 47;
var ST = 63;
var PT = 33;
var yT = 45;
function Vu(O, e) {
  this.name = O, this.parent = e, this.hash = e ? e.hash : 0;
  for (let t = 0; t < O.length; t++)
    this.hash += (this.hash << 4) + O.charCodeAt(t) + (O.charCodeAt(t) << 8);
}
var XT = [Nr, Zp, vp, kp, Yp];
var xT = new Ss({
  start: null,
  shift(O, e, t, i) {
    return XT.indexOf(e) > -1 ? new Vu(za(i, 1) || "", O) : O;
  },
  reduce(O, e) {
    return e == lT && O ? O.parent : O;
  },
  reuse(O, e, t, i) {
    let n = e.type.id;
    return n == Nr || n == Up ? new Vu(za(i, 1) || "", O) : O;
  },
  hash(O) {
    return O ? O.hash : 0;
  },
  strict: false
});
var bT = new te((O, e) => {
  if (O.next != Rp) {
    O.next < 0 && e.context && O.acceptToken(so);
    return;
  }
  O.advance();
  let t = O.next == jp;
  t && O.advance();
  let i = za(O, 0);
  if (i === void 0)
    return;
  if (!i)
    return O.acceptToken(t ? aT : Nr);
  let n = e.context ? e.context.name : null;
  if (t) {
    if (i == n)
      return O.acceptToken(rT);
    if (n && mT[n])
      return O.acceptToken(so, -2);
    if (e.dialectEnabled($T))
      return O.acceptToken(sT);
    for (let r = e.context; r; r = r.parent)
      if (r.name == i)
        return;
    O.acceptToken(oT);
  } else {
    if (i == "script")
      return O.acceptToken(vp);
    if (i == "style")
      return O.acceptToken(kp);
    if (i == "textarea")
      return O.acceptToken(Yp);
    if (pT.hasOwnProperty(i))
      return O.acceptToken(Zp);
    n && Zu[n] && Zu[n][i] ? O.acceptToken(so, -1) : O.acceptToken(Nr);
  }
}, { contextual: true });
var wT = new te((O) => {
  for (let e = 0, t = 0; ; t++) {
    if (O.next < 0) {
      t && O.acceptToken(Yu);
      break;
    }
    if (O.next == yT)
      e++;
    else if (O.next == _p && e >= 2) {
      t > 3 && O.acceptToken(Yu, -2);
      break;
    } else
      e = 0;
    O.advance();
  }
});
function Fl(O, e, t) {
  let i = 2 + O.length;
  return new te((n) => {
    for (let r = 0, s = 0, o = 0; ; o++) {
      if (n.next < 0) {
        o && n.acceptToken(e);
        break;
      }
      if (r == 0 && n.next == Rp || r == 1 && n.next == jp || r >= 2 && r < i && n.next == O.charCodeAt(r - 2))
        r++, s++;
      else if ((r == 2 || r == i) && Vp(n.next))
        s++;
      else if (r == i && n.next == _p) {
        o > s ? n.acceptToken(e, -s) : n.acceptToken(t, -(s - 2));
        break;
      } else if ((n.next == 10 || n.next == 13) && o) {
        n.acceptToken(e, 1);
        break;
      } else
        r = s = 0;
      n.advance();
    }
  });
}
var TT = Fl("script", Jw, eT);
var WT = Fl("style", tT, OT);
var vT = Fl("textarea", iT, nT);
var kT = ze({
  "Text RawText": c.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": c.angleBracket,
  TagName: c.tagName,
  "MismatchedCloseTag/TagName": [c.tagName, c.invalid],
  AttributeName: c.attributeName,
  "AttributeValue UnquotedAttributeValue": c.attributeValue,
  Is: c.definitionOperator,
  "EntityReference CharacterReference": c.character,
  Comment: c.blockComment,
  ProcessingInst: c.processingInstruction,
  DoctypeDecl: c.documentMeta
});
var YT = qe.deserialize({
  version: 14,
  states: ",xOVOxOOO!WQ!bO'#CoO!]Q!bO'#CyO!bQ!bO'#C|O!gQ!bO'#DPO!lQ!bO'#DRO!qOXO'#CnO!|OYO'#CnO#XO[O'#CnO$eOxO'#CnOOOW'#Cn'#CnO$lO!rO'#DTO$tQ!bO'#DVO$yQ!bO'#DWOOOW'#Dk'#DkOOOW'#DY'#DYQVOxOOO%OQ#tO,59ZO%WQ#tO,59eO%`Q#tO,59hO%hQ#tO,59kO%sQ#tO,59mOOOX'#D^'#D^O%{OXO'#CwO&WOXO,59YOOOY'#D_'#D_O&`OYO'#CzO&kOYO,59YOOO['#D`'#D`O&sO[O'#C}O'OO[O,59YOOOW'#Da'#DaO'WOxO,59YO'_Q!bO'#DQOOOW,59Y,59YOOO`'#Db'#DbO'dO!rO,59oOOOW,59o,59oO'lQ!bO,59qO'qQ!bO,59rOOOW-E7W-E7WO'vQ#tO'#CqOOQO'#DZ'#DZO(UQ#tO1G.uOOOX1G.u1G.uO(^Q#tO1G/POOOY1G/P1G/PO(fQ#tO1G/SOOO[1G/S1G/SO(nQ#tO1G/VOOOW1G/V1G/VOOOW1G/X1G/XO(yQ#tO1G/XOOOX-E7[-E7[O)RQ!bO'#CxOOOW1G.t1G.tOOOY-E7]-E7]O)WQ!bO'#C{OOO[-E7^-E7^O)]Q!bO'#DOOOOW-E7_-E7_O)bQ!bO,59lOOO`-E7`-E7`OOOW1G/Z1G/ZOOOW1G/]1G/]OOOW1G/^1G/^O)gQ&jO,59]OOQO-E7X-E7XOOOX7+$a7+$aOOOY7+$k7+$kOOO[7+$n7+$nOOOW7+$q7+$qOOOW7+$s7+$sO)rQ!bO,59dO)wQ!bO,59gO)|Q!bO,59jOOOW1G/W1G/WO*RO,UO'#CtO*dO7[O'#CtOOQO1G.w1G.wOOOW1G/O1G/OOOOW1G/R1G/ROOOW1G/U1G/UOOOO'#D['#D[O*uO,UO,59`OOQO,59`,59`OOOO'#D]'#D]O+WO7[O,59`OOOO-E7Y-E7YOOQO1G.z1G.zOOOO-E7Z-E7Z",
  stateData: "+u~O!^OS~OSSOTPOUQOVROWTOY]OZ[O[^O^^O_^O`^Oa^Ox^O{_O!dZO~OdaO~OdbO~OdcO~OddO~OdeO~O!WfOPkP!ZkP~O!XiOQnP!ZnP~O!YlORqP!ZqP~OSSOTPOUQOVROWTOXqOY]OZ[O[^O^^O_^O`^Oa^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OdvO~OdwO~OfyOj|O~OfyOj!OO~OfyOj!QO~OfyOj!SOv!TO~OfyOj!TO~O!WfOPkX!ZkX~OP!WO!Z!XO~O!XiOQnX!ZnX~OQ!ZO!Z!XO~O!YlORqX!ZqX~OR!]O!Z!XO~O!Z!XO~P#dOd!_O~O![sO!e!aO~Oj!bO~Oj!cO~Og!dOfeXjeXveX~OfyOj!fO~OfyOj!gO~OfyOj!hO~OfyOj!iOv!jO~OfyOj!jO~Od!kO~Od!lO~Od!mO~Oj!nO~Oi!qO!`!oO!b!pO~Oj!rO~Oj!sO~Oj!tO~O_!uO`!uOa!uO!`!wO!a!uO~O_!xO`!xOa!xO!b!wO!c!xO~O_!uO`!uOa!uO!`!{O!a!uO~O_!xO`!xOa!xO!b!{O!c!xO~Ov~vj`!dx{_a_~",
  goto: "%p!`PPPPPPPPPPPPPPPPPP!a!gP!mPP!yPP!|#P#S#Y#]#`#f#i#l#r#xP!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{}!P!R!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!UeZ!e{}!P!R!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue EndTag ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag SelfClosingEndTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: xT,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 5, 6, 7, 8, 9, 10, 11, "EndTag", 4, "EndTag SelfClosingEndTag", -4, 19, 29, 32, 35, "CloseTag"],
    ["group", -9, 12, 15, 16, 17, 18, 39, 40, 41, 42, "Entity", 14, "Entity TextContent", -3, 27, 30, 33, "TextContent Entity"],
    ["openedBy", 26, "StartTag StartCloseTag", -4, 28, 31, 34, 36, "OpenTag", 38, "StartTag"]
  ],
  propSources: [kT],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "#(r!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs4ysv-_vw5iwxJ^x}-_}!OKP!O!P-_!P!Q!!O!Q![-_![!]!$c!]!^-_!^!_!(k!_!`#'S!`!a#'z!a!c-_!c!}!$c!}#R-_#R#S!$c#S#T3V#T#o!$c#o#s-_#s$f$q$f%W-_%W%o!$c%o%p-_%p&a!$c&a&b-_&b1p!$c1p4U-_4U4d!$c4d4e-_4e$IS!$c$IS$I`-_$I`$Ib!$c$Ib$Kh-_$Kh%#t!$c%#t&/x-_&/x&Et!$c&Et&FV-_&FV;'S!$c;'S;:j!(e;:j;=`4s<%l?&r-_?&r?Ah!$c?Ah?BY$q?BY?Mn!$c?MnO$q!Z$|c^PiW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX^P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV^P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT^POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W^P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYiWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]`^P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljfS^PiW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_1n!_!a&X!a#S-_#S#T3V#T#s-_#s$f$q$f;'S-_;'S;=`4s<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ecfSiWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!^!_0p!a#S/^#S#T0p#T#s/^#s$f+P$f;'S/^;'S;=`1h<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0uXfSqr0psw0px!P0p!Q!_0p!a#s0p$f;'S0p;'S;=`1b<%l?Ah0p?BY?Mn0pS1eP;=`<%l0p[1kP;=`<%l/^!U1wbfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!U3SP;=`<%l1n!V3bcfS^P!a`!cpOq&Xqr3Vrs&}sv3Vvw0pwx(tx!P3V!P!Q&X!Q!^3V!^!_1n!_!a&X!a#s3V#s$f&X$f;'S3V;'S;=`4m<%l?Ah3V?Ah?BY&X?BY?Mn3V?MnO&X!V4pP;=`<%l3V!_4vP;=`<%l-_!Z5SV!`h^P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_5rjfSiWa!ROX7dXZ8qZ[7d[^8q^p7dqr:crs8qst@Ttw:cwx8qx!P:c!P!Q7d!Q!]:c!]!^/^!^!_=p!_!a8q!a#S:c#S#T=p#T#s:c#s$f7d$f;'S:c;'S;=`?}<%l?Ah:c?Ah?BY7d?BY?Mn:c?MnO7d!Z7ibiWOX7dXZ8qZ[7d[^8q^p7dqr7drs8qst+Ptw7dwx8qx!]7d!]!^9f!^!a8q!a#S7d#S#T8q#T;'S7d;'S;=`:]<%lO7d!R8tVOp8qqs8qt!]8q!]!^9Z!^;'S8q;'S;=`9`<%lO8q!R9`O_!R!R9cP;=`<%l8q!Z9mYiW_!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z:`P;=`<%l7d!_:jjfSiWOX7dXZ8qZ[7d[^8q^p7dqr:crs8qst/^tw:cwx8qx!P:c!P!Q7d!Q!]:c!]!^<[!^!_=p!_!a8q!a#S:c#S#T=p#T#s:c#s$f7d$f;'S:c;'S;=`?}<%l?Ah:c?Ah?BY7d?BY?Mn:c?MnO7d!_<ecfSiW_!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!^!_0p!a#S/^#S#T0p#T#s/^#s$f+P$f;'S/^;'S;=`1h<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V=udfSOp8qqr=prs8qst0ptw=pwx8qx!P=p!P!Q8q!Q!]=p!]!^?T!^!_=p!_!a8q!a#s=p#s$f8q$f;'S=p;'S;=`?w<%l?Ah=p?Ah?BY8q?BY?Mn=p?MnO8q!V?[XfS_!Rqr0psw0px!P0p!Q!_0p!a#s0p$f;'S0p;'S;=`1b<%l?Ah0p?BY?Mn0p!V?zP;=`<%l=p!_@QP;=`<%l:c!_@[ifSiWOXAyXZCTZ[Ay[^CT^pAyqrDrrsCTswDrwxCTx!PDr!P!QAy!Q!]Dr!]!^/^!^!_G|!_!aCT!a#SDr#S#TG|#T#sDr#s$fAy$f;'SDr;'S;=`JW<%l?AhDr?Ah?BYAy?BY?MnDr?MnOAy!ZBOaiWOXAyXZCTZ[Ay[^CT^pAyqrAyrsCTswAywxCTx!]Ay!]!^Cu!^!aCT!a#SAy#S#TCT#T;'SAy;'S;=`Dl<%lOAy!RCWUOpCTq!]CT!]!^Cj!^;'SCT;'S;=`Co<%lOCT!RCoO`!R!RCrP;=`<%lCT!ZC|YiW`!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZDoP;=`<%lAy!_DyifSiWOXAyXZCTZ[Ay[^CT^pAyqrDrrsCTswDrwxCTx!PDr!P!QAy!Q!]Dr!]!^Fh!^!_G|!_!aCT!a#SDr#S#TG|#T#sDr#s$fAy$f;'SDr;'S;=`JW<%l?AhDr?Ah?BYAy?BY?MnDr?MnOAy!_FqcfSiW`!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!^!_0p!a#S/^#S#T0p#T#s/^#s$f+P$f;'S/^;'S;=`1h<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VHRcfSOpCTqrG|rsCTswG|wxCTx!PG|!P!QCT!Q!]G|!]!^I^!^!_G|!_!aCT!a#sG|#s$fCT$f;'SG|;'S;=`JQ<%l?AhG|?Ah?BYCT?BY?MnG|?MnOCT!VIeXfS`!Rqr0psw0px!P0p!Q!_0p!a#s0p$f;'S0p;'S;=`1b<%l?Ah0p?BY?Mn0p!VJTP;=`<%lG|!_JZP;=`<%lDr!ZJgW!bx^P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aK^lfS^PiW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMU!O!P-_!P!Q$q!Q!^-_!^!_1n!_!a&X!a#S-_#S#T3V#T#s-_#s$f$q$f;'S-_;'S;=`4s<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aMckfS^PiW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_1n!_!`&X!`!a! W!a#S-_#S#T3V#T#s-_#s$f$q$f;'S-_;'S;=`4s<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!T! cX^P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!a!!Zd^PiW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!`&X!`!a!#i!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!X!#vX^P!a`!cpvSjUOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!a!$r!ZfSdQ^PiW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!O!$c!O!P!$c!P!Q$q!Q![!$c![!]!$c!]!^-_!^!_1n!_!a&X!a!c-_!c!}!$c!}#R-_#R#S!$c#S#T3V#T#o!$c#o#s-_#s$f$q$f$}-_$}%O!$c%O%W-_%W%o!$c%o%p-_%p&a!$c&a&b-_&b1p!$c1p4U!$c4U4d!$c4d4e-_4e$IS!$c$IS$I`-_$I`$Ib!$c$Ib$Je-_$Je$Jg!$c$Jg$Kh-_$Kh%#t!$c%#t&/x-_&/x&Et!$c&Et&FV-_&FV;'S!$c;'S;:j!(e;:j;=`4s<%l?&r-_?&r?Ah!$c?Ah?BY$q?BY?Mn!$c?MnO$q!a!(hP;=`<%l!$c!V!(tcfS!a`!cpOq*Vqr!*Prs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!b!H^!b#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!*YhfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex}1n}!O!+t!O!P1n!P!Q*V!Q!_1n!_!a*V!a!f1n!f!g!.p!g#W1n#W#X!?^#X#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!+}dfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex}1n}!O!-]!O!P1n!P!Q*V!Q!_1n!_!a*V!a#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!-hbfS!a`!cp!dPOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!.ydfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!q1n!q!r!0X!r#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!0bdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!e1n!e!f!1p!f#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!1ydfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!v1n!v!w!3X!w#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!3bdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!{1n!{!|!4p!|#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!4ydfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!r1n!r!s!6X!s#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!6bdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!g1n!g!h!7p!h#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!7ycfS!a`!cpOq!9Uqr!7prs!9{sv!7pvw!=swx!;ox!P!7p!P!Q!9U!Q!_!7p!_!`!9U!`!a!<}!a#s!7p#s$f!9U$f;'S!7p;'S;=`!?W<%l?Ah!7p?Ah?BY!9U?BY?Mn!7p?MnO!9U!R!9]Y!a`!cpOr!9Urs!9{sv!9Uvw!:gwx!;ox!`!9U!`!a!<}!a;'S!9U;'S;=`!=m<%lO!9Uq!:QV!cpOv!9{vx!:gx!`!9{!`!a!;U!a;'S!9{;'S;=`!;i<%lO!9{P!:jTO!`!:g!`!a!:y!a;'S!:g;'S;=`!;O<%lO!:gP!;OO{PP!;RP;=`<%l!:gq!;]S!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!;lP;=`<%l!9{a!;tX!a`Or!;ors!:gsv!;ovw!:gw!`!;o!`!a!<a!a;'S!;o;'S;=`!<w<%lO!;oa!<hT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!<zP;=`<%l!;o!R!=WV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!=pP;=`<%l!9UT!=xbfSOq!:gqr!=srs!:gsw!=swx!:gx!P!=s!P!Q!:g!Q!_!=s!_!`!:g!`!a!:y!a#s!=s#s$f!:g$f;'S!=s;'S;=`!?Q<%l?Ah!=s?Ah?BY!:g?BY?Mn!=s?MnO!:gT!?TP;=`<%l!=s!V!?ZP;=`<%l!7p!V!?gdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#c1n#c#d!@u#d#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!AOdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#V1n#V#W!B^#W#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!BgdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#h1n#h#i!Cu#i#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!DOdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#m1n#m#n!E^#n#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!EgdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#d1n#d#e!Fu#e#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!GOdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#X1n#X#Y!7p#Y#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!HgcfS!a`!cpOq!Irqr!H^rs!Jisv!H^vw#!vwx!MZx!P!H^!P!Q!Ir!Q!_!H^!_!a!Ir!a!b#%h!b#s!H^#s$f!Ir$f;'S!H^;'S;=`#&|<%l?Ah!H^?Ah?BY!Ir?BY?Mn!H^?MnO!Ir!R!IyY!a`!cpOr!Irrs!Jisv!Irvw!KTwx!MZx!a!Ir!a!b# Z!b;'S!Ir;'S;=`#!p<%lO!Irq!JnV!cpOv!Jivx!KTx!a!Ji!a!b!LU!b;'S!Ji;'S;=`!MT<%lO!JiP!KWTO!a!KT!a!b!Kg!b;'S!KT;'S;=`!LO<%lO!KTP!KjTO!`!KT!`!a!Ky!a;'S!KT;'S;=`!LO<%lO!KTP!LOOxPP!LRP;=`<%l!KTq!LZV!cpOv!Jivx!KTx!`!Ji!`!a!Lp!a;'S!Ji;'S;=`!MT<%lO!Jiq!LwS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!MWP;=`<%l!Jia!M`X!a`Or!MZrs!KTsv!MZvw!KTw!a!MZ!a!b!M{!b;'S!MZ;'S;=`# T<%lO!MZa!NQX!a`Or!MZrs!KTsv!MZvw!KTw!`!MZ!`!a!Nm!a;'S!MZ;'S;=`# T<%lO!MZa!NtT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea# WP;=`<%l!MZ!R# bY!a`!cpOr!Irrs!Jisv!Irvw!KTwx!MZx!`!Ir!`!a#!Q!a;'S!Ir;'S;=`#!p<%lO!Ir!R#!ZV!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R#!sP;=`<%l!IrT#!{bfSOq!KTqr#!vrs!KTsw#!vwx!KTx!P#!v!P!Q!KT!Q!_#!v!_!a!KT!a!b#$T!b#s#!v#s$f!KT$f;'S#!v;'S;=`#%b<%l?Ah#!v?Ah?BY!KT?BY?Mn#!v?MnO!KTT#$YbfSOq!KTqr#!vrs!KTsw#!vwx!KTx!P#!v!P!Q!KT!Q!_#!v!_!`!KT!`!a!Ky!a#s#!v#s$f!KT$f;'S#!v;'S;=`#%b<%l?Ah#!v?Ah?BY!KT?BY?Mn#!v?MnO!KTT#%eP;=`<%l#!v!V#%qcfS!a`!cpOq!Irqr!H^rs!Jisv!H^vw#!vwx!MZx!P!H^!P!Q!Ir!Q!_!H^!_!`!Ir!`!a#!Q!a#s!H^#s$f!Ir$f;'S!H^;'S;=`#&|<%l?Ah!H^?Ah?BY!Ir?BY?Mn!H^?MnO!Ir!V#'PP;=`<%l!H^!V#'_XgS^P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!X#(VX^P!a`!cpjUOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [TT, WT, vT, bT, wT, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 13] },
  dialects: { noMatch: 0, selfClosing: 485 },
  tokenPrec: 487
});
function Cp(O, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let i of O.getChildren(qp)) {
    let n = i.getChild(hT), r = i.getChild(qa) || i.getChild(zp);
    n && (t[e.read(n.from, n.to)] = r ? r.type.id == qa ? e.read(r.from + 1, r.to - 1) : e.read(r.from, r.to) : "");
  }
  return t;
}
function Ru(O, e) {
  let t = O.getChild(cT);
  return t ? e.read(t.from, t.to) : " ";
}
function oo(O, e, t) {
  let i;
  for (let n of t)
    if (!n.attrs || n.attrs(i || (i = Cp(O.node.parent.firstChild, e))))
      return { parser: n.parser };
  return null;
}
function Gp(O = [], e = []) {
  let t = [], i = [], n = [], r = [];
  for (let o of O)
    (o.tag == "script" ? t : o.tag == "style" ? i : o.tag == "textarea" ? n : r).push(o);
  let s = e.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let o of e)
    (s[o.name] || (s[o.name] = [])).push(o);
  return xl((o, a) => {
    let l = o.type.id;
    if (l == uT)
      return oo(o, a, t);
    if (l == fT)
      return oo(o, a, i);
    if (l == dT)
      return oo(o, a, n);
    if (l == Up && r.length) {
      let h2 = o.node, u = Ru(h2, a), f;
      for (let d of r)
        if (d.tag == u && (!d.attrs || d.attrs(f || (f = Cp(h2, a))))) {
          let Q = h2.parent.lastChild;
          return { parser: d.parser, overlay: [{ from: o.to, to: Q.type.id == QT ? Q.from : h2.parent.to }] };
        }
    }
    if (s && l == qp) {
      let h2 = o.node, u;
      if (u = h2.firstChild) {
        let f = s[a.read(u.from, u.to)];
        if (f)
          for (let d of f) {
            if (d.tagName && d.tagName != Ru(h2.parent, a))
              continue;
            let Q = h2.lastChild;
            if (Q.type.id == qa)
              return { parser: d.parser, overlay: [{ from: Q.from + 1, to: Q.to - 1 }] };
            if (Q.type.id == zp)
              return { parser: d.parser, overlay: [{ from: Q.from, to: Q.to }] };
          }
      }
    }
    return null;
  });
}
var ZT = 94;
var _u = 1;
var qT = 95;
var zT = 96;
var ju = 2;
var Ip = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
];
var UT = 58;
var VT = 40;
var Ep = 95;
var RT = 91;
var ur = 45;
var _T = 46;
var jT = 35;
var CT = 37;
function Fr(O) {
  return O >= 65 && O <= 90 || O >= 97 && O <= 122 || O >= 161;
}
function GT(O) {
  return O >= 48 && O <= 57;
}
var IT = new te((O, e) => {
  for (let t = false, i = 0, n = 0; ; n++) {
    let { next: r } = O;
    if (Fr(r) || r == ur || r == Ep || t && GT(r))
      !t && (r != ur || n > 0) && (t = true), i === n && r == ur && i++, O.advance();
    else {
      t && O.acceptToken(r == VT ? qT : i == 2 && e.canShift(ju) ? ju : zT);
      break;
    }
  }
});
var ET = new te((O) => {
  if (Ip.includes(O.peek(-1))) {
    let { next: e } = O;
    (Fr(e) || e == Ep || e == jT || e == _T || e == RT || e == UT || e == ur) && O.acceptToken(ZT);
  }
});
var AT = new te((O) => {
  if (!Ip.includes(O.peek(-1))) {
    let { next: e } = O;
    if (e == CT && (O.advance(), O.acceptToken(_u)), Fr(e)) {
      do
        O.advance();
      while (Fr(O.next));
      O.acceptToken(_u);
    }
  }
});
var DT = ze({
  "AtKeyword import charset namespace keyframes media supports": c.definitionKeyword,
  "from to selector": c.keyword,
  NamespaceName: c.namespace,
  KeyframeName: c.labelName,
  TagName: c.tagName,
  ClassName: c.className,
  PseudoClassName: c.constant(c.className),
  IdName: c.labelName,
  "FeatureName PropertyName": c.propertyName,
  AttributeName: c.attributeName,
  NumberLiteral: c.number,
  KeywordQuery: c.keyword,
  UnaryQueryOp: c.operatorKeyword,
  "CallTag ValueName": c.atom,
  VariableName: c.variableName,
  Callee: c.operatorKeyword,
  Unit: c.unit,
  "UniversalSelector NestingSelector": c.definitionOperator,
  MatchOp: c.compareOperator,
  "ChildOp SiblingOp, LogicOp": c.logicOperator,
  BinOp: c.arithmeticOperator,
  Important: c.modifier,
  Comment: c.blockComment,
  ParenthesizedContent: c.special(c.name),
  ColorLiteral: c.color,
  StringLiteral: c.string,
  ":": c.punctuation,
  "PseudoOp #": c.derefOperator,
  "; ,": c.separator,
  "( )": c.paren,
  "[ ]": c.squareBracket,
  "{ }": c.brace
});
var MT = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, "nth-last-of-type": 32, dir: 32, "host-context": 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 134 };
var LT = { __proto__: null, "@import": 114, "@media": 138, "@charset": 142, "@namespace": 146, "@keyframes": 152, "@supports": 164 };
var BT = { __proto__: null, not: 128, only: 128, from: 158, to: 160 };
var NT = qe.deserialize({
  version: 14,
  states: "7WQYQ[OOO#_Q[OOOOQP'#Cd'#CdOOQP'#Cc'#CcO#fQ[O'#CfO$YQXO'#CaO$aQ[O'#ChO$lQ[O'#DPO$qQ[O'#DTOOQP'#Ed'#EdO$vQdO'#DeO%bQ[O'#DrO$vQdO'#DtO%sQ[O'#DvO&OQ[O'#DyO&TQ[O'#EPO&cQ[O'#EROOQS'#Ec'#EcOOQS'#ET'#ETQYQ[OOO&jQXO'#CdO'_QWO'#DaO'dQWO'#EjO'oQ[O'#EjQOQWOOOOQP'#Cg'#CgOOQP,59Q,59QO#fQ[O,59QO'yQ[O'#EWO(eQWO,58{O(mQ[O,59SO$lQ[O,59kO$qQ[O,59oO'yQ[O,59sO'yQ[O,59uO'yQ[O,59vO(xQ[O'#D`OOQS,58{,58{OOQP'#Ck'#CkOOQO'#C}'#C}OOQP,59S,59SO)PQWO,59SO)UQWO,59SOOQP'#DR'#DROOQP,59k,59kOOQO'#DV'#DVO)ZQ`O,59oOOQS'#Cp'#CpO$vQdO'#CqO)cQvO'#CsO*pQtO,5:POOQO'#Cx'#CxO)UQWO'#CwO+UQWO'#CyOOQS'#Eg'#EgOOQO'#Dh'#DhO+ZQ[O'#DoO+iQWO'#EkO&TQ[O'#DmO+wQWO'#DpOOQO'#El'#ElO(hQWO,5:^O+|QpO,5:`OOQS'#Dx'#DxO,UQWO,5:bO,ZQ[O,5:bOOQO'#D{'#D{O,cQWO,5:eO,hQWO,5:kO,pQWO,5:mOOQS-E8R-E8RO$vQdO,59{O,xQ[O'#EYO-VQWO,5;UO-VQWO,5;UOOQP1G.l1G.lO-|QXO,5:rOOQO-E8U-E8UOOQS1G.g1G.gOOQP1G.n1G.nO)PQWO1G.nO)UQWO1G.nOOQP1G/V1G/VO.ZQ`O1G/ZO.tQXO1G/_O/[QXO1G/aO/rQXO1G/bO0YQWO,59zO0_Q[O'#DOO0fQdO'#CoOOQP1G/Z1G/ZO$vQdO1G/ZO0mQpO,59]OOQS,59_,59_O$vQdO,59aO0uQWO1G/kOOQS,59c,59cO0zQ!bO,59eO1SQWO'#DhO1_QWO,5:TO1dQWO,5:ZO&TQ[O,5:VO&TQ[O'#EZO1lQWO,5;VO1wQWO,5:XO'yQ[O,5:[OOQS1G/x1G/xOOQS1G/z1G/zOOQS1G/|1G/|O2YQWO1G/|O2_QdO'#D|OOQS1G0P1G0POOQS1G0V1G0VOOQS1G0X1G0XO2mQtO1G/gOOQO,5:t,5:tO3TQ[O,5:tOOQO-E8W-E8WO3bQWO1G0pOOQP7+$Y7+$YOOQP7+$u7+$uO$vQdO7+$uOOQS1G/f1G/fO3mQXO'#EiO3tQWO,59jO3yQtO'#EUO4nQdO'#EfO4xQWO,59ZO4}QpO7+$uOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%V7+%VO5VQWO1G/PO$vQdO1G/oOOQO1G/u1G/uOOQO1G/q1G/qO5[QWO,5:uOOQO-E8X-E8XO5jQXO1G/vOOQS7+%h7+%hO5qQYO'#CsO(hQWO'#E[O5yQdO,5:hOOQS,5:h,5:hO6XQtO'#EXO$vQdO'#EXO7VQdO7+%ROOQO7+%R7+%ROOQO1G0`1G0`O7jQpO<<HaO7rQWO,5;TOOQP1G/U1G/UOOQS-E8S-E8SO$vQdO'#EVO7zQWO,5;QOOQT1G.u1G.uOOQP<<Ha<<HaOOQS7+$k7+$kO8SQdO7+%ZOOQO7+%b7+%bOOQS,5:v,5:vOOQS-E8Y-E8YOOQS1G0S1G0SO8ZQtO,5:sOOQS-E8V-E8VOOQO<<Hm<<HmOOQPAN={AN={O9XQdO,5:qOOQO-E8T-E8TOOQO<<Hu<<Hu",
  stateData: "9i~O#UOSROS~OUXOXXO]UO^UOtVOxWO!Y`O!ZYO!gZO!i[O!k]O!n^O!t_O#SQO#XSO~OQeOUXOXXO]UO^UOtVOxWO!Y`O!ZYO!gZO!i[O!k]O!n^O!t_O#SdO#XSO~O#P#^P~P!ZO#SiO~O]nO^nOplOtoOxpO|qO!PsO#QrO#XkO~O!RtO~P#kO`zO#RwO#SvO~O#S{O~O#S}O~OQ!WOb!QOf!WOh!WOn!VO#R!TO#S!PO#[!RO~Ob!YO!b![O!e!]O#S!XO!R#_P~Oh!bOn!VO#S!aO~O#S!dO~Ob!YO!b![O!e!]O#S!XO~O!W#_P~P%bO]WX]!UX^WXpWXtWXxWX|WX!PWX!RWX#QWX#XWX~O]!iO~O!W!jO#P#^X!Q#^X~O#P#^X!Q#^X~P!ZOUXOXXO]UO^UOtVOxWO#SQO#XSO~OplO!RtO~O`!sO#RwO#SvO~O!Q#^P~P!ZOb!zO~Ob!{O~Ov!|Oz!}O~OP#PObgXjgX!WgX!bgX!egX#SgXagXQgXfgXhgXngXpgX!VgX#PgX#RgX#[gXvgX!QgX~Ob!YOj#QO!b![O!e!]O#S!XO!W#_P~Ob#TO~Ob!YO!b![O!e!]O#S#UO~Op#YO!`#XO!R#_X!W#_X~Ob#]O~Oj#QO!W#_O~O!W#`O~Oh#aOn!VO~O!R#bO~O!RtO!`#XO~O!RtO!W#eO~O!W!|X#P!|X!Q!|X~P!ZO!W!jO#P#^a!Q#^a~O]nO^nOtoOxpO|qO!PsO#QrO#XkO~Op!za!R!zaa!za~P-bOv#lOz#mO~O]nO^nOtoOxpO#XkO~Op{i|{i!P{i!R{i#Q{ia{i~P.cOp}i|}i!P}i!R}i#Q}ia}i~P.cOp!Oi|!Oi!P!Oi!R!Oi#Q!Oia!Oi~P.cO!Q#nO~Oa#]P~P'yOa#YP~P$vOa#uOj#QO~O!W#wO~Oh#xOo#xO~O]!^Xa![X!`![X~O]#yO~Oa#zO!`#XO~Op#YO!R#_a!W#_a~O!`#XOp!aa!R!aa!W!aaa!aa~O!W$PO~O!Q$TO!q$RO!r$RO#[$QO~Oj#QOp$VO!V$XO!W!Ti#P!Ti!Q!Ti~P$vO!W!|a#P!|a!Q!|a~P!ZO!W!jO#P#^i!Q#^i~Oa#]X~P#kOa$]O~Oj#QOQ!xXa!xXb!xXf!xXh!xXn!xXp!xX#R!xX#S!xX#[!xX~Op$_Oa#YX~P$vOa$aO~Oj#QOv$bO~Oa$cO~O!`#XOp!}a!R!}a!W!}a~Oa$eO~P-bOP#PO!RgX~O!Q$hO!q$RO!r$RO#[$QO~Oj#QOQ!{Xb!{Xf!{Xh!{Xn!{Xp!{X!V!{X!W!{X#P!{X#R!{X#S!{X#[!{X!Q!{X~Op$VO!V$kO!W!Tq#P!Tq!Q!Tq~P$vOj#QOv$lO~OplOa#]a~Op$_Oa#Ya~Oa$oO~P$vOj#QOQ!{ab!{af!{ah!{an!{ap!{a!V!{a!W!{a#P!{a#R!{a#S!{a#[!{a!Q!{a~Oa!yap!ya~P$vOo#[j!Pj~",
  goto: ",`#aPPPPP#bP#k#zP#k$Z#kPP$aPPP$g$p$pP%SP$pP$p%j%|PPP&f&l#kP&rP#kP&xP#kP#k#kPPP'O'b'oPP#bPP'v'v(Q'vP'vP'v'vP#bP#bP#bP(T#bP(W(ZPP#bP#bP(^(m({)R)])c)m)sPPPPPP)y*SP*o*rP+h+k+q+z_aOPcgt!j#hkXOPcglqrst!j!z#]#hkROPcglqrst!j!z#]#hQjSR!mkQxUR!qnQ!qzQ#S!UR#k!sq!WY[!Q!i!{!}#Q#f#m#r#y$V$W$_$d$mp!WY[!Q!i!{!}#Q#f#m#r#y$V$W$_$d$mT$R#b$Sq!UY[!Q!i!{!}#Q#f#m#r#y$V$W$_$d$mp!WY[!Q!i!{!}#Q#f#m#r#y$V$W$_$d$mQ!b]R#a!cQyUR!rnQ!qyR#k!rQ|VR!toQ!OWR!upQuTQ!pmQ#^!_Q#d!fQ#e!gR$f$RSfPtQ!lgQ#g!jR$Y#hZePgt!j#ha!^Z_`!S!Y![#X#YR#V!YR!c]R!e^R#c!eQcOSgPtU!hcg#hR#h!jQ#r!{U$^#r$d$mQ$d#yR$m$_Q$`#rR$n$`QmTS!om$[R$[#oQ$W#fR$j$WQ!kfS#i!k#jR#j!lQ#Z!ZR#}#ZQ$S#bR$g$S_bOPcgt!j#h^TOPcgt!j#hQ!nlQ!vqQ!wrQ!xsQ#o!zR$O#]R#s!{Q!SYQ!`[Q#O!QQ#f!i[#q!{#r#y$_$d$mQ#t!}Q#v#QS$U#f$WQ$Z#mR$i$VR#p!zQhPR!ytQ!_ZQ!g`R#R!SU!ZZ`!SQ!f_Q#W!YQ#[![Q#{#XR#|#Y",
  nodeNames: "⚠ Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent , PseudoClassName ArgList IdSelector # IdName ] AttributeSelector [ AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList from to SupportsStatement supports AtRule Styles",
  maxTerm: 108,
  nodeProps: [
    ["openedBy", 17, "(", 48, "{"],
    ["closedBy", 18, ")", 49, "}"]
  ],
  propSources: [DT],
  skippedNodes: [0, 3],
  repeatNodeCount: 8,
  tokenData: "Lq~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Cu![!]Dp!]!^El!^!_$}!_!`E}!`!aF`!a!b$}!b!cG[!c!}$}!}#OHt#O#P$}#P#QIV#Q#R6d#R#T$}#T#UIh#U#c$}#c#dJy#d#o$}#o#pK`#p#q6d#q#rKq#r#sLS#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`Lk<%lO$}W%QSOy%^z;'S%^;'S;=`%o<%lO%^W%cSoWOy%^z;'S%^;'S;=`%o<%lO%^W%rP;=`<%l%^~%zh#U~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#U~oWOX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^^)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^^)sUoWOy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^^*[UoWOy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^^*sUoWOy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^^+[UoWOy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^^+sUoWOy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^^,[UoWOy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^^,sUoWOy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^^-[UoWOy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^^-uS!VUoWOy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.R_/zYtPOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^^0oYoWOy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^^1dYoWOy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^^2ZYfUoWOy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^^3QYfUoWOy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^^3uYoWOy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^^4lYfUoWOy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^^5aYoWOy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^^6WSfUoWOy%^z;'S%^;'S;=`%o<%lO%^Y6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^Y7QSzQoWOy%^z;'S%^;'S;=`%o<%lO%^X7cSXPOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7o_9cSbVOy%^z;'S%^;'S;=`%o<%lO%^~9tOa~_9{UUPjSOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^_:fWjS!PPOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^^;TUoWOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^^;nYoW#[UOy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^^<cYoWOy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^^=WUoWOy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^^=qUoW#[UOy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^^>[[oW#[UOy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^_?VSpVOy%^z;'S%^;'S;=`%o<%lO%^^?hWjSOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^_@VU#XPOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjSOy%^z{@}{;'S%^;'S;=`%o<%lO%^~ASUoWOy@}yzAfz{Bm{;'S@};'S;=`Co<%lO@}~AiTOzAfz{Ax{;'SAf;'S;=`Bg<%lOAf~A{VOzAfz{Ax{!PAf!P!QBb!Q;'SAf;'S;=`Bg<%lOAf~BgOR~~BjP;=`<%lAf~BrWoWOy@}yzAfz{Bm{!P@}!P!QC[!Q;'S@};'S;=`Co<%lO@}~CcSoWR~Oy%^z;'S%^;'S;=`%o<%lO%^~CrP;=`<%l@}^Cz[#[UOy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^XDuU]POy%^z![%^![!]EX!];'S%^;'S;=`%o<%lO%^XE`S^PoWOy%^z;'S%^;'S;=`%o<%lO%^_EqS!WVOy%^z;'S%^;'S;=`%o<%lO%^YFSSzQOy%^z;'S%^;'S;=`%o<%lO%^XFeU|POy%^z!`%^!`!aFw!a;'S%^;'S;=`%o<%lO%^XGOS|PoWOy%^z;'S%^;'S;=`%o<%lO%^XG_WOy%^z!c%^!c!}Gw!}#T%^#T#oGw#o;'S%^;'S;=`%o<%lO%^XHO[!YPoWOy%^z}%^}!OGw!O!Q%^!Q![Gw![!c%^!c!}Gw!}#T%^#T#oGw#o;'S%^;'S;=`%o<%lO%^XHySxPOy%^z;'S%^;'S;=`%o<%lO%^^I[SvUOy%^z;'S%^;'S;=`%o<%lO%^XIkUOy%^z#b%^#b#cI}#c;'S%^;'S;=`%o<%lO%^XJSUoWOy%^z#W%^#W#XJf#X;'S%^;'S;=`%o<%lO%^XJmS!`PoWOy%^z;'S%^;'S;=`%o<%lO%^XJ|UOy%^z#f%^#f#gJf#g;'S%^;'S;=`%o<%lO%^XKeS!RPOy%^z;'S%^;'S;=`%o<%lO%^_KvS!QVOy%^z;'S%^;'S;=`%o<%lO%^ZLXU!PPOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^WLnP;=`<%l$}",
  tokenizers: [ET, AT, IT, 0, 1, 2, 3],
  topRules: { StyleSheet: [0, 4], Styles: [1, 84] },
  specialized: [{ term: 95, get: (O) => MT[O] || -1 }, { term: 56, get: (O) => LT[O] || -1 }, { term: 96, get: (O) => BT[O] || -1 }],
  tokenPrec: 1123
});
var ao = null;
function lo() {
  if (!ao && typeof document == "object" && document.body) {
    let { style: O } = document.body, e = [], t = /* @__PURE__ */ new Set();
    for (let i in O)
      i != "cssText" && i != "cssFloat" && typeof O[i] == "string" && (/[A-Z]/.test(i) && (i = i.replace(/[A-Z]/g, (n) => "-" + n.toLowerCase())), t.has(i) || (e.push(i), t.add(i)));
    ao = e.sort().map((i) => ({ type: "property", label: i }));
  }
  return ao || [];
}
var Cu = [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((O) => ({ type: "class", label: O }));
var Gu = [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((O) => ({ type: "keyword", label: O })).concat([
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((O) => ({ type: "constant", label: O })));
var FT = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((O) => ({ type: "type", label: O }));
var jt = /^[\w-]*/;
var HT = (O) => {
  let { state: e, pos: t } = O, i = B(e).resolveInner(t, -1);
  if (i.name == "PropertyName")
    return { from: i.from, options: lo(), validFor: jt };
  if (i.name == "ValueName")
    return { from: i.from, options: Gu, validFor: jt };
  if (i.name == "PseudoClassName")
    return { from: i.from, options: Cu, validFor: jt };
  if (i.name == "TagName") {
    for (let { parent: s } = i; s; s = s.parent)
      if (s.name == "Block")
        return { from: i.from, options: lo(), validFor: jt };
    return { from: i.from, options: FT, validFor: jt };
  }
  if (!O.explicit)
    return null;
  let n = i.resolve(t), r = n.childBefore(t);
  return r && r.name == ":" && n.name == "PseudoClassSelector" ? { from: t, options: Cu, validFor: jt } : r && r.name == ":" && n.name == "Declaration" || n.name == "ArgList" ? { from: t, options: Gu, validFor: jt } : n.name == "Block" ? { from: t, options: lo(), validFor: jt } : null;
};
var Hr = Ze.define({
  name: "css",
  parser: NT.configure({
    props: [
      Ce.add({
        Declaration: $e()
      }),
      Ge.add({
        Block: _t
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function Ap() {
  return new je(Hr, Hr.data.of({ autocomplete: HT }));
}
var Iu = 301;
var Eu = 1;
var KT = 2;
var Au = 302;
var JT = 304;
var e0 = 305;
var t0 = 3;
var O0 = 4;
var i0 = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
];
var Dp = 125;
var n0 = 59;
var Du = 47;
var r0 = 42;
var s0 = 43;
var o0 = 45;
var a0 = new Ss({
  start: false,
  shift(O, e) {
    return e == t0 || e == O0 || e == JT ? O : e == e0;
  },
  strict: false
});
var l0 = new te((O, e) => {
  let { next: t } = O;
  (t == Dp || t == -1 || e.context) && e.canShift(Au) && O.acceptToken(Au);
}, { contextual: true, fallback: true });
var c0 = new te((O, e) => {
  let { next: t } = O, i;
  i0.indexOf(t) > -1 || t == Du && ((i = O.peek(1)) == Du || i == r0) || t != Dp && t != n0 && t != -1 && !e.context && e.canShift(Iu) && O.acceptToken(Iu);
}, { contextual: true });
var h0 = new te((O, e) => {
  let { next: t } = O;
  if ((t == s0 || t == o0) && (O.advance(), t == O.next)) {
    O.advance();
    let i = !e.context && e.canShift(Eu);
    O.acceptToken(i ? Eu : KT);
  }
}, { contextual: true });
var u0 = ze({
  "get set async static": c.modifier,
  "for while do if else switch try catch finally return throw break continue default case": c.controlKeyword,
  "in of await yield void typeof delete instanceof": c.operatorKeyword,
  "let var const function class extends": c.definitionKeyword,
  "import export from": c.moduleKeyword,
  "with debugger as new": c.keyword,
  TemplateString: c.special(c.string),
  super: c.atom,
  BooleanLiteral: c.bool,
  this: c.self,
  null: c.null,
  Star: c.modifier,
  VariableName: c.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": c.function(c.variableName),
  VariableDefinition: c.definition(c.variableName),
  Label: c.labelName,
  PropertyName: c.propertyName,
  PrivatePropertyName: c.special(c.propertyName),
  "CallExpression/MemberExpression/PropertyName": c.function(c.propertyName),
  "FunctionDeclaration/VariableDefinition": c.function(c.definition(c.variableName)),
  "ClassDeclaration/VariableDefinition": c.definition(c.className),
  PropertyDefinition: c.definition(c.propertyName),
  PrivatePropertyDefinition: c.definition(c.special(c.propertyName)),
  UpdateOp: c.updateOperator,
  LineComment: c.lineComment,
  BlockComment: c.blockComment,
  Number: c.number,
  String: c.string,
  Escape: c.escape,
  ArithOp: c.arithmeticOperator,
  LogicOp: c.logicOperator,
  BitOp: c.bitwiseOperator,
  CompareOp: c.compareOperator,
  RegExp: c.regexp,
  Equals: c.definitionOperator,
  Arrow: c.function(c.punctuation),
  ": Spread": c.punctuation,
  "( )": c.paren,
  "[ ]": c.squareBracket,
  "{ }": c.brace,
  "InterpolationStart InterpolationEnd": c.special(c.brace),
  ".": c.derefOperator,
  ", ;": c.separator,
  "@": c.meta,
  TypeName: c.typeName,
  TypeDefinition: c.definition(c.typeName),
  "type enum interface implements namespace module declare": c.definitionKeyword,
  "abstract global Privacy readonly override": c.modifier,
  "is keyof unique infer": c.operatorKeyword,
  JSXAttributeValue: c.attributeValue,
  JSXText: c.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": c.angleBracket,
  "JSXIdentifier JSXNameSpacedName": c.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": c.attributeName,
  "JSXBuiltin/JSXIdentifier": c.standard(c.tagName)
});
var f0 = { __proto__: null, export: 14, as: 19, from: 27, default: 30, async: 35, function: 36, extends: 46, this: 50, true: 58, false: 58, null: 70, void: 74, typeof: 78, super: 96, new: 130, delete: 146, yield: 155, await: 159, class: 164, public: 219, private: 219, protected: 219, readonly: 221, instanceof: 240, satisfies: 243, in: 244, const: 246, import: 278, keyof: 333, unique: 337, infer: 343, is: 379, abstract: 399, implements: 401, type: 403, let: 406, var: 408, interface: 415, enum: 419, namespace: 425, module: 427, declare: 431, global: 435, for: 456, of: 465, while: 468, with: 472, do: 476, if: 480, else: 482, switch: 486, case: 492, try: 498, catch: 502, finally: 506, return: 510, throw: 514, break: 518, continue: 522, debugger: 526 };
var d0 = { __proto__: null, async: 117, get: 119, set: 121, public: 181, private: 181, protected: 181, static: 183, abstract: 185, override: 187, readonly: 193, accessor: 195, new: 383 };
var Q0 = { __proto__: null, "<": 137 };
var $0 = qe.deserialize({
  version: 14,
  states: "$BhO`QUOOO%QQUOOO'TQWOOP(_OSOOO*mQ(CjO'#CfO*tOpO'#CgO+SO!bO'#CgO+bO07`O'#DZO-sQUO'#DaO.TQUO'#DlO%QQUO'#DvO0[QUO'#EOOOQ(CY'#EW'#EWO0rQSO'#ETOOQO'#I_'#I_O0zQSO'#GjOOQO'#Eh'#EhO1VQSO'#EgO1[QSO'#EgO3^Q(CjO'#JbO5}Q(CjO'#JcO6kQSO'#FVO6pQ#tO'#FnOOQ(CY'#F_'#F_O6{O&jO'#F_O7ZQ,UO'#FuO8qQSO'#FtOOQ(CY'#Jc'#JcOOQ(CW'#Jb'#JbOOQQ'#J|'#J|O8vQSO'#IOO8{Q(C[O'#IPOOQQ'#JO'#JOOOQQ'#IT'#ITQ`QUOOO%QQUO'#DnO9TQUO'#DzO%QQUO'#D|O9[QSO'#GjO9aQ,UO'#ClO9oQSO'#EfO9zQSO'#EqO:PQ,UO'#F^O:nQSO'#GjO:sQSO'#GnO;OQSO'#GnO;^QSO'#GqO;^QSO'#GrO;^QSO'#GtO9[QSO'#GwO;}QSO'#GzO=`QSO'#CbO=pQSO'#HXO=xQSO'#H_O=xQSO'#HaO`QUO'#HcO=xQSO'#HeO=xQSO'#HhO=}QSO'#HnO>SQ(C]O'#HtO%QQUO'#HvO>_Q(C]O'#HxO>jQ(C]O'#HzO8{Q(C[O'#H|O>uQ(CjO'#CfO?wQWO'#DfQOQSOOO@_QSO'#EPO9aQ,UO'#EfO@jQSO'#EfO@uQ`O'#F^OOQQ'#Cd'#CdOOQ(CW'#Dk'#DkOOQ(CW'#Jf'#JfO%QQUO'#JfOBOQWO'#E_OOQ(CW'#E^'#E^OBYQ(C`O'#E_OBtQWO'#ESOOQO'#Ji'#JiOCYQWO'#ESOCgQWO'#E_OC}QWO'#EeODQQWO'#E_O@}QWO'#E_OBtQWO'#E_PDkO?MpO'#C`POOO)CDm)CDmOOOO'#IU'#IUODvOpO,59ROOQ(CY,59R,59ROOOO'#IV'#IVOEUO!bO,59RO%QQUO'#D]OOOO'#IX'#IXOEdO07`O,59uOOQ(CY,59u,59uOErQUO'#IYOFVQSO'#JdOHXQbO'#JdO+pQUO'#JdOH`QSO,59{OHvQSO'#EhOITQSO'#JqOI`QSO'#JpOI`QSO'#JpOIhQSO,5;UOImQSO'#JoOOQ(CY,5:W,5:WOItQUO,5:WOKuQ(CjO,5:bOLfQSO,5:jOLkQSO'#JmOMeQ(C[O'#JnO:sQSO'#JmOMlQSO'#JmOMtQSO,5;TOMyQSO'#JmOOQ(CY'#Cf'#CfO%QQUO'#EOONmQ`O,5:oOOQO'#Jj'#JjOOQO-E<]-E<]O9[QSO,5=UO! TQSO,5=UO! YQUO,5;RO!#]Q,UO'#EcO!$pQSO,5;RO!&YQ,UO'#DpO!&aQUO'#DuO!&kQWO,5;[O!&sQWO,5;[O%QQUO,5;[OOQQ'#E}'#E}OOQQ'#FP'#FPO%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]OOQQ'#FT'#FTO!'RQUO,5;nOOQ(CY,5;s,5;sOOQ(CY,5;t,5;tO!)UQSO,5;tOOQ(CY,5;u,5;uO%QQUO'#IeO!)^Q(C[O,5<bO!#]Q,UO,5;]O!){Q,UO,5;]O%QQUO,5;qO!*SQ#tO'#FdO!+PQ#tO'#JuO!*kQ#tO'#JuO!+WQ#tO'#JuOOQO'#Ju'#JuO!+lQ#tO,5;|OOOO,5<Y,5<YO!+}QUO'#FpOOOO'#Id'#IdO6{O&jO,5;yO!,UQ#tO'#FrOOQ(CY,5;y,5;yO!,uQ7[O'#CrOOQ(CY'#Cv'#CvO!-YQSO'#CvO!-_O07`O'#CzO!-{Q,UO,5<_O!.SQSO,5<aO!/iQMhO'#GPO!/vQSO'#GQO!/{QSO'#GQO!0QQMhO'#GUO!1PQWO'#GYO!1rQ7[O'#J]OOQ(CY'#J]'#J]O!1|QSO'#J[O!2[QSO'#JZO!2dQSO'#CqOOQ(CY'#Ct'#CtOOQ(CY'#DO'#DOOOQ(CY'#DQ'#DQO0uQSO'#DSO!$uQ,UO'#FwO!$uQ,UO'#FyO!2lQSO'#F{O!2qQSO'#F|O!/{QSO'#GSO!$uQ,UO'#GXO!2vQSO'#EiO!3bQSO,5<`O`QUO,5>jOOQQ'#JW'#JWOOQQ,5>k,5>kOOQQ-E<R-E<RO!5aQ(CjO,5:YO!7}Q(CjO,5:fO%QQUO,5:fO!:hQ(CjO,5:hOOQ(CW'#Co'#CoO!;XQ,UO,5=UO!;gQ(C[O'#JXO8qQSO'#JXO=}QSO,59WO!;xQWO,59WO!<QQ,UO,59WO9aQ,UO,59WO!<]QSO,5;RO!<eQSO'#HWO!<vQSO'#KQO%QQUO,5;vO!=OQWO,5;xO!=TQSO,5=qO!=YQSO,5=qO!=_QSO,5=qO8{Q(C[O,5=qO!=mQSO'#EjO!>gQWO'#EkOOQ(CW'#Jo'#JoO!>nQ(C[O'#J}O8{Q(C[O,5=YO;^QSO,5=`OOQO'#Cr'#CrO!>yQWO,5=]O!?RQ,UO,5=^O!?^QSO,5=`O!?cQ`O,5=cO=}QSO'#G|O9[QSO'#HOO!?kQSO'#HOO9aQ,UO'#HRO!?pQSO'#HROOQQ,5=f,5=fO!?uQSO'#HSO!?}QSO'#ClO!@SQSO,58|O!@^QSO,58|O!BfQUO,58|OOQQ,58|,58|O!BsQ(C[O,58|O%QQUO,58|O!COQUO'#HZOOQQ'#H['#H[OOQQ'#H]'#H]O`QUO,5=sO!C`QSO,5=sO`QUO,5=yO`QUO,5={O!CeQSO,5=}O`QUO,5>PO!CjQSO,5>SO!CoQUO,5>YOOQQ,5>`,5>`O%QQUO,5>`O8{Q(C[O,5>bOOQQ,5>d,5>dO!GvQSO,5>dOOQQ,5>f,5>fO!GvQSO,5>fOOQQ,5>h,5>hO!G{QWO'#DXO%QQUO'#JfO!HjQWO'#JfO!IXQWO'#DgO!IjQWO'#DgO!K{QUO'#DgO!LSQSO'#JeO!L[QSO,5:QO!LaQSO'#ElO!LoQSO'#JrO!LwQSO,5;VO!L|QWO'#DgO!MZQWO'#EROOQ(CY,5:k,5:kO%QQUO,5:kO!MbQSO,5:kO=}QSO,5;QO!;xQWO,5;QO!<QQ,UO,5;QO9aQ,UO,5;QO!MjQSO,5@QO!MoQ!LQO,5:oO!NrQ(C`O,5:yOBtQWO,5:nO# ^QWO,5:nO# kQWO,5:yO#!RQWO,5:yO#!lQWO,5:yOBtQWO,5:yO=}QSO,5:nOOQ(CW'#Eb'#EbOOQO,5:y,5:yO%QQUO,5:yO##]Q(C[O,5:yO##hQ(C[O,5:yO!;xQWO,5:nOOQO,5;P,5;PO##vQ(C[O,5:yPOOO'#IS'#ISP#$[O?MpO,58zPOOO,58z,58zOOOO-E<S-E<SOOQ(CY1G.m1G.mOOOO-E<T-E<TO#$gQ`O,59wOOOO-E<V-E<VOOQ(CY1G/a1G/aO#$lQbO,5>tO+pQUO,5>tOOQO,5>z,5>zO#$vQUO'#IYOOQO-E<W-E<WO#%TQSO,5@OO#%]QbO,5@OO#%dQSO,5@[OOQ(CY1G/g1G/gO%QQUO,5@]O#%lQSO'#I`OOQO-E<^-E<^O#%dQSO,5@[OOQ(CW1G0p1G0pOOQ(CY1G/r1G/rOOQ(CY1G0U1G0UO#&QQSO,5@XO:sQSO,5@XO#&YQSO,5@XO%QQUO,5@YO#&hQ(C[O,5@YO#&yQ(C[O,5@YO#'QQSO'#IbO#&QQSO,5@XOOQ(CW1G0o1G0oO!&kQWO,5:qO!&vQWO,5:qOOQO,5:s,5:sO#'oQSO,5:sO#'wQ,UO1G2pO9[QSO1G2pOOQ(CY1G0m1G0mO#(VQ(CjO1G0mO#)[Q(ChO,5:}OOQ(CY'#GO'#GOO#)xQ(CjO'#J]O! YQUO1G0mO#,QQ,UO'#JgO#,[QSO,5:[O#,aQbO'#JhO%QQUO'#JhO#,kQSO,5:aOOQ(CY'#DX'#DXOOQ(CY1G0v1G0vO%QQUO1G0vOOQ(CY1G1`1G1`O#,pQSO1G0vO#/XQ(CjO1G0wO#/`Q(CjO1G0wO#1yQ(CjO1G0wO#2QQ(CjO1G0wO#4[Q(CjO1G0wO#4rQ(CjO1G0wO#7lQ(CjO1G0wO#7sQ(CjO1G0wO#:^Q(CjO1G0wO#:eQ(CjO1G0wO#<]Q(CjO1G0wO#?]Q$IUO'#CfO#AZQ$IUO1G1YO#CXQ$IUO'#JcO!)XQSO1G1`O#ClQ(CjO,5?POOQ(CW-E<c-E<cO#D`Q(CjO1G0wOOQ(CY1G0w1G0wO#FkQ(CjO1G1]O#G_Q#tO,5<QO#GgQ#tO,5<RO#GoQ#tO'#FiO#HWQSO'#FhOOQO'#Jv'#JvOOQO'#Ic'#IcO#H]Q#tO1G1hOOQ(CY1G1h1G1hOOOO1G1s1G1sO#HnQ$IUO'#JbO#HxQSO,5<[O!'RQUO,5<[OOOO-E<b-E<bOOQ(CY1G1e1G1eO#H}QWO'#JuOOQ(CY,5<^,5<^O#IVQWO,5<^OOQ(CY,59b,59bO!#]Q,UO'#C|OOOO'#IW'#IWO#I[O07`O,59fOOQ(CY,59f,59fO%QQUO1G1yO!2qQSO'#IgO#IgQSO,5<rOOQ(CY,5<o,5<oOOQO'#Ge'#GeO!$uQ,UO,5=OOOQO'#Gg'#GgO!$uQ,UO,5=QO!#]Q,UO,5=SOOQO1G1{1G1{O#IuQ`O'#CoO#JYQ`O,5<kO#JaQSO'#JyO9[QSO'#JyO#JoQSO,5<mO!$uQ,UO,5<lO#JtQSO'#GRO#KPQSO,5<lO#KUQ`O'#GOO#KcQ`O'#JzO#KmQSO'#JzO!#]Q,UO'#JzO#KrQSO,5<pO#KwQWO'#GZO!0zQWO'#GZO#LYQSO'#G]O#L_QSO'#G_O!/{QSO'#GbO#LdQ(C[O'#IiO#LoQWO,5<tOOQ(CY,5<t,5<tO#LvQWO'#GZO#MUQWO'#G[O#M^QWO'#G[OOQ(CY,5=T,5=TO!$uQ,UO,5?vO!$uQ,UO,5?vO#McQSO'#IjO#MnQSO,5?uO#MvQSO,59]O#NgQ,UO,59nOOQ(CY,59n,59nO$ YQ,UO,5<cO$ {Q,UO,5<eO?oQSO,5<gOOQ(CY,5<h,5<hO$!VQSO,5<nO$![Q,UO,5<sO! YQUO1G1zO$!lQSO1G1zOOQQ1G4U1G4UOOQ(CY1G/t1G/tO!)UQSO1G/tO$$kQ(CjO1G0QOOQQ1G2p1G2pO!#]Q,UO1G2pO%QQUO1G2pO$%[QSO1G2pO$%gQ,UO'#EcOOQ(CW,5?s,5?sO$%qQ(C[O,5?sOOQQ1G.r1G.rO=}QSO1G.rO!;xQWO1G.rO!<QQ,UO1G.rO$&SQSO1G0mO$&XQSO'#CfO$&dQSO'#KRO$&lQSO,5=rO$&qQSO'#KRO$&vQSO'#KRO$'RQSO'#IrO$'aQSO,5@lO$'iQbO1G1bOOQ(CY1G1d1G1dO9[QSO1G3]O?oQSO1G3]O$'pQSO1G3]O$'uQSO1G3]OOQQ1G3]1G3]O:sQSO'#JpO:sQSO'#ElO%QQUO'#ElO:sQSO'#IlO$'zQ(C[O,5@iOOQQ1G2t1G2tO!?^QSO1G2zO!#]Q,UO1G2wO$(VQSO1G2wOOQQ1G2x1G2xO!#]Q,UO1G2xO$([QSO1G2xO$(dQWO'#GvOOQQ1G2z1G2zO!0zQWO'#InO!?cQ`O1G2}OOQQ1G2}1G2}OOQQ,5=h,5=hO$(lQ,UO,5=jO9[QSO,5=jO#L_QSO,5=mO8qQSO,5=mO!;xQWO,5=mO!<QQ,UO,5=mO9aQ,UO,5=mO$(zQSO'#KPO$)VQSO,5=nOOQQ1G.h1G.hO$)[Q(C[O1G.hO?oQSO1G.hO$)gQSO1G.hO8{Q(C[O1G.hO$)rQbO,5@nO$*VQSO,5@nO$*bQUO,5=uO$*iQSO,5=uO:sQSO,5@nOOQQ1G3_1G3_O`QUO1G3_OOQQ1G3e1G3eOOQQ1G3g1G3gO=xQSO1G3iO$*nQUO1G3kO$.oQUO'#HjOOQQ1G3n1G3nO$.|QSO'#HpO=}QSO'#HrOOQQ1G3t1G3tO$/UQUO1G3tO8{Q(C[O1G3zOOQQ1G3|1G3|OOQ(CW'#GV'#GVO8{Q(C[O1G4OO8{Q(C[O1G4QO$3YQSO,5@QO!'RQUO,5;WO:sQSO,5;WO=}QSO,5:RO!'RQUO,5:RO!;xQWO,5:RO$3_Q$IUO,5:ROOQO,5;W,5;WO$3iQWO'#IZO$4PQSO,5@POOQ(CY1G/l1G/lO$4XQWO'#IaO$4cQSO,5@^OOQ(CW1G0q1G0qO!IjQWO,5:ROOQO'#I^'#I^O$4kQWO,5:mOOQ(CY,5:m,5:mO!MeQSO1G0VOOQ(CY1G0V1G0VO%QQUO1G0VOOQ(CY1G0l1G0lO=}QSO1G0lO!;xQWO1G0lO!<QQ,UO1G0lOOQ(CW1G5l1G5lO=}QSO1G0YOOQO1G0e1G0eO%QQUO1G0eO$4rQ(C[O1G0eO$4}Q(C[O1G0eO!;xQWO1G0YOBtQWO1G0YO$5]Q(C`O1G0eO$5wQWO1G0YOBtQWO1G0eO$6UQWO1G0eO$6lQWO1G0eO$7VQ(C[O1G0eOOQO1G0Y1G0YO$7kQ(CjO1G0ePOOO-E<Q-E<QPOOO1G.f1G.fOOOO1G/c1G/cO$7uQ`O,5<bO$7}QbO1G4`OOQO1G4f1G4fO%QQUO,5>tO$8XQSO1G5jO$8aQSO1G5vO$8iQbO1G5wO:sQSO,5>zO$8sQSO1G5sO$8sQSO1G5sO:sQSO1G5sO$8{Q(CjO1G5tO%QQUO1G5tO$9]Q(C[O1G5tO$9nQSO,5>|O:sQSO,5>|OOQO,5>|,5>|O$:SQSO,5>|OOQO-E<`-E<`OOQO1G0]1G0]OOQO1G0_1G0_O!)XQSO1G0_OOQQ7+([7+([O!#]Q,UO7+([O%QQUO7+([O$:bQSO7+([O$:mQ,UO7+([O$:{Q(CjO,59nO$=TQ(CjO,5<cO$?`Q(CjO,5<eO$AkQ(CjO,5<sOOQ(CY7+&X7+&XO$C|Q(CjO7+&XO$DpQ,UO'#I[O$DzQSO,5@ROOQ(CY1G/v1G/vO$ESQUO'#I]O$EaQSO,5@SO$EiQbO,5@SOOQ(CY1G/{1G/{O$EsQSO7+&bOOQ(CY7+&b7+&bO$ExQ$IUO,5:bO%QQUO7+&tO$FSQ$IUO,5:YO$FaQ$IUO,5:fO$FkQ$IUO,5:hOOQ(CY7+&z7+&zOOQO1G1l1G1lOOQO1G1m1G1mO$FuQ#tO,5<TO!'RQUO,5<SOOQO-E<a-E<aOOQ(CY7+'S7+'SOOOO7+'_7+'_OOOO1G1v1G1vO$GQQSO1G1vOOQ(CY1G1x1G1xO$GVQ`O,59hOOOO-E<U-E<UOOQ(CY1G/Q1G/QO$G^Q(CjO7+'eOOQ(CY,5?R,5?RO$HQQSO,5?ROOQ(CY1G2^1G2^P$HVQSO'#IgPOQ(CY-E<e-E<eO$HyQ,UO1G2jO$IlQ,UO1G2lO$IvQ`O1G2nOOQ(CY1G2V1G2VO$I}QSO'#IfO$J]QSO,5@eO$J]QSO,5@eO$JeQSO,5@eO$JpQSO,5@eOOQO1G2X1G2XO$KOQ,UO1G2WO!$uQ,UO1G2WO$K`QMhO'#IhO$KpQSO,5@fO!#]Q,UO,5@fO$KxQ`O,5@fOOQ(CY1G2[1G2[OOQ(CW,5<u,5<uOOQ(CW,5<v,5<vO$LSQSO,5<vOBoQSO,5<vO!;xQWO,5<uOOQO'#G^'#G^O$LXQSO,5<wOOQ(CW,5<y,5<yO$LSQSO,5<|OOQO,5?T,5?TOOQO-E<g-E<gOOQ(CY1G2`1G2`O!0zQWO,5<uO$LaQSO,5<vO#LYQSO,5<wO!0zQWO,5<vO$LlQ,UO1G5bO$LvQ,UO1G5bOOQO,5?U,5?UOOQO-E<h-E<hOOQO1G.w1G.wO!=OQWO,59pO%QQUO,59pO$MTQSO1G2RO!$uQ,UO1G2YO$MYQ(CjO7+'fOOQ(CY7+'f7+'fO! YQUO7+'fOOQ(CY7+%`7+%`O$M|Q`O'#J{O!MeQSO7+([O$NWQbO7+([O$:eQSO7+([O$N_Q(ChO'#CfO$NrQ(ChO,5<zO% dQSO,5<zOOQ(CW1G5_1G5_OOQQ7+$^7+$^O=}QSO7+$^O!;xQWO7+$^O! YQUO7+&XO% iQSO'#IqO% }QSO,5@mOOQO1G3^1G3^O9[QSO,5@mO% }QSO,5@mO%!VQSO,5@mOOQO,5?^,5?^OOQO-E<p-E<pOOQ(CY7+&|7+&|O%![QSO7+(wO8{Q(C[O7+(wO9[QSO7+(wO?oQSO7+(wO%!aQSO,5;WOOQ(CW,5?W,5?WOOQ(CW-E<j-E<jOOQQ7+(f7+(fO%!fQ(ChO7+(cO!#]Q,UO7+(cO%!pQ`O7+(dOOQQ7+(d7+(dO!#]Q,UO7+(dO%!wQSO'#KOO%#SQSO,5=bOOQO,5?Y,5?YOOQO-E<l-E<lOOQQ7+(i7+(iO%$`QWO'#HPOOQQ1G3U1G3UO!#]Q,UO1G3UO%QQUO1G3UO%$gQSO1G3UO%$rQ,UO1G3UO8{Q(C[O1G3XO#L_QSO1G3XO8qQSO1G3XO!;xQWO1G3XO!<QQ,UO1G3XO%%QQSO'#IpO%%]QSO,5@kO%%eQWO,5@kOOQ(CW1G3Y1G3YOOQQ7+$S7+$SO?oQSO7+$SO8{Q(C[O7+$SO%%pQSO7+$SO%QQUO1G6YO%QQUO1G6ZO%%uQUO1G3aO%%|QSO1G3aO%&RQUO1G3aO%&YQ(C[O1G6YOOQQ7+(y7+(yO8{Q(C[O7+)TO`QUO7+)VOOQQ'#KU'#KUOOQQ'#Is'#IsO%&dQUO,5>UOOQQ,5>U,5>UO%QQUO'#HkO%&qQSO'#HmOOQQ,5>[,5>[O:sQSO,5>[OOQQ,5>^,5>^OOQQ7+)`7+)`OOQQ7+)f7+)fOOQQ7+)j7+)jOOQQ7+)l7+)lO%&vQWO1G5lO%'[Q$IUO1G0rO%'fQSO1G0rOOQO1G/m1G/mO%'qQ$IUO1G/mO=}QSO1G/mO!'RQUO'#DgOOQO,5>u,5>uOOQO-E<X-E<XOOQO,5>{,5>{OOQO-E<_-E<_O!;xQWO1G/mOOQO-E<[-E<[OOQ(CY1G0X1G0XOOQ(CY7+%q7+%qO!MeQSO7+%qOOQ(CY7+&W7+&WO=}QSO7+&WO!;xQWO7+&WOOQO7+%t7+%tO$7kQ(CjO7+&POOQO7+&P7+&PO%QQUO7+&PO%'{Q(C[O7+&PO=}QSO7+%tO!;xQWO7+%tO%(WQ(C[O7+&POBtQWO7+%tO%(fQ(C[O7+&PO%(zQ(C`O7+&PO%)UQWO7+%tOBtQWO7+&PO%)cQWO7+&PO%)yQSO7++_O%)yQSO7++_O%*RQ(CjO7++`O%QQUO7++`OOQO1G4h1G4hO:sQSO1G4hO%*cQSO1G4hOOQO7+%y7+%yO!MeQSO<<KvO$NWQbO<<KvO%*qQSO<<KvOOQQ<<Kv<<KvO!#]Q,UO<<KvO%QQUO<<KvO%*yQSO<<KvO%+UQ(CjO1G2jO%-aQ(CjO1G2lO%/lQ(CjO1G2WO%1}Q,UO,5>vOOQO-E<Y-E<YO%2XQbO,5>wO%QQUO,5>wOOQO-E<Z-E<ZO%2cQSO1G5nOOQ(CY<<I|<<I|O%2kQ$IUO1G0mO%4uQ$IUO1G0wO%4|Q$IUO1G0wO%7QQ$IUO1G0wO%7XQ$IUO1G0wO%8|Q$IUO1G0wO%9dQ$IUO1G0wO%;wQ$IUO1G0wO%<OQ$IUO1G0wO%>SQ$IUO1G0wO%>ZQ$IUO1G0wO%@RQ$IUO1G0wO%@fQ(CjO<<J`O%AkQ$IUO1G0wO%CaQ$IUO'#J]O%EdQ$IUO1G1]O%EqQ$IUO1G0QO!'RQUO'#FkOOQO'#Jw'#JwOOQO1G1o1G1oO%E{QSO1G1nO%FQQ$IUO,5?POOOO7+'b7+'bOOOO1G/S1G/SOOQ(CY1G4m1G4mO!$uQ,UO7+(YO%F[QSO,5?QO9[QSO,5?QOOQO-E<d-E<dO%FjQSO1G6PO%FjQSO1G6PO%FrQSO1G6PO%F}Q,UO7+'rO%G_Q`O,5?SO%GiQSO,5?SO!#]Q,UO,5?SOOQO-E<f-E<fO%GnQ`O1G6QO%GxQSO1G6QOOQ(CW1G2b1G2bO$LSQSO1G2bOOQ(CW1G2a1G2aO%HQQSO1G2cO!#]Q,UO1G2cOOQ(CW1G2h1G2hO!;xQWO1G2aOBoQSO1G2bO%HVQSO1G2cO%H_QSO1G2bO!$uQ,UO7+*|OOQ(CY1G/[1G/[O%HjQSO1G/[OOQ(CY7+'m7+'mO%HoQ,UO7+'tO%IPQ(CjO<<KQOOQ(CY<<KQ<<KQO!#]Q,UO'#IkO%IsQSO,5@gO!#]Q,UO1G2fOOQQ<<Gx<<GxO=}QSO<<GxO%I{Q(CjO<<IsOOQ(CY<<Is<<IsOOQO,5?],5?]O%JoQSO,5?]O$&vQSO,5?]OOQO-E<o-E<oO%JtQSO1G6XO%JtQSO1G6XO9[QSO1G6XO?oQSO<<LcOOQQ<<Lc<<LcO%J|QSO<<LcO8{Q(C[O<<LcO%KRQSO1G0rOOQQ<<K}<<K}O%!fQ(ChO<<K}OOQQ<<LO<<LOO%!pQ`O<<LOO%KWQWO'#ImO%KcQSO,5@jO!'RQUO,5@jOOQQ1G2|1G2|O%KkQ(C`O'#JfO%LVQUO'#JfO%L^QWO'#E_O%LwQ(C[O'#E_OBYQ(C`O'#E_O(VQWO'#HQOOQO'#Io'#IoO8{Q(C[O'#IoO%M]QWO,5=kOOQQ,5=k,5=kO%MuQWO'#E_O%LmQWO'#E_O%M|QWO'#E_O%NgQWO'#E_O& WQWO'#HQO& iQSO7+(pO& nQSO7+(pOOQQ7+(p7+(pO!#]Q,UO7+(pO%QQUO7+(pO& vQSO7+(pOOQQ7+(s7+(sO8{Q(C[O7+(sO#L_QSO7+(sO8qQSO7+(sO!;xQWO7+(sO&!RQSO,5?[OOQO-E<n-E<nOOQO'#HT'#HTO&!^QSO1G6VO8{Q(C[O<<GnOOQQ<<Gn<<GnO?oQSO<<GnO&!fQSO7++tO&!kQSO7++uOOQQ7+({7+({O&!pQSO7+({O&!uQUO7+({O&!|QSO7+({O%QQUO7++tO%QQUO7++uOOQQ<<Lo<<LoOOQQ<<Lq<<LqOOQQ-E<q-E<qOOQQ1G3p1G3pO&#RQSO,5>VOOQQ,5>X,5>XO&#WQSO1G3vO:sQSO7+&^O!'RQUO7+&^OOQO7+%X7+%XO&#]Q$IUO1G5wO=}QSO7+%XOOQ(CY<<I]<<I]OOQ(CY<<Ir<<IrO=}QSO<<IrOOQO<<Ik<<IkO$7kQ(CjO<<IkO%QQUO<<IkOOQO<<I`<<I`O=}QSO<<I`O&#gQ(C[O<<IkO!;xQWO<<I`O&#rQ(C[O<<IkOBtQWO<<I`O&$QQ(C[O<<IkO&$fQ(C`O<<IkO&$pQWO<<I`OBtQWO<<IkO&$}QSO<<NyO&%VQ(CjO<<NzOOQO7+*S7+*SO:sQSO7+*SOOQQANAbANAbO&%gQSOANAbO!#]Q,UOANAbO!MeQSOANAbO$NWQbOANAbO%QQUOANAbO&%oQ(CjO7+'rO&(QQ(CjO7+'tO&*cQbO1G4cO&*mQ$IUO7+&XO&*zQ$IUO,59nO&,}Q$IUO,5<cO&/QQ$IUO,5<eO&1TQ$IUO,5<sO&2yQ$IUO7+'eO&3WQ$IUO7+'fO&3eQSO,5<VOOQO7+'Y7+'YO&3jQ,UO<<KtOOQO1G4l1G4lO&3qQSO1G4lO&3|QSO1G4lO&4[QSO7++kO&4[QSO7++kO!#]Q,UO1G4nO&4dQ`O1G4nO&4nQSO7++lOOQ(CW7+'|7+'|O$LSQSO7+'}O&4vQ`O7+'}OOQ(CW7+'{7+'{O$LSQSO7+'|O&4}QSO7+'}O!#]Q,UO7+'}OBoQSO7+'|O&5SQ,UO<<NhOOQ(CY7+$v7+$vO&5^Q`O,5?VOOQO-E<i-E<iO&5hQ(ChO7+(QOOQQAN=dAN=dO9[QSO1G4wOOQO1G4w1G4wO&5xQSO1G4wO&5}QSO7++sO&5}QSO7++sO8{Q(C[OANA}O?oQSOANA}OOQQANA}ANA}OOQQANAiANAiOOQQANAjANAjO&6VQSO,5?XOOQO-E<k-E<kO&6bQ$IUO1G6UO#L_QSO,5=lO8qQSO,5=lO&8rQbO'#CfO&8|QWO,5:yO&9WQWO,5:yO&9eQWO,5:yO!;xQWO,5=lOOQO,5?Z,5?ZOOQO-E<m-E<mOOQQ1G3V1G3VO%LVQUO,5<wO%KkQ(C`O,5=lO!NrQ(C`O,5:yO(VQWO,5=lO&9xQWO,5=lO&:ZQWO,5:yOOQQ<<L[<<L[O!#]Q,UO<<L[O& iQSO<<L[O&:tQSO<<L[O%QQUO<<L[OOQQ<<L_<<L_O8{Q(C[O<<L_O#L_QSO<<L_O8qQSO<<L_O&:|QWO1G4vO&;XQSO7++qOOQQAN=YAN=YO8{Q(C[OAN=YOOQQ<= `<= `OOQQ<= a<= aOOQQ<<Lg<<LgO&;aQSO<<LgO&;fQUO<<LgO&;mQSO<= `O&;rQSO<= aOOQQ1G3q1G3qO=}QSO7+)bO&;wQSO<<IxO&<SQ$IUO<<IxOOQO<<Hs<<HsOOQ(CYAN?^AN?^OOQOAN?VAN?VO$7kQ(CjOAN?VOOQOAN>zAN>zO%QQUOAN?VO=}QSOAN>zO&<^Q(C[OAN?VO!;xQWOAN>zO&<iQ(C[OAN?VOBtQWOAN>zO&<wQ(C[OAN?VOOQO<<Mn<<MnOOQQG26|G26|O!#]Q,UOG26|O!MeQSOG26|O&=]QSOG26|O$NWQbOG26|O&=eQ$IUO<<J`O&=rQ$IUO1G2WO&?hQ$IUO1G2jO&AkQ$IUO1G2lO&CnQ$IUO<<KQO&C{Q$IUO<<IsOOQO1G1q1G1qO!$uQ,UOANA`OOQO7+*W7+*WO&DYQSO7+*WO&DeQSO<= VO&DmQ`O7+*YOOQ(CW<<Ki<<KiO$LSQSO<<KiOOQ(CW<<Kh<<KhO&DwQ`O<<KiO$LSQSO<<KhOOQO7+*c7+*cO9[QSO7+*cO&EOQSO<= _OOQQG27iG27iO8{Q(C[OG27iO!'RQUO1G4sO&EWQSO7++pO8{Q(C[O1G3WO#L_QSO1G3WO&E`QWO1G0eO&EjQWO1G0eO8qQSO1G3WO!;xQWO1G3WO(VQWO1G3WO%KkQ(C`O1G3WO$5]Q(C`O1G0eO&EwQWO1G3WO& iQSOANAvOOQQANAvANAvO!#]Q,UOANAvO&FYQSOANAvOOQQANAyANAyO8{Q(C[OANAyO#L_QSOANAyOOQO'#HU'#HUOOQO7+*b7+*bOOQQG22tG22tOOQQANBRANBRO&FbQSOANBROOQQANDzANDzOOQQAND{AND{OOQQ<<L|<<L|O!'RQUOAN?dOOQOG24qG24qO$7kQ(CjOG24qOOQOG24fG24fO%QQUOG24qO=}QSOG24fO&FgQ(C[OG24qO!;xQWOG24fO&FrQ(C[OG24qO!MeQSOLD,hOOQQLD,hLD,hO!#]Q,UOLD,hO&GQQSOLD,hO&GYQ$IUO7+'rO&IOQ$IUO7+'tO&JtQ,UOG26zOOQO<<Mr<<MrOOQ(CWANATANATO$LSQSOANATOOQ(CWANASANASOOQO<<M}<<M}OOQQLD-TLD-TO&KUQ$IUO7+*_OOQO7+(r7+(rO8{Q(C[O7+(rO&K`QWO7+&PO#L_QSO7+(rO8qQSO7+(rO!;xQWO7+(rO(VQWO7+(rOOQQG27bG27bO& iQSOG27bO!#]Q,UOG27bOOQQG27eG27eO8{Q(C[OG27eOOQQG27mG27mO&KjQ$IUOG25OOOQOLD*]LD*]O$7kQ(CjOLD*]OOQOLD*QLD*QO%QQUOLD*]O=}QSOLD*QO&KtQ(C[OLD*]OOQQ!$(!S!$(!SO!MeQSO!$(!SO!#]Q,UO!$(!SO&LPQ(CjOG26zOOQ(CWG26oG26oOOQO<<L^<<L^O8{Q(C[O<<L^O#L_QSO<<L^O8qQSO<<L^O!;xQWO<<L^OOQQLD,|LD,|O& iQSOLD,|OOQQLD-PLD-POOQO!$'Mw!$'MwO$7kQ(CjO!$'MwOOQO!$'Ml!$'MlO%QQUO!$'MwOOQQ!)9En!)9EnO!MeQSO!)9EnOOQOANAxANAxO8{Q(C[OANAxO#L_QSOANAxO8qQSOANAxOOQQ!$(!h!$(!hOOQO!)9Cc!)9CcO$7kQ(CjO!)9CcOOQQ!.K;Y!.K;YO&NbQ$IUOG26zOOQOG27dG27dO8{Q(C[OG27dO#L_QSOG27dOOQO!.K8}!.K8}OOQOLD-OLD-OO8{Q(C[OLD-OOOQO!$(!j!$(!jO!'RQUO'#DvO0rQSO'#ETO'!WQbO'#JbO!'RQUO'#DnO'!_QUO'#DzO!'RQUO'#D|O'!fQbO'#CfO'$|QbO'#CfO'%^QUO,5;RO!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO'#IeO''aQSO,5<bO''iQ,UO,5;]O'(|Q,UO,5;]O!'RQUO,5;qO0uQSO'#DSO0uQSO'#DSO!#]Q,UO'#FwO''iQ,UO'#FwO!#]Q,UO'#FyO''iQ,UO'#FyO!#]Q,UO'#GXO''iQ,UO'#GXO!'RQUO,5:fO!'RQUO,5@]O'%^QUO1G0mO')TQ$IUO'#CfO!'RQUO1G1yO!#]Q,UO,5=OO''iQ,UO,5=OO!#]Q,UO,5=QO''iQ,UO,5=QO!#]Q,UO,5<lO''iQ,UO,5<lO'%^QUO1G1zO!'RQUO7+&tO!#]Q,UO1G2WO''iQ,UO1G2WO!#]Q,UO1G2YO''iQ,UO1G2YO'%^QUO7+'fO'%^QUO7+&XO!#]Q,UOANA`O''iQ,UOANA`O')_QSO'#EgO')dQSO'#EgO')lQSO'#FVO')qQSO'#EqO')vQSO'#JqO'*RQSO'#JoO'*^QSO,5;RO'*cQ,UO,5<_O'*jQSO'#GQO'*oQSO'#GQO'*tQSO,5<`O'*|QSO,5;RO'+UQ$IUO1G1YO'+]QSO,5<lO'+bQSO,5<lO'+gQSO,5<nO'+lQSO,5<nO'+qQSO1G1zO'+vQSO1G0mO'+{Q,UO<<KtO',SQ,UO<<KtO7ZQ,UO'#FuO8qQSO'#FtO@jQSO'#EfO!'RQUO,5;nO!/{QSO'#GQO!/{QSO'#GQO!/{QSO'#GSO!/{QSO'#GSO!$uQ,UO7+(YO!$uQ,UO7+(YO$IvQ`O1G2nO$IvQ`O1G2nO!#]Q,UO,5=SO!#]Q,UO,5=S",
  stateData: "'-[~O'lOS'mOSROS'nRQ~OPYOQYOV!TO^pOaxObwOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!XXO!csO!hZO!kYO!lYO!mYO!otO!quO!tvO!x]O#o}O$PzO$TfO%_{O%a!OO%c|O%d|O%g!PO%i!QO%l!RO%m!RO%o!SO%|!UO&S!VO&U!WO&W!XO&Y!YO&]!ZO&c![O&i!]O&k!^O&m!_O&o!`O&q!aO'sSO'uTO'xUO(QVO(_[O(liO~OPYOQYOa!gOb!fOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!cO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$P!hO$TfO's!bO'uTO'xUO(QVO(_[O(liO~O^!qOl!kO|!lO![!rO!]!pO!^!pO!x;oO!|!vO!}!tO#O!uO#P!sO#S!wO#T!wO't!iO'uTO'xUO(T!jO(_!nO~O'n!xO~OPYXXYX^YXkYXyYXzYX|YX!VYX!eYX!fYX!hYX!lYX#WYX#ccX#fYX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#pYX#rYX#tYX#uYX#zYX'jYX(QYX(`YX(gYX(hYX~O!a$yX~P(dO[!zO'u!|O'v!zO'w!|O~O[!}O'w!|O'x!|O'y!}O~Oq#PO!O#QO(R#QO(S#SO~OPYOQYOa!gOb!fOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!cO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$P!hO$TfO's;tO'uTO'xUO(QVO(_[O(liO~O!U#WO!V#TO!S(WP!S(dP~P+pO!W#`O~P`OPYOQYOa!gOb!fOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!cO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$P!hO$TfO'uTO'xUO(QVO(_[O(liO~O!U#fO!x]O#a#iO#b#fO's;uO!g(aP~P.[O!h#kO's#jO~O!t#oO!x]O%_#pO~O#c#qO~O!a#rO#c#qO~OP$YOX$aOk#}Oy#vOz#wO|#xO!V$^O!e$PO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O#j$OO#k$PO#l$PO#m$`O#n$PO#p$QO#r$SO#t$UO#u$VO(QVO(`$WO(g#yO(h#zO~O^(UX'j(UX'h(UX!g(UX!S(UX!X(UX%`(UX!a(UX~P1dO#W$bO#z$bOP(VXX(VXk(VXy(VXz(VX|(VX!V(VX!e(VX!h(VX!l(VX#f(VX#g(VX#h(VX#i(VX#j(VX#k(VX#l(VX#m(VX#n(VX#p(VX#r(VX#t(VX#u(VX(Q(VX(`(VX(g(VX(h(VX!X(VX%`(VX~O^(VX!f(VX'j(VX'h(VX!S(VX!g(VXo(VX!a(VX~P3zO#W$bO~O$V$dO$X$cO$`$iO~O!X$jO$TfO$c$kO$e$mO~Oi%POk$qOl$pOm$pOs%QOu%ROw%SO|$xO!X$yO!c%XO!h$uO#b%YO$P%VO$l%TO$n%UO$q%WO's$oO'uTO'xUO'|%OO(Q$rOd'}P~O!h%ZO~O!a%]O~O^%^O'j%^O~O't!iO~P%QO's%eO~O!h%ZO's%eO't!iO'|%OO~Ob%lO!h%ZO's%eO~O#n$PO~Oy%qO!X%nO!h%pO%a%tO's%eO't!iO'uTO'xUO](tP~O!t#oO~O|%vO!X%wO's%eO~O|%vO!X%wO%i%{O's%eO~O's%|O~O#o}O%a!OO%c|O%d|O%g!PO%i!QO%l!RO%m!RO~Oa&VOb&UO!t&SO%_&TO%q&RO~P;cOa&YObwO!X&XO!tvO!x]O#o}O%_{O%c|O%d|O%g!PO%i!QO%l!RO%m!RO%o!SO~O_&]O#W&`O%a&ZO't!iO~P<bO!h&aO!q&eO~O!h#kO~O!XXO~O^%^O'i&mO'j%^O~O^%^O'i&pO'j%^O~O^%^O'i&rO'j%^O~O'hYX!SYXoYX!gYX&QYX!XYX%`YX!aYX~P(dO!['PO!]&xO!^&xO't!iO'uTO'xUO~Ol&vO|&uO!U&yO(T&tO!W(XP!W(fP~P?cOg'SO!X'QO's%eO~Ob'XO!h%ZO's%eO~Oy%qO!h%pO~Ol!kO|!lO!['^O!]']O!^']O!}'`O#O'`O#P'_O#S'bO#T'bO't!iO'uTO'xUO(T!jO(_!nO~O!x;oO!|'aO~P@}O^%^O!a#rO!h%ZO!l'hO#W'fO'j%^O'|%OO(`'dO~Ol!kO|!lO'uTO'xUO(T!jO(_!nO~O!]']O!^']O't!iO~PBtO!['^O!]']O!^']O#S'bO#T'bO't!iO~PBtO!XXO!['^O!]']O!^']O#P'_O#S'bO#T'bO't!iO~PBtO'o'lO'p'lO'q'nO~O[!zO'u'pO'v!zO'w'pO~O[!}O'w'pO'x'pO'y!}O~Oq#PO!O#QO(R#QO(S'tO~O!U'vO!S&|X!S'SX!V&|X!V'SX~P+pO!V'xO!S(WX~OP$YOX$aOk#}Oy#vOz#wO|#xO!V'xO!e$PO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O#j$OO#k$PO#l$PO#m$`O#n$PO#p$QO#r$SO#t$UO#u$VO(QVO(`$WO(g#yO(h#zO~O!S(WX~PF_O!S'}O~O!S(cX!V(cX!a(cX!g(cX(`(cX~O#W(cX#c#[X!W(cX~PHeO#W(OO!S(eX!V(eX~O!V(PO!S(dX~O!S(SO~O#W$bO~PHeO!W(TO~P`Oy#vOz#wO|#xO!f#tO!h#uO(QVOP!jaX!jak!ja!V!ja!e!ja!l!ja#f!ja#g!ja#h!ja#i!ja#j!ja#k!ja#l!ja#m!ja#n!ja#p!ja#r!ja#t!ja#u!ja(`!ja(g!ja(h!ja~O^!ja'j!ja'h!ja!S!ja!g!jao!ja!X!ja%`!ja!a!ja~PI{O!g(UO~O|%vO!X%wO!x]O#a(XO#b(WO's%eO~O!a#rO#W(YO(`'dO!V(bX^(bX'j(bX~O!g(bX~PMPO!V(]O!g(aX~O!g(_O~O|%vO!X%wO#b(WO's%eO~Oy(`Oz(aO!f#tO!h#uO!x!wa|!wa~O!t!wa%_!wa!X!wa#a!wa#b!wa's!wa~PNXO!t(eO~OPYOQYOa!gOb!fOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!XXO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$P!hO$TfO's!bO'uTO'xUO(QVO(_[O(liO~Oi%POk$qOl$pOm$pOs%QOu%ROw<XO|$xO!X$yO!c=cO!h$uO#b<_O$P%VO$l<ZO$n<]O$q%WO's(iO'uTO'xUO'|%OO(Q$rO~O#c(kO~Oi%POk$qOl$pOm$pOs%QOu%ROw%SO|$xO!X$yO!c%XO!h$uO#b%YO$P%VO$l%TO$n%UO$q%WO's(iO'uTO'xUO'|%OO(Q$rO~Od(ZP~P!$uO!U(oO!g([P~P%QO(T(qO(_[O~O|(sO!h#uO(T(qO(_[O~OP;nOQ;nOa=_Ob!fOikOk;nOlkOmkOskOu;nOw;nO|WO!QkO!RkO!X!cO!c;qO!hZO!k;nO!l;nO!m;nO!o;rO!q;sO!t!eO$P!hO$TfO's)RO'uTO'xUO(QVO(_[O(l=]O~Oz)UO!h#uO~O!V$^O^$ja'j$ja'h$ja!g$ja!S$ja!X$ja%`$ja!a$ja~O#o)YO~P!#]Oy)]O!a)[O!X$WX$S$WX$V$WX$X$WX$`$WX~O!a)[O!X(iX$S(iX$V(iX$X(iX$`(iX~Oy)]O~P!*kOy)]O!X(iX$S(iX$V(iX$X(iX$`(iX~O!X)_O$S)cO$V)^O$X)^O$`)dO~O!U)gO~P!'RO$V$dO$X$cO$`)kO~Og$rXy$rX|$rX!f$rX(g$rX(h$rX~OdfXd$rXgfX!VfX#WfX~P!,aOl)mO~Oq)nO(R)oO(S)qO~Og)zOy)sO|)tO(g)vO(h)xO~Od)rO~P!-jOd){O~Oi%POk$qOl$pOm$pOs%QOu%ROw<XO|$xO!X$yO!c=cO!h$uO#b<_O$P%VO$l<ZO$n<]O$q%WO'uTO'xUO'|%OO(Q$rO~O!U*PO's)|O!g(mP~P!.XO#c*RO~O!h*SO~O!U*XO's*UO!S(nP~P!.XOk*eO|*]O![*cO!]*[O!^*[O!h*SO#S*dO%V*_O't!iO(T!jO~O!W*bO~P!0_O!f#tOg(PXy(PX|(PX(g(PX(h(PX!V(PX#W(PX~Od(PX#x(PX~P!1WOg*hO#W*gOd(OX!V(OX~O!V*iOd'}X~O's%|Od'}P~O!h*pO~O's(iO~O|%vO!U#fO!X%wO!x]O#a#iO#b#fO's%eO!g(aP~O!a#rO#c*tO~OP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O#j$OO#k$PO#l$PO#m$`O#n$PO#p$QO#r$SO#t$UO#u$VO(QVO(`$WO(g#yO(h#zO~O^!ba!V!ba'j!ba'h!ba!S!ba!g!bao!ba!X!ba%`!ba!a!ba~P!3jOy#vOz#wO|#xO!f#tO!h#uO(QVOP!naX!nak!na!V!na!e!na!l!na#f!na#g!na#h!na#i!na#j!na#k!na#l!na#m!na#n!na#p!na#r!na#t!na#u!na(`!na(g!na(h!na~O^!na'j!na'h!na!S!na!g!nao!na!X!na%`!na!a!na~P!6TOy#vOz#wO|#xO!f#tO!h#uO(QVOP!paX!pak!pa!V!pa!e!pa!l!pa#f!pa#g!pa#h!pa#i!pa#j!pa#k!pa#l!pa#m!pa#n!pa#p!pa#r!pa#t!pa#u!pa(`!pa(g!pa(h!pa~O^!pa'j!pa'h!pa!S!pa!g!pao!pa!X!pa%`!pa!a!pa~P!8nOg*|O!X'QO%`*{O'|%OO~O!a+OO!X'{X^'{X!V'{X'j'{X~O!h%ZO'|%OO~O!h%ZO's%eO'|%OO~O!a#rO#c(kO~O%a+[O's+WO'uTO'xUO!W(uP~O!V+]O](tX~O(T(qO~OX+aO~O]+bO~O!X%nO's%eO't!iO](tP~O|%vO!U+fO!V(PO!X%wO's%eO!S(dP~Ol&|O|+hO!U+gO'uTO'xUO(T(qO~O!W(fP~P!>RO!V+iO^(qX'j(qX~O#W+mO'|%OO~Og+pO!X$yO'|%OO~O!X+rO~Oy+tO!XXO~O!t+yO~Ob,OO~O's#jO!W(sP~Ob%lO~O%a!OO's%|O~P<bOX,UO],TO~OPYOQYOaxObwOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!csO!hZO!kYO!lYO!mYO!otO!quO!tvO!x]O$TfO%_{O'uTO'xUO(QVO(_[O(liO~O!X!cO$P!hO's!bO~P!@fO],TO^%^O'j%^O~O^,YO#o,[O%c,[O%d,[O~P%QO!h&aO~O&S,aO~O!X,cO~O&e,eO&g,fOP&baQ&baV&ba^&baa&bab&bai&bak&bal&bam&bas&bau&baw&ba|&ba!Q&ba!R&ba!X&ba!c&ba!h&ba!k&ba!l&ba!m&ba!o&ba!q&ba!t&ba!x&ba#o&ba$P&ba$T&ba%_&ba%a&ba%c&ba%d&ba%g&ba%i&ba%l&ba%m&ba%o&ba%|&ba&S&ba&U&ba&W&ba&Y&ba&]&ba&c&ba&i&ba&k&ba&m&ba&o&ba&q&ba'h&ba's&ba'u&ba'x&ba(Q&ba(_&ba(l&ba!W&ba&Z&ba_&ba&`&ba~O's,kO~O!V{X!V!_X!W{X!W!_X!a{X!a!_X!h!_X#W{X'|!_X~O!a,pO#W,oO!V#`X!V(YX!W#`X!W(YX!a(YX!h(YX'|(YX~O!a,rO!h%ZO'|%OO!V!ZX!W!ZX~Ol!kO|!lO'uTO'xUO(T!jO~OP;nOQ;nOa=_Ob!fOikOk;nOlkOmkOskOu;nOw;nO|WO!QkO!RkO!X!cO!c;qO!hZO!k;nO!l;nO!m;nO!o;rO!q;sO!t!eO$P!hO$TfO'uTO'xUO(QVO(_[O(l=]O~O's<dO~P!I{O!V,vO!W(XX~O!W,xO~O!a,pO#W,oO!V#`X!W#`X~O!V,yO!W(fX~O!W,{O~O!],|O!^,|O't!iO~P!IjO!W-PO~P'TOg-SO!X'QO~O!S-XO~Ol!wa![!wa!]!wa!^!wa!|!wa!}!wa#O!wa#P!wa#S!wa#T!wa't!wa'u!wa'x!wa(T!wa(_!wa~PNXO^%^O!a#rO!h%ZO!l-^O#W-[O'j%^O'|%OO(`'dO~O!]-`O!^-`O't!iO~PBtO![-bO!]-`O!^-`O#S-cO#T-cO't!iO~PBtO![-bO!]-`O!^-`O#P-dO#S-cO#T-cO't!iO~PBtO![-bO!]-`O!^-`O!}-eO#O-eO#P-dO#S-cO#T-cO't!iO~PBtO^%^O#W-[O'j%^O~O^%^O!a#rO#W-[O'j%^O~O^%^O!a#rO!l-^O#W-[O'j%^O(`'dO~O'o'lO'p'lO'q-jO~Oo-kO~O!S&|a!V&|a~P!3jO!U-oO!S&|X!V&|X~P%QO!V'xO!S(Wa~O!S(Wa~PF_O!V(PO!S(da~O|%vO!U-sO!X%wO's%eO!S'SX!V'SX~O!V(]O!g(aa~O|%vO!X%wO#b-vO's%eO~O#W-xO!V(ba!g(ba^(ba'j(ba~O!a#rO~P#&hO|%vO!U-{O!X%wO!x]O#a-}O#b-{O's%eO!V'UX!g'UX~Oz.RO!h#uO~Og.UO!X'QO%`.TO'|%OO~O^#Zi!V#Zi'j#Zi'h#Zi!S#Zi!g#Zio#Zi!X#Zi%`#Zi!a#Zi~P!3jOg=iOy)sO|)tO(g)vO(h)xO~O#c#Va^#Va#W#Va'j#Va!V#Va!g#Va!X#Va!S#Va~P#(yO#c(PXP(PXX(PX^(PXk(PXz(PX!e(PX!h(PX!l(PX#f(PX#g(PX#h(PX#i(PX#j(PX#k(PX#l(PX#m(PX#n(PX#p(PX#r(PX#t(PX#u(PX'j(PX(Q(PX(`(PX!g(PX!S(PX'h(PXo(PX!X(PX%`(PX!a(PX~P!1WO!V._Od(ZX~P!-jOd.aO~O!V.bO!g([X~P!3jO!g.eO~O!S.gO~OP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO(QVOX#ei^#eik#ei!V#ei!e#ei#g#ei#h#ei#i#ei#j#ei#k#ei#l#ei#m#ei#n#ei#p#ei#r#ei#t#ei#u#ei'j#ei(`#ei(g#ei(h#ei'h#ei!S#ei!g#eio#ei!X#ei%`#ei!a#ei~O#f#ei~P#,uO#f#{O~P#,uOP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O(QVOX#ei^#ei!V#ei!e#ei#j#ei#k#ei#l#ei#m#ei#n#ei#p#ei#r#ei#t#ei#u#ei'j#ei(`#ei(g#ei(h#ei'h#ei!S#ei!g#eio#ei!X#ei%`#ei!a#ei~Ok#ei~P#/gOk#}O~P#/gOP$YOk#}Oy#vOz#wO|#xO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O#j$OO(QVO^#ei!V#ei#p#ei#r#ei#t#ei#u#ei'j#ei(`#ei(g#ei(h#ei'h#ei!S#ei!g#eio#ei!X#ei%`#ei!a#ei~OX#ei!e#ei#k#ei#l#ei#m#ei#n#ei~P#2XOX$aO!e$PO#k$PO#l$PO#m$`O#n$PO~P#2XOP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O#j$OO#k$PO#l$PO#m$`O#n$PO#p$QO(QVO^#ei!V#ei#r#ei#t#ei#u#ei'j#ei(`#ei(h#ei'h#ei!S#ei!g#eio#ei!X#ei%`#ei!a#ei~O(g#ei~P#5YO(g#yO~P#5YOP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O#j$OO#k$PO#l$PO#m$`O#n$PO#p$QO#r$SO(QVO(g#yO^#ei!V#ei#t#ei#u#ei'j#ei(`#ei'h#ei!S#ei!g#eio#ei!X#ei%`#ei!a#ei~O(h#ei~P#7zO(h#zO~P#7zOP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O#j$OO#k$PO#l$PO#m$`O#n$PO#p$QO#r$SO#t$UO(QVO(g#yO(h#zO~O^#ei!V#ei#u#ei'j#ei(`#ei'h#ei!S#ei!g#eio#ei!X#ei%`#ei!a#ei~P#:lOPYXXYXkYXyYXzYX|YX!eYX!fYX!hYX!lYX#WYX#ccX#fYX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#pYX#rYX#tYX#uYX#zYX(QYX(`YX(gYX(hYX!VYX!WYX~O#xYX~P#=VOP$YOX<VOk;yOy#vOz#wO|#xO!e;{O!f#tO!h#uO!l$YO#f;wO#g;xO#h;xO#i;xO#j;zO#k;{O#l;{O#m<UO#n;{O#p;|O#r<OO#t<QO#u<RO(QVO(`$WO(g#yO(h#zO~O#x.iO~P#?dOP(VXX(VXk(VXy(VXz(VX|(VX!e(VX!f(VX!h(VX!l(VX#f(VX#g(VX#h(VX#i(VX#j(VX#k(VX#l(VX#m(VX#p(VX#r(VX#t(VX#u(VX(Q(VX(`(VX(g(VX(h(VX!V(VX~O#W<WO#z<WO#n(VX#x(VX!W(VX~P#AbO^'Xa!V'Xa'j'Xa'h'Xa!g'Xa!S'Xao'Xa!X'Xa%`'Xa!a'Xa~P!3jOP#eiX#ei^#eik#eiz#ei!V#ei!e#ei!f#ei!h#ei!l#ei#f#ei#g#ei#h#ei#i#ei#j#ei#k#ei#l#ei#m#ei#n#ei#p#ei#r#ei#t#ei#u#ei'j#ei(Q#ei(`#ei'h#ei!S#ei!g#eio#ei!X#ei%`#ei!a#ei~P#(yO^#yi!V#yi'j#yi'h#yi!S#yi!g#yio#yi!X#yi%`#yi!a#yi~P!3jO$V.nO$X.nO~O$V.oO$X.oO~O!a)[O#W.pO!X$]X$S$]X$V$]X$X$]X$`$]X~O!U.qO~O!X)_O$S.sO$V)^O$X)^O$`.tO~O!V<SO!W(UX~P#?dO!W.uO~O!a)[O$`(iX~O$`.wO~Oq)nO(R)oO(S.zO~Ol.}O!S/OO'uTO'xUO~O!VcX!acX!gcX!g$rX(`cX~P!,aO!g/UO~P#(yO!V/VO!a#rO(`'dO!g(mX~O!g/[O~O!U*PO's%eO!g(mP~O#c/^O~O!S$rX!V$rX!a$yX~P!,aO!V/_O!S(nX~P#(yO!a/aO~O!S/cO~Ok/gO!a#rO!h%ZO'|%OO(`'dO~O's/iO~O!a+OO~O^%^O!V/mO'j%^O~O!W/oO~P!0_O!]/pO!^/pO't!iO(T!jO~O|/rO(T!jO~O#S/sO~O's%|Od'^X!V'^X~O!V*iOd'}a~Od/xO~Oy/yOz/yO|/zOgva(gva(hva!Vva#Wva~Odva#xva~P#M{Oy)sO|)tOg$ka(g$ka(h$ka!V$ka#W$ka~Od$ka#x$ka~P#NqOy)sO|)tOg$ma(g$ma(h$ma!V$ma#W$ma~Od$ma#x$ma~P$ dO#c/|O~Od${a!V${a#W${a#x${a~P!-jO#c0PO~Oy#vOz#wO|#xO!f#tO!h#uO(QVOP!niX!nik!ni!V!ni!e!ni!l!ni#f!ni#g!ni#h!ni#i!ni#j!ni#k!ni#l!ni#m!ni#n!ni#p!ni#r!ni#t!ni#u!ni(`!ni(g!ni(h!ni~O^!ni'j!ni'h!ni!S!ni!g!nio!ni!X!ni%`!ni!a!ni~P$!qOg.UO!X'QO%`.TO~Oi0WO's0VO~P!.[O!a+OO!X'{a^'{a!V'{a'j'{a~O#c0^O~OXYX!VcX!WcX~O!V0_O!W(uX~O!W0aO~OX0bO~O's+WO'uTO'xUO~O!X%nO's%eO]'fX!V'fX~O!V+]O](ta~O!g0gO~P!3jOX0jO~O]0kO~O!V+iO^(qa'j(qa~O#W0qO~Og0tO!X$yO~O(T(qO!W(rP~Og0}O!X0zO%`0|O'|%OO~OX1XO!V1VO!W(sX~O!W1YO~O]1[O^%^O'j%^O~O's#jO'uTO'xUO~O#W$bO#n1_O#z$bO&Q1`O^(VX~P#AbO#W$bO#n1_O&Q1`O~O^1aO~P%QO^1cO~O&Z1gOP&XiQ&XiV&Xi^&Xia&Xib&Xii&Xik&Xil&Xim&Xis&Xiu&Xiw&Xi|&Xi!Q&Xi!R&Xi!X&Xi!c&Xi!h&Xi!k&Xi!l&Xi!m&Xi!o&Xi!q&Xi!t&Xi!x&Xi#o&Xi$P&Xi$T&Xi%_&Xi%a&Xi%c&Xi%d&Xi%g&Xi%i&Xi%l&Xi%m&Xi%o&Xi%|&Xi&S&Xi&U&Xi&W&Xi&Y&Xi&]&Xi&c&Xi&i&Xi&k&Xi&m&Xi&o&Xi&q&Xi'h&Xi's&Xi'u&Xi'x&Xi(Q&Xi(_&Xi(l&Xi!W&Xi_&Xi&`&Xi~O_1mO!W1kO&`1lO~P`O!XXO!h1oO~O&g,fOP&biQ&biV&bi^&bia&bib&bii&bik&bil&bim&bis&biu&biw&bi|&bi!Q&bi!R&bi!X&bi!c&bi!h&bi!k&bi!l&bi!m&bi!o&bi!q&bi!t&bi!x&bi#o&bi$P&bi$T&bi%_&bi%a&bi%c&bi%d&bi%g&bi%i&bi%l&bi%m&bi%o&bi%|&bi&S&bi&U&bi&W&bi&Y&bi&]&bi&c&bi&i&bi&k&bi&m&bi&o&bi&q&bi'h&bi's&bi'u&bi'x&bi(Q&bi(_&bi(l&bi!W&bi&Z&bi_&bi&`&bi~O!S1uO~O!V!Za!W!Za~P#?dOl!kO|!lO!U1{O(T!jO!V&}X!W&}X~P?cO!V,vO!W(Xa~O!V'TX!W'TX~P!>RO!V,yO!W(fa~O!W2SO~P'TO^%^O#W2]O'j%^O~O^%^O!a#rO#W2]O'j%^O~O^%^O!a#rO!h%ZO!l2aO#W2]O'j%^O'|%OO(`'dO~O!]2bO!^2bO't!iO~PBtO![2eO!]2bO!^2bO#S2fO#T2fO't!iO~PBtO![2eO!]2bO!^2bO#P2gO#S2fO#T2fO't!iO~PBtO^%^O!a#rO!l2aO#W2]O'j%^O(`'dO~O^%^O'j%^O~P!3jO!V$^Oo$ja~O!S&|i!V&|i~P!3jO!V'xO!S(Wi~O!V(PO!S(di~O!S(ei!V(ei~P!3jO!V(]O!g(ai~O!V(bi!g(bi^(bi'j(bi~P!3jO#W2kO!V(bi!g(bi^(bi'j(bi~O|%vO!X%wO!x]O#a2nO#b2mO's%eO~O|%vO!X%wO#b2mO's%eO~Og2uO!X'QO%`2tO~Og2uO!X'QO%`2tO'|%OO~O#cvaPvaXva^vakva!eva!fva!hva!lva#fva#gva#hva#iva#jva#kva#lva#mva#nva#pva#rva#tva#uva'jva(Qva(`va!gva!Sva'hvaova!Xva%`va!ava~P#M{O#c$kaP$kaX$ka^$kak$kaz$ka!e$ka!f$ka!h$ka!l$ka#f$ka#g$ka#h$ka#i$ka#j$ka#k$ka#l$ka#m$ka#n$ka#p$ka#r$ka#t$ka#u$ka'j$ka(Q$ka(`$ka!g$ka!S$ka'h$kao$ka!X$ka%`$ka!a$ka~P#NqO#c$maP$maX$ma^$mak$maz$ma!e$ma!f$ma!h$ma!l$ma#f$ma#g$ma#h$ma#i$ma#j$ma#k$ma#l$ma#m$ma#n$ma#p$ma#r$ma#t$ma#u$ma'j$ma(Q$ma(`$ma!g$ma!S$ma'h$mao$ma!X$ma%`$ma!a$ma~P$ dO#c${aP${aX${a^${ak${az${a!V${a!e${a!f${a!h${a!l${a#f${a#g${a#h${a#i${a#j${a#k${a#l${a#m${a#n${a#p${a#r${a#t${a#u${a'j${a(Q${a(`${a!g${a!S${a'h${a#W${ao${a!X${a%`${a!a${a~P#(yO^#Zq!V#Zq'j#Zq'h#Zq!S#Zq!g#Zqo#Zq!X#Zq%`#Zq!a#Zq~P!3jOd'OX!V'OX~P!$uO!V._Od(Za~O!U2}O!V'PX!g'PX~P%QO!V.bO!g([a~O!V.bO!g([a~P!3jO!S3QO~O#x!ja!W!ja~PI{O#x!ba!V!ba!W!ba~P#?dO#x!na!W!na~P!6TO#x!pa!W!pa~P!8nO!X3dO$TfO$^3eO~O!W3iO~Oo3jO~P#(yO^$gq!V$gq'j$gq'h$gq!S$gq!g$gqo$gq!X$gq%`$gq!a$gq~P!3jO!S3kO~Ol.}O'uTO'xUO~Oy)sO|)tO(h)xOg%Wi(g%Wi!V%Wi#W%Wi~Od%Wi#x%Wi~P$HbOy)sO|)tOg%Yi(g%Yi(h%Yi!V%Yi#W%Yi~Od%Yi#x%Yi~P$ITO(`$WO~P#(yO!U3nO's%eO!V'YX!g'YX~O!V/VO!g(ma~O!V/VO!a#rO!g(ma~O!V/VO!a#rO(`'dO!g(ma~Od$ti!V$ti#W$ti#x$ti~P!-jO!U3vO's*UO!S'[X!V'[X~P!.XO!V/_O!S(na~O!V/_O!S(na~P#(yO!a#rO~O!a#rO#n4OO~Ok4RO!a#rO(`'dO~Od(Oi!V(Oi~P!-jO#W4UOd(Oi!V(Oi~P!-jO!g4XO~O^$hq!V$hq'j$hq'h$hq!S$hq!g$hqo$hq!X$hq%`$hq!a$hq~P!3jO!V4]O!X(oX~P#(yO!f#tO~P3zO!X$rX%TYX^$rX!V$rX'j$rX~P!,aO%T4_OghXyhX|hX!XhX(ghX(hhX^hX!VhX'jhX~O%T4_O~O%a4fO's+WO'uTO'xUO!V'eX!W'eX~O!V0_O!W(ua~OX4jO~O]4kO~O!S4oO~O^%^O'j%^O~P#(yO!X$yO~P#(yO!V4tO#W4vO!W(rX~O!W4wO~Ol!kO|4yO![5WO!]4}O!^4}O!x;oO!|5VO!}5UO#O5UO#P5TO#S5SO#T!wO't!iO'uTO'xUO(T!jO(_!nO~O!W5RO~P%#XOg5]O!X0zO%`5[O~Og5]O!X0zO%`5[O'|%OO~O's#jO!V'dX!W'dX~O!V1VO!W(sa~O'uTO'xUO(T5fO~O]5jO~O!g5mO~P%QO^5oO~O^5oO~P%QO#n5qO&Q5rO~PMPO_1mO!W5vO&`1lO~P`O!a5xO~O!a5zO!V(Yi!W(Yi!a(Yi!h(Yi'|(Yi~O!V#`i!W#`i~P#?dO#W5{O!V#`i!W#`i~O!V!Zi!W!Zi~P#?dO^%^O#W6UO'j%^O~O^%^O!a#rO#W6UO'j%^O~O^%^O!a#rO!l6ZO#W6UO'j%^O(`'dO~O!h%ZO'|%OO~P%(fO!]6[O!^6[O't!iO~PBtO![6_O!]6[O!^6[O#S6`O#T6`O't!iO~PBtO!V(]O!g(aq~O!V(bq!g(bq^(bq'j(bq~P!3jO|%vO!X%wO#b6dO's%eO~O!X'QO%`6gO~Og6jO!X'QO%`6gO~O#c%WiP%WiX%Wi^%Wik%Wiz%Wi!e%Wi!f%Wi!h%Wi!l%Wi#f%Wi#g%Wi#h%Wi#i%Wi#j%Wi#k%Wi#l%Wi#m%Wi#n%Wi#p%Wi#r%Wi#t%Wi#u%Wi'j%Wi(Q%Wi(`%Wi!g%Wi!S%Wi'h%Wio%Wi!X%Wi%`%Wi!a%Wi~P$HbO#c%YiP%YiX%Yi^%Yik%Yiz%Yi!e%Yi!f%Yi!h%Yi!l%Yi#f%Yi#g%Yi#h%Yi#i%Yi#j%Yi#k%Yi#l%Yi#m%Yi#n%Yi#p%Yi#r%Yi#t%Yi#u%Yi'j%Yi(Q%Yi(`%Yi!g%Yi!S%Yi'h%Yio%Yi!X%Yi%`%Yi!a%Yi~P$ITO#c$tiP$tiX$ti^$tik$tiz$ti!V$ti!e$ti!f$ti!h$ti!l$ti#f$ti#g$ti#h$ti#i$ti#j$ti#k$ti#l$ti#m$ti#n$ti#p$ti#r$ti#t$ti#u$ti'j$ti(Q$ti(`$ti!g$ti!S$ti'h$ti#W$tio$ti!X$ti%`$ti!a$ti~P#(yOd'Oa!V'Oa~P!-jO!V'Pa!g'Pa~P!3jO!V.bO!g([i~O#x#Zi!V#Zi!W#Zi~P#?dOP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO(QVOX#eik#ei!e#ei#g#ei#h#ei#i#ei#j#ei#k#ei#l#ei#m#ei#n#ei#p#ei#r#ei#t#ei#u#ei#x#ei(`#ei(g#ei(h#ei!V#ei!W#ei~O#f#ei~P%2xO#f;wO~P%2xOP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO#f;wO#g;xO#h;xO#i;xO(QVOX#ei!e#ei#j#ei#k#ei#l#ei#m#ei#n#ei#p#ei#r#ei#t#ei#u#ei#x#ei(`#ei(g#ei(h#ei!V#ei!W#ei~Ok#ei~P%5TOk;yO~P%5TOP$YOk;yOy#vOz#wO|#xO!f#tO!h#uO!l$YO#f;wO#g;xO#h;xO#i;xO#j;zO(QVO#p#ei#r#ei#t#ei#u#ei#x#ei(`#ei(g#ei(h#ei!V#ei!W#ei~OX#ei!e#ei#k#ei#l#ei#m#ei#n#ei~P%7`OX<VO!e;{O#k;{O#l;{O#m<UO#n;{O~P%7`OP$YOX<VOk;yOy#vOz#wO|#xO!e;{O!f#tO!h#uO!l$YO#f;wO#g;xO#h;xO#i;xO#j;zO#k;{O#l;{O#m<UO#n;{O#p;|O(QVO#r#ei#t#ei#u#ei#x#ei(`#ei(h#ei!V#ei!W#ei~O(g#ei~P%9zO(g#yO~P%9zOP$YOX<VOk;yOy#vOz#wO|#xO!e;{O!f#tO!h#uO!l$YO#f;wO#g;xO#h;xO#i;xO#j;zO#k;{O#l;{O#m<UO#n;{O#p;|O#r<OO(QVO(g#yO#t#ei#u#ei#x#ei(`#ei!V#ei!W#ei~O(h#ei~P%<VO(h#zO~P%<VOP$YOX<VOk;yOy#vOz#wO|#xO!e;{O!f#tO!h#uO!l$YO#f;wO#g;xO#h;xO#i;xO#j;zO#k;{O#l;{O#m<UO#n;{O#p;|O#r<OO#t<QO(QVO(g#yO(h#zO~O#u#ei#x#ei(`#ei!V#ei!W#ei~P%>bO^#vy!V#vy'j#vy'h#vy!S#vy!g#vyo#vy!X#vy%`#vy!a#vy~P!3jOg=jOy)sO|)tO(g)vO(h)xO~OP#eiX#eik#eiz#ei!e#ei!f#ei!h#ei!l#ei#f#ei#g#ei#h#ei#i#ei#j#ei#k#ei#l#ei#m#ei#n#ei#p#ei#r#ei#t#ei#u#ei#x#ei(Q#ei(`#ei!V#ei!W#ei~P%AYO!f#tOP(PXX(PXg(PXk(PXy(PXz(PX|(PX!e(PX!h(PX!l(PX#f(PX#g(PX#h(PX#i(PX#j(PX#k(PX#l(PX#m(PX#n(PX#p(PX#r(PX#t(PX#u(PX#x(PX(Q(PX(`(PX(g(PX(h(PX!V(PX!W(PX~O#x#yi!V#yi!W#yi~P#?dO#x!ni!W!ni~P$!qO!W6vO~O!V'Xa!W'Xa~P#?dO!a#rO(`'dO!V'Ya!g'Ya~O!V/VO!g(mi~O!V/VO!a#rO!g(mi~Od$tq!V$tq#W$tq#x$tq~P!-jO!S'[a!V'[a~P#(yO!a6}O~O!V/_O!S(ni~P#(yO!V/_O!S(ni~O!S7RO~O!a#rO#n7WO~Ok7XO!a#rO(`'dO~O!S7ZO~Od$vq!V$vq#W$vq#x$vq~P!-jO^$hy!V$hy'j$hy'h$hy!S$hy!g$hyo$hy!X$hy%`$hy!a$hy~P!3jO!V4]O!X(oa~O^#Zy!V#Zy'j#Zy'h#Zy!S#Zy!g#Zyo#Zy!X#Zy%`#Zy!a#Zy~P!3jOX7`O~O!V0_O!W(ui~O]7fO~O!a5zO~O(T(qO!V'aX!W'aX~O!V4tO!W(ra~O!h%ZO'|%OO^(YX!a(YX!l(YX#W(YX'j(YX(`(YX~O's7oO~P.[O!x;oO!|7rO!}7qO#O7qO#P7pO#S'bO#T'bO~PBtO^%^O!a#rO!l'hO#W'fO'j%^O(`'dO~O!W7vO~P%#XOl!kO'uTO'xUO(T!jO(_!nO~O|7wO~P%MdO![7{O!]7zO!^7zO#P7pO#S'bO#T'bO't!iO~PBtO![7{O!]7zO!^7zO!}7|O#O7|O#P7pO#S'bO#T'bO't!iO~PBtO!]7zO!^7zO't!iO(T!jO(_!nO~O!X0zO~O!X0zO%`8OO~Og8RO!X0zO%`8OO~OX8WO!V'da!W'da~O!V1VO!W(si~O!g8[O~O!g8]O~O!g8^O~O!g8^O~P%QO^8`O~O!a8cO~O!g8dO~O!V(ei!W(ei~P#?dO^%^O#W8lO'j%^O~O^%^O!a#rO#W8lO'j%^O~O^%^O!a#rO!l8pO#W8lO'j%^O(`'dO~O!h%ZO'|%OO~P&$QO!]8qO!^8qO't!iO~PBtO!V(]O!g(ay~O!V(by!g(by^(by'j(by~P!3jO!X'QO%`8uO~O#c$tqP$tqX$tq^$tqk$tqz$tq!V$tq!e$tq!f$tq!h$tq!l$tq#f$tq#g$tq#h$tq#i$tq#j$tq#k$tq#l$tq#m$tq#n$tq#p$tq#r$tq#t$tq#u$tq'j$tq(Q$tq(`$tq!g$tq!S$tq'h$tq#W$tqo$tq!X$tq%`$tq!a$tq~P#(yO#c$vqP$vqX$vq^$vqk$vqz$vq!V$vq!e$vq!f$vq!h$vq!l$vq#f$vq#g$vq#h$vq#i$vq#j$vq#k$vq#l$vq#m$vq#n$vq#p$vq#r$vq#t$vq#u$vq'j$vq(Q$vq(`$vq!g$vq!S$vq'h$vq#W$vqo$vq!X$vq%`$vq!a$vq~P#(yO!V'Pi!g'Pi~P!3jO#x#Zq!V#Zq!W#Zq~P#?dOy/yOz/yO|/zOPvaXvagvakva!eva!fva!hva!lva#fva#gva#hva#iva#jva#kva#lva#mva#nva#pva#rva#tva#uva#xva(Qva(`va(gva(hva!Vva!Wva~Oy)sO|)tOP$kaX$kag$kak$kaz$ka!e$ka!f$ka!h$ka!l$ka#f$ka#g$ka#h$ka#i$ka#j$ka#k$ka#l$ka#m$ka#n$ka#p$ka#r$ka#t$ka#u$ka#x$ka(Q$ka(`$ka(g$ka(h$ka!V$ka!W$ka~Oy)sO|)tOP$maX$mag$mak$maz$ma!e$ma!f$ma!h$ma!l$ma#f$ma#g$ma#h$ma#i$ma#j$ma#k$ma#l$ma#m$ma#n$ma#p$ma#r$ma#t$ma#u$ma#x$ma(Q$ma(`$ma(g$ma(h$ma!V$ma!W$ma~OP${aX${ak${az${a!e${a!f${a!h${a!l${a#f${a#g${a#h${a#i${a#j${a#k${a#l${a#m${a#n${a#p${a#r${a#t${a#u${a#x${a(Q${a(`${a!V${a!W${a~P%AYO#x$gq!V$gq!W$gq~P#?dO#x$hq!V$hq!W$hq~P#?dO!W9PO~O#x9QO~P!-jO!a#rO!V'Yi!g'Yi~O!a#rO(`'dO!V'Yi!g'Yi~O!V/VO!g(mq~O!S'[i!V'[i~P#(yO!V/_O!S(nq~O!S9WO~P#(yO!S9WO~Od(Oy!V(Oy~P!-jO!V'_a!X'_a~P#(yO!X%Sq^%Sq!V%Sq'j%Sq~P#(yOX9]O~O!V0_O!W(uq~O#W9aO!V'aa!W'aa~O!V4tO!W(ri~P#?dOPYXXYXkYXyYXzYX|YX!SYX!VYX!eYX!fYX!hYX!lYX#WYX#ccX#fYX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#pYX#rYX#tYX#uYX#zYX(QYX(`YX(gYX(hYX~O!a%QX#n%QX~P&6lO#S-cO#T-cO~PBtO#P9eO#S-cO#T-cO~PBtO!}9fO#O9fO#P9eO#S-cO#T-cO~PBtO!]9iO!^9iO't!iO(T!jO(_!nO~O![9lO!]9iO!^9iO#P9eO#S-cO#T-cO't!iO~PBtO!X0zO%`9oO~O'uTO'xUO(T9tO~O!V1VO!W(sq~O!g9wO~O!g9wO~P%QO!g9yO~O!g9zO~O#W9|O!V#`y!W#`y~O!V#`y!W#`y~P#?dO^%^O#W:QO'j%^O~O^%^O!a#rO#W:QO'j%^O~O^%^O!a#rO!l:UO#W:QO'j%^O(`'dO~O!X'QO%`:XO~O#x#vy!V#vy!W#vy~P#?dOP$tiX$tik$tiz$ti!e$ti!f$ti!h$ti!l$ti#f$ti#g$ti#h$ti#i$ti#j$ti#k$ti#l$ti#m$ti#n$ti#p$ti#r$ti#t$ti#u$ti#x$ti(Q$ti(`$ti!V$ti!W$ti~P%AYOy)sO|)tO(h)xOP%WiX%Wig%Wik%Wiz%Wi!e%Wi!f%Wi!h%Wi!l%Wi#f%Wi#g%Wi#h%Wi#i%Wi#j%Wi#k%Wi#l%Wi#m%Wi#n%Wi#p%Wi#r%Wi#t%Wi#u%Wi#x%Wi(Q%Wi(`%Wi(g%Wi!V%Wi!W%Wi~Oy)sO|)tOP%YiX%Yig%Yik%Yiz%Yi!e%Yi!f%Yi!h%Yi!l%Yi#f%Yi#g%Yi#h%Yi#i%Yi#j%Yi#k%Yi#l%Yi#m%Yi#n%Yi#p%Yi#r%Yi#t%Yi#u%Yi#x%Yi(Q%Yi(`%Yi(g%Yi(h%Yi!V%Yi!W%Yi~O#x$hy!V$hy!W$hy~P#?dO#x#Zy!V#Zy!W#Zy~P#?dO!a#rO!V'Yq!g'Yq~O!V/VO!g(my~O!S'[q!V'[q~P#(yO!S:`O~P#(yO!V0_O!W(uy~O!V4tO!W(rq~O#S2fO#T2fO~PBtO#P:gO#S2fO#T2fO~PBtO!]:kO!^:kO't!iO(T!jO(_!nO~O!X0zO%`:nO~O!g:qO~O^%^O#W:vO'j%^O~O^%^O!a#rO#W:vO'j%^O~O!X'QO%`:{O~OP$tqX$tqk$tqz$tq!e$tq!f$tq!h$tq!l$tq#f$tq#g$tq#h$tq#i$tq#j$tq#k$tq#l$tq#m$tq#n$tq#p$tq#r$tq#t$tq#u$tq#x$tq(Q$tq(`$tq!V$tq!W$tq~P%AYOP$vqX$vqk$vqz$vq!e$vq!f$vq!h$vq!l$vq#f$vq#g$vq#h$vq#i$vq#j$vq#k$vq#l$vq#m$vq#n$vq#p$vq#r$vq#t$vq#u$vq#x$vq(Q$vq(`$vq!V$vq!W$vq~P%AYOd%[!Z!V%[!Z#W%[!Z#x%[!Z~P!-jO!V'aq!W'aq~P#?dO#S6`O#T6`O~PBtO!V#`!Z!W#`!Z~P#?dO^%^O#W;ZO'j%^O~O#c%[!ZP%[!ZX%[!Z^%[!Zk%[!Zz%[!Z!V%[!Z!e%[!Z!f%[!Z!h%[!Z!l%[!Z#f%[!Z#g%[!Z#h%[!Z#i%[!Z#j%[!Z#k%[!Z#l%[!Z#m%[!Z#n%[!Z#p%[!Z#r%[!Z#t%[!Z#u%[!Z'j%[!Z(Q%[!Z(`%[!Z!g%[!Z!S%[!Z'h%[!Z#W%[!Zo%[!Z!X%[!Z%`%[!Z!a%[!Z~P#(yOP%[!ZX%[!Zk%[!Zz%[!Z!e%[!Z!f%[!Z!h%[!Z!l%[!Z#f%[!Z#g%[!Z#h%[!Z#i%[!Z#j%[!Z#k%[!Z#l%[!Z#m%[!Z#n%[!Z#p%[!Z#r%[!Z#t%[!Z#u%[!Z#x%[!Z(Q%[!Z(`%[!Z!V%[!Z!W%[!Z~P%AYOo(UX~P1dO't!iO~P!'RO!ScX!VcX#WcX~P&6lOPYXXYXkYXyYXzYX|YX!VYX!VcX!eYX!fYX!hYX!lYX#WYX#WcX#ccX#fYX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#pYX#rYX#tYX#uYX#zYX(QYX(`YX(gYX(hYX~O!acX!gYX!gcX(`cX~P'!sOP;nOQ;nOa=_Ob!fOikOk;nOlkOmkOskOu;nOw;nO|WO!QkO!RkO!XXO!c;qO!hZO!k;nO!l;nO!m;nO!o;rO!q;sO!t!eO$P!hO$TfO's)RO'uTO'xUO(QVO(_[O(l=]O~O!V<SO!W$ja~Oi%POk$qOl$pOm$pOs%QOu%ROw<YO|$xO!X$yO!c=dO!h$uO#b<`O$P%VO$l<[O$n<^O$q%WO's(iO'uTO'xUO'|%OO(Q$rO~O#o)YO~P''iO!WYX!WcX~P'!sO#c;vO~O!a#rO#c;vO~O#W<WO~O#n;{O~O#W<bO!V(eX!W(eX~O#W<WO!V(cX!W(cX~O#c<cO~Od<eO~P!-jO#c<jO~O#c<kO~O!a#rO#c<lO~O!a#rO#c<cO~O#x<mO~P#?dO#c<nO~O#c<oO~O#c<pO~O#c<qO~O#c<rO~O#c<sO~O#x<tO~P!-jO#x<uO~P!-jO$T~!f!|#O#P#S#a#b#m(l$l$n$q%T%_%`%a%g%i%l%m%o%q~'nR$T(l#g!R'l't#hl#f#iky'm(T'm's$V$X$V~",
  goto: "$/X(yPPPP(zP(}P)_P+a/fPPPP6iPP7OP<|@mPAQPAQPPPAQPBpPAQPAQPAQPBtPPByPCdPH`PPPHdPPPPHdKfPPPKlMlPHdP!!SPPPP!$eHdPPPHdPHdP!&vHdP!*]!+_!+dP!,U!,Y!,UPPPP!/f!1kPP!1t!3OP!+_HdHd!6b!9m!>v!>v!BnPPP!BuHdPPPPPPPPPPP!FTP!GiPPHd!HyPHdPHdHdHdHdPHd!J`PP!MiP#!nP#!r#!|##Q##QP!MfP##U##UP#&ZP#&_HdHd#&e#)iAQPAQPAQAQP#*sAQAQ#,mAQ#.zAQ#0nAQAQ#1[#3W#3W#3[#3d#3W#3lP#3WPAQ#4hAQ#5pAQAQ6iPPP#6{PP#7e#7eP#7eP#7z#7ePP#8QP#7wP#7w#8d!1p#7w#9O#9U6f(}#9X(}P#9`#9`#9`P(}P(}P(}P(}PP(}P#9f#9iP#9i(}P#9mP#9pP(}P(}P(}P(}P(}P(}(}PP#9v#9|#:W#:^#:d#:j#:p#;O#;U#;[#;f#;l#<h#<w#<}#=a#=g#=m#={#>b#?r#@Q#@W#@^#@d#@j#@t#@z#AQ#A[#An#AtPPPPPPPPPP#AzPPPPPPP#Bn#FYP#Gu#G|#HUPPPP#L`$ U$'t$'w$'z$)w$)z$)}$*UPP$*[$*`$+X$,X$,]$,qPP$,u$,{$-PP$-S$-W$-Z$.P$.g$.l$.o$.r$.x$.{$/P$/TR!yRmpOXr!X#a%]&d&f&g&i,^,c1g1jU!pQ'Q-OQ%ctQ%kwQ%rzQ&[!TS&x!c,vQ'W!f[']!m!r!s!t!u!vS*[$y*aQ+U%lQ+c%tQ+}&UQ,|'PQ-W'XW-`'^'_'`'aQ/p*cQ1U,OU2b-b-d-eS4}0z5QS6[2e2gU7z5U5V5WQ8q6_S9i7{7|Q:k9lR<a;r%QdOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&d&f&g&i&m&u'S'f'v'x(O(Y(k(o(s)r*t+h,Y,^,c-S-[-o-x.b.i/z0P0^0}1_1`1a1c1g1j1l2]2k2}4y5]5o5q5r6U7w8R8`8l:Q:v;ZS#m];o!r)T$X$j&y)g,o,r.q1{3d4v5{9a9|;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`Q*l%SQ+Z%nQ,P&XQ,W&aQ.X<XQ0T*|Q0X+OQ0d+[Q1^,UQ2q.UQ4e0_Q5d1VQ6i2uQ6o<YQ7b4fR8x6j'OkOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'f'v'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`#S!kQ!m!p!r!s!t!u!v!w&x'P'Q']'^'_'`'a'b,v,|-O-`-b-c-d-e0z2b2e2f2g4z5Q5S5T5U5V6[6_6`7p7q7r7|8q9e9f:g$Y$pi#r#t$`$a$u$x%T%U%Y)n)w)y)z*R*X*g*h*{+O+m+p.T._/^/_/a/|0q0t0|2t3l3v4O4U4]4_5[6g6}7W8O8u9Q9o:X:n:{<U<V<Z<[<]<^<_<`<f<g<h<i<j<k<n<o<p<q<t<u=]=e=f=i=jQ%uzQ&v!cS&|%w,yQ+Z%nS.})t/PQ/{*pQ0d+[Q0i+bQ1],TQ1^,UQ4e0_Q4n0kQ5g1XQ5h1[Q7b4fQ7e4kQ8Z5jQ9`7fR9u8WpmOXr!T!X#a%]&Z&d&f&g&i,^,c1g1jR,R&]&x`OPXYrstux!X!^!g!l#P#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u'S'f'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=_=`[#YWZ#T#W&y'vQ%fvQ%jwS%oz%t!U%x|}#d#f#i%Z%v(P(W(X(]+f+g+i,[,p-s-v-z-{-}1o2m2n5z6dQ&Q!RQ'T!eQ'V!fQ(d#oS*O$u*SS+T%k%lQ+X%nQ+x&SQ+|&US-V'W'XQ.W(eQ/Z*PQ0]+UQ0c+[Q0e+]Q0h+aQ1P+yS1T+},OQ2X-WQ3m/VQ4d0_Q4h0bQ4m0jQ5c1UQ6z3nQ7a4fQ7d4jQ9[7`R:b9]v$wi#t%T%U%Y)w)y*R*g*h._/^/|3l4U9Q=]=e=f!`%hw!f!o%j%k%l&w'V'W'X'['i*Z+T+U,s-V-W-_-a/h0]2Q2X2`2d4Q6Y6^8o:TQ*}%fQ+n%}Q+q&OQ+{&UQ.V(dQ1O+xU1S+|+},OQ2v.WQ5^1PS5b1T1US7n4x4|Q8V5cU9g7s7x7yU:i9h9j9kQ;R:jQ;a;S!z=a#r$`$a$u$x)n)z*X*{+O+m+p.T/_/a0q0t0|2t3v4O4]4_5[6g6}7W8O8u9o:X:n:{<Z<]<_<f<h<j<n<p<t=i=jg=b<U<V<[<^<`<g<i<k<o<q<uW$|i%O*i=]S%}!O&ZQ&O!PQ&P!QR+l%{$Z${i#r#t$`$a$u$x%T%U%Y)n)w)y)z*R*X*g*h*{+O+m+p.T._/^/_/a/|0q0t0|2t3l3v4O4U4]4_5[6g6}7W8O8u9Q9o:X:n:{<U<V<Z<[<]<^<_<`<f<g<h<i<j<k<n<o<p<q<t<u=]=e=f=i=jT)o$r)pV*m%S<X<YU&|!c%w,yS(r#v#wQ+`%qS.P(`(aQ0u+rQ4V/yR7j4t'OkOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'f'v'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`$o$]c#V#b%a%b%d'u'{(g(n(v(w(x(y(z({(|(})O)P)Q)S)V)Z)e*y+_,t-h-m-r-w.^.d.h.j.k.l.{/}1v1y2Z2j2|3R3S3T3U3V3W3X3Y3Z3[3]3^3_3b3c3h4Z4b5}6T6b6m6n6s6t7l8f8j8y8}9O:O:d:r:t;X;d;p=ST#QV#R'PkOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'f'v'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`Q&z!cR1|,v!z!kQ!c!m!p!r!s!t!u!v!w&x'P'Q']'^'_'`'a'b,v,|-O-`-b-c-d-e2b2e2f2g4z5S5T6[6_6`7p7q7r8q9e9f:gS*Z$y*aS/h*[*cQ/q*dQ0w+tQ4Q/pQ4T/sS4x0z5QS7s4}5WS7x5U5VS9h7z7{Q9j7|S:j9i9lR;S:klpOXr!X#a%]&d&f&g&i,^,c1g1jQ&k![Q'j!tS(f#q;vQ+R%iQ+v&QQ+w&RQ-T'UQ-g'cS.](k<cS0O*t<lQ0Z+SQ0y+uQ1n,eQ1p,fQ1x,qQ2V-UQ2Y-YS4[0P<rQ4`0[S4c0^<sQ5|1zQ6Q2WQ6V2_Q7_4aQ8g6OQ8h6RQ8k6WQ9{8dQ:P8mQ:u:RR;Y:w$j$[c#V#b%b%d'u'{(g(n(v(w(x(y(z({(|(})O)P)Q)S)V)Z)e*y+_,t-h-m-r-w.^.d.h.k.l.{/}1v1y2Z2j2|3R3S3T3U3V3W3X3Y3Z3[3]3^3_3b3c3h4Z4b5}6T6b6m6n6s6t7l8f8j8y8}9O:O:d:r:t;X;d;p=SS(c#l'ZU*f$z(j3aS*x%a.jQ2r0TQ6f2qQ8w6iR:Y8x$j$Zc#V#b%b%d'u'{(g(n(v(w(x(y(z({(|(})O)P)Q)S)V)Z)e*y+_,t-h-m-r-w.^.d.h.k.l.{/}1v1y2Z2j2|3R3S3T3U3V3W3X3Y3Z3[3]3^3_3b3c3h4Z4b5}6T6b6m6n6s6t7l8f8j8y8}9O:O:d:r:t;X;d;p=SS(b#l'ZS(t#w$[S*w%a.jS.Q(a(cQ.m)UQ0Q*xR2o.R'OkOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'f'v'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`S#m];oQ&f!VQ&g!WQ&i!YQ&j!ZR1f,aQ'R!eQ*z%fQ-R'TS.S(d*}Q2T-QW2s.V.W0S0UQ6P2UU6e2p2r2vS8t6f6hS:W8v8wS:y:V:YQ;[:zR;e;]V!qQ'Q-O!_^OQXZ_r!T!X!m#a#d%Z%]&Z&]&d&f&g&i'Q(],^,c-O-z0z1g1j4z5QT#m];o%[yOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'f'v'x(O(Y(k(o(s)r*t*|+h,Y,^,c-S-[-o-x.U.b.i/z0P0^0}1_1`1a1c1g1j1l2]2k2u2}4y5]5o5q5r6U6j7w8R8`8l:Q:v;ZS(r#v#wS.P(`(a!s<y$X$j&y)g,o,r.q1{3d4v5{9a9|;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`U!oQ'Q-OY'[!m!s!t!u!vS'i!p!rW'k!w4z5S5TS-_']'^U-a'_'`'aW-f'b7p7q7rS2`-`-bU2c-c9e9fS2d-d-eS4|0z5QS6Y2b2eS6]2f:gQ6^2gS7s4}5WS7y5U5VS8o6[6_Q8r6`S9h7z7{Q9k7|Q:T8qS:j9i9lR;S:kU!qQ'Q-OT5O0z5QU'h!o4{4|S([#e1dU-^'['k7yQ/Y*OQ/f*ZU2a-a-f9kQ3r/ZS3{/g/qS6Z2c2dQ6y3mS7U4R4TS8p6]6^Q9S6zQ9Z7XR:U8rQ#sbU'g!o4{4|S(Z#e1dQ*u%[Q+P%gQ+V%mW-]'['h'k7yQ-y([Q/X*OQ/e*ZQ/k*^Q0Y+QQ1Q+zW2^-^-a-f9kS3q/Y/ZS3z/f/qQ3}/jQ4P/lQ5`1RU6X2a2c2dQ6x3mQ6|3rS7Q3{4TQ7V4SQ8T5aU8n6Z6]6^S9R6y6zQ9V7RQ9X7UQ9c7mQ9r8US:S8p8rQ:^9SQ:_9WQ:a9ZQ:f9dQ:p9sQ:x:UQ:}:`Q;P:hQ;_;QQ;h;`Q;l;iQ<|<wQ=X=QR=Y=R%[aOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'f'v'x(O(Y(k(o(s)r*t*|+h,Y,^,c-S-[-o-x.U.b.i/z0P0^0}1_1`1a1c1g1j1l2]2k2u2}4y5]5o5q5r6U6j7w8R8`8l:Q:v;ZS#sx!g!r<v$X$j&y)g,o,r.q1{3d4v5{9a9|;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`R<|=_%[bOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'f'v'x(O(Y(k(o(s)r*t*|+h,Y,^,c-S-[-o-x.U.b.i/z0P0^0}1_1`1a1c1g1j1l2]2k2u2}4y5]5o5q5r6U6j7w8R8`8l:Q:v;ZQ%[j!`%gw!f!o%j%k%l&w'V'W'X'['i*Z+T+U,s-V-W-_-a/h0]2Q2X2`2d4Q6Y6^8o:TS%mx!gQ+Q%hQ+z&UW1R+{+|+},OU5a1S1T1US7m4x4|S8U5b5cW9d7n7s7x7yQ9s8VW:h9g9h9j9kS;Q:i:jS;`;R;SQ;i;a!r<w$X$j&y)g,o,r.q1{3d4v5{9a9|;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`Q=Q=^R=R=_%OeOPXYrstu!X!^!l#P#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&d&f&g&i&m&u'S'f'x(O(Y(k(o(s)r*t*|+h,Y,^,c-S-[-o-x.U.b.i/z0P0^0}1_1`1a1c1g1j1l2]2k2u2}4y5]5o5q5r6U6j7w8R8`8l:Q:v;ZY#_WZ#T#W'v!U%x|}#d#f#i%Z%v(P(W(X(]+f+g+i,[,p-s-v-z-{-}1o2m2n5z6dQ,X&a!p<x$X$j)g,o,r.q1{3d4v5{9a9|;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`R<{&yS&}!c%wR2O,y%QdOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&d&f&g&i&m&u'S'f'v'x(O(Y(k(o(s)r*t+h,Y,^,c-S-[-o-x.b.i/z0P0^0}1_1`1a1c1g1j1l2]2k2}4y5]5o5q5r6U7w8R8`8l:Q:v;Z!r)T$X$j&y)g,o,r.q1{3d4v5{9a9|;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`Q,W&aQ0T*|Q2q.UQ6i2uR8x6j!l$Rc#V%a'u'{(g(n(})O)P)Q)V)Z+_-h-m-r-w.^.d.{/}2Z2j2|3_4Z4b6T6b6m8j:O:t;X;d;p!T;})S)e,t.j1v1y3R3Z3[3]3^3b3h5}6n6s6t7l8f8y8}9O:d:r=S!h$Tc#V%a'u'{(g(n)P)Q)V)Z+_-h-m-r-w.^.d.{/}2Z2j2|3_4Z4b6T6b6m8j:O:t;X;d;p!P<P)S)e,t.j1v1y3R3]3^3b3h5}6n6s6t7l8f8y8}9O:d:r=S!d$Xc#V%a'u'{(g(n)V)Z+_-h-m-r-w.^.d.{/}2Z2j2|3_4Z4b6T6b6m8j:O:t;X;d;pQ3l/Tz=`)S)e,t.j1v1y3R3b3h5}6n6s6t7l8f8y8}9O:d:r=SQ=e=gR=f=h'OkOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'f'v'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`S$kh$lR3e.p'VgOPWXYZhrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j$l%]%c%p&]&`&a&d&f&g&i&m&u&y'S'f'v'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.p.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`T$gf$mQ$efS)^$h)bR)j$mT$ff$mT)`$h)b'VhOPWXYZhrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j$l%]%c%p&]&`&a&d&f&g&i&m&u&y'S'f'v'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.p.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`T$kh$lQ$nhR)i$l%[jOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'f'v'x(O(Y(k(o(s)r*t*|+h,Y,^,c-S-[-o-x.U.b.i/z0P0^0}1_1`1a1c1g1j1l2]2k2u2}4y5]5o5q5r6U6j7w8R8`8l:Q:v;Z!s=^$X$j&y)g,o,r.q1{3d4v5{9a9|;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`#alOPXZr!X!^!l#P#a#k#x$j%]&]&`&a&d&f&g&i&m&u'S(s)g*|+h,Y,^,c-S.U.q/z0}1_1`1a1c1g1j1l2u3d4y5]5o5q5r6j7w8R8`v$zi#t%T%U%Y)w)y*R*g*h._/^/|3l4U9Q=]=e=f!z(j#r$`$a$u$x)n)z*X*{+O+m+p.T/_/a0q0t0|2t3v4O4]4_5[6g6}7W8O8u9o:X:n:{<Z<]<_<f<h<j<n<p<t=i=jQ*q%WQ.|)sg3a<U<V<[<^<`<g<i<k<o<q<uv$vi#t%T%U%Y)w)y*R*g*h._/^/|3l4U9Q=]=e=fQ*T$wS*^$y*aQ*r%XQ/l*_!z=O#r$`$a$u$x)n)z*X*{+O+m+p.T/_/a0q0t0|2t3v4O4]4_5[6g6}7W8O8u9o:X:n:{<Z<]<_<f<h<j<n<p<t=i=jf=P<U<V<[<^<`<g<i<k<o<q<uQ=T=aQ=U=bQ=V=cR=W=dv$zi#t%T%U%Y)w)y*R*g*h._/^/|3l4U9Q=]=e=f!z(j#r$`$a$u$x)n)z*X*{+O+m+p.T/_/a0q0t0|2t3v4O4]4_5[6g6}7W8O8u9o:X:n:{<Z<]<_<f<h<j<n<p<t=i=jg3a<U<V<[<^<`<g<i<k<o<q<ulnOXr!X#a%]&d&f&g&i,^,c1g1jQ*W$xQ,l&pQ,m&rR3u/_$Y${i#r#t$`$a$u$x%T%U%Y)n)w)y)z*R*X*g*h*{+O+m+p.T._/^/_/a/|0q0t0|2t3l3v4O4U4]4_5[6g6}7W8O8u9Q9o:X:n:{<U<V<Z<[<]<^<_<`<f<g<h<i<j<k<n<o<p<q<t<u=]=e=f=i=jQ+o&OQ0s+qQ4r0rR7i4sT*`$y*aS*`$y*aT5P0z5QS/j*]4yT4S/r7wQ+P%gQ/k*^Q0Y+QQ1Q+zQ5`1RQ8T5aQ9c7mQ9r8UQ:f9dQ:p9sQ;P:hQ;_;QQ;h;`R;l;in)w$s(l*s/]/t/u2z3s4Y6w7Y:]<}=Z=[!W<f(h)X)}*V.[.x/T/b0R0p0r2y3t3x4q4s6k6l7O7S7[7^9U9Y:|=g=h]<g3`6r8z:Z:[;fp)y$s(l*s/R/]/t/u2z3s4Y6w7Y:]<}=Z=[!Y<h(h)X)}*V.[.x/T/b0R0p0r2w2y3t3x4q4s6k6l7O7S7[7^9U9Y:|=g=h_<i3`6r8z8{:Z:[;fpmOXr!T!X#a%]&Z&d&f&g&i,^,c1g1jQ&W!SR,Y&apmOXr!T!X#a%]&Z&d&f&g&i,^,c1g1jR&W!SQ+s&PR0o+lqmOXr!T!X#a%]&Z&d&f&g&i,^,c1g1jQ0{+xS5Z1O1PU7}5X5Y5^S9n8P8QS:l9m9pQ;T:mR;b;UQ&_!TR,S&ZR5g1XS%oz%tR0e+]Q&d!UR,^&eR,d&jT1h,c1jR,h&kQ,g&kR1q,hQ'm!xR-i'mQrOQ#aXT%`r#aQ!{TR'o!{Q#OUR'q#OQ)p$rR.y)pQ#RVR's#RQ#UWU'y#U'z-pQ'z#VR-p'{Q,w&zR1},wQ.`(lR2{.`Q.c(nS3O.c3PR3P.dQ-O'QR2R-Or_OXr!T!X#a%]&Z&]&d&f&g&i,^,c1g1jU!mQ'Q-OS#dZ%ZY#n_!m#d-z4zQ-z(]T4z0z5QS#[W%vU(Q#[(R-qQ(R#]R-q'|Q,z&}R2P,zQ(^#gQ-t(VW.O(^-t2h6aQ2h-uR6a2iQ)b$hR.r)bQ$lhR)h$lQ$_cU)W$_-l<TQ-l;pR<T)eQ/W*OW3o/W3p6{9TU3p/X/Y/ZS6{3q3rR9T6|#m)u$s(h(l)X)}*V*n*o*s.Y.Z.[.x/R/S/T/]/b/t/u0R0p0r2w2x2y2z3`3s3t3x4Y4q4s6k6l6p6q6r6w7O7S7Y7[7^8z8{8|9U9Y:Z:[:]:|;f<}=Z=[=g=hQ/`*VU3w/`3y7PQ3y/bR7P3xQ*a$yR/n*aQ*j$}R/w*jQ4^0RR7]4^Q+j%yR0n+jQ4u0uS7k4u9bR9b7lQ+u&QR0x+uQ5Q0zR7u5QQ1W,PS5e1W8XR8X5gQ0`+XW4g0`4i7c9^Q4i0cQ7c4hR9^7dQ+^%oR0f+^Q1j,cR5u1jWqOXr#aQ&h!XQ*v%]Q,]&dQ,_&fQ,`&gQ,b&iQ1e,^S1h,c1jR5t1gQ%_oQ&l!]Q&o!_Q&q!`Q&s!aU'e!o4{4|Q+e%uQ+k%zQ,R&_Q,j&nY-Z'['g'h'k7yQ/m*`S1Z,S,VQ1r,iQ1s,lQ1t,m[2[-]-^-a-f-h9kQ4l0iQ4p0pQ5_1QQ5i1]Q5s1fY6S2Z2^2a2c2dQ7g4nQ7h4qQ7t5PQ8S5`Q8Y5hY8i6T6X6Z6]6^Q9_7eQ9q8TQ9v8ZW9}8j8n8p8rQ:c9`Q:e9cQ:o9rU:s:O:S:UQ;O:fQ;V:pS;W:t:xQ;^;PQ;c;XQ;g;_Q;j;dQ;k;hR;m;lQ%iwQ'U!fQ'c!oU+S%j%k%lQ,q&wU-U'V'W'XS-Y'['iQ/d*ZS0[+T+UQ1z,sS2W-V-WS2_-_-aQ3|/hQ4a0]Q6O2QQ6R2XS6W2`2dQ7T4QS8m6Y6^Q:R8oR:w:TS$ti=]R*k%OU$}i%O=]R/v*iQ$siS(h#r+OQ(l#tS)X$`$aQ)}$uQ*V$xQ*n%TQ*o%UQ*s%YQ.Y<ZQ.Z<]Q.[<_Q.x)nQ/R)wQ/S)yQ/T)zQ/]*RQ/b*XQ/t*gQ/u*hh0R*{.T0|2t5[6g8O8u9o:X:n:{Q0p+mQ0r+pQ2w<fQ2x<hQ2y<jQ2z._S3`<U<VQ3s/^Q3t/_Q3x/aQ4Y/|Q4q0qQ4s0tQ6k<nQ6l<pQ6p<[Q6q<^Q6r<`Q6w3lQ7O3vQ7S4OQ7Y4UQ7[4]Q7^4_Q8z<kQ8{<gQ8|<iQ9U6}Q9Y7WQ:Z<oQ:[<qQ:]9QQ:|<tQ;f<uQ<}=]Q=Z=eQ=[=fQ=g=iR=h=jloOXr!X#a%]&d&f&g&i,^,c1g1jQ!dPS#cZ#kQ&n!^U'Y!l4y7wQ'r#PQ(u#xQ)f$jS,V&]&`Q,Z&aQ,i&mQ,n&uQ-Q'SQ.f(sQ.v)gQ0U*|Q0l+hQ1b,YQ2U-SQ2r.UQ3g.qQ4W/zQ5Y0}Q5k1_Q5l1`Q5n1aQ5p1cQ5w1lQ6f2uQ6u3dQ8Q5]Q8_5oQ8a5qQ8b5rQ8w6jQ9p8RR9x8`#UcOPXZr!X!^!l#a#k#x%]&]&`&a&d&f&g&i&m&u'S(s*|+h,Y,^,c-S.U/z0}1_1`1a1c1g1j1l2u4y5]5o5q5r6j7w8R8`Q#VWQ#bYQ%asQ%btQ%duS'u#T'xQ'{#WQ(g#qQ(n#uQ(v#{Q(w#|Q(x#}Q(y$OQ(z$PQ({$QQ(|$RQ(}$SQ)O$TQ)P$UQ)Q$VQ)S$XQ)V$^Q)Z$bW)e$j)g.q3dQ*y%cQ+_%pS,t&y1{Q-h'fS-m'v-oQ-r(OQ-w(YQ.^(kQ.d(oQ.h;nQ.j;qQ.k;rQ.l;sQ.{)rQ/}*tQ1v,oQ1y,rQ2Z-[Q2j-xQ2|.bQ3R;vQ3S;wQ3T;xQ3U;yQ3V;zQ3W;{Q3X;|Q3Y;}Q3Z<OQ3[<PQ3]<QQ3^<RQ3_.iQ3b<WQ3c<aQ3h<SQ4Z0PQ4b0^Q5}<bQ6T2]Q6b2kQ6m2}Q6n<cQ6s<eQ6t<lQ7l4vQ8f5{Q8j6UQ8y<mQ8}<rQ9O<sQ:O8lQ:d9aQ:r9|Q:t:QQ;X:vQ;d;ZQ;p#PR=S=`R#XWR&{!cU!oQ'Q-OS&w!c,vY'[!m!s!t!u!vS'i!p!r['k!w4z5S5T5U5VS,s&x'PS-_']'^U-a'_'`'aY-f'b7p7q7r7|Q2Q,|S2`-`-bU2c-c9e9fS2d-d-eS4{0z5QS6Y2b2eS6]2f:gQ6^2gS8o6[6_Q8r6`R:T8qR(m#tR(p#uQ!dQT,}'Q-OQ#l]R'Z;oT#hZ%ZS#gZ%ZU%y|},[U(V#d#f#iS-u(W(XQ-|(]Q0m+iQ2i-vU2l-z-{-}S6c2m2nR8s6d`#ZW#T#W%v'v(P+f-st#eZ|}#d#f#i%Z(W(X(]+i-v-z-{-}2m2n6dQ1d,[Q1w,pQ5y1oQ8e5zT<z&y+gT#^W%vS#]W%vS'w#T(PS'|#W+fS,u&y+gT-n'v-sT'O!c%wQ$hfR)l$mT)a$h)bR3f.pT*Q$u*SR*Y$xQ0S*{Q2p.TQ5X0|Q6h2tQ8P5[Q8v6gQ9m8OQ:V8uQ:m9oQ:z:XQ;U:nR;]:{lpOXr!X#a%]&d&f&g&i,^,c1g1jQ&^!TR,R&ZV%z|},[R0v+rR,Q&XQ%szR+d%tR+Y%nT&b!U&eT&c!U&eT1i,c1j",
  nodeNames: "⚠ ArithOp ArithOp LineComment BlockComment Script ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody MethodDeclaration AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 362,
  context: a0,
  nodeProps: [
    ["group", -26, 6, 14, 16, 62, 198, 202, 205, 206, 208, 211, 214, 225, 227, 233, 235, 237, 239, 242, 248, 254, 256, 258, 260, 262, 264, 265, "Statement", -32, 10, 11, 25, 28, 29, 35, 45, 48, 49, 51, 56, 64, 72, 76, 78, 80, 81, 102, 103, 112, 113, 130, 133, 135, 136, 137, 138, 140, 141, 161, 162, 164, "Expression", -23, 24, 26, 30, 34, 36, 38, 165, 167, 169, 170, 172, 173, 174, 176, 177, 178, 180, 181, 182, 192, 194, 196, 197, "Type", -3, 84, 95, 101, "ClassItem"],
    ["openedBy", 31, "InterpolationStart", 50, "[", 54, "{", 69, "(", 142, "JSXStartTag", 154, "JSXStartTag JSXStartCloseTag"],
    ["closedBy", 33, "InterpolationEnd", 44, "]", 55, "}", 70, ")", 143, "JSXSelfCloseEndTag JSXEndTag", 159, "JSXEndTag"]
  ],
  propSources: [u0],
  skippedNodes: [0, 3, 4, 268],
  repeatNodeCount: 32,
  tokenData: "$>y(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tu>PuvBavwDxwxGgxyMvyz! Qz{!![{|!%O|}!&]}!O!%O!O!P!'g!P!Q!1w!Q!R#0t!R![#3T![!]#@T!]!^#Aa!^!_#Bk!_!`#GS!`!a#In!a!b#N{!b!c$$z!c!}>P!}#O$&U#O#P$'`#P#Q$,w#Q#R$.R#R#S>P#S#T$/`#T#o$0j#o#p$4z#p#q$5p#q#r$7Q#r#s$8^#s$f%Z$f$g+g$g#BY>P#BY#BZ$9h#BZ$IS>P$IS$I_$9h$I_$I|>P$I|$I}$<s$I}$JO$<s$JO$JT>P$JT$JU$9h$JU$KV>P$KV$KW$9h$KW&FU>P&FU&FV$9h&FV;'S>P;'S;=`BZ<%l?HT>P?HT?HU$9h?HUO>P(n%d_$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$c&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$c&j'y!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU'y!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$c&j'vpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU'vpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX'vp'y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$c&j'vp'y!b'l(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST'w#S$c&j'm(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$c&j'vp'y!b'm(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$c&j!l$Ip'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#p$Id$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#p$Id$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2b3l_'u$(n$c&j'y!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k*r4r_$c&j'y!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k)`5vX$c&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q)`6jT$^#t$c&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#t6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y#t7bO$^#t#t7eP;=`<%l6y)`7kP;=`<%l5q*r7w]$^#t$c&j'y!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}%W8uZ'y!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p%W9oU$^#t'y!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}%W:UP;=`<%l8p*r:[P;=`<%l4k#%|:hg$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}st%Ztu<Puw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}<P!}#O%Z#O#P&c#P#R%Z#R#S<P#S#T%Z#T#o<P#o#p*g#p$g%Z$g;'S<P;'S;=`=y<%lO<P#%|<[i$c&j(_!L^'vp'y!bOY%ZYZ&cZr%Zrs&}st%Ztu<Puw%Zwx(rx!Q%Z!Q![<P![!^%Z!^!_*g!_!c%Z!c!}<P!}#O%Z#O#P&c#P#R%Z#R#S<P#S#T%Z#T#o<P#o#p*g#p$g%Z$g;'S<P;'S;=`=y<%lO<P#%|=|P;=`<%l<P(CS>`k$c&j'vp'y!b(T!LY's&;d$V#tOY%ZYZ&cZr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$g%Z$g;'S>P;'S;=`BZ<%lO>P+d@`k$c&j'vp'y!b$V#tOY%ZYZ&cZr%Zrs&}st%Ztu@Tuw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![@T![!^%Z!^!_*g!_!c%Z!c!}@T!}#O%Z#O#P&c#P#R%Z#R#S@T#S#T%Z#T#o@T#o#p*g#p$g%Z$g;'S@T;'S;=`BT<%lO@T+dBWP;=`<%l@T(CSB^P;=`<%l>P%#SBl`$c&j'vp'y!b#h$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SCy_$c&j#z$Id'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%DfETa(h%<v$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sv%ZvwFYwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SFe`$c&j#t$Id'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2bGp_'x$)`$c&j'vpOYHoYZIuZrHorsIuswHowxKVx!^Ho!^!_LX!_#OHo#O#PIu#P#oHo#o#pLX#p;'SHo;'S;=`Mp<%lOHo*QHv_$c&j'vpOYHoYZIuZrHorsIuswHowxKVx!^Ho!^!_LX!_#OHo#O#PIu#P#oHo#o#pLX#p;'SHo;'S;=`Mp<%lOHo)`IzX$c&jOwIuwx6cx!^Iu!^!_Jg!_#oIu#o#pJg#p;'SIu;'S;=`KP<%lOIu#tJjTOwJgwx7]x;'SJg;'S;=`Jy<%lOJg#tJ|P;=`<%lJg)`KSP;=`<%lIu*QK`]$^#t$c&j'vpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r$fL^Z'vpOYLXYZJgZrLXrsJgswLXwxMPx#OLX#O#PJg#P;'SLX;'S;=`Mj<%lOLX$fMWU$^#t'vpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r$fMmP;=`<%lLX*QMsP;=`<%lHo(*QNR_!h(!b$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l! ]_!gM|$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!!ib$c&j'vp'y!b't#)d#i$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!#q{!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!#|`$c&j'vp'y!b#f$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!%Z`$c&j'vp'y!bk&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!&h_!V&;l$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!'rc$c&j'vp'y!by'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!(}!P!Q%Z!Q![!+g![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!)Wa$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!*]!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!*h_!UMt$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!+rg$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!+g![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S!+g#S#X%Z#X#Y!-Z#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!-dg$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!.{|}%Z}!O!.{!O!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!/Uc$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!0lc$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!2Sf$c&j'vp'y!b#g$IdOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}xz!3hz{#$s{!P!3h!P!Q#&Y!Q!^!3h!^!_!Mh!_!`#-x!`!a#/_!a!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(r!3sb$c&j'vp'y!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(Q!5U`$c&j'y!b!RSOY!4{YZ&cZw!4{wx!6Wx!P!4{!P!Q!=o!Q!^!4{!^!_!?g!_!}!4{!}#O!Bn#O#P!<w#P#o!4{#o#p!?g#p;'S!4{;'S;=`!Cw<%lO!4{&n!6_^$c&j!RSOY!6WYZ&cZ!P!6W!P!Q!7Z!Q!^!6W!^!_!8g!_!}!6W!}#O!;U#O#P!<w#P#o!6W#o#p!8g#p;'S!6W;'S;=`!=i<%lO!6W&n!7ba$c&j!RSO!^&c!_#Z&c#Z#[!7Z#[#]&c#]#^!7Z#^#a&c#a#b!7Z#b#g&c#g#h!7Z#h#i&c#i#j!7Z#j#m&c#m#n!7Z#n#o&c#p;'S&c;'S;=`&w<%lO&cS!8lX!RSOY!8gZ!P!8g!P!Q!9X!Q!}!8g!}#O!9p#O#P!:o#P;'S!8g;'S;=`!;O<%lO!8gS!9^U!RS#Z#[!9X#]#^!9X#a#b!9X#g#h!9X#i#j!9X#m#n!9XS!9sVOY!9pZ#O!9p#O#P!:Y#P#Q!8g#Q;'S!9p;'S;=`!:i<%lO!9pS!:]SOY!9pZ;'S!9p;'S;=`!:i<%lO!9pS!:lP;=`<%l!9pS!:rSOY!8gZ;'S!8g;'S;=`!;O<%lO!8gS!;RP;=`<%l!8g&n!;Z[$c&jOY!;UYZ&cZ!^!;U!^!_!9p!_#O!;U#O#P!<P#P#Q!6W#Q#o!;U#o#p!9p#p;'S!;U;'S;=`!<q<%lO!;U&n!<UX$c&jOY!;UYZ&cZ!^!;U!^!_!9p!_#o!;U#o#p!9p#p;'S!;U;'S;=`!<q<%lO!;U&n!<tP;=`<%l!;U&n!<|X$c&jOY!6WYZ&cZ!^!6W!^!_!8g!_#o!6W#o#p!8g#p;'S!6W;'S;=`!=i<%lO!6W&n!=lP;=`<%l!6W(Q!=xi$c&j'y!b!RSOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!=o#[#]&}#]#^!=o#^#a&}#a#b!=o#b#g&}#g#h!=o#h#i&}#i#j!=o#j#m&}#m#n!=o#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!?nZ'y!b!RSOY!?gZw!?gwx!8gx!P!?g!P!Q!@a!Q!}!?g!}#O!Ap#O#P!:o#P;'S!?g;'S;=`!Bh<%lO!?g!f!@hb'y!b!RSOY'}Zw'}x#O'}#P#Z'}#Z#[!@a#[#]'}#]#^!@a#^#a'}#a#b!@a#b#g'}#g#h!@a#h#i'}#i#j!@a#j#m'}#m#n!@a#n;'S'};'S;=`(f<%lO'}!f!AuX'y!bOY!ApZw!Apwx!9px#O!Ap#O#P!:Y#P#Q!?g#Q;'S!Ap;'S;=`!Bb<%lO!Ap!f!BeP;=`<%l!Ap!f!BkP;=`<%l!?g(Q!Bu^$c&j'y!bOY!BnYZ&cZw!Bnwx!;Ux!^!Bn!^!_!Ap!_#O!Bn#O#P!<P#P#Q!4{#Q#o!Bn#o#p!Ap#p;'S!Bn;'S;=`!Cq<%lO!Bn(Q!CtP;=`<%l!Bn(Q!CzP;=`<%l!4{'`!DW`$c&j'vp!RSOY!C}YZ&cZr!C}rs!6Ws!P!C}!P!Q!EY!Q!^!C}!^!_!GQ!_!}!C}!}#O!JX#O#P!<w#P#o!C}#o#p!GQ#p;'S!C};'S;=`!Kb<%lO!C}'`!Eci$c&j'vp!RSOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!EY#[#](r#]#^!EY#^#a(r#a#b!EY#b#g(r#g#h!EY#h#i(r#i#j!EY#j#m(r#m#n!EY#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!GXZ'vp!RSOY!GQZr!GQrs!8gs!P!GQ!P!Q!Gz!Q!}!GQ!}#O!IZ#O#P!:o#P;'S!GQ;'S;=`!JR<%lO!GQt!HRb'vp!RSOY)rZr)rs#O)r#P#Z)r#Z#[!Gz#[#])r#]#^!Gz#^#a)r#a#b!Gz#b#g)r#g#h!Gz#h#i)r#i#j!Gz#j#m)r#m#n!Gz#n;'S)r;'S;=`*Z<%lO)rt!I`X'vpOY!IZZr!IZrs!9ps#O!IZ#O#P!:Y#P#Q!GQ#Q;'S!IZ;'S;=`!I{<%lO!IZt!JOP;=`<%l!IZt!JUP;=`<%l!GQ'`!J`^$c&j'vpOY!JXYZ&cZr!JXrs!;Us!^!JX!^!_!IZ!_#O!JX#O#P!<P#P#Q!C}#Q#o!JX#o#p!IZ#p;'S!JX;'S;=`!K[<%lO!JX'`!K_P;=`<%l!JX'`!KeP;=`<%l!C}(r!Ksk$c&j'vp'y!b!RSOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[!Kh#[#]%Z#]#^!Kh#^#a%Z#a#b!Kh#b#g%Z#g#h!Kh#h#i%Z#i#j!Kh#j#m%Z#m#n!Kh#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W!Mq]'vp'y!b!RSOY!MhZr!Mhrs!?gsw!Mhwx!GQx!P!Mh!P!Q!Nj!Q!}!Mh!}#O#!U#O#P!:o#P;'S!Mh;'S;=`##U<%lO!Mh#W!Nse'vp'y!b!RSOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[!Nj#[#]*g#]#^!Nj#^#a*g#a#b!Nj#b#g*g#g#h!Nj#h#i*g#i#j!Nj#j#m*g#m#n!Nj#n;'S*g;'S;=`+Z<%lO*g#W#!]Z'vp'y!bOY#!UZr#!Urs!Apsw#!Uwx!IZx#O#!U#O#P!:Y#P#Q!Mh#Q;'S#!U;'S;=`##O<%lO#!U#W##RP;=`<%l#!U#W##XP;=`<%l!Mh(r##e`$c&j'vp'y!bOY##[YZ&cZr##[rs!Bnsw##[wx!JXx!^##[!^!_#!U!_#O##[#O#P!<P#P#Q!3h#Q#o##[#o#p#!U#p;'S##[;'S;=`#$g<%lO##[(r#$jP;=`<%l##[(r#$pP;=`<%l!3h(CS#%Qb$c&j'vp'y!b'n(;d!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(CS#&e_$c&j'vp'y!bR(;dOY#&YYZ&cZr#&Yrs#'dsw#&Ywx#*tx!^#&Y!^!_#,s!_#O#&Y#O#P#(f#P#o#&Y#o#p#,s#p;'S#&Y;'S;=`#-r<%lO#&Y(Bb#'m]$c&j'y!bR(;dOY#'dYZ&cZw#'dwx#(fx!^#'d!^!_#)w!_#O#'d#O#P#(f#P#o#'d#o#p#)w#p;'S#'d;'S;=`#*n<%lO#'d(AO#(mX$c&jR(;dOY#(fYZ&cZ!^#(f!^!_#)Y!_#o#(f#o#p#)Y#p;'S#(f;'S;=`#)q<%lO#(f(;d#)_SR(;dOY#)YZ;'S#)Y;'S;=`#)k<%lO#)Y(;d#)nP;=`<%l#)Y(AO#)tP;=`<%l#(f(<v#*OW'y!bR(;dOY#)wZw#)wwx#)Yx#O#)w#O#P#)Y#P;'S#)w;'S;=`#*h<%lO#)w(<v#*kP;=`<%l#)w(Bb#*qP;=`<%l#'d(Ap#*}]$c&j'vpR(;dOY#*tYZ&cZr#*trs#(fs!^#*t!^!_#+v!_#O#*t#O#P#(f#P#o#*t#o#p#+v#p;'S#*t;'S;=`#,m<%lO#*t(<U#+}W'vpR(;dOY#+vZr#+vrs#)Ys#O#+v#O#P#)Y#P;'S#+v;'S;=`#,g<%lO#+v(<U#,jP;=`<%l#+v(Ap#,pP;=`<%l#*t(=h#,|Y'vp'y!bR(;dOY#,sZr#,srs#)wsw#,swx#+vx#O#,s#O#P#)Y#P;'S#,s;'S;=`#-l<%lO#,s(=h#-oP;=`<%l#,s(CS#-uP;=`<%l#&Y%#W#.Vb$c&j#z$Id'vp'y!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h+h#/lb$S#t$c&j'vp'y!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h$/l#1Pp$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!+g!P!Q%Z!Q![#3T![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S#3T#S#U%Z#U#V#6_#V#X%Z#X#Y!-Z#Y#b%Z#b#c#5T#c#d#9g#d#l%Z#l#m#<i#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#3`k$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!+g!P!Q%Z!Q![#3T![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S#3T#S#X%Z#X#Y!-Z#Y#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#5`_$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#6hd$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#7v!R!S#7v!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#7v#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#8Rf$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#7v!R!S#7v!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#7v#S#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#9pc$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#:{!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#:{#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;We$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#:{!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#:{#S#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#<rg$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#>Z![!^%Z!^!_*g!_!c%Z!c!i#>Z!i#O%Z#O#P&c#P#R%Z#R#S#>Z#S#T%Z#T#Z#>Z#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>fi$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#>Z![!^%Z!^!_*g!_!c%Z!c!i#>Z!i#O%Z#O#P&c#P#R%Z#R#S#>Z#S#T%Z#T#Z#>Z#Z#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#@b_!a$b$c&j#x%<f'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Al_^l$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS#Bz^'|!*v!e'.r'vp'y!b$T)d(lSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Cv!Q!^*g!^!_#Dl!_!`#F^!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#DPX$e&j'vp'y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#DuZ#j$Id'vp'y!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Eh!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#EqX#z$Id'vp'y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#FgX#k$Id'vp'y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh#G_a#W%?x$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a#Hd!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W#Ho_#c$Ih$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#I}adBf#k$Id$`#|$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`#KS!`!a#L^!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#K__#k$Id$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#Lia#j$Id$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`!a#Mn!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#My`#j$Id$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$ Wc(`$Ip$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$!c!P!^%Z!^!_*g!_!a%Z!a!b$#m!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$!n_z'#p$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$#x`$c&j#u$Id'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$%V_!x!Ln$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$&a_|(8n$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$'eZ$c&jO!^$(W!^!_$(n!_#i$(W#i#j$(s#j#l$(W#l#m$*f#m#o$(W#o#p$(n#p;'S$(W;'S;=`$,q<%lO$(W(n$(_T[#S$c&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$(sO[#S(n$(x[$c&jO!Q&c!Q![$)n![!^&c!_!c&c!c!i$)n!i#T&c#T#Z$)n#Z#o&c#o#p$,U#p;'S&c;'S;=`&w<%lO&c(n$)sZ$c&jO!Q&c!Q![$*f![!^&c!_!c&c!c!i$*f!i#T&c#T#Z$*f#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$*kZ$c&jO!Q&c!Q![$+^![!^&c!_!c&c!c!i$+^!i#T&c#T#Z$+^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$+cZ$c&jO!Q&c!Q![$(W![!^&c!_!c&c!c!i$(W!i#T&c#T#Z$(W#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$,XR!Q![$,b!c!i$,b#T#Z$,b#S$,eS!Q![$,b!c!i$,b#T#Z$,b#q#r$(n(n$,tP;=`<%l$(W!'l$-S_!SM|$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$.^`#r$Id$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$/k_$c&j'vp'y!b(Q&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$0yk$c&j'vp'y!b(T!LY's&;d$X#tOY%ZYZ&cZr%Zrs&}st%Ztu$0juw%Zwx(rx}%Z}!O$2n!O!Q%Z!Q![$0j![!^%Z!^!_*g!_!c%Z!c!}$0j!}#O%Z#O#P&c#P#R%Z#R#S$0j#S#T%Z#T#o$0j#o#p*g#p$g%Z$g;'S$0j;'S;=`$4t<%lO$0j+d$2yk$c&j'vp'y!b$X#tOY%ZYZ&cZr%Zrs&}st%Ztu$2nuw%Zwx(rx}%Z}!O$2n!O!Q%Z!Q![$2n![!^%Z!^!_*g!_!c%Z!c!}$2n!}#O%Z#O#P&c#P#R%Z#R#S$2n#S#T%Z#T#o$2n#o#p*g#p$g%Z$g;'S$2n;'S;=`$4n<%lO$2n+d$4qP;=`<%l$2n(CS$4wP;=`<%l$0j!5p$5TX!X!3l'vp'y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Df$5{a(g%<v$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$#m#q;'S%Z;'S;=`+a<%lO%Z%#`$7__!W$I`o`$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$8i_!mS$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$9y|$c&j'vp'y!b'l(;d(T!LY's&;d$V#tOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$f%Z$f$g+g$g#BY>P#BY#BZ$9h#BZ$IS>P$IS$I_$9h$I_$JT>P$JT$JU$9h$JU$KV>P$KV$KW$9h$KW&FU>P&FU&FV$9h&FV;'S>P;'S;=`BZ<%l?HT>P?HT?HU$9h?HUO>P(CS$=Uk$c&j'vp'y!b'm(;d(T!LY's&;d$V#tOY%ZYZ&cZr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$g%Z$g;'S>P;'S;=`BZ<%lO>P",
  tokenizers: [c0, h0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, l0, new Za("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOq~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!O~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(S~~", 141, 325), new Za("j~RQYZXz{^~^O'p~~aP!P!Qd~iO'q~~", 25, 307)],
  topRules: { Script: [0, 5], SingleExpression: [1, 266], SingleClassItem: [2, 267] },
  dialects: { jsx: 13213, ts: 13215 },
  dynamicPrecedences: { 76: 1, 78: 1, 162: 1, 190: 1 },
  specialized: [{ term: 311, get: (O) => f0[O] || -1 }, { term: 327, get: (O) => d0[O] || -1 }, { term: 67, get: (O) => Q0[O] || -1 }],
  tokenPrec: 13238
});
var p0 = [
  ce("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  ce("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  ce("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  ce("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  ce("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  ce(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  ce("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  ce(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  ce(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  ce('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  ce('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
];
var Mu = new e$();
var Mp = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function Qi(O) {
  return (e, t) => {
    let i = e.node.getChild("VariableDefinition");
    return i && t(i, O), true;
  };
}
var m0 = ["FunctionDeclaration"];
var g0 = {
  FunctionDeclaration: Qi("function"),
  ClassDeclaration: Qi("class"),
  ClassExpression: () => true,
  EnumDeclaration: Qi("constant"),
  TypeAliasDeclaration: Qi("type"),
  NamespaceDeclaration: Qi("namespace"),
  VariableDefinition(O, e) {
    O.matchContext(m0) || e(O, "variable");
  },
  TypeDefinition(O, e) {
    e(O, "type");
  },
  __proto__: null
};
function Lp(O, e) {
  let t = Mu.get(e);
  if (t)
    return t;
  let i = [], n = true;
  function r(s, o) {
    let a = O.sliceString(s.from, s.to);
    i.push({ label: a, type: o });
  }
  return e.cursor(K.IncludeAnonymous).iterate((s) => {
    if (n)
      n = false;
    else if (s.name) {
      let o = g0[s.name];
      if (o && o(s, r) || Mp.has(s.name))
        return false;
    } else if (s.to - s.from > 8192) {
      for (let o of Lp(O, s.node))
        i.push(o);
      return false;
    }
  }), Mu.set(e, i), i;
}
var Lu = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/;
var Bp = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName"
];
function S0(O) {
  let e = B(O.state).resolveInner(O.pos, -1);
  if (Bp.indexOf(e.name) > -1)
    return null;
  let t = e.name == "VariableName" || e.to - e.from < 20 && Lu.test(O.state.sliceDoc(e.from, e.to));
  if (!t && !O.explicit)
    return null;
  let i = [];
  for (let n = e; n; n = n.parent)
    Mp.has(n.name) && (i = i.concat(Lp(O.state.doc, n)));
  return {
    options: i,
    from: t ? e.from : O.pos,
    validFor: Lu
  };
}
var zt = Ze.define({
  name: "javascript",
  parser: $0.configure({
    props: [
      Ce.add({
        IfStatement: $e({ except: /^\s*({|else\b)/ }),
        TryStatement: $e({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: Wl,
        SwitchBody: (O) => {
          let e = O.textAfter, t = /^\s*\}/.test(e), i = /^\s*(case|default)\b/.test(e);
          return O.baseIndent + (t ? 0 : i ? 1 : 2) * O.unit;
        },
        Block: Ft({ closing: "}" }),
        ArrowFunction: (O) => O.baseIndent + O.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": $e({ except: /^{/ }),
        JSXElement(O) {
          let e = /^\s*<\//.test(O.textAfter);
          return O.lineIndent(O.node.from) + (e ? 0 : O.unit);
        },
        JSXEscape(O) {
          let e = /\s*\}/.test(O.textAfter);
          return O.lineIndent(O.node.from) + (e ? 0 : O.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(O) {
          return O.column(O.node.from) + O.unit;
        }
      }),
      Ge.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression": _t,
        BlockComment(O) {
          return { from: O.from + 2, to: O.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
});
var Np = zt.configure({ dialect: "ts" }, "typescript");
var Fp = zt.configure({ dialect: "jsx" });
var Hp = zt.configure({ dialect: "jsx ts" }, "typescript");
var P0 = "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map((O) => ({ label: O, type: "keyword" }));
function Wi(O = {}) {
  let e = O.jsx ? O.typescript ? Hp : Fp : O.typescript ? Np : zt;
  return new je(e, [
    zt.data.of({
      autocomplete: Gl(Bp, ps(p0.concat(P0)))
    }),
    zt.data.of({
      autocomplete: S0
    }),
    O.jsx ? x0 : []
  ]);
}
function y0(O) {
  for (; ; ) {
    if (O.name == "JSXOpenTag" || O.name == "JSXSelfClosingTag" || O.name == "JSXFragmentTag")
      return O;
    if (!O.parent)
      return null;
    O = O.parent;
  }
}
function Bu(O, e, t = O.length) {
  for (let i = e == null ? void 0 : e.firstChild; i; i = i.nextSibling)
    if (i.name == "JSXIdentifier" || i.name == "JSXBuiltin" || i.name == "JSXNamespacedName" || i.name == "JSXMemberExpression")
      return O.sliceString(i.from, Math.min(i.to, t));
  return "";
}
var X0 = typeof navigator == "object" && /Android\b/.test(navigator.userAgent);
var x0 = k.inputHandler.of((O, e, t, i) => {
  if ((X0 ? O.composing : O.compositionStarted) || O.state.readOnly || e != t || i != ">" && i != "/" || !zt.isActiveAt(O.state, e, -1))
    return false;
  let { state: n } = O, r = n.changeByRange((s) => {
    var o, a;
    let { head: l } = s, h2 = B(n).resolveInner(l, -1), u;
    if (h2.name == "JSXStartTag" && (h2 = h2.parent), i == ">" && h2.name == "JSXFragmentTag")
      return { range: S.cursor(l + 1), changes: { from: l, insert: "></>" } };
    if (i == "/" && h2.name == "JSXFragmentTag") {
      let f = h2.parent, d = f == null ? void 0 : f.parent;
      if (f.from == l - 1 && ((o = d.lastChild) === null || o === void 0 ? void 0 : o.name) != "JSXEndTag" && (u = Bu(n.doc, d == null ? void 0 : d.firstChild, l))) {
        let Q = `/${u}>`;
        return { range: S.cursor(l + Q.length), changes: { from: l, insert: Q } };
      }
    } else if (i == ">") {
      let f = y0(h2);
      if (f && ((a = f.lastChild) === null || a === void 0 ? void 0 : a.name) != "JSXEndTag" && n.sliceDoc(l, l + 2) != "</" && (u = Bu(n.doc, f, l)))
        return { range: S.cursor(l + 1), changes: { from: l, insert: `></${u}>` } };
    }
    return { range: s };
  });
  return r.changes.empty ? false : (O.dispatch(r, { userEvent: "input.type", scrollIntoView: true }), true);
});
var $i = ["_blank", "_self", "_top", "_parent"];
var co = ["ascii", "utf-8", "utf-16", "latin1", "latin1"];
var ho = ["get", "post", "put", "delete"];
var uo = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"];
var Ee = ["true", "false"];
var U = {};
var b0 = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: $i,
      hreflang: null
    }
  },
  abbr: U,
  address: U,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: U,
  aside: U,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: U,
  base: { attrs: { href: null, target: $i } },
  bdi: U,
  bdo: U,
  blockquote: { attrs: { cite: null } },
  body: U,
  br: U,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: uo,
      formmethod: ho,
      formnovalidate: ["novalidate"],
      formtarget: $i,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: U,
  center: U,
  cite: U,
  code: U,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: U,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: U,
  div: U,
  dl: U,
  dt: U,
  em: U,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: U,
  figure: U,
  footer: U,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": co,
      autocomplete: ["on", "off"],
      enctype: uo,
      method: ho,
      novalidate: ["novalidate"],
      target: $i
    }
  },
  h1: U,
  h2: U,
  h3: U,
  h4: U,
  h5: U,
  h6: U,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: U,
  hgroup: U,
  hr: U,
  html: {
    attrs: { manifest: null }
  },
  i: U,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: uo,
      formmethod: ho,
      formnovalidate: ["novalidate"],
      formtarget: $i,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: U,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: U,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: U,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: co,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: U,
  noscript: U,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: U,
  param: { attrs: { name: null, value: null } },
  pre: U,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: U,
  rt: U,
  ruby: U,
  samp: U,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: co
    }
  },
  section: U,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: U,
  source: { attrs: { src: null, type: null, media: null } },
  span: U,
  strong: U,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: U,
  summary: U,
  sup: U,
  table: U,
  tbody: U,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: U,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: U,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: U,
  time: { attrs: { datetime: null } },
  title: U,
  tr: U,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: U,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: U
};
var Kp = {
  accesskey: null,
  class: null,
  contenteditable: Ee,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: Ee,
  autocorrect: Ee,
  autocapitalize: Ee,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": Ee,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": Ee,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": Ee,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": Ee,
  "aria-hidden": Ee,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": Ee,
  "aria-multiselectable": Ee,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": Ee,
  "aria-relevant": null,
  "aria-required": Ee,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
};
var Jp = "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((O) => "on" + O);
for (let O of Jp)
  Kp[O] = null;
var Kr = class {
  constructor(e, t) {
    this.tags = Object.assign(Object.assign({}, b0), e), this.globalAttrs = Object.assign(Object.assign({}, Kp), t), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
};
Kr.default = new Kr();
function JO(O, e, t = O.length) {
  if (!e)
    return "";
  let i = e.firstChild, n = i && i.getChild("TagName");
  return n ? O.sliceString(n.from, Math.min(n.to, t)) : "";
}
function Ps(O, e = false) {
  for (let t = O.parent; t; t = t.parent)
    if (t.name == "Element")
      if (e)
        e = false;
      else
        return t;
  return null;
}
function em(O, e, t) {
  let i = t.tags[JO(O, Ps(e, true))];
  return (i == null ? void 0 : i.children) || t.allTags;
}
function Hl(O, e) {
  let t = [];
  for (let i = e; i = Ps(i); ) {
    let n = JO(O, i);
    if (n && i.lastChild.name == "CloseTag")
      break;
    n && t.indexOf(n) < 0 && (e.name == "EndTag" || e.from >= i.firstChild.to) && t.push(n);
  }
  return t;
}
var tm = /^[:\-\.\w\u00b7-\uffff]*$/;
function Nu(O, e, t, i, n) {
  let r = /\s*>/.test(O.sliceDoc(n, n + 5)) ? "" : ">";
  return {
    from: i,
    to: n,
    options: em(O.doc, t, e).map((s) => ({ label: s, type: "type" })).concat(Hl(O.doc, t).map((s, o) => ({
      label: "/" + s,
      apply: "/" + s + r,
      type: "type",
      boost: 99 - o
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function Fu(O, e, t, i) {
  let n = /\s*>/.test(O.sliceDoc(i, i + 5)) ? "" : ">";
  return {
    from: t,
    to: i,
    options: Hl(O.doc, e).map((r, s) => ({ label: r, apply: r + n, type: "type", boost: 99 - s })),
    validFor: tm
  };
}
function w0(O, e, t, i) {
  let n = [], r = 0;
  for (let s of em(O.doc, t, e))
    n.push({ label: "<" + s, type: "type" });
  for (let s of Hl(O.doc, t))
    n.push({ label: "</" + s + ">", type: "type", boost: 99 - r++ });
  return { from: i, to: i, options: n, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function T0(O, e, t, i, n) {
  let r = Ps(t), s = r ? e.tags[JO(O.doc, r)] : null, o = s && s.attrs ? Object.keys(s.attrs) : [], a = s && s.globalAttrs === false ? o : o.length ? o.concat(e.globalAttrNames) : e.globalAttrNames;
  return {
    from: i,
    to: n,
    options: a.map((l) => ({ label: l, type: "property" })),
    validFor: tm
  };
}
function W0(O, e, t, i, n) {
  var r;
  let s = (r = t.parent) === null || r === void 0 ? void 0 : r.getChild("AttributeName"), o = [], a;
  if (s) {
    let l = O.sliceDoc(s.from, s.to), h2 = e.globalAttrs[l];
    if (!h2) {
      let u = Ps(t), f = u ? e.tags[JO(O.doc, u)] : null;
      h2 = (f == null ? void 0 : f.attrs) && f.attrs[l];
    }
    if (h2) {
      let u = O.sliceDoc(i, n).toLowerCase(), f = '"', d = '"';
      /^['"]/.test(u) ? (a = u[0] == '"' ? /^[^"]*$/ : /^[^']*$/, f = "", d = O.sliceDoc(n, n + 1) == u[0] ? "" : u[0], u = u.slice(1), i++) : a = /^[^\s<>='"]*$/;
      for (let Q of h2)
        o.push({ label: Q, apply: f + Q + d, type: "constant" });
    }
  }
  return { from: i, to: n, options: o, validFor: a };
}
function v0(O, e) {
  let { state: t, pos: i } = e, n = B(t).resolveInner(i), r = n.resolve(i, -1);
  for (let s = i, o; n == r && (o = r.childBefore(s)); ) {
    let a = o.lastChild;
    if (!a || !a.type.isError || a.from < a.to)
      break;
    n = r = o, s = a.from;
  }
  return r.name == "TagName" ? r.parent && /CloseTag$/.test(r.parent.name) ? Fu(t, r, r.from, i) : Nu(t, O, r, r.from, i) : r.name == "StartTag" ? Nu(t, O, r, i, i) : r.name == "StartCloseTag" || r.name == "IncompleteCloseTag" ? Fu(t, r, i, i) : e.explicit && (r.name == "OpenTag" || r.name == "SelfClosingTag") || r.name == "AttributeName" ? T0(t, O, r, r.name == "AttributeName" ? r.from : i, i) : r.name == "Is" || r.name == "AttributeValue" || r.name == "UnquotedAttributeValue" ? W0(t, O, r, r.name == "Is" ? i : r.from, i) : e.explicit && (n.name == "Element" || n.name == "Text" || n.name == "Document") ? w0(t, O, r, i) : null;
}
function k0(O) {
  let { extraTags: e, extraGlobalAttributes: t } = O, i = t || e ? new Kr(e, t) : Kr.default;
  return (n) => v0(i, n);
}
var Om = [
  {
    tag: "script",
    attrs: (O) => O.type == "text/typescript" || O.lang == "ts",
    parser: Np.parser
  },
  {
    tag: "script",
    attrs: (O) => O.type == "text/babel" || O.type == "text/jsx",
    parser: Fp.parser
  },
  {
    tag: "script",
    attrs: (O) => O.type == "text/typescript-jsx",
    parser: Hp.parser
  },
  {
    tag: "script",
    attrs(O) {
      return !O.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(O.type);
    },
    parser: zt.parser
  },
  {
    tag: "style",
    attrs(O) {
      return (!O.lang || O.lang == "css") && (!O.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(O.type));
    },
    parser: Hr.parser
  }
];
var im = [
  {
    name: "style",
    parser: Hr.parser.configure({ top: "Styles" })
  }
].concat(Jp.map((O) => ({ name: O, parser: zt.parser })));
var fr = Ze.define({
  name: "html",
  parser: YT.configure({
    props: [
      Ce.add({
        Element(O) {
          let e = /^(\s*)(<\/)?/.exec(O.textAfter);
          return O.node.to <= O.pos + e[0].length ? O.continue() : O.lineIndent(O.node.from) + (e[2] ? 0 : O.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(O) {
          return O.column(O.node.from) + O.unit;
        },
        Document(O) {
          if (O.pos + /\s*/.exec(O.textAfter)[0].length < O.node.to)
            return O.continue();
          let e = null, t;
          for (let i = O.node; ; ) {
            let n = i.lastChild;
            if (!n || n.name != "Element" || n.to != i.to)
              break;
            e = i = n;
          }
          return e && !((t = e.lastChild) && (t.name == "CloseTag" || t.name == "SelfClosingTag")) ? O.lineIndent(e.from) + O.unit : null;
        }
      }),
      Ge.add({
        Element(O) {
          let e = O.firstChild, t = O.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: t.name == "CloseTag" ? t.from : O.to };
        }
      }),
      kl.add({
        "OpenTag CloseTag": (O) => O.getChild("TagName")
      })
    ],
    wrap: Gp(Om, im)
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
});
function Kl(O = {}) {
  let e = "", t;
  O.matchClosingTags === false && (e = "noMatch"), O.selfClosingTags === true && (e = (e ? e + " " : "") + "selfClosing"), (O.nestedLanguages && O.nestedLanguages.length || O.nestedAttributes && O.nestedAttributes.length) && (t = Gp((O.nestedLanguages || []).concat(Om), (O.nestedAttributes || []).concat(im)));
  let i = t || e ? fr.configure({ dialect: e, wrap: t }) : fr;
  return new je(i, [
    fr.data.of({ autocomplete: k0(O) }),
    O.autoCloseTags !== false ? Y0 : [],
    Wi().support,
    Ap().support
  ]);
}
var Y0 = k.inputHandler.of((O, e, t, i) => {
  if (O.composing || O.state.readOnly || e != t || i != ">" && i != "/" || !fr.isActiveAt(O.state, e, -1))
    return false;
  let { state: n } = O, r = n.changeByRange((s) => {
    var o, a, l;
    let { head: h2 } = s, u = B(n).resolveInner(h2, -1), f;
    if ((u.name == "TagName" || u.name == "StartTag") && (u = u.parent), i == ">" && u.name == "OpenTag") {
      if (((a = (o = u.parent) === null || o === void 0 ? void 0 : o.lastChild) === null || a === void 0 ? void 0 : a.name) != "CloseTag" && (f = JO(n.doc, u.parent, h2))) {
        let d = O.state.doc.sliceString(h2, h2 + 1) === ">", Q = `${d ? "" : ">"}</${f}>`;
        return { range: S.cursor(h2 + 1), changes: { from: h2 + (d ? 1 : 0), insert: Q } };
      }
    } else if (i == "/" && u.name == "OpenTag") {
      let d = u.parent, Q = d == null ? void 0 : d.parent;
      if (d.from == h2 - 1 && ((l = Q.lastChild) === null || l === void 0 ? void 0 : l.name) != "CloseTag" && (f = JO(n.doc, Q, h2))) {
        let $ = O.state.doc.sliceString(h2, h2 + 1) === ">", p = `/${f}${$ ? "" : ">"}`, m = h2 + p.length + ($ ? 1 : 0);
        return { range: S.cursor(m), changes: { from: h2, insert: p } };
      }
    }
    return { range: s };
  });
  return r.changes.empty ? false : (O.dispatch(r, { userEvent: "input.type", scrollIntoView: true }), true);
});
var Z0 = 1;
var nm = 189;
var rm = 190;
var q0 = 191;
var z0 = 192;
var U0 = 193;
var V0 = 194;
var R0 = 22;
var _0 = 23;
var j0 = 47;
var C0 = 48;
var G0 = 53;
var I0 = 54;
var E0 = 55;
var A0 = 57;
var D0 = 58;
var M0 = 59;
var L0 = 60;
var B0 = 61;
var N0 = 63;
var F0 = 230;
var H0 = 71;
var K0 = 255;
var J0 = 121;
var eW = 142;
var tW = 143;
var OW = 146;
var tn = 10;
var On = 13;
var Jl = 32;
var ys = 9;
var ec = 35;
var iW = 40;
var nW = 46;
var rW = /* @__PURE__ */ new Set([
  _0,
  j0,
  C0,
  K0,
  N0,
  J0,
  I0,
  E0,
  F0,
  L0,
  B0,
  D0,
  M0,
  H0,
  eW,
  tW,
  OW
]);
var sW = new te((O, e) => {
  if (O.next < 0)
    O.acceptToken(V0);
  else if (!(O.next != tn && O.next != On))
    if (e.context.depth < 0)
      O.acceptToken(z0, 1);
    else {
      O.advance();
      let t = 0;
      for (; O.next == Jl || O.next == ys; )
        O.advance(), t++;
      let i = O.next == tn || O.next == On || O.next == ec;
      O.acceptToken(i ? U0 : q0, -t);
    }
}, { contextual: true, fallback: true });
var oW = new te((O, e) => {
  let t = e.context.depth;
  if (t < 0)
    return;
  let i = O.peek(-1);
  if ((i == tn || i == On) && e.context.depth >= 0) {
    let n = 0, r = 0;
    for (; ; ) {
      if (O.next == Jl)
        n++;
      else if (O.next == ys)
        n += 8 - n % 8;
      else
        break;
      O.advance(), r++;
    }
    n != t && O.next != tn && O.next != On && O.next != ec && (n < t ? O.acceptToken(rm, -r) : O.acceptToken(nm));
  }
});
function Ua(O, e) {
  this.parent = O, this.depth = e, this.hash = (O ? O.hash + O.hash << 8 : 0) + e + (e << 4);
}
var aW = new Ua(null, 0);
function lW(O) {
  let e = 0;
  for (let t = 0; t < O.length; t++)
    e += O.charCodeAt(t) == ys ? 8 - e % 8 : 1;
  return e;
}
var cW = new Ss({
  start: aW,
  reduce(O, e) {
    return O.depth < 0 && rW.has(e) ? O.parent : O;
  },
  shift(O, e, t, i) {
    return e == nm ? new Ua(O, lW(i.read(i.pos, t.pos))) : e == rm ? O.parent : e == R0 || e == G0 || e == A0 ? new Ua(O, -1) : O;
  },
  hash(O) {
    return O.hash;
  }
});
var hW = new te((O) => {
  for (let e = 0; e < 5; e++) {
    if (O.next != "print".charCodeAt(e))
      return;
    O.advance();
  }
  if (!/\w/.test(String.fromCharCode(O.next)))
    for (let e = 0; ; e++) {
      let t = O.peek(e);
      if (!(t == Jl || t == ys)) {
        t != iW && t != nW && t != tn && t != On && t != ec && O.acceptToken(Z0);
        return;
      }
    }
});
var uW = ze({
  'async "*" "**" FormatConversion FormatSpec': c.modifier,
  "for while if elif else try except finally return raise break continue with pass assert await yield match case": c.controlKeyword,
  "in not and or is del": c.operatorKeyword,
  "from def class global nonlocal lambda": c.definitionKeyword,
  import: c.moduleKeyword,
  "with as print": c.keyword,
  Boolean: c.bool,
  None: c.null,
  VariableName: c.variableName,
  "CallExpression/VariableName": c.function(c.variableName),
  "FunctionDefinition/VariableName": c.function(c.definition(c.variableName)),
  "ClassDefinition/VariableName": c.definition(c.className),
  PropertyName: c.propertyName,
  "CallExpression/MemberExpression/PropertyName": c.function(c.propertyName),
  Comment: c.lineComment,
  Number: c.number,
  String: c.string,
  FormatString: c.special(c.string),
  UpdateOp: c.updateOperator,
  "ArithOp!": c.arithmeticOperator,
  BitOp: c.bitwiseOperator,
  CompareOp: c.compareOperator,
  AssignOp: c.definitionOperator,
  Ellipsis: c.punctuation,
  At: c.meta,
  "( )": c.paren,
  "[ ]": c.squareBracket,
  "{ }": c.brace,
  ".": c.derefOperator,
  ", ;": c.separator
});
var fW = { __proto__: null, await: 40, or: 50, and: 52, in: 56, not: 58, is: 60, if: 66, else: 68, lambda: 72, yield: 90, from: 92, async: 98, for: 100, None: 152, True: 154, False: 154, del: 168, pass: 172, break: 176, continue: 180, return: 184, raise: 192, import: 196, as: 198, global: 202, nonlocal: 204, assert: 208, elif: 218, while: 222, try: 228, except: 230, finally: 232, with: 236, def: 240, class: 250, match: 261, case: 267 };
var dW = qe.deserialize({
  version: 14,
  states: "!L`O`Q$IXOOO%fQ$I[O'#G|OOQ$IS'#Cm'#CmOOQ$IS'#Cn'#CnO'UQ$IWO'#ClO(wQ$I[O'#G{OOQ$IS'#G|'#G|OOQ$IS'#DS'#DSOOQ$IS'#G{'#G{O)eQ$IWO'#CsO)uQ$IWO'#DdO*VQ$IWO'#DhOOQ$IS'#Ds'#DsO*jO`O'#DsO*rOpO'#DsO*zO!bO'#DtO+VO#tO'#DtO+bO&jO'#DtO+mO,UO'#DtO-oQ$I[O'#GmOOQ$IS'#Gm'#GmO'UQ$IWO'#GlO/RQ$I[O'#GlOOQ$IS'#E]'#E]O/jQ$IWO'#E^OOQ$IS'#Gk'#GkO/tQ$IWO'#GjOOQ$IV'#Gj'#GjO0PQ$IWO'#FPOOQ$IS'#GX'#GXO0UQ$IWO'#FOOOQ$IV'#Hx'#HxOOQ$IV'#Gi'#GiOOQ$IT'#Fh'#FhQ`Q$IXOOO'UQ$IWO'#CoO0dQ$IWO'#C{O0kQ$IWO'#DPO0yQ$IWO'#HQO1ZQ$I[O'#EQO'UQ$IWO'#EROOQ$IS'#ET'#ETOOQ$IS'#EV'#EVOOQ$IS'#EX'#EXO1oQ$IWO'#EZO2VQ$IWO'#E_O0PQ$IWO'#EaO2jQ$I[O'#EaO0PQ$IWO'#EdO/jQ$IWO'#EgO/jQ$IWO'#EkO/jQ$IWO'#EnO2uQ$IWO'#EpO2|Q$IWO'#EuO3XQ$IWO'#EqO/jQ$IWO'#EuO0PQ$IWO'#EwO0PQ$IWO'#E|O3^Q$IWO'#FROOQ$IS'#Cc'#CcOOQ$IS'#Cd'#CdOOQ$IS'#Ce'#CeOOQ$IS'#Cf'#CfOOQ$IS'#Cg'#CgOOQ$IS'#Ch'#ChOOQ$IS'#Cj'#CjO'UQ$IWO,58|O'UQ$IWO,58|O'UQ$IWO,58|O'UQ$IWO,58|O'UQ$IWO,58|O'UQ$IWO,58|O3eQ$IWO'#DmOOQ$IS,5:W,5:WO3xQ$IWO'#H[OOQ$IS,5:Z,5:ZO4VQ%1`O,5:ZO4[Q$I[O,59WO0dQ$IWO,59`O0dQ$IWO,59`O0dQ$IWO,59`O6zQ$IWO,59`O7PQ$IWO,59`O7WQ$IWO,59hO7_Q$IWO'#G{O8eQ$IWO'#GzOOQ$IS'#Gz'#GzOOQ$IS'#DY'#DYO8|Q$IWO,59_O'UQ$IWO,59_O9[Q$IWO,59_O9aQ$IWO,5:PO'UQ$IWO,5:POOQ$IS,5:O,5:OO9oQ$IWO,5:OO9tQ$IWO,5:VO'UQ$IWO,5:VO'UQ$IWO,5:TOOQ$IS,5:S,5:SO:VQ$IWO,5:SO:[Q$IWO,5:UOOOO'#Fp'#FpO:aO`O,5:_OOQ$IS,5:_,5:_OOOO'#Fq'#FqO:iOpO,5:_O:qQ$IWO'#DuOOOO'#Fr'#FrO;RO!bO,5:`OOQ$IS,5:`,5:`OOOO'#Fu'#FuO;^O#tO,5:`OOOO'#Fv'#FvO;iO&jO,5:`OOOO'#Fw'#FwO;tO,UO,5:`OOQ$IS'#Fx'#FxO<PQ$I[O,5:dO>qQ$I[O,5=WO?[Q%GlO,5=WO?{Q$I[O,5=WOOQ$IS,5:x,5:xO@dQ$IXO'#GQOAsQ$IWO,5;TOOQ$IV,5=U,5=UOBOQ$I[O'#HtOBgQ$IWO,5;kOOQ$IS-E:V-E:VOOQ$IV,5;j,5;jO3SQ$IWO'#EwOOQ$IT-E9f-E9fOBoQ$I[O,59ZODvQ$I[O,59gOEaQ$IWO'#G}OElQ$IWO'#G}O0PQ$IWO'#G}OEwQ$IWO'#DROFPQ$IWO,59kOFUQ$IWO'#HRO'UQ$IWO'#HRO/jQ$IWO,5=lOOQ$IS,5=l,5=lO/jQ$IWO'#D|OOQ$IS'#D}'#D}OFsQ$IWO'#FzOGTQ$IWO,58zOGTQ$IWO,58zO)hQ$IWO,5:jOGcQ$I[O'#HTOOQ$IS,5:m,5:mOOQ$IS,5:u,5:uOGvQ$IWO,5:yOHXQ$IWO,5:{OOQ$IS'#F}'#F}OHgQ$I[O,5:{OHuQ$IWO,5:{OHzQ$IWO'#HwOOQ$IS,5;O,5;OOIYQ$IWO'#HsOOQ$IS,5;R,5;RO3XQ$IWO,5;VO3XQ$IWO,5;YOIkQ$I[O'#HyO'UQ$IWO'#HyOIuQ$IWO,5;[O2uQ$IWO,5;[O/jQ$IWO,5;aO0PQ$IWO,5;cOIzQ$IXO'#ElOKTQ$IZO,5;]ONiQ$IWO'#HzO3XQ$IWO,5;aONtQ$IWO,5;cONyQ$IWO,5;hO! RQ$I[O,5;mO'UQ$IWO,5;mO!#uQ$I[O1G.hO!#|Q$I[O1G.hO!&mQ$I[O1G.hO!&wQ$I[O1G.hO!)bQ$I[O1G.hO!)uQ$I[O1G.hO!*YQ$IWO'#HZO!*hQ$I[O'#GmO/jQ$IWO'#HZO!*rQ$IWO'#HYOOQ$IS,5:X,5:XO!*zQ$IWO,5:XO!+PQ$IWO'#H]O!+[Q$IWO'#H]O!+oQ$IWO,5=vOOQ$IS'#Dq'#DqOOQ$IS1G/u1G/uOOQ$IS1G.z1G.zO!,oQ$I[O1G.zO!,vQ$I[O1G.zO0dQ$IWO1G.zO!-cQ$IWO1G/SOOQ$IS'#DX'#DXO/jQ$IWO,59rOOQ$IS1G.y1G.yO!-jQ$IWO1G/cO!-zQ$IWO1G/cO!.SQ$IWO1G/dO'UQ$IWO'#HSO!.XQ$IWO'#HSO!.^Q$I[O1G.yO!.nQ$IWO,59gO!/tQ$IWO,5=rO!0UQ$IWO,5=rO!0^Q$IWO1G/kO!0cQ$I[O1G/kOOQ$IS1G/j1G/jO!0sQ$IWO,5=mO!1jQ$IWO,5=mO/jQ$IWO1G/oO!2XQ$IWO1G/qO!2^Q$I[O1G/qO!2nQ$I[O1G/oOOQ$IS1G/n1G/nOOQ$IS1G/p1G/pOOOO-E9n-E9nOOQ$IS1G/y1G/yOOOO-E9o-E9oO!3OQ$IWO'#HhO/jQ$IWO'#HhO!3^Q$IWO,5:aOOOO-E9p-E9pOOQ$IS1G/z1G/zOOOO-E9s-E9sOOOO-E9t-E9tOOOO-E9u-E9uOOQ$IS-E9v-E9vO!3iQ%GlO1G2rO!4YQ$I[O1G2rO'UQ$IWO,5<eOOQ$IS,5<e,5<eOOQ$IS-E9w-E9wOOQ$IS,5<l,5<lOOQ$IS-E:O-E:OOOQ$IV1G0o1G0oO0PQ$IWO'#F|O!4qQ$I[O,5>`OOQ$IS1G1V1G1VO!5YQ$IWO1G1VOOQ$IS'#DT'#DTO/jQ$IWO,5=iOOQ$IS,5=i,5=iO!5_Q$IWO'#FiO!5jQ$IWO,59mO!5rQ$IWO1G/VO!5|Q$I[O,5=mOOQ$IS1G3W1G3WOOQ$IS,5:h,5:hO!6mQ$IWO'#GlOOQ$IS,5<f,5<fOOQ$IS-E9x-E9xO!7OQ$IWO1G.fOOQ$IS1G0U1G0UO!7^Q$IWO,5=oO!7nQ$IWO,5=oO/jQ$IWO1G0eO/jQ$IWO1G0eO0PQ$IWO1G0gOOQ$IS-E9{-E9{O!8PQ$IWO1G0gO!8[Q$IWO1G0gO!8aQ$IWO,5>cO!8oQ$IWO,5>cO!8}Q$IWO,5>_O!9eQ$IWO,5>_O!9vQ$IZO1G0qO!=XQ$IZO1G0tO!@gQ$IWO,5>eO!@qQ$IWO,5>eO!@yQ$I[O,5>eO/jQ$IWO1G0vO!ATQ$IWO1G0vO3XQ$IWO1G0{ONtQ$IWO1G0}OOQ$IV,5;W,5;WO!AYQ$IYO,5;WO!A_Q$IZO1G0wO!DsQ$IWO'#GUO3XQ$IWO1G0wO3XQ$IWO1G0wO!EQQ$IWO,5>fO!E_Q$IWO,5>fO0PQ$IWO,5>fOOQ$IV1G0{1G0{O!EgQ$IWO'#EyO!ExQ%1`O1G0}OOQ$IV1G1S1G1SO3XQ$IWO1G1SO!FQQ$IWO'#FTOOQ$IV1G1X1G1XO! RQ$I[O1G1XOOQ$IS,5=u,5=uOOQ$IS'#Dn'#DnO/jQ$IWO,5=uO!FVQ$IWO,5=tO!FjQ$IWO,5=tOOQ$IS1G/s1G/sO!FrQ$IWO,5=wO!GSQ$IWO,5=wO!G[Q$IWO,5=wO!GoQ$IWO,5=wO!HPQ$IWO,5=wOOQ$IS1G3b1G3bOOQ$IS7+$f7+$fO!5rQ$IWO7+$nO!IrQ$IWO1G.zO!IyQ$IWO1G.zOOQ$IS1G/^1G/^OOQ$IS,5<V,5<VO'UQ$IWO,5<VOOQ$IS7+$}7+$}O!JQQ$IWO7+$}OOQ$IS-E9i-E9iOOQ$IS7+%O7+%OO!JbQ$IWO,5=nO'UQ$IWO,5=nOOQ$IS7+$e7+$eO!JgQ$IWO7+$}O!JoQ$IWO7+%OO!JtQ$IWO1G3^OOQ$IS7+%V7+%VO!KUQ$IWO1G3^O!K^Q$IWO7+%VOOQ$IS,5<U,5<UO'UQ$IWO,5<UO!KcQ$IWO1G3XOOQ$IS-E9h-E9hO!LYQ$IWO7+%ZOOQ$IS7+%]7+%]O!LhQ$IWO1G3XO!MVQ$IWO7+%]O!M[Q$IWO1G3_O!MlQ$IWO1G3_O!MtQ$IWO7+%ZO!MyQ$IWO,5>SO!NaQ$IWO,5>SO!NaQ$IWO,5>SO!NoO!LQO'#DwO!NzOSO'#HiOOOO1G/{1G/{O# PQ$IWO1G/{O# XQ%GlO7+(^O# xQ$I[O1G2PP#!cQ$IWO'#FyOOQ$IS,5<h,5<hOOQ$IS-E9z-E9zOOQ$IS7+&q7+&qOOQ$IS1G3T1G3TOOQ$IS,5<T,5<TOOQ$IS-E9g-E9gOOQ$IS7+$q7+$qO#!pQ$IWO,5=WO##ZQ$IWO,5=WO##lQ$I[O,5<WO#$PQ$IWO1G3ZOOQ$IS-E9j-E9jOOQ$IS7+&P7+&PO#$aQ$IWO7+&POOQ$IS7+&R7+&RO#$oQ$IWO'#HvO0PQ$IWO'#HuO#%TQ$IWO7+&ROOQ$IS,5<k,5<kO#%`Q$IWO1G3}OOQ$IS-E9}-E9}OOQ$IS,5<g,5<gO#%nQ$IWO1G3yOOQ$IS-E9y-E9yO#&UQ$IZO7+&]O!DsQ$IWO'#GSO3XQ$IWO7+&]O3XQ$IWO7+&`O#)gQ$I[O,5<oO'UQ$IWO,5<oO#)qQ$IWO1G4POOQ$IS-E:R-E:RO#){Q$IWO1G4PO3XQ$IWO7+&bO/jQ$IWO7+&bOOQ$IV7+&g7+&gO!ExQ%1`O7+&iO#*TQ$IXO1G0rOOQ$IV-E:S-E:SO3XQ$IWO7+&cO3XQ$IWO7+&cOOQ$IV,5<p,5<pO#+yQ$IWO,5<pOOQ$IV7+&c7+&cO#,UQ$IZO7+&cO#/dQ$IWO,5<qO#/oQ$IWO1G4QOOQ$IS-E:T-E:TO#/|Q$IWO1G4QO#0UQ$IWO'#H|O#0dQ$IWO'#H|O0PQ$IWO'#H|OOQ$IS'#H|'#H|O#0oQ$IWO'#H{OOQ$IS,5;e,5;eO#0wQ$IWO,5;eO/jQ$IWO'#E{OOQ$IV7+&i7+&iO3XQ$IWO7+&iOOQ$IV7+&n7+&nO#0|Q$IYO,5;oOOQ$IV7+&s7+&sOOQ$IS1G3a1G3aOOQ$IS,5<Y,5<YO#1RQ$IWO1G3`OOQ$IS-E9l-E9lO#1fQ$IWO,5<ZO#1qQ$IWO,5<ZO#2UQ$IWO1G3cOOQ$IS-E9m-E9mO#2fQ$IWO1G3cO#2nQ$IWO1G3cO#3OQ$IWO1G3cO#2fQ$IWO1G3cOOQ$IS<<HY<<HYO#3ZQ$I[O1G1qOOQ$IS<<Hi<<HiP#3hQ$IWO'#FkO7WQ$IWO1G3YO#3uQ$IWO1G3YO#3zQ$IWO<<HiOOQ$IS<<Hj<<HjO#4[Q$IWO7+(xOOQ$IS<<Hq<<HqO#4lQ$I[O1G1pP#5]Q$IWO'#FjO#5jQ$IWO7+(yO#5zQ$IWO7+(yO#6SQ$IWO<<HuO#6XQ$IWO7+(sOOQ$IS<<Hw<<HwO#7OQ$IWO,5<XO'UQ$IWO,5<XOOQ$IS-E9k-E9kOOQ$IS<<Hu<<HuOOQ$IS,5<_,5<_O/jQ$IWO,5<_O#7TQ$IWO1G3nOOQ$IS-E9q-E9qO#7kQ$IWO1G3nOOOO'#Ft'#FtO#7yO!LQO,5:cOOOO,5>T,5>TOOOO7+%g7+%gO#8UQ$IWO1G2rO#8oQ$IWO1G2rP'UQ$IWO'#FlO/jQ$IWO<<IkO#9QQ$IWO,5>bO#9cQ$IWO,5>bO0PQ$IWO,5>bO#9tQ$IWO,5>aOOQ$IS<<Im<<ImP0PQ$IWO'#GPP/jQ$IWO'#F{OOQ$IV-E:Q-E:QO3XQ$IWO<<IwOOQ$IV,5<n,5<nO3XQ$IWO,5<nOOQ$IV<<Iw<<IwOOQ$IV<<Iz<<IzO#9yQ$I[O1G2ZP#:TQ$IWO'#GTO#:[Q$IWO7+)kO#:fQ$IZO<<I|O3XQ$IWO<<I|OOQ$IV<<JT<<JTO3XQ$IWO<<JTOOQ$IV'#GR'#GRO#=tQ$IZO7+&^OOQ$IV<<I}<<I}O#?pQ$IZO<<I}OOQ$IV1G2[1G2[O0PQ$IWO1G2[O3XQ$IWO<<I}O0PQ$IWO1G2]P/jQ$IWO'#GVO#COQ$IWO7+)lO#C]Q$IWO7+)lOOQ$IS'#Ez'#EzO/jQ$IWO,5>hO#CeQ$IWO,5>hOOQ$IS,5>h,5>hO#CpQ$IWO,5>gO#DRQ$IWO,5>gOOQ$IS1G1P1G1POOQ$IS,5;g,5;gO#DZQ$IWO1G1ZP#D`Q$IWO'#FnO#DpQ$IWO1G1uO#ETQ$IWO1G1uO#EeQ$IWO1G1uP#EpQ$IWO'#FoO#E}Q$IWO7+(}O#F_Q$IWO7+(}O#F_Q$IWO7+(}O#FgQ$IWO7+(}O#FwQ$IWO7+(tO7WQ$IWO7+(tOOQ$ISAN>TAN>TO#GbQ$IWO<<LeOOQ$ISAN>aAN>aO/jQ$IWO1G1sO#GrQ$I[O1G1sP#G|Q$IWO'#FmOOQ$IS1G1y1G1yP#HZQ$IWO'#FsO#HhQ$IWO7+)YOOOO-E9r-E9rO#IOQ$IWO7+(^OOQ$ISAN?VAN?VO#IiQ$IWO,5<jO#I}Q$IWO1G3|OOQ$IS-E9|-E9|O#J`Q$IWO1G3|OOQ$IS1G3{1G3{OOQ$IVAN?cAN?cOOQ$IV1G2Y1G2YO3XQ$IWOAN?hO#JqQ$IZOAN?hOOQ$IVAN?oAN?oOOQ$IV-E:P-E:POOQ$IV<<Ix<<IxO3XQ$IWOAN?iO3XQ$IWO7+'vOOQ$IVAN?iAN?iOOQ$IS7+'w7+'wO#NPQ$IWO<<MWOOQ$IS1G4S1G4SO/jQ$IWO1G4SOOQ$IS,5<r,5<rO#N^Q$IWO1G4ROOQ$IS-E:U-E:UOOQ$IU'#GY'#GYO#NoQ$IYO7+&uO#NzQ$IWO'#FUO$ rQ$IWO7+'aO$!SQ$IWO7+'aOOQ$IS7+'a7+'aO$!_Q$IWO<<LiO$!oQ$IWO<<LiO$!oQ$IWO<<LiO$!wQ$IWO'#HUOOQ$IS<<L`<<L`O$#RQ$IWO<<L`OOQ$IS7+'_7+'_O0PQ$IWO1G2UP0PQ$IWO'#GOO$#lQ$IWO7+)hO$#}Q$IWO7+)hOOQ$IVG25SG25SO3XQ$IWOG25SOOQ$IVG25TG25TOOQ$IV<<Kb<<KbOOQ$IS7+)n7+)nP$$`Q$IWO'#GWOOQ$IU-E:W-E:WOOQ$IV<<Ja<<JaO$%SQ$I[O'#FWOOQ$IS'#FY'#FYO$%dQ$IWO'#FXO$&UQ$IWO'#FXOOQ$IS'#FX'#FXO$&ZQ$IWO'#IOO#NzQ$IWO'#F`O#NzQ$IWO'#F`O$&rQ$IWO'#FaO#NzQ$IWO'#FbO$&yQ$IWO'#IPOOQ$IS'#IP'#IPO$'hQ$IWO,5;pOOQ$IS<<J{<<J{O$'pQ$IWO<<J{O$(QQ$IWOANBTO$(bQ$IWOANBTO$(jQ$IWO'#HVOOQ$IS'#HV'#HVO0kQ$IWO'#DaO$)TQ$IWO,5=pOOQ$ISANAzANAzOOQ$IS7+'p7+'pO$)lQ$IWO<<MSOOQ$IVLD*nLD*nO4VQ%1`O'#G[O$)}Q$I[O,5;yO#NzQ$IWO'#FdOOQ$IS,5;},5;}OOQ$IS'#FZ'#FZO$*oQ$IWO,5;sO$*tQ$IWO,5;sOOQ$IS'#F^'#F^O#NzQ$IWO'#GZO$+fQ$IWO,5;wO$,QQ$IWO,5>jO$,bQ$IWO,5>jO0PQ$IWO,5;vO$,sQ$IWO,5;zO$,xQ$IWO,5;zO#NzQ$IWO'#IQO$,}Q$IWO'#IQO$-SQ$IWO,5;{OOQ$IS,5;|,5;|O'UQ$IWO'#FgOOQ$IU1G1[1G1[O3XQ$IWO1G1[OOQ$ISAN@gAN@gO$-XQ$IWOG27oO$-iQ$IWO,59{OOQ$IS1G3[1G3[OOQ$IS,5<v,5<vOOQ$IS-E:Y-E:YO$-nQ$I[O'#FWO$-uQ$IWO'#IRO$.TQ$IWO'#IRO$.]Q$IWO,5<OOOQ$IS1G1_1G1_O$.bQ$IWO1G1_O$.gQ$IWO,5<uOOQ$IS-E:X-E:XO$/RQ$IWO,5<yO$/jQ$IWO1G4UOOQ$IS-E:]-E:]OOQ$IS1G1b1G1bOOQ$IS1G1f1G1fO$/zQ$IWO,5>lO#NzQ$IWO,5>lOOQ$IS1G1g1G1gO$0YQ$I[O,5<ROOQ$IU7+&v7+&vO$!wQ$IWO1G/gO#NzQ$IWO,5<PO$0aQ$IWO,5>mO$0hQ$IWO,5>mOOQ$IS1G1j1G1jOOQ$IS7+&y7+&yP#NzQ$IWO'#G_O$0pQ$IWO1G4WO$0zQ$IWO1G4WO$1SQ$IWO1G4WOOQ$IS7+%R7+%RO$1bQ$IWO1G1kO$1pQ$I[O'#FWO$1wQ$IWO,5<xOOQ$IS,5<x,5<xO$2VQ$IWO1G4XOOQ$IS-E:[-E:[O#NzQ$IWO,5<wO$2^Q$IWO,5<wO$2cQ$IWO7+)rOOQ$IS-E:Z-E:ZO$2mQ$IWO7+)rO#NzQ$IWO,5<QP#NzQ$IWO'#G^O$2uQ$IWO1G2cO#NzQ$IWO1G2cP$3TQ$IWO'#G]O$3[Q$IWO<<M^O$3fQ$IWO1G1lO$3tQ$IWO7+'}O7WQ$IWO'#C{O7WQ$IWO,59`O7WQ$IWO,59`O7WQ$IWO,59`O$4SQ$I[O,5=WO7WQ$IWO1G.zO/jQ$IWO1G/VO/jQ$IWO7+$nP$4gQ$IWO'#FyO'UQ$IWO'#GlO$4tQ$IWO,59`O$4yQ$IWO,59`O$5QQ$IWO,59kO$5VQ$IWO1G/SO0kQ$IWO'#DPO7WQ$IWO,59h",
  stateData: "$5m~O%[OS%XOS%WOSQOS~OPhOTeOdsOfXOmtOq!SOtuO}vO!O!PO!R!VO!S!UO!VYO!ZZO!fdO!mdO!ndO!odO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#c!TO#f!WO#j!XO#l!YO#q!ZO#tlO#v![O%VqO%gQO%hQO%lRO%mVO&R[O&S]O&V^O&Y_O&``O&caO&ebO~OT!bO]!bO_!cOf!jO!V!lO!d!nO%b!]O%c!^O%d!_O%e!`O%f!`O%g!aO%h!aO%i!bO%j!bO%k!bO~Oi%pXj%pXk%pXl%pXm%pXn%pXq%pXx%pXy%pX!s%pX#^%pX%V%pX%Y%pX%r%pXe%pX!R%pX!S%pX%s%pX!U%pX!Y%pX!O%pX#V%pXr%pX!j%pX~P$bOdsOfXO!VYO!ZZO!fdO!mdO!ndO!odO%gQO%hQO%lRO%mVO&R[O&S]O&V^O&Y_O&``O&caO&ebO~Ox%oXy%oX#^%oX%V%oX%Y%oX%r%oX~Oi!qOj!rOk!pOl!pOm!sOn!tOq!uO!s%oX~P(cOT!{Om/iOt/wO}vO~P'UOT#OOm/iOt/wO!U#PO~P'UOT#SO_#TOm/iOt/wO!Y#UO~P'UO&T#XO&U#ZO~O&W#[O&X#ZO~O!Z#^O&Z#_O&_#aO~O!Z#^O&a#bO&b#aO~O!Z#^O&U#aO&d#dO~O!Z#^O&X#aO&f#fO~OT%aX]%aX_%aXf%aXi%aXj%aXk%aXl%aXm%aXn%aXq%aXx%aX!V%aX!d%aX%b%aX%c%aX%d%aX%e%aX%f%aX%g%aX%h%aX%i%aX%j%aX%k%aXe%aX!R%aX!S%aX~O&R[O&S]O&V^O&Y_O&``O&caO&ebOy%aX!s%aX#^%aX%V%aX%Y%aX%r%aX%s%aX!U%aX!Y%aX!O%aX#V%aXr%aX!j%aX~P+xOx#kOy%`X!s%`X#^%`X%V%`X%Y%`X%r%`X~Om/iOt/wO~P'UO#^#nO%V#pO%Y#pO~O%mVO~O!R#uO#l!YO#q!ZO#tlO~OmtO~P'UOT#zO_#{O%mVOyuP~OT$POm/iOt/wO!O$QO~P'UOy$SO!s$XO%r$TO#^!tX%V!tX%Y!tX~OT$POm/iOt/wO#^!}X%V!}X%Y!}X~P'UOm/iOt/wO#^#RX%V#RX%Y#RX~P'UO!d$_O!m$_O%mVO~OT$iO~P'UO!S$kO#j$lO#l$mO~Oy$nO~OT$uO~P'UOT%OO_%OOe%QOm/iOt/wO~P'UOm/iOt/wOy%TO~P'UO&Q%VO~O_!cOf!jO!V!lO!d!nOT`a]`ai`aj`ak`al`am`an`aq`ax`ay`a!s`a#^`a%V`a%Y`a%b`a%c`a%d`a%e`a%f`a%g`a%h`a%i`a%j`a%k`a%r`ae`a!R`a!S`a%s`a!U`a!Y`a!O`a#V`ar`a!j`a~Ol%[O~Om%[O~P'UOm/iO~P'UOi/kOj/lOk/jOl/jOm/sOn/tOq/xOe%oX!R%oX!S%oX%s%oX!U%oX!Y%oX!O%oX#V%oX!j%oX~P(cO%s%^Oe%nXx%nX!R%nX!S%nX!U%nXy%nX~Oe%`Ox%aO!R%eO!S%dO~Oe%`O~Ox%hO!R%eO!S%dO!U%zX~O!U%lO~Ox%mOy%oO!R%eO!S%dO!Y%uX~O!Y%sO~O!Y%tO~O&T#XO&U%vO~O&W#[O&X%vO~OT%yOm/iOt/wO}vO~P'UO!Z#^O&Z#_O&_%|O~O!Z#^O&a#bO&b%|O~O!Z#^O&U%|O&d#dO~O!Z#^O&X%|O&f#fO~OT!la]!la_!laf!lai!laj!lak!lal!lam!lan!laq!lax!lay!la!V!la!d!la!s!la#^!la%V!la%Y!la%b!la%c!la%d!la%e!la%f!la%g!la%h!la%i!la%j!la%k!la%r!lae!la!R!la!S!la%s!la!U!la!Y!la!O!la#V!lar!la!j!la~P#yOx&ROy%`a!s%`a#^%`a%V%`a%Y%`a%r%`a~P$bOT&TOmtOtuOy%`a!s%`a#^%`a%V%`a%Y%`a%r%`a~P'UOx&ROy%`a!s%`a#^%`a%V%`a%Y%`a%r%`a~OPhOTeOmtOtuO}vO!O!PO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#^$tX%V$tX%Y$tX~P'UO#^#nO%V&YO%Y&YO~O!d&ZOf&hX%V&hX#V&hX#^&hX%Y&hX#U&hX~Of!jO%V&]O~Oicajcakcalcamcancaqcaxcayca!sca#^ca%Vca%Yca%rcaeca!Rca!Sca%sca!Uca!Yca!Oca#Vcarca!jca~P$bOqoaxoayoa#^oa%Voa%Yoa%roa~Oi!qOj!rOk!pOl!pOm!sOn!tO!soa~PD_O%r&_Ox%qXy%qX~O%mVOx%qXy%qX~Ox&bOyuX~Oy&dO~Ox%mO#^%uX%V%uX%Y%uXe%uXy%uX!Y%uX!j%uX%r%uX~OT/rOm/iOt/wO}vO~P'UO%r$TO#^Sa%VSa%YSa~Ox&mO#^%wX%V%wX%Y%wXl%wX~P$bOx&pO!O&oO#^#Ra%V#Ra%Y#Ra~O#V&qO#^#Ta%V#Ta%Y#Ta~O!d$_O!m$_O#U&sO%mVO~O#U&sO~Ox&uO#^&kX%V&kX%Y&kX~Ox&wO#^&gX%V&gX%Y&gXy&gX~Ox&{Ol&mX~P$bOl'OO~OPhOTeOmtOtuO}vO!O!PO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO%V'TO~P'UOr'XO#g'VO#h'WOP#eaT#ead#eaf#eam#eaq#eat#ea}#ea!O#ea!R#ea!S#ea!V#ea!Z#ea!f#ea!m#ea!n#ea!o#ea!v#ea!x#ea!z#ea!|#ea#O#ea#S#ea#U#ea#X#ea#Y#ea#[#ea#c#ea#f#ea#j#ea#l#ea#q#ea#t#ea#v#ea%S#ea%V#ea%g#ea%h#ea%l#ea%m#ea&R#ea&S#ea&V#ea&Y#ea&`#ea&c#ea&e#ea%U#ea%Y#ea~Ox'YO#V'[Oy&nX~Of'^O~Of!jOy$nO~Oy'bO~P$bOT!bO]!bO_!cOf!jO!V!lO!d!nO%d!_O%e!`O%f!`O%g!aO%h!aO%i!bO%j!bO%k!bOiUijUikUilUimUinUiqUixUiyUi!sUi#^Ui%VUi%YUi%bUi%rUieUi!RUi!SUi%sUi!UUi!YUi!OUi#VUirUi!jUi~O%c!^O~P! YO%cUi~P! YOT!bO]!bO_!cOf!jO!V!lO!d!nO%g!aO%h!aO%i!bO%j!bO%k!bOiUijUikUilUimUinUiqUixUiyUi!sUi#^Ui%VUi%YUi%bUi%cUi%dUi%rUieUi!RUi!SUi%sUi!UUi!YUi!OUi#VUirUi!jUi~O%e!`O%f!`O~P!$TO%eUi%fUi~P!$TO_!cOf!jO!V!lO!d!nOiUijUikUilUimUinUiqUixUiyUi!sUi#^Ui%VUi%YUi%bUi%cUi%dUi%eUi%fUi%gUi%hUi%rUieUi!RUi!SUi%sUi!UUi!YUi!OUi#VUirUi!jUi~OT!bO]!bO%i!bO%j!bO%k!bO~P!'ROTUi]Ui%iUi%jUi%kUi~P!'RO!R%eO!S%dOe%}Xx%}X~O%r'fO%s'fO~P+xOx'hOe%|X~Oe'jO~Ox'kOy'mO!U&PX~Om/iOt/wOx'kOy'nO!U&PX~P'UO!U'pO~Ok!pOl!pOm!sOn!tOihiqhixhiyhi!shi#^hi%Vhi%Yhi%rhi~Oj!rO~P!+tOjhi~P!+tOi/kOj/lOk/jOl/jOm/sOn/tO~Or'rO~P!,}OT'wOe'xOm/iOt/wO~P'UOe'xOx'yO~Oe'{O~O!S'}O~Oe(OOx'yO!R%eO!S%dO~P$bOi/kOj/lOk/jOl/jOm/sOn/tOeoa!Roa!Soa%soa!Uoa!Yoa!Ooa#Voaroa!joa~PD_OT'wOm/iOt/wO!U%za~P'UOx(RO!U%za~O!U(SO~Ox(RO!R%eO!S%dO!U%za~P$bOT(WOm/iOt/wO!Y%ua#^%ua%V%ua%Y%uae%uay%ua!j%ua%r%ua~P'UOx(XO!Y%ua#^%ua%V%ua%Y%uae%uay%ua!j%ua%r%ua~O!Y([O~Ox(XO!R%eO!S%dO!Y%ua~P$bOx(_O!R%eO!S%dO!Y%{a~P$bOx(bOy&[X!Y&[X!j&[X~Oy(eO!Y(gO!j(hO~OT&TOmtOtuOy%`i!s%`i#^%`i%V%`i%Y%`i%r%`i~P'UOx(iOy%`i!s%`i#^%`i%V%`i%Y%`i%r%`i~O!d&ZOf&ha%V&ha#V&ha#^&ha%Y&ha#U&ha~O%V(nO~OT#zO_#{O%mVO~Ox&bOyua~OmtOtuO~P'UOx(XO#^%ua%V%ua%Y%uae%uay%ua!Y%ua!j%ua%r%ua~P$bOx(sO#^%`X%V%`X%Y%`X%r%`X~O%r$TO#^Si%VSi%YSi~O#^%wa%V%wa%Y%wal%wa~P'UOx(vO#^%wa%V%wa%Y%wal%wa~OT(zOf(|O%mVO~O#U(}O~O%mVO#^&ka%V&ka%Y&ka~Ox)PO#^&ka%V&ka%Y&ka~Om/iOt/wO#^&ga%V&ga%Y&gay&ga~P'UOx)SO#^&ga%V&ga%Y&gay&ga~Or)WO#a)VOP#_iT#_id#_if#_im#_iq#_it#_i}#_i!O#_i!R#_i!S#_i!V#_i!Z#_i!f#_i!m#_i!n#_i!o#_i!v#_i!x#_i!z#_i!|#_i#O#_i#S#_i#U#_i#X#_i#Y#_i#[#_i#c#_i#f#_i#j#_i#l#_i#q#_i#t#_i#v#_i%S#_i%V#_i%g#_i%h#_i%l#_i%m#_i&R#_i&S#_i&V#_i&Y#_i&`#_i&c#_i&e#_i%U#_i%Y#_i~Or)XOP#biT#bid#bif#bim#biq#bit#bi}#bi!O#bi!R#bi!S#bi!V#bi!Z#bi!f#bi!m#bi!n#bi!o#bi!v#bi!x#bi!z#bi!|#bi#O#bi#S#bi#U#bi#X#bi#Y#bi#[#bi#c#bi#f#bi#j#bi#l#bi#q#bi#t#bi#v#bi%S#bi%V#bi%g#bi%h#bi%l#bi%m#bi&R#bi&S#bi&V#bi&Y#bi&`#bi&c#bi&e#bi%U#bi%Y#bi~OT)ZOl&ma~P'UOx)[Ol&ma~Ox)[Ol&ma~P$bOl)`O~O%T)cO~Or)fO#g'VO#h)eOP#eiT#eid#eif#eim#eiq#eit#ei}#ei!O#ei!R#ei!S#ei!V#ei!Z#ei!f#ei!m#ei!n#ei!o#ei!v#ei!x#ei!z#ei!|#ei#O#ei#S#ei#U#ei#X#ei#Y#ei#[#ei#c#ei#f#ei#j#ei#l#ei#q#ei#t#ei#v#ei%S#ei%V#ei%g#ei%h#ei%l#ei%m#ei&R#ei&S#ei&V#ei&Y#ei&`#ei&c#ei&e#ei%U#ei%Y#ei~Om/iOt/wOy$nO~P'UOm/iOt/wOy&na~P'UOx)lOy&na~OT)pO_)qOe)tO%i)rO%mVO~Oy$nO&q)vO~O%V)zO~OT%OO_%OOm/iOt/wOe%|a~P'UOx*OOe%|a~Om/iOt/wOy*RO!U&Pa~P'UOx*SO!U&Pa~Om/iOt/wOx*SOy*VO!U&Pa~P'UOm/iOt/wOx*SO!U&Pa~P'UOx*SOy*VO!U&Pa~Ok/jOl/jOm/sOn/tOehiihiqhixhi!Rhi!Shi%shi!Uhiyhi!Yhi#^hi%Vhi%Yhi!Ohi#Vhirhi!jhi%rhi~Oj/lO~P!H[Ojhi~P!H[OT'wOe*[Om/iOt/wO~P'UOl*^O~Oe*[Ox*`O~Oe*aO~OT'wOm/iOt/wO!U%zi~P'UOx*bO!U%zi~O!U*cO~OT(WOm/iOt/wO!Y%ui#^%ui%V%ui%Y%uie%uiy%ui!j%ui%r%ui~P'UOx*fO!R%eO!S%dO!Y%{i~Ox*iO!Y%ui#^%ui%V%ui%Y%uie%uiy%ui!j%ui%r%ui~O!Y*jO~O_*lOm/iOt/wO!Y%{i~P'UOx*fO!Y%{i~O!Y*nO~OT*pOm/iOt/wOy&[a!Y&[a!j&[a~P'UOx*qOy&[a!Y&[a!j&[a~O!Z#^O&^*tO!Y!kX~O!Y*vO~Oy(eO!Y*wO~OT&TOmtOtuOy%`q!s%`q#^%`q%V%`q%Y%`q%r%`q~P'UOx$miy$mi!s$mi#^$mi%V$mi%Y$mi%r$mi~P$bOT&TOmtOtuO~P'UOT&TOm/iOt/wO#^%`a%V%`a%Y%`a%r%`a~P'UOx*xO#^%`a%V%`a%Y%`a%r%`a~Ox$`a#^$`a%V$`a%Y$`al$`a~P$bO#^%wi%V%wi%Y%wil%wi~P'UOx*{O#^#Rq%V#Rq%Y#Rq~Ox*|O#V+OO#^&jX%V&jX%Y&jXe&jX~OT+QOf(|O%mVO~O%mVO#^&ki%V&ki%Y&ki~Om/iOt/wO#^&gi%V&gi%Y&giy&gi~P'UOr+UO#a)VOP#_qT#_qd#_qf#_qm#_qq#_qt#_q}#_q!O#_q!R#_q!S#_q!V#_q!Z#_q!f#_q!m#_q!n#_q!o#_q!v#_q!x#_q!z#_q!|#_q#O#_q#S#_q#U#_q#X#_q#Y#_q#[#_q#c#_q#f#_q#j#_q#l#_q#q#_q#t#_q#v#_q%S#_q%V#_q%g#_q%h#_q%l#_q%m#_q&R#_q&S#_q&V#_q&Y#_q&`#_q&c#_q&e#_q%U#_q%Y#_q~Ol$wax$wa~P$bOT)ZOl&mi~P'UOx+]Ol&mi~OPhOTeOmtOq!SOtuO}vO!O!PO!R!VO!S!UO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#c!TO#f!WO#j!XO#l!YO#q!ZO#tlO#v![O~P'UOx+gOy$nO#V+gO~O#h+hOP#eqT#eqd#eqf#eqm#eqq#eqt#eq}#eq!O#eq!R#eq!S#eq!V#eq!Z#eq!f#eq!m#eq!n#eq!o#eq!v#eq!x#eq!z#eq!|#eq#O#eq#S#eq#U#eq#X#eq#Y#eq#[#eq#c#eq#f#eq#j#eq#l#eq#q#eq#t#eq#v#eq%S#eq%V#eq%g#eq%h#eq%l#eq%m#eq&R#eq&S#eq&V#eq&Y#eq&`#eq&c#eq&e#eq%U#eq%Y#eq~O#V+iOx$yay$ya~Om/iOt/wOy&ni~P'UOx+kOy&ni~Oy$SO%r+mOe&pXx&pX~O%mVOe&pXx&pX~Ox+qOe&oX~Oe+sO~O%T+uO~OT%OO_%OOm/iOt/wOe%|i~P'UOy+wOx$ca!U$ca~Om/iOt/wOy+xOx$ca!U$ca~P'UOm/iOt/wOy*RO!U&Pi~P'UOx+{O!U&Pi~Om/iOt/wOx+{O!U&Pi~P'UOx+{Oy,OO!U&Pi~Oe$_ix$_i!U$_i~P$bOT'wOm/iOt/wO~P'UOl,QO~OT'wOe,ROm/iOt/wO~P'UOT'wOm/iOt/wO!U%zq~P'UOx$^i!Y$^i#^$^i%V$^i%Y$^ie$^iy$^i!j$^i%r$^i~P$bOT(WOm/iOt/wO~P'UO_*lOm/iOt/wO!Y%{q~P'UOx,SO!Y%{q~O!Y,TO~OT(WOm/iOt/wO!Y%uq#^%uq%V%uq%Y%uqe%uqy%uq!j%uq%r%uq~P'UOy,UO~OT*pOm/iOt/wOy&[i!Y&[i!j&[i~P'UOx,ZOy&[i!Y&[i!j&[i~O!Z#^O&^*tO!Y!ka~OT&TOm/iOt/wO#^%`i%V%`i%Y%`i%r%`i~P'UOx,]O#^%`i%V%`i%Y%`i%r%`i~O%mVO#^&ja%V&ja%Y&jae&ja~Ox,`O#^&ja%V&ja%Y&jae&ja~Oe,cO~Ol$wix$wi~P$bOT)ZO~P'UOT)ZOl&mq~P'UOr,fOP#dyT#dyd#dyf#dym#dyq#dyt#dy}#dy!O#dy!R#dy!S#dy!V#dy!Z#dy!f#dy!m#dy!n#dy!o#dy!v#dy!x#dy!z#dy!|#dy#O#dy#S#dy#U#dy#X#dy#Y#dy#[#dy#c#dy#f#dy#j#dy#l#dy#q#dy#t#dy#v#dy%S#dy%V#dy%g#dy%h#dy%l#dy%m#dy&R#dy&S#dy&V#dy&Y#dy&`#dy&c#dy&e#dy%U#dy%Y#dy~OPhOTeOmtOq!SOtuO}vO!O!PO!R!VO!S!UO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#c!TO#f!WO#j!XO#l!YO#q!ZO#tlO#v![O%U,jO%Y,jO~P'UO#h,kOP#eyT#eyd#eyf#eym#eyq#eyt#ey}#ey!O#ey!R#ey!S#ey!V#ey!Z#ey!f#ey!m#ey!n#ey!o#ey!v#ey!x#ey!z#ey!|#ey#O#ey#S#ey#U#ey#X#ey#Y#ey#[#ey#c#ey#f#ey#j#ey#l#ey#q#ey#t#ey#v#ey%S#ey%V#ey%g#ey%h#ey%l#ey%m#ey&R#ey&S#ey&V#ey&Y#ey&`#ey&c#ey&e#ey%U#ey%Y#ey~Om/iOt/wOy&nq~P'UOx,oOy&nq~O%r+mOe&pax&pa~OT)pO_)qO%i)rO%mVOe&oa~Ox,sOe&oa~O#y,wO~OT%OO_%OOm/iOt/wO~P'UOm/iOt/wOy,xOx$ci!U$ci~P'UOm/iOt/wOx$ci!U$ci~P'UOy,xOx$ci!U$ci~Om/iOt/wOy*RO~P'UOm/iOt/wOy*RO!U&Pq~P'UOx,{O!U&Pq~Om/iOt/wOx,{O!U&Pq~P'UOq-OO!R%eO!S%dOe%vq!U%vq!Y%vqx%vq~P!,}O_*lOm/iOt/wO!Y%{y~P'UOx$ai!Y$ai~P$bO_*lOm/iOt/wO~P'UOT*pOm/iOt/wO~P'UOT*pOm/iOt/wOy&[q!Y&[q!j&[q~P'UOT&TOm/iOt/wO#^%`q%V%`q%Y%`q%r%`q~P'UO#V-SOx$ra#^$ra%V$ra%Y$rae$ra~O%mVO#^&ji%V&ji%Y&jie&ji~Ox-UO#^&ji%V&ji%Y&jie&ji~Or-XOP#d!RT#d!Rd#d!Rf#d!Rm#d!Rq#d!Rt#d!R}#d!R!O#d!R!R#d!R!S#d!R!V#d!R!Z#d!R!f#d!R!m#d!R!n#d!R!o#d!R!v#d!R!x#d!R!z#d!R!|#d!R#O#d!R#S#d!R#U#d!R#X#d!R#Y#d!R#[#d!R#c#d!R#f#d!R#j#d!R#l#d!R#q#d!R#t#d!R#v#d!R%S#d!R%V#d!R%g#d!R%h#d!R%l#d!R%m#d!R&R#d!R&S#d!R&V#d!R&Y#d!R&`#d!R&c#d!R&e#d!R%U#d!R%Y#d!R~Om/iOt/wOy&ny~P'UOT)pO_)qO%i)rO%mVOe&oi~O#y,wO%U-_O%Y-_O~OT-iOf-gO!V-fO!Z-hO!f-bO!n-dO!o-dO%h-aO%mVO&R[O&S]O&V^O~Om/iOt/wOx$cq!U$cq~P'UOy-nOx$cq!U$cq~Om/iOt/wOy*RO!U&Py~P'UOx-oO!U&Py~Om/iOt-sO~P'UOq-OO!R%eO!S%dOe%vy!U%vy!Y%vyx%vy~P!,}O%mVO#^&jq%V&jq%Y&jqe&jq~Ox-wO#^&jq%V&jq%Y&jqe&jq~OT)pO_)qO%i)rO%mVO~Of-{O!d-yOx#zX#V#zX%b#zXe#zX~Oq#zXy#zX!U#zX!Y#zX~P$$nO%g-}O%h-}Oq#{Xx#{Xy#{X#V#{X%b#{X!U#{Xe#{X!Y#{X~O!f.PO~Ox.TO#V.VO%b.QOq&rXy&rX!U&rXe&rX~O_.YO~P$ WOf-{Oq&sXx&sXy&sX#V&sX%b&sX!U&sXe&sX!Y&sX~Oq.^Oy$nO~Om/iOt/wOx$cy!U$cy~P'UOm/iOt/wOy*RO!U&P!R~P'UOx.bO!U&P!R~Oe%yXq%yX!R%yX!S%yX!U%yX!Y%yXx%yX~P!,}Oq-OO!R%eO!S%dOe%xa!U%xa!Y%xax%xa~O%mVO#^&jy%V&jy%Y&jye&jy~O!d-yOf$Raq$Rax$Ray$Ra#V$Ra%b$Ra!U$Rae$Ra!Y$Ra~O!f.kO~O%g-}O%h-}Oq#{ax#{ay#{a#V#{a%b#{a!U#{ae#{a!Y#{a~O%b.QOq$Pax$Pay$Pa#V$Pa!U$Pae$Pa!Y$Pa~Oq&ray&ra!U&rae&ra~P#NzOx.pOq&ray&ra!U&rae&ra~O!U.sO~Oe.sO~Oy.uO~O!Y.vO~Om/iOt/wOy*RO!U&P!Z~P'UOy.yO~O%r.zO~P$$nOx.{O#V.VO%b.QOe&uX~Ox.{Oe&uX~Oe.}O~O!f/OO~O#V.VOq$}ax$}ay$}a%b$}a!U$}ae$}a!Y$}a~O#V.VO%b.QOq%Rax%Ray%Ra!U%Rae%Ra~Oq&riy&ri!U&rie&ri~P#NzOx/QO#V.VO%b.QO!Y&ta~Oy$Za~P$bOe&ua~P#NzOx/YOe&ua~O_/[O!Y&ti~P$ WOx/^O!Y&ti~Ox/^O#V.VO%b.QO!Y&ti~O#V.VO%b.QOe$Xix$Xi~O%r/aO~P$$nO#V.VO%b.QOe%Qax%Qa~Oe&ui~P#NzOy/dO~O_/[O!Y&tq~P$ WOx/fO!Y&tq~O#V.VO%b.QOx%Pi!Y%Pi~O_/[O~P$ WO_/[O!Y&ty~P$ WO#V.VO%b.QOe$Yix$Yi~O#V.VO%b.QOx%Pq!Y%Pq~Ox*xO#^%`a%V%`a%Y%`a%r%`a~P$bOT&TOm/iOt/wO~P'UOl/nO~Om/nO~P'UOy/oO~Or/pO~P!,}O&S&V&c&e&R!Z&Z&a&d&f&Y&`&Y%m~",
  goto: "!9p&vPPPP&wP'P*e*}+h,S,o-]P-zP'P.k.k'PPPP'P2PPPPPPP2P4oPP4oP6{7U=QPP=T=c=fPP'P'PPP=rPP'P'PPP'P'P'P'P'P=v>m'PP>pP>vByFcPFw'PPPPF{GR&wP&w&wP&wP&wP&wP&wP&w&w&wP&wPP&wPP&wPGXPG`GfPG`PG`G`PPPG`PIePInItIzIePG`JQPG`PJXJ_PJcJwKfLPJcJcLVLdJcJcJcJcLxMOMRMWMZMaMgMsNVN]NgNm! Z! a! g! m! w! }!!T!!Z!!a!!g!!y!#T!#Z!#a!#g!#q!#w!#}!$T!$Z!$e!$k!$u!${!%U!%[!%k!%s!%}!&UPPPPPPPPP!&[!&d!&m!&w!'SPPPPPPPPPPPP!+r!,[!0j!3vPP!4O!4^!4g!5]!5S!5f!5l!5o!5r!5u!5}!6nPPPPPPPPPP!6q!6tPPPPPPPPP!6z!7W!7d!7j!7s!7v!7|!8S!8Y!8]P!8e!8n!9j!9m]iOr#n$n)c+c'udOSXYZehrstvx|}!R!S!T!U!X![!d!e!f!g!h!i!j!l!p!q!r!t!u!{#O#S#T#^#k#n$P$Q$S$U$X$i$k$l$n$u%O%T%[%_%a%d%h%m%o%y&R&T&`&d&m&o&p&w&{'O'V'Y'g'h'k'm'n'r'w'y'}(R(W(X(_(b(i(k(s(v)S)V)Z)[)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*l*p*q*x*z*{+S+[+]+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.^.b.y/i/j/k/l/n/o/p/q/r/t/x}!dP#j#w$Y$h$t%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!P!eP#j#w$Y$h$t$v%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!R!fP#j#w$Y$h$t$v$w%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!T!gP#j#w$Y$h$t$v$w$x%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!V!hP#j#w$Y$h$t$v$w$x$y%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!X!iP#j#w$Y$h$t$v$w$x$y$z%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m!]!iP!o#j#w$Y$h$t$v$w$x$y$z${%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/m'uSOSXYZehrstvx|}!R!S!T!U!X![!d!e!f!g!h!i!j!l!p!q!r!t!u!{#O#S#T#^#k#n$P$Q$S$U$X$i$k$l$n$u%O%T%[%_%a%d%h%m%o%y&R&T&`&d&m&o&p&w&{'O'V'Y'g'h'k'm'n'r'w'y'}(R(W(X(_(b(i(k(s(v)S)V)Z)[)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*l*p*q*x*z*{+S+[+]+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.^.b.y/i/j/k/l/n/o/p/q/r/t/x&ZUOXYZhrtv|}!R!S!T!X!j!l!p!q!r!t!u#^#k#n$Q$S$U$X$l$n%O%T%[%_%a%h%m%o%y&R&`&d&o&p&w'O'V'Y'g'h'k'm'n'r'y(R(X(_(b(i(k(s)S)V)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*p*q*x*{+S+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.b.y/i/j/k/l/n/o/p/q/t/x%eWOXYZhrv|}!R!S!T!X!j!l#^#k#n$Q$S$U$X$l$n%O%T%_%a%h%m%o%y&R&`&d&o&p&w'O'V'Y'g'h'k'm'n'r'y(R(X(_(b(i(k(s)S)V)`)c)l)v*O*R*S*V*]*`*b*e*f*i*p*q*x*{+S+c+j+k+n+v+w+x+z+{,O,S,U,W,Y,Z,],o,q,x,{-n-o.b/o/p/qQ#}uQ.c-sR/u/w'ldOSXYZehrstvx|}!R!S!T!U!X![!d!e!f!g!h!i!l!p!q!r!t!u!{#O#S#T#^#k#n$P$Q$S$U$X$i$k$l$n$u%O%T%[%_%a%d%h%m%o%y&R&T&`&d&m&o&p&w&{'O'V'Y'g'k'm'n'r'w'y'}(R(W(X(_(b(i(k(s(v)S)V)Z)[)`)c)l)v*R*S*V*]*^*`*b*e*f*i*l*p*q*x*z*{+S+[+]+c+j+k+n+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.^.b.y/i/j/k/l/n/o/p/q/r/t/xW#ql!O!P$`W#yu&b-s/wQ$b!QQ$r!YQ$s!ZW$}!j'h*O+vS&a#z#{Q'R$mQ(l&ZQ(z&qU({&s(|(}U)O&u)P+RQ)n'[W)o'^+q,s-]S+p)p)qY,_*|,`-T-U-wQ,b+OQ,l+gQ,n+il-`,w-f-g-i.R.T.Y.p.u.z/P/[/a/dQ-v-SQ.Z-hQ.g-{Q.r.VU/V.{/Y/bX/]/Q/^/e/fR&`#yi!xXY!S!T%a%h'y(R)V*]*`*bR%_!wQ!|XQ%z#^Q&i$UR&l$XT-r-O.y![!kP!o#j#w$Y$h$t$v$w$x$y$z${%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/mQ&^#rR'a$sR'g$}Q%W!nR.e-y'tcOSXYZehrstvx|}!R!S!T!U!X![!d!e!f!g!h!i!j!l!p!q!r!t!u!{#O#S#T#^#k#n$P$Q$S$U$X$i$k$l$n$u%O%T%[%_%a%d%h%m%o%y&R&T&`&d&m&o&p&w&{'O'V'Y'g'h'k'm'n'r'w'y'}(R(W(X(_(b(i(k(s(v)S)V)Z)[)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*l*p*q*x*z*{+S+[+]+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.^.b.y/i/j/k/l/n/o/p/q/r/t/xS#hc#i!P-d,w-f-g-h-i-{.R.T.Y.p.u.z.{/P/Q/Y/[/^/a/b/d/e/f'tcOSXYZehrstvx|}!R!S!T!U!X![!d!e!f!g!h!i!j!l!p!q!r!t!u!{#O#S#T#^#k#n$P$Q$S$U$X$i$k$l$n$u%O%T%[%_%a%d%h%m%o%y&R&T&`&d&m&o&p&w&{'O'V'Y'g'h'k'm'n'r'w'y'}(R(W(X(_(b(i(k(s(v)S)V)Z)[)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*l*p*q*x*z*{+S+[+]+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.^.b.y/i/j/k/l/n/o/p/q/r/t/xT#hc#iS#__#`S#b`#cS#da#eS#fb#gT*t(e*uT(f%z(hQ$WwR+o)oX$Uw$V$W&kZkOr$n)c+cXoOr)c+cQ$o!WQ&y$fQ&z$gQ']$qQ'`$sQ)a'QQ)g'VQ)i'WQ)j'XQ)w'_Q)y'aQ+V)VQ+X)WQ+Y)XQ+^)_S+`)b)xQ+d)eQ+e)fQ+f)hQ,d+UQ,e+WQ,g+_Q,h+aQ,m+hQ-W,fQ-Y,kQ-Z,lQ-x-XQ._-lR.x.`WoOr)c+cR#tnQ'_$rR)b'RQ+n)oR,q+oQ)x'_R+a)bZmOnr)c+cQ'c$tR){'dT,u+u,vu-k,w-f-g-i-{.R.T.Y.p.u.z.{/P/Y/[/a/b/dt-k,w-f-g-i-{.R.T.Y.p.u.z.{/P/Y/[/a/b/dQ.Z-hX/]/Q/^/e/f!P-c,w-f-g-h-i-{.R.T.Y.p.u.z.{/P/Q/Y/[/^/a/b/d/e/fQ.O-bR.l.Pg.R-e.S.h.o.t/S/U/W/c/g/hu-j,w-f-g-i-{.R.T.Y.p.u.z.{/P/Y/[/a/b/dX-|-`-j.g/VR.i-{V/X.{/Y/bR.`-lQrOR#vrQ&c#|R(q&cS%n#R$OS(Y%n(]T(]%q&eQ%b!zQ%i!}W'z%b%i(P(TQ(P%fR(T%kQ&n$YR(w&nQ(`%rQ*g(ZT*m(`*gQ'i%PR*P'iS'l%S%TY*T'l*U+|,|-pU*U'm'n'oU+|*V*W*XS,|+},OR-p,}Q#Y]R%u#YQ#]^R%w#]Q#`_R%{#`Q(c%xS*r(c*sR*s(dQ*u(eR,[*uQ#c`R%}#cQ#eaR&O#eQ#gbR&P#gQ#icR&Q#iQ#lfQ&S#jW&V#l&S(t*yQ(t&hR*y/mQ$VwS&j$V&kR&k$WQ&x$dR)T&xQ&[#qR(m&[Q$`!PR&r$`Q*}({S,a*}-VR-V,bQ&v$bR)Q&vQ#ojR&X#oQ+c)cR,i+cQ)U&yR+T)UQ&|$hS)]&|)^R)^&}Q'U$oR)d'UQ'Z$pS)m'Z+lR+l)nQ+r)sR,t+rWnOr)c+cR#snQ,v+uR-^,vd.S-e.h.o.t/S/U/W/c/g/hR.n.SU-z-`.g/VR.f-zQ/R.tS/_/R/`R/`/SS.|.h.iR/Z.|Q.U-eR.q.USqOrT+b)c+cWpOr)c+cR'S$nYjOr$n)c+cR&W#n[wOr#n$n)c+cR&i$U&YPOXYZhrtv|}!R!S!T!X!j!l!p!q!r!t!u#^#k#n$Q$S$U$X$l$n%O%T%[%_%a%h%m%o%y&R&`&d&o&p&w'O'V'Y'g'h'k'm'n'r'y(R(X(_(b(i(k(s)S)V)`)c)l)v*O*R*S*V*]*^*`*b*e*f*i*p*q*x*{+S+c+j+k+n+v+w+x+z+{,O,Q,S,U,W,Y,Z,],o,q,x,{-O-n-o.b.y/i/j/k/l/n/o/p/q/t/xQ!oSQ#jeQ#wsU$Yx%d'}S$h!U$kQ$t![Q$v!dQ$w!eQ$x!fQ$y!gQ$z!hQ${!iQ%f!{Q%k#OQ%q#SQ%r#TQ&e$PQ&}$iQ'd$uQ(j&TU(u&m(v*zW)Y&{)[+[+]Q*Z'wQ*d(WQ+Z)ZQ,V*lQ.w.^R/m/rQ!zXQ!}YQ$f!SQ$g!T^'v%a%h'y(R*]*`*bR+W)V[fOr#n$n)c+ch!wXY!S!T%a%h'y(R)V*]*`*bQ#RZQ#mhS$Ov|Q$]}W$d!R$X'O)`S$p!X$lW$|!j'h*O+vQ%S!lQ%x#^`&U#k&R(i(k(s*x,]/qQ&f$QQ&g$SQ&h$UQ'e%OQ'o%TQ'u%_W(V%m(X*e*iQ(Z%oQ(d%yQ(o&`S(r&d/oQ(x&oQ(y&pU)R&w)S+SQ)h'VY)k'Y)l+j+k,oQ)|'g^*Q'k*S+z+{,{-o.bQ*W'mQ*X'nS*Y'r/pW*k(_*f,S,WW*o(b*q,Y,ZQ+t)vQ+y*RQ+}*VQ,X*pQ,^*{Q,p+nQ,y+wQ,z+xQ,},OQ-R,UQ-[,qQ-m,xR.a-nhTOr#k#n$n&R&d'r(i(k)c+c$z!vXYZhv|}!R!S!T!X!j!l#^$Q$S$U$X$l%O%T%_%a%h%m%o%y&`&o&p&w'O'V'Y'g'h'k'm'n'y(R(X(_(b(s)S)V)`)l)v*O*R*S*V*]*`*b*e*f*i*p*q*x*{+S+j+k+n+v+w+x+z+{,O,S,U,W,Y,Z,],o,q,x,{-n-o.b/o/p/qQ#xtW%X!p!t/j/tQ%Y!qQ%Z!rQ%]!uQ%g/iS'q%[/nQ's/kQ't/lQ,P*^Q-Q,QS-q-O.yR/v/xU#|u-s/wR(p&b[gOr#n$n)c+cX!yX#^$U$XQ#WZQ$RvR$[|Q%c!zQ%j!}Q%p#RQ'e$|Q(Q%fQ(U%kQ(^%qQ(a%rQ*h(ZQ-P,PQ-u-QR.d-tQ$ZxQ'|%dR*_'}Q-t-OR/T.yR#QYR#VZR%R!jQ%P!jV)}'h*O+v!]!mP!o#j#w$Y$h$t$v$w$x$y$z${%f%k%q%r&e&}'d(j(u)Y*Z*d+Z,V.w/mR%U!lR%z#^Q(g%zR*w(hQ$e!RQ&l$XQ)_'OR+_)`Q#rlQ$^!OQ$a!PR&t$`Q(z&sR+Q(}Q(z&sQ+P(|R+Q(}R$c!QXpOr)c+cQ$j!UR'P$kQ$q!XR'Q$lR)u'^Q)s'^V,r+q,s-]Q-l,wQ.W-fR.X-gU-e,w-f-gQ.]-iQ.h-{Q.m.RU.o.T.p/PQ.t.YQ/S.uQ/U.zU/W.{/Y/bQ/c/[Q/g/aR/h/dR.[-hR.j-{",
  nodeNames: "⚠ print Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatConversion FormatSpec ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard",
  maxTerm: 267,
  context: cW,
  nodeProps: [
    ["group", -14, 4, 80, 82, 83, 85, 87, 89, 91, 93, 94, 95, 97, 100, 103, "Statement Statement", -22, 6, 16, 19, 23, 38, 47, 48, 54, 55, 58, 59, 60, 61, 62, 65, 68, 69, 70, 74, 75, 76, 77, "Expression", -10, 105, 107, 110, 112, 113, 117, 119, 124, 126, 129, "Statement", -9, 134, 135, 138, 139, 141, 142, 143, 144, 145, "Pattern"],
    ["openedBy", 21, "(", 52, "[", 56, "{"],
    ["closedBy", 22, ")", 53, "]", 57, "}"]
  ],
  propSources: [uW],
  skippedNodes: [0, 2],
  repeatNodeCount: 38,
  tokenData: ")'WMgR!`OX%TXY!EQY[%T[]!EQ]p%Tpq!EQqr!Gkrs!Ktst#J]tu%Tuv&'{vw&*kwx&+}xy'*fyz'+rz{'-O{|'/z|}'1^}!O'2j!O!P'5]!P!Q'Ae!Q!R'Da!R!['Ho![!](&g!]!^()V!^!_(*c!_!`(-_!`!a(.q!a!b%T!b!c(1j!c!d(3O!d!e(4|!e!h(3O!h!i(?z!i!t(3O!t!u(J[!u!w(3O!w!x(>S!x!}(3O!}#O(Ll#O#P!Fp#P#Q(Mx#Q#R) U#R#S(3O#S#T%T#T#U(3O#U#V(4|#V#Y(3O#Y#Z(?z#Z#f(3O#f#g(J[#g#i(3O#i#j(>S#j#o(3O#o#p)!h#p#q)#d#q#r)$v#r#s)%z#s$g%T$g;'S(3O;'S;=`(4v<%lO(3O<r%f]&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<Q&j]&^7[&TS&Z`&d!bOr'crs!,gsw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'c<Q'r]&^7[&TS&WW&Z`&d!b&f#tOr'crs&_sw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'c;p(t]&^7[&WW&f#tOr)mrs*ssw)mwxKmx#O)m#O#P7}#P#o)m#o#pDs#p#q)m#q#r8l#r;'S)m;'S;=`Kg<%lO)m;p)z]&^7[&TS&WW&d!b&f#tOr)mrs*ssw)mwx(kx#O)m#O#P7}#P#o)m#o#pDs#p#q)m#q#r8l#r;'S)m;'S;=`Kg<%lO)m;p*|]&^7[&TS&d!bOr)mrs+usw)mwx(kx#O)m#O#P7}#P#o)m#o#pDs#p#q)m#q#r8l#r;'S)m;'S;=`Kg<%lO)m;p,O]&^7[&TS&d!bOr)mrs,wsw)mwx(kx#O)m#O#P7}#P#o)m#o#pDs#p#q)m#q#r8l#r;'S)m;'S;=`Kg<%lO)m8r-QZ&^7[&TS&d!bOw,wwx-sx#O,w#O#P/}#P#o,w#o#p3n#p#q,w#q#r0l#r;'S,w;'S;=`7w<%lO,w8r-xZ&^7[Ow,wwx.kx#O,w#O#P/}#P#o,w#o#p3n#p#q,w#q#r0l#r;'S,w;'S;=`7w<%lO,w8r.pZ&^7[Ow,wwx/cx#O,w#O#P/}#P#o,w#o#p3n#p#q,w#q#r0l#r;'S,w;'S;=`7w<%lO,w7[/hT&^7[O#o/c#p#q/c#r;'S/c;'S;=`/w<%lO/c7[/zP;=`<%l/c8r0SW&^7[O#o,w#o#p0l#p#q,w#q#r0l#r;'S,w;'S;=`7Q;=`<%l0l<%lO,w!f0sX&TS&d!bOw0lwx1`x#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z<%lO0l!f1cXOw0lwx2Ox#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z<%lO0l!f2RWOw0lx#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z<%lO0l!f2nRO;'S0l;'S;=`2w;=`O0l!f3OY&TS&d!bOw0lwx1`x#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z;=`<%l0l<%lO0l!f3sX&TSOw4`wx4zx#O4`#O#P5y#P#o4`#o#p0l#p;'S4`;'S;=`6t<%lO4`S4eV&TSOw4`wx4zx#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`S4}VOw4`wx5dx#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`S5gUOw4`x#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`S5|RO;'S4`;'S;=`6V;=`O4`S6[W&TSOw4`wx4zx#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l4`<%lO4`S6wP;=`<%l4`!f6}P;=`<%l0l8r7XY&TS&d!bOw0lwx1`x#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z;=`<%l,w<%lO0l8r7zP;=`<%l,w;p8SW&^7[O#o)m#o#p8l#p#q)m#q#r8l#r;'S)m;'S;=`Jf;=`<%l8l<%lO)m%d8wZ&TS&WW&d!b&f#tOr8lrs9jsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`<%lO8l%d9qZ&TS&d!bOr8lrs:dsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`<%lO8l%d:kZ&TS&d!bOr8lrs0lsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`<%lO8l%d;eZ&WW&f#tOr8lrs9jsw8lwx<Wx#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`<%lO8l%d<_Z&WW&f#tOr8lrs9jsw8lwx=Qx#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`<%lO8l#|=XX&WW&f#tOr=Qrs=ts#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`<%lO=Q#|=wXOr=Qrs>ds#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`<%lO=Q#|>gWOr=Qs#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`<%lO=Q#|?SRO;'S=Q;'S;=`?];=`O=Q#|?dY&WW&f#tOr=Qrs=ts#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`;=`<%l=Q<%lO=Q#|@XX&WWOr@trsA`s#O@t#O#PB_#P#o@t#o#p=Q#p;'S@t;'S;=`CY<%lO@tW@yV&WWOr@trsA`s#O@t#O#PB_#P;'S@t;'S;=`CY<%lO@tWAcVOr@trsAxs#O@t#O#PB_#P;'S@t;'S;=`CY<%lO@tWA{UOr@ts#O@t#O#PB_#P;'S@t;'S;=`CY<%lO@tWBbRO;'S@t;'S;=`Bk;=`O@tWBpW&WWOr@trsA`s#O@t#O#PB_#P;'S@t;'S;=`CY;=`<%l@t<%lO@tWC]P;=`<%l@t#|CcP;=`<%l=Q%dCiRO;'S8l;'S;=`Cr;=`O8l%dC}[&TS&WW&d!b&f#tOr8lrs9jsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`;=`<%l8l<%lO8l%dDzZ&TS&WWOrEmrsFaswEmwxGsx#OEm#O#PIV#P#oEm#o#p8l#p;'SEm;'S;=`JY<%lOEm[EtX&TS&WWOrEmrsFaswEmwxGsx#OEm#O#PIV#P;'SEm;'S;=`JY<%lOEm[FfX&TSOrEmrsGRswEmwxGsx#OEm#O#PIV#P;'SEm;'S;=`JY<%lOEm[GWX&TSOrEmrs4`swEmwxGsx#OEm#O#PIV#P;'SEm;'S;=`JY<%lOEm[GxX&WWOrEmrsFaswEmwxHex#OEm#O#PIV#P;'SEm;'S;=`JY<%lOEm[HjX&WWOrEmrsFaswEmwx@tx#OEm#O#PIV#P;'SEm;'S;=`JY<%lOEm[IYRO;'SEm;'S;=`Ic;=`OEm[IjY&TS&WWOrEmrsFaswEmwxGsx#OEm#O#PIV#P;'SEm;'S;=`JY;=`<%lEm<%lOEm[J]P;=`<%lEm%dJcP;=`<%l8l;pJq[&TS&WW&d!b&f#tOr8lrs9jsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`;=`<%l)m<%lO8l;pKjP;=`<%l)m;pKv]&^7[&WW&f#tOr)mrs*ssw)mwxLox#O)m#O#P7}#P#o)m#o#pDs#p#q)m#q#r8l#r;'S)m;'S;=`Kg<%lO)m:YLxZ&^7[&WW&f#tOrLorsMks#OLo#O#P! Z#P#oLo#o#p@S#p#qLo#q#r=Q#r;'SLo;'S;=`!!o<%lOLo:YMpZ&^7[OrLorsNcs#OLo#O#P! Z#P#oLo#o#p@S#p#qLo#q#r=Q#r;'SLo;'S;=`!!o<%lOLo:YNhZ&^7[OrLors/cs#OLo#O#P! Z#P#oLo#o#p@S#p#qLo#q#r=Q#r;'SLo;'S;=`!!o<%lOLo:Y! `W&^7[O#oLo#o#p=Q#p#qLo#q#r=Q#r;'SLo;'S;=`! x;=`<%l=Q<%lOLo:Y!!PY&WW&f#tOr=Qrs=ts#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`;=`<%lLo<%lO=Q:Y!!rP;=`<%lLo<Q!!zW&^7[O#o'c#o#p!#d#p#q'c#q#r!#d#r;'S'c;'S;=`!+^;=`<%l!#d<%lO'c%t!#qZ&TS&WW&Z`&d!b&f#tOr!#drs!$dsw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W<%lO!#d%t!$mZ&TS&Z`&d!bOr!#drs!%`sw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W<%lO!#d%t!%iZ&TS&Z`&d!bOr!#drs!&[sw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W<%lO!#d!v!&eX&TS&Z`&d!bOw!&[wx1`x#O!&[#O#P!'Q#P#o!&[#o#p!(V#p;'S!&[;'S;=`!(w<%lO!&[!v!'TRO;'S!&[;'S;=`!'^;=`O!&[!v!'gY&TS&Z`&d!bOw!&[wx1`x#O!&[#O#P!'Q#P#o!&[#o#p!(V#p;'S!&[;'S;=`!(w;=`<%l!&[<%lO!&[!v!([X&TSOw4`wx4zx#O4`#O#P5y#P#o4`#o#p!&[#p;'S4`;'S;=`6t<%lO4`!v!(zP;=`<%l!&[%t!)QRO;'S!#d;'S;=`!)Z;=`O!#d%t!)h[&TS&WW&Z`&d!b&f#tOr!#drs!$dsw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W;=`<%l!#d<%lO!#d%t!*eZ&TS&WWOrEmrsFaswEmwxGsx#OEm#O#PIV#P#oEm#o#p!#d#p;'SEm;'S;=`JY<%lOEm%t!+ZP;=`<%l!#d<Q!+k[&TS&WW&Z`&d!b&f#tOr!#drs!$dsw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W;=`<%l'c<%lO!#d<Q!,dP;=`<%l'c<Q!,r]&^7[&TS&Z`&d!bOr'crs!-ksw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'c9S!-vZ&^7[&TS&Z`&d!bOw!-kwx-sx#O!-k#O#P!.i#P#o!-k#o#p!(V#p#q!-k#q#r!&[#r;'S!-k;'S;=`!0P<%lO!-k9S!.nW&^7[O#o!-k#o#p!&[#p#q!-k#q#r!&[#r;'S!-k;'S;=`!/W;=`<%l!&[<%lO!-k9S!/aY&TS&Z`&d!bOw!&[wx1`x#O!&[#O#P!'Q#P#o!&[#o#p!(V#p;'S!&[;'S;=`!(w;=`<%l!-k<%lO!&[9S!0SP;=`<%l!-k<b!0b]&^7[&WW&ap&f#tOr!1Zrs*ssw!1Zwx!<Tx#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1Z<b!1j]&^7[&TS&WW&ap&d!b&f#tOr!1Zrs*ssw!1Zwx!0Vx#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1Z<b!2hW&^7[O#o!1Z#o#p!3Q#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!:z;=`<%l!3Q<%lO!1Z&U!3_Z&TS&WW&ap&d!b&f#tOr!3Qrs9jsw!3Qwx!4Qx#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t<%lO!3Q&U!4ZZ&WW&ap&f#tOr!3Qrs9jsw!3Qwx!4|x#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t<%lO!3Q&U!5VZ&WW&ap&f#tOr!3Qrs9jsw!3Qwx!5xx#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t<%lO!3Q$n!6RX&WW&ap&f#tOr!5xrs=ts#O!5x#O#P!6n#P#o!5x#o#p!7s#p;'S!5x;'S;=`!8e<%lO!5x$n!6qRO;'S!5x;'S;=`!6z;=`O!5x$n!7TY&WW&ap&f#tOr!5xrs=ts#O!5x#O#P!6n#P#o!5x#o#p!7s#p;'S!5x;'S;=`!8e;=`<%l!5x<%lO!5x$n!7xX&WWOr@trsA`s#O@t#O#PB_#P#o@t#o#p!5x#p;'S@t;'S;=`CY<%lO@t$n!8hP;=`<%l!5x&U!8nRO;'S!3Q;'S;=`!8w;=`O!3Q&U!9U[&TS&WW&ap&d!b&f#tOr!3Qrs9jsw!3Qwx!4Qx#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t;=`<%l!3Q<%lO!3Q&U!:RZ&TS&WWOrEmrsFaswEmwxGsx#OEm#O#PIV#P#oEm#o#p!3Q#p;'SEm;'S;=`JY<%lOEm&U!:wP;=`<%l!3Q<b!;X[&TS&WW&ap&d!b&f#tOr!3Qrs9jsw!3Qwx!4Qx#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t;=`<%l!1Z<%lO!3Q<b!<QP;=`<%l!1Z<b!<`]&^7[&WW&ap&f#tOr!1Zrs*ssw!1Zwx!=Xx#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1Z:z!=dZ&^7[&WW&ap&f#tOr!=XrsMks#O!=X#O#P!>V#P#o!=X#o#p!7s#p#q!=X#q#r!5x#r;'S!=X;'S;=`!?m<%lO!=X:z!>[W&^7[O#o!=X#o#p!5x#p#q!=X#q#r!5x#r;'S!=X;'S;=`!>t;=`<%l!5x<%lO!=X:z!>}Y&WW&ap&f#tOr!5xrs=ts#O!5x#O#P!6n#P#o!5x#o#p!7s#p;'S!5x;'S;=`!8e;=`<%l!=X<%lO!5x:z!?pP;=`<%l!=X<r!?xW&^7[O#o%T#o#p!@b#p#q%T#q#r!@b#r;'S%T;'S;=`!Cu;=`<%l!@b<%lO%T&f!@qZ&TS&WW&Z`&ap&d!b&f#tOr!@brs!$dsw!@bwx!4Qx#O!@b#O#P!Ad#P#o!@b#o#p!Bu#p;'S!@b;'S;=`!Co<%lO!@b&f!AgRO;'S!@b;'S;=`!Ap;=`O!@b&f!BP[&TS&WW&Z`&ap&d!b&f#tOr!@brs!$dsw!@bwx!4Qx#O!@b#O#P!Ad#P#o!@b#o#p!Bu#p;'S!@b;'S;=`!Co;=`<%l!@b<%lO!@b&f!B|Z&TS&WWOrEmrsFaswEmwxGsx#OEm#O#PIV#P#oEm#o#p!@b#p;'SEm;'S;=`JY<%lOEm&f!CrP;=`<%l!@b<r!DU[&TS&WW&Z`&ap&d!b&f#tOr!@brs!$dsw!@bwx!4Qx#O!@b#O#P!Ad#P#o!@b#o#p!Bu#p;'S!@b;'S;=`!Co;=`<%l%T<%lO!@b<r!D}P;=`<%l%TMg!Eec&^7[&TS&WW%[1s&Z`&ap&d!b&f#tOX%TXY!EQY[%T[]!EQ]p%Tpq!EQqr%Trs&_sw%Twx!0Vx#O%T#O#P!Fp#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TMg!Fu[&^7[OY%TYZ!EQZ]%T]^!EQ^#o%T#o#p!@b#p#q%T#q#r!@b#r;'S%T;'S;=`!Cu;=`<%l!@b<%lO%T<u!G|d&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`!I[!`#O%T#O#P!?s#P#T%T#T#U!Jh#U#f%T#f#g!Jh#g#h!Jh#h#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<u!Io]kR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<u!J{]!jR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{!LTa&bp&^7[&TS&R,X&Z`&d!bOY!MYYZ'cZ]!MY]^'c^r!MYrs#HTsw!MYwx# vx#O!MY#O#P#@t#P#o!MY#o#p#E^#p#q!MY#q#r#Ac#r;'S!MY;'S;=`#G}<%lO!MYGZ!Mka&^7[&TS&WW&R,X&Z`&d!b&f#tOY!MYYZ'cZ]!MY]^'c^r!MYrs!Npsw!MYwx# vx#O!MY#O#P#@t#P#o!MY#o#p#E^#p#q!MY#q#r#Ac#r;'S!MY;'S;=`#G}<%lO!MYGZ!N}]&^7[&TS&R,X&Z`&d!bOr'crs!,gsw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'cFy#!Ra&^7[&WW&R,X&f#tOY##WYZ)mZ]##W]^)m^r##Wrs#$lsw##Wwx#;fx#O##W#O#P#%p#P#o##W#o#p#3d#p#q##W#q#r#&_#r;'S##W;'S;=`#;`<%lO##WFy##ga&^7[&TS&WW&R,X&d!b&f#tOY##WYZ)mZ]##W]^)m^r##Wrs#$lsw##Wwx# vx#O##W#O#P#%p#P#o##W#o#p#3d#p#q##W#q#r#&_#r;'S##W;'S;=`#;`<%lO##WFy#$w]&^7[&TS&R,X&d!bOr)mrs+usw)mwx(kx#O)m#O#P7}#P#o)m#o#pDs#p#q)m#q#r8l#r;'S)m;'S;=`Kg<%lO)mFy#%uW&^7[O#o##W#o#p#&_#p#q##W#q#r#&_#r;'S##W;'S;=`#:P;=`<%l#&_<%lO##W0m#&l_&TS&WW&R,X&d!b&f#tOY#&_YZ8lZ]#&_]^8l^r#&_rs#'ksw#&_wx#(gx#O#&_#O#P#1w#P#o#&_#o#p#3d#p;'S#&_;'S;=`#9y<%lO#&_0m#'tZ&TS&R,X&d!bOr8lrs:dsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`<%lO8l0m#(p_&WW&R,X&f#tOY#&_YZ8lZ]#&_]^8l^r#&_rs#'ksw#&_wx#)ox#O#&_#O#P#1w#P#o#&_#o#p#3d#p;'S#&_;'S;=`#9y<%lO#&_0m#)x_&WW&R,X&f#tOY#&_YZ8lZ]#&_]^8l^r#&_rs#'ksw#&_wx#*wx#O#&_#O#P#1w#P#o#&_#o#p#3d#p;'S#&_;'S;=`#9y<%lO#&_/V#+Q]&WW&R,X&f#tOY#*wYZ=QZ]#*w]^=Q^r#*wrs#+ys#O#*w#O#P#,k#P#o#*w#o#p#-|#p;'S#*w;'S;=`#1q<%lO#*w/V#,OX&R,XOr=Qrs>ds#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`<%lO=Q/V#,nRO;'S#*w;'S;=`#,w;=`O#*w/V#-Q^&WW&R,X&f#tOY#*wYZ=QZ]#*w]^=Q^r#*wrs#+ys#O#*w#O#P#,k#P#o#*w#o#p#-|#p;'S#*w;'S;=`#1q;=`<%l#*w<%lO#*w/V#.T]&WW&R,XOY#.|YZ@tZ]#.|]^@t^r#.|rs#/vs#O#.|#O#P#0b#P#o#.|#o#p#*w#p;'S#.|;'S;=`#1k<%lO#.|,a#/TZ&WW&R,XOY#.|YZ@tZ]#.|]^@t^r#.|rs#/vs#O#.|#O#P#0b#P;'S#.|;'S;=`#1k<%lO#.|,a#/{V&R,XOr@trsAxs#O@t#O#PB_#P;'S@t;'S;=`CY<%lO@t,a#0eRO;'S#.|;'S;=`#0n;=`O#.|,a#0u[&WW&R,XOY#.|YZ@tZ]#.|]^@t^r#.|rs#/vs#O#.|#O#P#0b#P;'S#.|;'S;=`#1k;=`<%l#.|<%lO#.|,a#1nP;=`<%l#.|/V#1tP;=`<%l#*w0m#1zRO;'S#&_;'S;=`#2T;=`O#&_0m#2b`&TS&WW&R,X&d!b&f#tOY#&_YZ8lZ]#&_]^8l^r#&_rs#'ksw#&_wx#(gx#O#&_#O#P#1w#P#o#&_#o#p#3d#p;'S#&_;'S;=`#9y;=`<%l#&_<%lO#&_0m#3m_&TS&WW&R,XOY#4lYZEmZ]#4l]^Em^r#4lrs#5nsw#4lwx#6bx#O#4l#O#P#8b#P#o#4l#o#p#&_#p;'S#4l;'S;=`#9s<%lO#4l,e#4u]&TS&WW&R,XOY#4lYZEmZ]#4l]^Em^r#4lrs#5nsw#4lwx#6bx#O#4l#O#P#8b#P;'S#4l;'S;=`#9s<%lO#4l,e#5uX&TS&R,XOrEmrsGRswEmwxGsx#OEm#O#PIV#P;'SEm;'S;=`JY<%lOEm,e#6i]&WW&R,XOY#4lYZEmZ]#4l]^Em^r#4lrs#5nsw#4lwx#7bx#O#4l#O#P#8b#P;'S#4l;'S;=`#9s<%lO#4l,e#7i]&WW&R,XOY#4lYZEmZ]#4l]^Em^r#4lrs#5nsw#4lwx#.|x#O#4l#O#P#8b#P;'S#4l;'S;=`#9s<%lO#4l,e#8eRO;'S#4l;'S;=`#8n;=`O#4l,e#8w^&TS&WW&R,XOY#4lYZEmZ]#4l]^Em^r#4lrs#5nsw#4lwx#6bx#O#4l#O#P#8b#P;'S#4l;'S;=`#9s;=`<%l#4l<%lO#4l,e#9vP;=`<%l#4l0m#9|P;=`<%l#&_Fy#:^`&TS&WW&R,X&d!b&f#tOY#&_YZ8lZ]#&_]^8l^r#&_rs#'ksw#&_wx#(gx#O#&_#O#P#1w#P#o#&_#o#p#3d#p;'S#&_;'S;=`#9y;=`<%l##W<%lO#&_Fy#;cP;=`<%l##WFy#;qa&^7[&WW&R,X&f#tOY##WYZ)mZ]##W]^)m^r##Wrs#$lsw##Wwx#<vx#O##W#O#P#%p#P#o##W#o#p#3d#p#q##W#q#r#&_#r;'S##W;'S;=`#;`<%lO##WEc#=R_&^7[&WW&R,X&f#tOY#<vYZLoZ]#<v]^Lo^r#<vrs#>Qs#O#<v#O#P#>z#P#o#<v#o#p#-|#p#q#<v#q#r#*w#r;'S#<v;'S;=`#@n<%lO#<vEc#>XZ&^7[&R,XOrLorsNcs#OLo#O#P! Z#P#oLo#o#p@S#p#qLo#q#r=Q#r;'SLo;'S;=`!!o<%lOLoEc#?PW&^7[O#o#<v#o#p#*w#p#q#<v#q#r#*w#r;'S#<v;'S;=`#?i;=`<%l#*w<%lO#<vEc#?r^&WW&R,X&f#tOY#*wYZ=QZ]#*w]^=Q^r#*wrs#+ys#O#*w#O#P#,k#P#o#*w#o#p#-|#p;'S#*w;'S;=`#1q;=`<%l#<v<%lO#*wEc#@qP;=`<%l#<vGZ#@yW&^7[O#o!MY#o#p#Ac#p#q!MY#q#r#Ac#r;'S!MY;'S;=`#Fl;=`<%l#Ac<%lO!MY0}#Ar_&TS&WW&R,X&Z`&d!b&f#tOY#AcYZ!#dZ]#Ac]^!#d^r#Acrs#Bqsw#Acwx#(gx#O#Ac#O#P#Co#P#o#Ac#o#p#E^#p;'S#Ac;'S;=`#Ff<%lO#Ac0}#B|Z&TS&R,X&Z`&d!bOr!#drs!%`sw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W<%lO!#d0}#CrRO;'S#Ac;'S;=`#C{;=`O#Ac0}#D[`&TS&WW&R,X&Z`&d!b&f#tOY#AcYZ!#dZ]#Ac]^!#d^r#Acrs#Bqsw#Acwx#(gx#O#Ac#O#P#Co#P#o#Ac#o#p#E^#p;'S#Ac;'S;=`#Ff;=`<%l#Ac<%lO#Ac0}#Eg_&TS&WW&R,XOY#4lYZEmZ]#4l]^Em^r#4lrs#5nsw#4lwx#6bx#O#4l#O#P#8b#P#o#4l#o#p#Ac#p;'S#4l;'S;=`#9s<%lO#4l0}#FiP;=`<%l#AcGZ#F{`&TS&WW&R,X&Z`&d!b&f#tOY#AcYZ!#dZ]#Ac]^!#d^r#Acrs#Bqsw#Acwx#(gx#O#Ac#O#P#Co#P#o#Ac#o#p#E^#p;'S#Ac;'S;=`#Ff;=`<%l!MY<%lO#AcGZ#HQP;=`<%l!MYGZ#Hb]&^7[&TS&R,X&Z`&d!bOr'crs#IZsw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'cGZ#IjZ&X#|&^7[&TS&V,X&Z`&d!bOw!-kwx-sx#O!-k#O#P!.i#P#o!-k#o#p!(V#p#q!-k#q#r!&[#r;'S!-k;'S;=`!0P<%lO!-kMg#JpaQ1s&^7[&TS&WW&Z`&ap&d!b&f#tOY#J]YZ%TZ]#J]]^%T^r#J]rs#Kusw#J]wx%;ax#O#J]#O#P& a#P#o#J]#o#p&%b#p#q#J]#q#r&!^#r;'S#J];'S;=`&'u<%lO#J]Lu#LSaQ1s&^7[&TS&Z`&d!bOY#MXYZ'cZ]#MX]^'c^r#MXrs%6usw#MXwx#Nox#O#MX#O#P%*Z#P#o#MX#o#p%4^#p#q#MX#q#r%+W#r;'S#MX;'S;=`%6o<%lO#MXLu#MjaQ1s&^7[&TS&WW&Z`&d!b&f#tOY#MXYZ'cZ]#MX]^'c^r#MXrs#Kusw#MXwx#Nox#O#MX#O#P%*Z#P#o#MX#o#p%4^#p#q#MX#q#r%+W#r;'S#MX;'S;=`%6o<%lO#MXLe#NzaQ1s&^7[&WW&f#tOY$!PYZ)mZ]$!P]^)m^r$!Prs$#esw$!Pwx%#ix#O$!P#O#P$6g#P#o$!P#o#p$Hf#p#q$!P#q#r$7d#r;'S$!P;'S;=`%#c<%lO$!PLe$!`aQ1s&^7[&TS&WW&d!b&f#tOY$!PYZ)mZ]$!P]^)m^r$!Prs$#esw$!Pwx#Nox#O$!P#O#P$6g#P#o$!P#o#p$Hf#p#q$!P#q#r$7d#r;'S$!P;'S;=`%#c<%lO$!PLe$#paQ1s&^7[&TS&d!bOY$!PYZ)mZ]$!P]^)m^r$!Prs$$usw$!Pwx#Nox#O$!P#O#P$6g#P#o$!P#o#p$Hf#p#q$!P#q#r$7d#r;'S$!P;'S;=`%#c<%lO$!PLe$%QaQ1s&^7[&TS&d!bOY$!PYZ)mZ]$!P]^)m^r$!Prs$&Vsw$!Pwx#Nox#O$!P#O#P$6g#P#o$!P#o#p$Hf#p#q$!P#q#r$7d#r;'S$!P;'S;=`%#c<%lO$!PIg$&b_Q1s&^7[&TS&d!bOY$&VYZ,wZ]$&V]^,w^w$&Vwx$'ax#O$&V#O#P$+X#P#o$&V#o#p$0h#p#q$&V#q#r$,U#r;'S$&V;'S;=`$6a<%lO$&VIg$'h_Q1s&^7[OY$&VYZ,wZ]$&V]^,w^w$&Vwx$(gx#O$&V#O#P$+X#P#o$&V#o#p$0h#p#q$&V#q#r$,U#r;'S$&V;'S;=`$6a<%lO$&VIg$(n_Q1s&^7[OY$&VYZ,wZ]$&V]^,w^w$&Vwx$)mx#O$&V#O#P$+X#P#o$&V#o#p$0h#p#q$&V#q#r$,U#r;'S$&V;'S;=`$6a<%lO$&VHP$)tZQ1s&^7[OY$)mYZ/cZ]$)m]^/c^#o$)m#o#p$*g#p#q$)m#q#r$*g#r;'S$)m;'S;=`$+R<%lO$)m1s$*lTQ1sOY$*gZ]$*g^;'S$*g;'S;=`$*{<%lO$*g1s$+OP;=`<%l$*gHP$+UP;=`<%l$)mIg$+`[Q1s&^7[OY$&VYZ,wZ]$&V]^,w^#o$&V#o#p$,U#p#q$&V#q#r$,U#r;'S$&V;'S;=`$5j;=`<%l0l<%lO$&V3Z$,_]Q1s&TS&d!bOY$,UYZ0lZ]$,U]^0l^w$,Uwx$-Wx#O$,U#O#P$/S#P#o$,U#o#p$0h#p;'S$,U;'S;=`$5d<%lO$,U3Z$-]]Q1sOY$,UYZ0lZ]$,U]^0l^w$,Uwx$.Ux#O$,U#O#P$/S#P#o$,U#o#p$0h#p;'S$,U;'S;=`$5d<%lO$,U3Z$.Z]Q1sOY$,UYZ0lZ]$,U]^0l^w$,Uwx$*gx#O$,U#O#P$/S#P#o$,U#o#p$0h#p;'S$,U;'S;=`$5d<%lO$,U3Z$/XWQ1sOY$,UYZ0lZ]$,U]^0l^;'S$,U;'S;=`$/q;=`<%l0l<%lO$,U3Z$/xY&TS&d!bOw0lwx1`x#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z;=`<%l$,U<%lO0l3Z$0o]Q1s&TSOY$1hYZ4`Z]$1h]^4`^w$1hwx$2bx#O$1h#O#P$4Q#P#o$1h#o#p$,U#p;'S$1h;'S;=`$5^<%lO$1h1w$1oZQ1s&TSOY$1hYZ4`Z]$1h]^4`^w$1hwx$2bx#O$1h#O#P$4Q#P;'S$1h;'S;=`$5^<%lO$1h1w$2gZQ1sOY$1hYZ4`Z]$1h]^4`^w$1hwx$3Yx#O$1h#O#P$4Q#P;'S$1h;'S;=`$5^<%lO$1h1w$3_ZQ1sOY$1hYZ4`Z]$1h]^4`^w$1hwx$*gx#O$1h#O#P$4Q#P;'S$1h;'S;=`$5^<%lO$1h1w$4VWQ1sOY$1hYZ4`Z]$1h]^4`^;'S$1h;'S;=`$4o;=`<%l4`<%lO$1h1w$4tW&TSOw4`wx4zx#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l$1h<%lO4`1w$5aP;=`<%l$1h3Z$5gP;=`<%l$,UIg$5qY&TS&d!bOw0lwx1`x#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z;=`<%l$&V<%lO0lIg$6dP;=`<%l$&VLe$6n[Q1s&^7[OY$!PYZ)mZ]$!P]^)m^#o$!P#o#p$7d#p#q$!P#q#r$7d#r;'S$!P;'S;=`%!b;=`<%l8l<%lO$!P6X$7q_Q1s&TS&WW&d!b&f#tOY$7dYZ8lZ]$7d]^8l^r$7drs$8psw$7dwx$;Qx#O$7d#O#P$Fv#P#o$7d#o#p$Hf#p;'S$7d;'S;=`%![<%lO$7d6X$8y_Q1s&TS&d!bOY$7dYZ8lZ]$7d]^8l^r$7drs$9xsw$7dwx$;Qx#O$7d#O#P$Fv#P#o$7d#o#p$Hf#p;'S$7d;'S;=`%![<%lO$7d6X$:R_Q1s&TS&d!bOY$7dYZ8lZ]$7d]^8l^r$7drs$,Usw$7dwx$;Qx#O$7d#O#P$Fv#P#o$7d#o#p$Hf#p;'S$7d;'S;=`%![<%lO$7d6X$;Z_Q1s&WW&f#tOY$7dYZ8lZ]$7d]^8l^r$7drs$8psw$7dwx$<Yx#O$7d#O#P$Fv#P#o$7d#o#p$Hf#p;'S$7d;'S;=`%![<%lO$7d6X$<c_Q1s&WW&f#tOY$7dYZ8lZ]$7d]^8l^r$7drs$8psw$7dwx$=bx#O$7d#O#P$Fv#P#o$7d#o#p$Hf#p;'S$7d;'S;=`%![<%lO$7d4q$=k]Q1s&WW&f#tOY$=bYZ=QZ]$=b]^=Q^r$=brs$>ds#O$=b#O#P$@`#P#o$=b#o#p$At#p;'S$=b;'S;=`$Fp<%lO$=b4q$>i]Q1sOY$=bYZ=QZ]$=b]^=Q^r$=brs$?bs#O$=b#O#P$@`#P#o$=b#o#p$At#p;'S$=b;'S;=`$Fp<%lO$=b4q$?g]Q1sOY$=bYZ=QZ]$=b]^=Q^r$=brs$*gs#O$=b#O#P$@`#P#o$=b#o#p$At#p;'S$=b;'S;=`$Fp<%lO$=b4q$@eWQ1sOY$=bYZ=QZ]$=b]^=Q^;'S$=b;'S;=`$@};=`<%l=Q<%lO$=b4q$AUY&WW&f#tOr=Qrs=ts#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`;=`<%l$=b<%lO=Q4q$A{]Q1s&WWOY$BtYZ@tZ]$Bt]^@t^r$Btrs$Cns#O$Bt#O#P$E^#P#o$Bt#o#p$=b#p;'S$Bt;'S;=`$Fj<%lO$Bt1{$B{ZQ1s&WWOY$BtYZ@tZ]$Bt]^@t^r$Btrs$Cns#O$Bt#O#P$E^#P;'S$Bt;'S;=`$Fj<%lO$Bt1{$CsZQ1sOY$BtYZ@tZ]$Bt]^@t^r$Btrs$Dfs#O$Bt#O#P$E^#P;'S$Bt;'S;=`$Fj<%lO$Bt1{$DkZQ1sOY$BtYZ@tZ]$Bt]^@t^r$Btrs$*gs#O$Bt#O#P$E^#P;'S$Bt;'S;=`$Fj<%lO$Bt1{$EcWQ1sOY$BtYZ@tZ]$Bt]^@t^;'S$Bt;'S;=`$E{;=`<%l@t<%lO$Bt1{$FQW&WWOr@trsA`s#O@t#O#PB_#P;'S@t;'S;=`CY;=`<%l$Bt<%lO@t1{$FmP;=`<%l$Bt4q$FsP;=`<%l$=b6X$F{WQ1sOY$7dYZ8lZ]$7d]^8l^;'S$7d;'S;=`$Ge;=`<%l8l<%lO$7d6X$Gp[&TS&WW&d!b&f#tOr8lrs9jsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`;=`<%l$7d<%lO8l6X$Ho_Q1s&TS&WWOY$InYZEmZ]$In]^Em^r$Inrs$Jpsw$Inwx$Lpx#O$In#O#P$Np#P#o$In#o#p$7d#p;'S$In;'S;=`%!U<%lO$In2P$Iw]Q1s&TS&WWOY$InYZEmZ]$In]^Em^r$Inrs$Jpsw$Inwx$Lpx#O$In#O#P$Np#P;'S$In;'S;=`%!U<%lO$In2P$Jw]Q1s&TSOY$InYZEmZ]$In]^Em^r$Inrs$Kpsw$Inwx$Lpx#O$In#O#P$Np#P;'S$In;'S;=`%!U<%lO$In2P$Kw]Q1s&TSOY$InYZEmZ]$In]^Em^r$Inrs$1hsw$Inwx$Lpx#O$In#O#P$Np#P;'S$In;'S;=`%!U<%lO$In2P$Lw]Q1s&WWOY$InYZEmZ]$In]^Em^r$Inrs$Jpsw$Inwx$Mpx#O$In#O#P$Np#P;'S$In;'S;=`%!U<%lO$In2P$Mw]Q1s&WWOY$InYZEmZ]$In]^Em^r$Inrs$Jpsw$Inwx$Btx#O$In#O#P$Np#P;'S$In;'S;=`%!U<%lO$In2P$NuWQ1sOY$InYZEmZ]$In]^Em^;'S$In;'S;=`% _;=`<%lEm<%lO$In2P% fY&TS&WWOrEmrsFaswEmwxGsx#OEm#O#PIV#P;'SEm;'S;=`JY;=`<%l$In<%lOEm2P%!XP;=`<%l$In6X%!_P;=`<%l$7dLe%!m[&TS&WW&d!b&f#tOr8lrs9jsw8lwx;^x#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`;=`<%l$!P<%lO8lLe%#fP;=`<%l$!PLe%#taQ1s&^7[&WW&f#tOY$!PYZ)mZ]$!P]^)m^r$!Prs$#esw$!Pwx%$yx#O$!P#O#P$6g#P#o$!P#o#p$Hf#p#q$!P#q#r$7d#r;'S$!P;'S;=`%#c<%lO$!PJ}%%U_Q1s&^7[&WW&f#tOY%$yYZLoZ]%$y]^Lo^r%$yrs%&Ts#O%$y#O#P%(a#P#o%$y#o#p$At#p#q%$y#q#r$=b#r;'S%$y;'S;=`%*T<%lO%$yJ}%&[_Q1s&^7[OY%$yYZLoZ]%$y]^Lo^r%$yrs%'Zs#O%$y#O#P%(a#P#o%$y#o#p$At#p#q%$y#q#r$=b#r;'S%$y;'S;=`%*T<%lO%$yJ}%'b_Q1s&^7[OY%$yYZLoZ]%$y]^Lo^r%$yrs$)ms#O%$y#O#P%(a#P#o%$y#o#p$At#p#q%$y#q#r$=b#r;'S%$y;'S;=`%*T<%lO%$yJ}%(h[Q1s&^7[OY%$yYZLoZ]%$y]^Lo^#o%$y#o#p$=b#p#q%$y#q#r$=b#r;'S%$y;'S;=`%)^;=`<%l=Q<%lO%$yJ}%)eY&WW&f#tOr=Qrs=ts#O=Q#O#P?P#P#o=Q#o#p@S#p;'S=Q;'S;=`C`;=`<%l%$y<%lO=QJ}%*WP;=`<%l%$yLu%*b[Q1s&^7[OY#MXYZ'cZ]#MX]^'c^#o#MX#o#p%+W#p#q#MX#q#r%+W#r;'S#MX;'S;=`%5l;=`<%l!#d<%lO#MX6i%+g_Q1s&TS&WW&Z`&d!b&f#tOY%+WYZ!#dZ]%+W]^!#d^r%+Wrs%,fsw%+Wwx$;Qx#O%+W#O#P%2l#P#o%+W#o#p%4^#p;'S%+W;'S;=`%5f<%lO%+W6i%,q_Q1s&TS&Z`&d!bOY%+WYZ!#dZ]%+W]^!#d^r%+Wrs%-psw%+Wwx$;Qx#O%+W#O#P%2l#P#o%+W#o#p%4^#p;'S%+W;'S;=`%5f<%lO%+W6i%-{_Q1s&TS&Z`&d!bOY%+WYZ!#dZ]%+W]^!#d^r%+Wrs%.zsw%+Wwx$;Qx#O%+W#O#P%2l#P#o%+W#o#p%4^#p;'S%+W;'S;=`%5f<%lO%+W3k%/V]Q1s&TS&Z`&d!bOY%.zYZ!&[Z]%.z]^!&[^w%.zwx$-Wx#O%.z#O#P%0O#P#o%.z#o#p%1f#p;'S%.z;'S;=`%2f<%lO%.z3k%0TWQ1sOY%.zYZ!&[Z]%.z]^!&[^;'S%.z;'S;=`%0m;=`<%l!&[<%lO%.z3k%0vY&TS&Z`&d!bOw!&[wx1`x#O!&[#O#P!'Q#P#o!&[#o#p!(V#p;'S!&[;'S;=`!(w;=`<%l%.z<%lO!&[3k%1m]Q1s&TSOY$1hYZ4`Z]$1h]^4`^w$1hwx$2bx#O$1h#O#P$4Q#P#o$1h#o#p%.z#p;'S$1h;'S;=`$5^<%lO$1h3k%2iP;=`<%l%.z6i%2qWQ1sOY%+WYZ!#dZ]%+W]^!#d^;'S%+W;'S;=`%3Z;=`<%l!#d<%lO%+W6i%3h[&TS&WW&Z`&d!b&f#tOr!#drs!$dsw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W;=`<%l%+W<%lO!#d6i%4g_Q1s&TS&WWOY$InYZEmZ]$In]^Em^r$Inrs$Jpsw$Inwx$Lpx#O$In#O#P$Np#P#o$In#o#p%+W#p;'S$In;'S;=`%!U<%lO$In6i%5iP;=`<%l%+WLu%5y[&TS&WW&Z`&d!b&f#tOr!#drs!$dsw!#dwx;^x#O!#d#O#P!(}#P#o!#d#o#p!*^#p;'S!#d;'S;=`!+W;=`<%l#MX<%lO!#dLu%6rP;=`<%l#MXLu%7SaQ1s&^7[&TS&Z`&d!bOY#MXYZ'cZ]#MX]^'c^r#MXrs%8Xsw#MXwx#Nox#O#MX#O#P%*Z#P#o#MX#o#p%4^#p#q#MX#q#r%+W#r;'S#MX;'S;=`%6o<%lO#MXIw%8f_Q1s&^7[&TS&Z`&d!bOY%8XYZ!-kZ]%8X]^!-k^w%8Xwx$'ax#O%8X#O#P%9e#P#o%8X#o#p%1f#p#q%8X#q#r%.z#r;'S%8X;'S;=`%;Z<%lO%8XIw%9l[Q1s&^7[OY%8XYZ!-kZ]%8X]^!-k^#o%8X#o#p%.z#p#q%8X#q#r%.z#r;'S%8X;'S;=`%:b;=`<%l!&[<%lO%8XIw%:kY&TS&Z`&d!bOw!&[wx1`x#O!&[#O#P!'Q#P#o!&[#o#p!(V#p;'S!&[;'S;=`!(w;=`<%l%8X<%lO!&[Iw%;^P;=`<%l%8XMV%;naQ1s&^7[&WW&ap&f#tOY%<sYZ!1ZZ]%<s]^!1Z^r%<srs$#esw%<swx%Jux#O%<s#O#P%>Z#P#o%<s#o#p%H^#p#q%<s#q#r%?W#r;'S%<s;'S;=`%Jo<%lO%<sMV%=UaQ1s&^7[&TS&WW&ap&d!b&f#tOY%<sYZ!1ZZ]%<s]^!1Z^r%<srs$#esw%<swx%;ax#O%<s#O#P%>Z#P#o%<s#o#p%H^#p#q%<s#q#r%?W#r;'S%<s;'S;=`%Jo<%lO%<sMV%>b[Q1s&^7[OY%<sYZ!1ZZ]%<s]^!1Z^#o%<s#o#p%?W#p#q%<s#q#r%?W#r;'S%<s;'S;=`%Il;=`<%l!3Q<%lO%<s6y%?g_Q1s&TS&WW&ap&d!b&f#tOY%?WYZ!3QZ]%?W]^!3Q^r%?Wrs$8psw%?Wwx%@fx#O%?W#O#P%Fl#P#o%?W#o#p%H^#p;'S%?W;'S;=`%If<%lO%?W6y%@q_Q1s&WW&ap&f#tOY%?WYZ!3QZ]%?W]^!3Q^r%?Wrs$8psw%?Wwx%Apx#O%?W#O#P%Fl#P#o%?W#o#p%H^#p;'S%?W;'S;=`%If<%lO%?W6y%A{_Q1s&WW&ap&f#tOY%?WYZ!3QZ]%?W]^!3Q^r%?Wrs$8psw%?Wwx%Bzx#O%?W#O#P%Fl#P#o%?W#o#p%H^#p;'S%?W;'S;=`%If<%lO%?W5c%CV]Q1s&WW&ap&f#tOY%BzYZ!5xZ]%Bz]^!5x^r%Bzrs$>ds#O%Bz#O#P%DO#P#o%Bz#o#p%Ef#p;'S%Bz;'S;=`%Ff<%lO%Bz5c%DTWQ1sOY%BzYZ!5xZ]%Bz]^!5x^;'S%Bz;'S;=`%Dm;=`<%l!5x<%lO%Bz5c%DvY&WW&ap&f#tOr!5xrs=ts#O!5x#O#P!6n#P#o!5x#o#p!7s#p;'S!5x;'S;=`!8e;=`<%l%Bz<%lO!5x5c%Em]Q1s&WWOY$BtYZ@tZ]$Bt]^@t^r$Btrs$Cns#O$Bt#O#P$E^#P#o$Bt#o#p%Bz#p;'S$Bt;'S;=`$Fj<%lO$Bt5c%FiP;=`<%l%Bz6y%FqWQ1sOY%?WYZ!3QZ]%?W]^!3Q^;'S%?W;'S;=`%GZ;=`<%l!3Q<%lO%?W6y%Gh[&TS&WW&ap&d!b&f#tOr!3Qrs9jsw!3Qwx!4Qx#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t;=`<%l%?W<%lO!3Q6y%Hg_Q1s&TS&WWOY$InYZEmZ]$In]^Em^r$Inrs$Jpsw$Inwx$Lpx#O$In#O#P$Np#P#o$In#o#p%?W#p;'S$In;'S;=`%!U<%lO$In6y%IiP;=`<%l%?WMV%Iy[&TS&WW&ap&d!b&f#tOr!3Qrs9jsw!3Qwx!4Qx#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t;=`<%l%<s<%lO!3QMV%JrP;=`<%l%<sMV%KSaQ1s&^7[&WW&ap&f#tOY%<sYZ!1ZZ]%<s]^!1Z^r%<srs$#esw%<swx%LXx#O%<s#O#P%>Z#P#o%<s#o#p%H^#p#q%<s#q#r%?W#r;'S%<s;'S;=`%Jo<%lO%<sKo%Lf_Q1s&^7[&WW&ap&f#tOY%LXYZ!=XZ]%LX]^!=X^r%LXrs%&Ts#O%LX#O#P%Me#P#o%LX#o#p%Ef#p#q%LX#q#r%Bz#r;'S%LX;'S;=`& Z<%lO%LXKo%Ml[Q1s&^7[OY%LXYZ!=XZ]%LX]^!=X^#o%LX#o#p%Bz#p#q%LX#q#r%Bz#r;'S%LX;'S;=`%Nb;=`<%l!5x<%lO%LXKo%NkY&WW&ap&f#tOr!5xrs=ts#O!5x#O#P!6n#P#o!5x#o#p!7s#p;'S!5x;'S;=`!8e;=`<%l%LX<%lO!5xKo& ^P;=`<%l%LXMg& h[Q1s&^7[OY#J]YZ%TZ]#J]]^%T^#o#J]#o#p&!^#p#q#J]#q#r&!^#r;'S#J];'S;=`&&p;=`<%l!@b<%lO#J]7Z&!o_Q1s&TS&WW&Z`&ap&d!b&f#tOY&!^YZ!@bZ]&!^]^!@b^r&!^rs%,fsw&!^wx%@fx#O&!^#O#P&#n#P#o&!^#o#p&%b#p;'S&!^;'S;=`&&j<%lO&!^7Z&#sWQ1sOY&!^YZ!@bZ]&!^]^!@b^;'S&!^;'S;=`&$];=`<%l!@b<%lO&!^7Z&$l[&TS&WW&Z`&ap&d!b&f#tOr!@brs!$dsw!@bwx!4Qx#O!@b#O#P!Ad#P#o!@b#o#p!Bu#p;'S!@b;'S;=`!Co;=`<%l&!^<%lO!@b7Z&%k_Q1s&TS&WWOY$InYZEmZ]$In]^Em^r$Inrs$Jpsw$Inwx$Lpx#O$In#O#P$Np#P#o$In#o#p&!^#p;'S$In;'S;=`%!U<%lO$In7Z&&mP;=`<%l&!^Mg&'P[&TS&WW&Z`&ap&d!b&f#tOr!@brs!$dsw!@bwx!4Qx#O!@b#O#P!Ad#P#o!@b#o#p!Bu#p;'S!@b;'S;=`!Co;=`<%l#J]<%lO!@bMg&'xP;=`<%l#J]Gz&(`_%jQ&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGz&)r]!s,W&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGz&+O_%dQ&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{&,^a&_`&^7[&WW&R,X&ap&f#tOY&-cYZ!1ZZ]&-c]^!1Z^r&-crs&.ysw&-cwx'(^x#O&-c#O#P&N}#P#o&-c#o#p'%g#p#q&-c#q#r' l#r;'S&-c;'S;=`'(W<%lO&-cGk&-ta&^7[&TS&WW&R,X&ap&d!b&f#tOY&-cYZ!1ZZ]&-c]^!1Z^r&-crs&.ysw&-cwx&Mwx#O&-c#O#P&N}#P#o&-c#o#p'%g#p#q&-c#q#r' l#r;'S&-c;'S;=`'(W<%lO&-cFy&/Ua&^7[&TS&R,X&d!bOY&0ZYZ)mZ]&0Z]^)m^r&0Zrs&Hisw&0Zwx&1ox#O&0Z#O#P&2s#P#o&0Z#o#p&@g#p#q&0Z#q#r&3b#r;'S&0Z;'S;=`&Hc<%lO&0ZFy&0ja&^7[&TS&WW&R,X&d!b&f#tOY&0ZYZ)mZ]&0Z]^)m^r&0Zrs&.ysw&0Zwx&1ox#O&0Z#O#P&2s#P#o&0Z#o#p&@g#p#q&0Z#q#r&3b#r;'S&0Z;'S;=`&Hc<%lO&0ZFy&1z]&^7[&WW&R,X&f#tOr)mrs*ssw)mwxKmx#O)m#O#P7}#P#o)m#o#pDs#p#q)m#q#r8l#r;'S)m;'S;=`Kg<%lO)mFy&2xW&^7[O#o&0Z#o#p&3b#p#q&0Z#q#r&3b#r;'S&0Z;'S;=`&GS;=`<%l&3b<%lO&0Z0m&3o_&TS&WW&R,X&d!b&f#tOY&3bYZ8lZ]&3b]^8l^r&3brs&4nsw&3bwx&>Ox#O&3b#O#P&>z#P#o&3b#o#p&@g#p;'S&3b;'S;=`&F|<%lO&3b0m&4w_&TS&R,X&d!bOY&3bYZ8lZ]&3b]^8l^r&3brs&5vsw&3bwx&>Ox#O&3b#O#P&>z#P#o&3b#o#p&@g#p;'S&3b;'S;=`&F|<%lO&3b0m&6P_&TS&R,X&d!bOY&3bYZ8lZ]&3b]^8l^r&3brs&7Osw&3bwx&>Ox#O&3b#O#P&>z#P#o&3b#o#p&@g#p;'S&3b;'S;=`&F|<%lO&3b-o&7X]&TS&R,X&d!bOY&7OYZ0lZ]&7O]^0l^w&7Owx&8Qx#O&7O#O#P&8r#P#o&7O#o#p&:T#p;'S&7O;'S;=`&=x<%lO&7O-o&8VX&R,XOw0lwx2Ox#O0l#O#P2k#P#o0l#o#p3n#p;'S0l;'S;=`6z<%lO0l-o&8uRO;'S&7O;'S;=`&9O;=`O&7O-o&9X^&TS&R,X&d!bOY&7OYZ0lZ]&7O]^0l^w&7Owx&8Qx#O&7O#O#P&8r#P#o&7O#o#p&:T#p;'S&7O;'S;=`&=x;=`<%l&7O<%lO&7O-o&:[]&TS&R,XOY&;TYZ4`Z]&;T]^4`^w&;Twx&;}x#O&;T#O#P&<i#P#o&;T#o#p&7O#p;'S&;T;'S;=`&=r<%lO&;T,]&;[Z&TS&R,XOY&;TYZ4`Z]&;T]^4`^w&;Twx&;}x#O&;T#O#P&<i#P;'S&;T;'S;=`&=r<%lO&;T,]&<SV&R,XOw4`wx5dx#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`,]&<lRO;'S&;T;'S;=`&<u;=`O&;T,]&<|[&TS&R,XOY&;TYZ4`Z]&;T]^4`^w&;Twx&;}x#O&;T#O#P&<i#P;'S&;T;'S;=`&=r;=`<%l&;T<%lO&;T,]&=uP;=`<%l&;T-o&={P;=`<%l&7O0m&>XZ&WW&R,X&f#tOr8lrs9jsw8lwx<Wx#O8l#O#PCf#P#o8l#o#pDs#p;'S8l;'S;=`J`<%lO8l0m&>}RO;'S&3b;'S;=`&?W;=`O&3b0m&?e`&TS&WW&R,X&d!b&f#tOY&3bYZ8lZ]&3b]^8l^r&3brs&4nsw&3bwx&>Ox#O&3b#O#P&>z#P#o&3b#o#p&@g#p;'S&3b;'S;=`&F|;=`<%l&3b<%lO&3b0m&@p_&TS&WW&R,XOY&AoYZEmZ]&Ao]^Em^r&Aors&Bqsw&Aowx&Dqx#O&Ao#O#P&Ee#P#o&Ao#o#p&3b#p;'S&Ao;'S;=`&Fv<%lO&Ao,e&Ax]&TS&WW&R,XOY&AoYZEmZ]&Ao]^Em^r&Aors&Bqsw&Aowx&Dqx#O&Ao#O#P&Ee#P;'S&Ao;'S;=`&Fv<%lO&Ao,e&Bx]&TS&R,XOY&AoYZEmZ]&Ao]^Em^r&Aors&Cqsw&Aowx&Dqx#O&Ao#O#P&Ee#P;'S&Ao;'S;=`&Fv<%lO&Ao,e&Cx]&TS&R,XOY&AoYZEmZ]&Ao]^Em^r&Aors&;Tsw&Aowx&Dqx#O&Ao#O#P&Ee#P;'S&Ao;'S;=`&Fv<%lO&Ao,e&DxX&WW&R,XOrEmrsFaswEmwxHex#OEm#O#PIV#P;'SEm;'S;=`JY<%lOEm,e&EhRO;'S&Ao;'S;=`&Eq;=`O&Ao,e&Ez^&TS&WW&R,XOY&AoYZEmZ]&Ao]^Em^r&Aors&Bqsw&Aowx&Dqx#O&Ao#O#P&Ee#P;'S&Ao;'S;=`&Fv;=`<%l&Ao<%lO&Ao,e&FyP;=`<%l&Ao0m&GPP;=`<%l&3bFy&Ga`&TS&WW&R,X&d!b&f#tOY&3bYZ8lZ]&3b]^8l^r&3brs&4nsw&3bwx&>Ox#O&3b#O#P&>z#P#o&3b#o#p&@g#p;'S&3b;'S;=`&F|;=`<%l&0Z<%lO&3bFy&HfP;=`<%l&0ZFy&Hta&^7[&TS&R,X&d!bOY&0ZYZ)mZ]&0Z]^)m^r&0Zrs&Iysw&0Zwx&1ox#O&0Z#O#P&2s#P#o&0Z#o#p&@g#p#q&0Z#q#r&3b#r;'S&0Z;'S;=`&Hc<%lO&0ZC{&JU_&^7[&TS&R,X&d!bOY&IyYZ,wZ]&Iy]^,w^w&Iywx&KTx#O&Iy#O#P&K}#P#o&Iy#o#p&:T#p#q&Iy#q#r&7O#r;'S&Iy;'S;=`&Mq<%lO&IyC{&K[Z&^7[&R,XOw,wwx.kx#O,w#O#P/}#P#o,w#o#p3n#p#q,w#q#r0l#r;'S,w;'S;=`7w<%lO,wC{&LSW&^7[O#o&Iy#o#p&7O#p#q&Iy#q#r&7O#r;'S&Iy;'S;=`&Ll;=`<%l&7O<%lO&IyC{&Lu^&TS&R,X&d!bOY&7OYZ0lZ]&7O]^0l^w&7Owx&8Qx#O&7O#O#P&8r#P#o&7O#o#p&:T#p;'S&7O;'S;=`&=x;=`<%l&Iy<%lO&7OC{&MtP;=`<%l&IyGk&NU]&^7[&WW&R,X&ap&f#tOr!1Zrs*ssw!1Zwx!<Tx#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1ZGk' SW&^7[O#o&-c#o#p' l#p#q&-c#q#r' l#r;'S&-c;'S;=`'&u;=`<%l' l<%lO&-c1_' {_&TS&WW&R,X&ap&d!b&f#tOY' lYZ!3QZ]' l]^!3Q^r' lrs&4nsw' lwx'!zx#O' l#O#P'#x#P#o' l#o#p'%g#p;'S' l;'S;=`'&o<%lO' l1_'#VZ&WW&R,X&ap&f#tOr!3Qrs9jsw!3Qwx!4|x#O!3Q#O#P!8k#P#o!3Q#o#p!9z#p;'S!3Q;'S;=`!:t<%lO!3Q1_'#{RO;'S' l;'S;=`'$U;=`O' l1_'$e`&TS&WW&R,X&ap&d!b&f#tOY' lYZ!3QZ]' l]^!3Q^r' lrs&4nsw' lwx'!zx#O' l#O#P'#x#P#o' l#o#p'%g#p;'S' l;'S;=`'&o;=`<%l' l<%lO' l1_'%p_&TS&WW&R,XOY&AoYZEmZ]&Ao]^Em^r&Aors&Bqsw&Aowx&Dqx#O&Ao#O#P&Ee#P#o&Ao#o#p' l#p;'S&Ao;'S;=`&Fv<%lO&Ao1_'&rP;=`<%l' lGk''U`&TS&WW&R,X&ap&d!b&f#tOY' lYZ!3QZ]' l]^!3Q^r' lrs&4nsw' lwx'!zx#O' l#O#P'#x#P#o' l#o#p'%g#p;'S' l;'S;=`'&o;=`<%l&-c<%lO' lGk'(ZP;=`<%l&-cGk'(k]&^7[&WW&R,X&ap&f#tOr!1Zrs*ssw!1Zwx')dx#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1ZGk')sZ&U!f&^7[&WW&S,X&ap&f#tOr!=XrsMks#O!=X#O#P!>V#P#o!=X#o#p!7s#p#q!=X#q#r!5x#r;'S!=X;'S;=`!?m<%lO!=XG{'*y]f,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<u',V]eR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{'-caT,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vxz%Tz{'.h{!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{'.{__R&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{'0__%g,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<u'1q]xR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TMg'2}`%h,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`!a'4P!a#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TB^'4d]&q&j&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{'5pa!dQ&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!O%T!O!P'6u!P!Q%T!Q!['9c![#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{'7W_&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!O%T!O!P'8V!P#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{'8j]!m,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'9vi!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!['9c![!g%T!g!h';e!h!l%T!l!m'@X!m#O%T#O#P!?s#P#R%T#R#S'9c#S#X%T#X#Y';e#Y#^%T#^#_'@X#_#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy';vc&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx{%T{|'=R|}%T}!O'=R!O!Q%T!Q!['>c![#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'=d_&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!['>c![#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'>ve!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!['>c![!l%T!l!m'@X!m#O%T#O#P!?s#P#R%T#R#S'>c#S#^%T#^#_'@X#_#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'@l]!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{'Axa%iR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!P%T!P!Q'B}!Q!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGz'Cb_%kQ&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'Dtw!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!O%T!O!P'G_!P!Q%T!Q!['Ho![!d%T!d!e'Jw!e!g%T!g!h';e!h!l%T!l!m'@X!m!q%T!q!r'M}!r!z%T!z!{(!}!{#O%T#O#P!?s#P#R%T#R#S'Ho#S#U%T#U#V'Jw#V#X%T#X#Y';e#Y#^%T#^#_'@X#_#c%T#c#d'M}#d#l%T#l#m(!}#m#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'Gp_&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!['9c![#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'ISk!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!O%T!O!P'G_!P!Q%T!Q!['Ho![!g%T!g!h';e!h!l%T!l!m'@X!m#O%T#O#P!?s#P#R%T#R#S'Ho#S#X%T#X#Y';e#Y#^%T#^#_'@X#_#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'KYb&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!R'Lb!R!S'Lb!S#O%T#O#P!?s#P#R%T#R#S'Lb#S#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'Lub!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!R'Lb!R!S'Lb!S#O%T#O#P!?s#P#R%T#R#S'Lb#S#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy'N`a&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!Y( e!Y#O%T#O#P!?s#P#R%T#R#S( e#S#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy( xa!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q!Y( e!Y#O%T#O#P!?s#P#R%T#R#S( e#S#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy(#`e&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q![($q![!c%T!c!i($q!i#O%T#O#P!?s#P#R%T#R#S($q#S#T%T#T#Z($q#Z#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy(%Ue!f,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!Q%T!Q![($q![!c%T!c!i($q!i#O%T#O#P!?s#P#R%T#R#S($q#S#T%T#T#Z($q#Z#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TMg(&z_y1s&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`('y!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<u((^]%sR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{()j]#^,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{(*vakR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!^%T!^!_(+{!_!`!I[!`!a!I[!a#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGz(,`_%eQ&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{(-r_%r,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`!I[!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{(/U`kR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`!I[!`!a(0W!a#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGz(0k_%fQ&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TG{(2P_]Q#tP&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TMg(3ee&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr%Trs&_sw%Twx!0Vx!Q%T!Q![(3O![!c%T!c!}(3O!}#O%T#O#P!?s#P#R%T#R#S(3O#S#T%T#T#o(3O#o#p!Bu#p#q%T#q#r!@b#r$g%T$g;'S(3O;'S;=`(4v<%lO(3OMg(4yP;=`<%l(3OMg(5ci&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr%Trs(7Qsw%Twx(:jx!Q%T!Q![(3O![!c%T!c!t(3O!t!u(>S!u!}(3O!}#O%T#O#P!?s#P#R%T#R#S(3O#S#T%T#T#f(3O#f#g(>S#g#o(3O#o#p!Bu#p#q%T#q#r!@b#r$g%T$g;'S(3O;'S;=`(4v<%lO(3OGZ(7_a&^7[&TS&R,X&Z`&d!bOY!MYYZ'cZ]!MY]^'c^r!MYrs(8dsw!MYwx# vx#O!MY#O#P#@t#P#o!MY#o#p#E^#p#q!MY#q#r#Ac#r;'S!MY;'S;=`#G}<%lO!MYGZ(8q]&^7[&TS&R,X&Z`&d!bOr'crs(9jsw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'cD](9wZ&^7[&TS&V,X&Z`&d!bOw!-kwx-sx#O!-k#O#P!.i#P#o!-k#o#p!(V#p#q!-k#q#r!&[#r;'S!-k;'S;=`!0P<%lO!-kGk(:wa&^7[&WW&R,X&ap&f#tOY&-cYZ!1ZZ]&-c]^!1Z^r&-crs&.ysw&-cwx(;|x#O&-c#O#P&N}#P#o&-c#o#p'%g#p#q&-c#q#r' l#r;'S&-c;'S;=`'(W<%lO&-cGk(<Z]&^7[&WW&R,X&ap&f#tOr!1Zrs*ssw!1Zwx(=Sx#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1ZFT(=aZ&^7[&WW&S,X&ap&f#tOr!=XrsMks#O!=X#O#P!>V#P#o!=X#o#p!7s#p#q!=X#q#r!5x#r;'S!=X;'S;=`!?m<%lO!=XMg(>ie&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr%Trs(7Qsw%Twx(:jx!Q%T!Q![(3O![!c%T!c!}(3O!}#O%T#O#P!?s#P#R%T#R#S(3O#S#T%T#T#o(3O#o#p!Bu#p#q%T#q#r!@b#r$g%T$g;'S(3O;'S;=`(4v<%lO(3OMg(@ai&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr%Trs(BOsw%Twx(EYx!Q%T!Q![(3O![!c%T!c!t(3O!t!u(Hd!u!}(3O!}#O%T#O#P!?s#P#R%T#R#S(3O#S#T%T#T#f(3O#f#g(Hd#g#o(3O#o#p!Bu#p#q%T#q#r!@b#r$g%T$g;'S(3O;'S;=`(4v<%lO(3OGZ(B]]&^7[&TS&Z`&d!b&`,XOr'crs(CUsw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'cGZ(Ca]&^7[&TS&Z`&d!bOr'crs(DYsw'cwx(kx#O'c#O#P!!u#P#o'c#o#p!*^#p#q'c#q#r!#d#r;'S'c;'S;=`!,a<%lO'cD](DgZ&^7[&TS&e,X&Z`&d!bOw!-kwx-sx#O!-k#O#P!.i#P#o!-k#o#p!(V#p#q!-k#q#r!&[#r;'S!-k;'S;=`!0P<%lO!-kGk(Eg]&^7[&WW&ap&f#t&Y,XOr!1Zrs*ssw!1Zwx(F`x#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1ZGk(Fk]&^7[&WW&ap&f#tOr!1Zrs*ssw!1Zwx(Gdx#O!1Z#O#P!2c#P#o!1Z#o#p!9z#p#q!1Z#q#r!3Q#r;'S!1Z;'S;=`!;}<%lO!1ZFT(GqZ&^7[&WW&c,X&ap&f#tOr!=XrsMks#O!=X#O#P!>V#P#o!=X#o#p!7s#p#q!=X#q#r!5x#r;'S!=X;'S;=`!?m<%lO!=XMg(Hye&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr%Trs(BOsw%Twx(EYx!Q%T!Q![(3O![!c%T!c!}(3O!}#O%T#O#P!?s#P#R%T#R#S(3O#S#T%T#T#o(3O#o#p!Bu#p#q%T#q#r!@b#r$g%T$g;'S(3O;'S;=`(4v<%lO(3OMg(Jqm&^7[&TS&WW&Q&j&Z`&ap&d!b&f#t%m,XOr%Trs(7Qsw%Twx(:jx!Q%T!Q![(3O![!c%T!c!h(3O!h!i(Hd!i!t(3O!t!u(>S!u!}(3O!}#O%T#O#P!?s#P#R%T#R#S(3O#S#T%T#T#U(3O#U#V(>S#V#Y(3O#Y#Z(Hd#Z#o(3O#o#p!Bu#p#q%T#q#r!@b#r$g%T$g;'S(3O;'S;=`(4v<%lO(3OG{(MP]!V,X&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<u(N]]!UR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGz) i_%cQ&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%TGy)!qZ&TS&WW!ZGmOrEmrsFaswEmwxGsx#OEm#O#PIV#P#oEm#o#p!@b#p;'SEm;'S;=`JY<%lOEmG{)#w_%bR&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx!_%T!_!`&)_!`#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T<u)%XZ!Y7_&TS&WW&Z`&ap&d!b&f#tOr!@brs!$dsw!@bwx!4Qx#O!@b#O#P!Ad#P#o!@b#o#p!Bu#p;'S!@b;'S;=`!Co<%lO!@bGy)&_]%l,V&^7[&TS&WW&Z`&ap&d!b&f#tOr%Trs&_sw%Twx!0Vx#O%T#O#P!?s#P#o%T#o#p!Bu#p#q%T#q#r!@b#r;'S%T;'S;=`!Dz<%lO%T",
  tokenizers: [hW, oW, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, sW],
  topRules: { Script: [0, 3] },
  specialized: [{ term: 213, get: (O) => fW[O] || -1 }],
  tokenPrec: 7282
});
var Hu = new e$();
var sm = /* @__PURE__ */ new Set([
  "Script",
  "Body",
  "FunctionDefinition",
  "ClassDefinition",
  "LambdaExpression",
  "ForStatement",
  "MatchClause"
]);
function An(O) {
  return (e, t, i) => {
    if (i)
      return false;
    let n = e.node.getChild("VariableName");
    return n && t(n, O), true;
  };
}
var QW = {
  FunctionDefinition: An("function"),
  ClassDefinition: An("class"),
  ForStatement(O, e, t) {
    if (t) {
      for (let i = O.node.firstChild; i; i = i.nextSibling)
        if (i.name == "VariableName")
          e(i, "variable");
        else if (i.name == "in")
          break;
    }
  },
  ImportStatement(O, e) {
    var t, i;
    let { node: n } = O, r = ((t = n.firstChild) === null || t === void 0 ? void 0 : t.name) == "from";
    for (let s = n.getChild("import"); s; s = s.nextSibling)
      s.name == "VariableName" && ((i = s.nextSibling) === null || i === void 0 ? void 0 : i.name) != "as" && e(s, r ? "variable" : "namespace");
  },
  AssignStatement(O, e) {
    for (let t = O.node.firstChild; t; t = t.nextSibling)
      if (t.name == "VariableName")
        e(t, "variable");
      else if (t.name == ":" || t.name == "AssignOp")
        break;
  },
  ParamList(O, e) {
    for (let t = null, i = O.node.firstChild; i; i = i.nextSibling)
      i.name == "VariableName" && (!t || !/\*|AssignOp/.test(t.name)) && e(i, "variable"), t = i;
  },
  CapturePattern: An("variable"),
  AsPattern: An("variable"),
  __proto__: null
};
function om(O, e) {
  let t = Hu.get(e);
  if (t)
    return t;
  let i = [], n = true;
  function r(s, o) {
    let a = O.sliceString(s.from, s.to);
    i.push({ label: a, type: o });
  }
  return e.cursor(K.IncludeAnonymous).iterate((s) => {
    if (s.name) {
      let o = QW[s.name];
      if (o && o(s, r, n) || !n && sm.has(s.name))
        return false;
      n = false;
    } else if (s.to - s.from > 8192) {
      for (let o of om(O, s.node))
        i.push(o);
      return false;
    }
  }), Hu.set(e, i), i;
}
var Ku = /^[\w\xa1-\uffff][\w\d\xa1-\uffff]*$/;
var am = ["String", "FormatString", "Comment", "PropertyName"];
function $W(O) {
  let e = B(O.state).resolveInner(O.pos, -1);
  if (am.indexOf(e.name) > -1)
    return null;
  let t = e.name == "VariableName" || e.to - e.from < 20 && Ku.test(O.state.sliceDoc(e.from, e.to));
  if (!t && !O.explicit)
    return null;
  let i = [];
  for (let n = e; n; n = n.parent)
    sm.has(n.name) && (i = i.concat(om(O.state.doc, n)));
  return {
    options: i,
    from: t ? e.from : O.pos,
    validFor: Ku
  };
}
var pW = [
  "__annotations__",
  "__builtins__",
  "__debug__",
  "__doc__",
  "__import__",
  "__name__",
  "__loader__",
  "__package__",
  "__spec__",
  "False",
  "None",
  "True"
].map((O) => ({ label: O, type: "constant" })).concat([
  "ArithmeticError",
  "AssertionError",
  "AttributeError",
  "BaseException",
  "BlockingIOError",
  "BrokenPipeError",
  "BufferError",
  "BytesWarning",
  "ChildProcessError",
  "ConnectionAbortedError",
  "ConnectionError",
  "ConnectionRefusedError",
  "ConnectionResetError",
  "DeprecationWarning",
  "EOFError",
  "Ellipsis",
  "EncodingWarning",
  "EnvironmentError",
  "Exception",
  "FileExistsError",
  "FileNotFoundError",
  "FloatingPointError",
  "FutureWarning",
  "GeneratorExit",
  "IOError",
  "ImportError",
  "ImportWarning",
  "IndentationError",
  "IndexError",
  "InterruptedError",
  "IsADirectoryError",
  "KeyError",
  "KeyboardInterrupt",
  "LookupError",
  "MemoryError",
  "ModuleNotFoundError",
  "NameError",
  "NotADirectoryError",
  "NotImplemented",
  "NotImplementedError",
  "OSError",
  "OverflowError",
  "PendingDeprecationWarning",
  "PermissionError",
  "ProcessLookupError",
  "RecursionError",
  "ReferenceError",
  "ResourceWarning",
  "RuntimeError",
  "RuntimeWarning",
  "StopAsyncIteration",
  "StopIteration",
  "SyntaxError",
  "SyntaxWarning",
  "SystemError",
  "SystemExit",
  "TabError",
  "TimeoutError",
  "TypeError",
  "UnboundLocalError",
  "UnicodeDecodeError",
  "UnicodeEncodeError",
  "UnicodeError",
  "UnicodeTranslateError",
  "UnicodeWarning",
  "UserWarning",
  "ValueError",
  "Warning",
  "ZeroDivisionError"
].map((O) => ({ label: O, type: "type" }))).concat([
  "bool",
  "bytearray",
  "bytes",
  "classmethod",
  "complex",
  "float",
  "frozenset",
  "int",
  "list",
  "map",
  "memoryview",
  "object",
  "range",
  "set",
  "staticmethod",
  "str",
  "super",
  "tuple",
  "type"
].map((O) => ({ label: O, type: "class" }))).concat([
  "abs",
  "aiter",
  "all",
  "anext",
  "any",
  "ascii",
  "bin",
  "breakpoint",
  "callable",
  "chr",
  "compile",
  "delattr",
  "dict",
  "dir",
  "divmod",
  "enumerate",
  "eval",
  "exec",
  "exit",
  "filter",
  "format",
  "getattr",
  "globals",
  "hasattr",
  "hash",
  "help",
  "hex",
  "id",
  "input",
  "isinstance",
  "issubclass",
  "iter",
  "len",
  "license",
  "locals",
  "max",
  "min",
  "next",
  "oct",
  "open",
  "ord",
  "pow",
  "print",
  "property",
  "quit",
  "repr",
  "reversed",
  "round",
  "setattr",
  "slice",
  "sorted",
  "sum",
  "vars",
  "zip"
].map((O) => ({ label: O, type: "function" })));
var mW = [
  ce("def ${name}(${params}):\n	${}", {
    label: "def",
    detail: "function",
    type: "keyword"
  }),
  ce("for ${name} in ${collection}:\n	${}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  ce("while ${}:\n	${}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  ce("try:\n	${}\nexcept ${error}:\n	${}", {
    label: "try",
    detail: "/ except block",
    type: "keyword"
  }),
  ce(`if \${}:
	
`, {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  ce("if ${}:\n	${}\nelse:\n	${}", {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  ce("class ${name}:\n	def __init__(self, ${params}):\n			${}", {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  ce("import ${module}", {
    label: "import",
    detail: "statement",
    type: "keyword"
  }),
  ce("from ${module} import ${names}", {
    label: "from",
    detail: "import",
    type: "keyword"
  })
];
var gW = Gl(am, ps(pW.concat(mW)));
function Ju(O, e) {
  let t = O.lineIndent(e.from), i = O.lineAt(O.pos, -1), n = i.from + i.text.length;
  return !/\S/.test(i.text) && O.node.to < n + 100 && !/\S/.test(O.state.sliceDoc(n, O.node.to)) && O.lineIndent(O.pos, -1) <= t || /^\s*(else:|elif |except |finally:)/.test(O.textAfter) && O.lineIndent(O.pos, -1) > t ? null : t + O.unit;
}
var fo = Ze.define({
  name: "python",
  parser: dW.configure({
    props: [
      Ce.add({
        Body: (O) => {
          var e;
          return (e = Ju(O, O.node)) !== null && e !== void 0 ? e : O.continue();
        },
        IfStatement: (O) => /^\s*(else:|elif )/.test(O.textAfter) ? O.baseIndent : O.continue(),
        TryStatement: (O) => /^\s*(except |finally:|else:)/.test(O.textAfter) ? O.baseIndent : O.continue(),
        "TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression": Ft({ closing: ")" }),
        "DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression": Ft({ closing: "}" }),
        "ArrayExpression ArrayComprehensionExpression": Ft({ closing: "]" }),
        "String FormatString": () => null,
        Script: (O) => {
          if (O.pos + /\s*/.exec(O.textAfter)[0].length >= O.node.to) {
            let e = null;
            for (let t = O.node, i = t.to; t = t.lastChild, !(!t || t.to != i); )
              t.type.name == "Body" && (e = t);
            if (e) {
              let t = Ju(O, e);
              if (t != null)
                return t;
            }
          }
          return O.continue();
        }
      }),
      Ge.add({
        "ArrayExpression DictionaryExpression SetExpression TupleExpression": _t,
        Body: (O, e) => ({ from: O.from + 1, to: O.to - (O.to == e.doc.length ? 0 : 1) })
      })
    ]
  }),
  languageData: {
    closeBrackets: {
      brackets: ["(", "[", "{", "'", '"', "'''", '"""'],
      stringPrefixes: [
        "f",
        "fr",
        "rf",
        "r",
        "u",
        "b",
        "br",
        "rb",
        "F",
        "FR",
        "RF",
        "R",
        "U",
        "B",
        "BR",
        "RB"
      ]
    },
    commentTokens: { line: "#" },
    indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:)$/
  }
});
function SW() {
  return new je(fo, [
    fo.data.of({ autocomplete: $W }),
    fo.data.of({ autocomplete: gW })
  ]);
}
var PW = 1;
var yW = 2;
var XW = 3;
var xW = 4;
var bW = 5;
var ef = 98;
var wW = 101;
var TW = 102;
var tf = 114;
var WW = 69;
var Dn = 48;
var Of = 46;
var vW = 43;
var kW = 45;
var nf = 35;
var rf = 34;
var YW = 124;
var ZW = 60;
var qW = 62;
function Va(O) {
  return O >= 48 && O <= 57;
}
function Mn(O) {
  return Va(O) || O == 95;
}
var zW = new te((O, e) => {
  if (Va(O.next)) {
    let t = false;
    do
      O.advance();
    while (Mn(O.next));
    if (O.next == Of) {
      if (t = true, O.advance(), Va(O.next))
        do
          O.advance();
        while (Mn(O.next));
      else if (O.next == Of || O.next > 127 || /\w/.test(String.fromCharCode(O.next)))
        return;
    }
    if (O.next == wW || O.next == WW) {
      if (t = true, O.advance(), (O.next == vW || O.next == kW) && O.advance(), !Mn(O.next))
        return;
      do
        O.advance();
      while (Mn(O.next));
    }
    if (O.next == TW) {
      let i = O.peek(1);
      if (i == Dn + 3 && O.peek(2) == Dn + 2 || i == Dn + 6 && O.peek(2) == Dn + 4)
        O.advance(3), t = true;
      else
        return;
    }
    t && O.acceptToken(bW);
  } else if (O.next == ef || O.next == tf) {
    if (O.next == ef && O.advance(), O.next != tf)
      return;
    O.advance();
    let t = 0;
    for (; O.next == nf; )
      t++, O.advance();
    if (O.next != rf)
      return;
    O.advance();
    e:
      for (; ; ) {
        if (O.next < 0)
          return;
        let i = O.next == rf;
        if (O.advance(), i) {
          for (let n = 0; n < t; n++) {
            if (O.next != nf)
              continue e;
            O.advance();
          }
          O.acceptToken(xW);
          return;
        }
      }
  }
});
var UW = new te((O) => {
  O.next == YW && O.acceptToken(PW, 1);
});
var VW = new te((O) => {
  O.next == ZW ? O.acceptToken(yW, 1) : O.next == qW && O.acceptToken(XW, 1);
});
var RW = ze({
  "const macro_rules struct union enum type fn impl trait let static": c.definitionKeyword,
  "mod use crate": c.moduleKeyword,
  "pub unsafe async mut extern default move": c.modifier,
  "for if else loop while match continue break return await": c.controlKeyword,
  "as in ref": c.operatorKeyword,
  "where _ crate super dyn": c.keyword,
  self: c.self,
  String: c.string,
  Char: c.character,
  RawString: c.special(c.string),
  Boolean: c.bool,
  Identifier: c.variableName,
  "CallExpression/Identifier": c.function(c.variableName),
  BoundIdentifier: c.definition(c.variableName),
  "FunctionItem/BoundIdentifier": c.function(c.definition(c.variableName)),
  LoopLabel: c.labelName,
  FieldIdentifier: c.propertyName,
  "CallExpression/FieldExpression/FieldIdentifier": c.function(c.propertyName),
  Lifetime: c.special(c.variableName),
  ScopeIdentifier: c.namespace,
  TypeIdentifier: c.typeName,
  "MacroInvocation/Identifier MacroInvocation/ScopedIdentifier/Identifier": c.macroName,
  "MacroInvocation/TypeIdentifier MacroInvocation/ScopedIdentifier/TypeIdentifier": c.macroName,
  '"!"': c.macroName,
  UpdateOp: c.updateOperator,
  LineComment: c.lineComment,
  BlockComment: c.blockComment,
  Integer: c.integer,
  Float: c.float,
  ArithOp: c.arithmeticOperator,
  LogicOp: c.logicOperator,
  BitOp: c.bitwiseOperator,
  CompareOp: c.compareOperator,
  "=": c.definitionOperator,
  ".. ... => ->": c.punctuation,
  "( )": c.paren,
  "[ ]": c.squareBracket,
  "{ }": c.brace,
  ". DerefOp": c.derefOperator,
  "&": c.operator,
  ", ; ::": c.separator,
  "Attribute/...": c.meta
});
var _W = { __proto__: null, self: 28, super: 32, crate: 34, impl: 46, true: 72, false: 72, pub: 88, in: 92, const: 96, unsafe: 104, async: 108, move: 110, if: 114, let: 118, ref: 142, mut: 144, _: 198, else: 200, match: 204, as: 248, return: 252, await: 262, break: 270, continue: 276, while: 312, loop: 316, for: 320, macro_rules: 327, mod: 334, extern: 342, struct: 346, where: 364, union: 379, enum: 382, type: 390, default: 395, fn: 396, trait: 412, use: 420, static: 438, dyn: 476 };
var jW = qe.deserialize({
  version: 14,
  states: "$2xQ]Q_OOP$wOWOOO&sQWO'#CnO)WQWO'#I`OOQP'#I`'#I`OOQQ'#Ie'#IeO)hO`O'#C}OOQR'#Ih'#IhO)sQWO'#IuOOQO'#Hk'#HkO)xQWO'#DpOOQR'#Iw'#IwO)xQWO'#DpO*ZQWO'#DpOOQO'#Iv'#IvO,SQWO'#J`O,ZQWO'#EiOOQV'#Hp'#HpO,cQYO'#F{OOQV'#El'#ElOOQV'#Em'#EmOOQV'#En'#EnO.YQ_O'#EkO0_Q_O'#EoO2gQWOOO4QQ_O'#FPO7hQWO'#J`OOQV'#FY'#FYO7{Q_O'#F^O:WQ_O'#FaOOQO'#F`'#F`O=sQ_O'#FcO=}Q_O'#FbO@VQWO'#FgOOQO'#J`'#J`OOQV'#Io'#IoOA]Q_O'#InOEPQWO'#InOOQV'#Fw'#FwOF[QWO'#JuOFcQWO'#F|OOQO'#IO'#IOOGrQWO'#GhOOQV'#Im'#ImOOQV'#Il'#IlOOQV'#Hj'#HjQGyQ_OOOKeQ_O'#DUOKlQYO'#CqOOQP'#I_'#I_OOQV'#Hg'#HgQ]Q_OOOLuQWO'#I`ONsQYO'#DXO!!eQWO'#JuO!!lQWO'#JuO!!vQ_O'#DfO!%]Q_O'#E}O!(sQ_O'#FWO!,ZQWO'#FZO!.^QXO'#FbO!.cQ_O'#EeO!!vQ_O'#FmO!0uQWO'#FoO!0zQWO'#FoO!1PQ^O'#FqO!1WQWO'#JuO!1_QWO'#FtO!1dQWO'#FxO!2WQWO'#JjO!2_QWO'#GOO!2_QWO'#G`O!2_QWO'#GbO!2_QWO'#GsOOQO'#Ju'#JuO!2dQWO'#GhO!2lQYO'#GpO!2_QWO'#GqO!3uQ^O'#GtO!3|QWO'#GuO!4hQWO'#HOP!4sOpO'#CcPOOO)CC})CC}OOOO'#Hi'#HiO!5OO`O,59iOOQV,59i,59iO!5ZQYO,5?aOOQO-E;i-E;iOOQO,5:[,5:[OOQP,59Z,59ZO)xQWO,5:[O)xQWO,5:[O!5oQWO,5?kO!5zQYO,5;qO!6PQYO,5;TO!6hQWO,59QO!7kQXO'#CnO!7xQXO'#I`O!9SQWO'#CoO,^QWO'#EiOOQV-E;n-E;nO!9eQWO'#FsOOQV,5<g,5<gO!9SQWO'#CoO!9jQWO'#CoO!9oQWO'#I`O! yQWO'#JuO!9yQWO'#J`O!:aQWO,5;VOOQO'#In'#InO!0zQWO'#DaO!<aQWO'#DcO!<iQWO,5;ZO.YQ_O,5;ZOOQO,5;[,5;[OOQV'#Er'#ErOOQV'#Es'#EsOOQV'#Et'#EtOOQV'#Eu'#EuOOQV'#Ev'#EvOOQV'#Ew'#EwOOQV'#Ex'#ExOOQV'#Ey'#EyO.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;fO!=PQ_O,5;kO!@gQ_O'#FROOQO,5;l,5;lO!BrQWO,5;pO.YQ_O,5;wOKlQYO,5;gO!D_QWO,5;kO!EOQWO,5;xOOQO,5;x,5;xO!E]QWO,5;xO!EbQ_O,5;xO!GmQWO'#CfO!GrQWO,5<QO!G|Q_O,5<QOOQO,5;{,5;{O!JjQXO'#CnO!K{QXO'#I`OOQS'#Dk'#DkOOQP'#Ir'#IrO!LuQ[O'#IrO!L}QXO'#DjO!M{QWO'#DnO!M{QWO'#DnO!N^QWO'#DnOOQP'#It'#ItO!NcQXO'#ItO# ^Q^O'#DoO# hQWO'#DrO# pQ^O'#DzO# zQ^O'#D|O#!RQWO'#EPO#!^QXO'#FdOOQP'#ES'#ESOOQP'#Iq'#IqO#!lQXO'#JfOOQP'#Je'#JeO#!tQXO,5;}O#!yQXO'#I`O!1PQ^O'#DyO!1PQ^O'#FdO##sQWO,5;|OOQO,5;|,5;|OKlQYO,5;|O#$ZQWO'#FhOOQO,5<R,5<ROOQV,5=l,5=lO#&`QYO'#FzOOQV,5<h,5<hO#&gQWO,5<hO#&nQWO,5=SO!1WQWO,59rO!1dQWO,5<dO#&uQWO,5=iO!2_QWO,5<jO!2_QWO,5<zO!2_QWO,5<|O!2_QWO,5=QO#&|QWO,5=]O#'TQWO,5=SO!2_QWO,5=]O!3|QWO,5=aO#']QWO,5=jOOQO-E;|-E;|O#'hQWO'#JjOOQV-E;h-E;hO#(PQWO'#HRO#(WQ_O,59pOOQV,59p,59pO#(_QWO,59pO#(dQ_O,59pO#)SQZO'#CuO#+[QZO'#CvOOQV'#C|'#C|O#-wQWO'#HTO#.OQYO'#IdOOQO'#Hh'#HhO#.WQWO'#CwO#.WQWO'#CwO#.iQWO'#CwOOQR'#Ic'#IcO#.nQZO'#IbO#1TQYO'#HTO#1qQYO'#H[O#2}QYO'#H_OKlQYO'#H`OOQR'#Hb'#HbO#4ZQWO'#HeO#4`QYO,59]OOQR'#Ib'#IbO#5PQZO'#CtO#7[QYO'#HUO#7aQWO'#HTO#7fQYO'#CrO#8VQWO'#H]O#7fQYO'#HcOOQV-E;e-E;eO#8_QWO,59sOOQV,59{,59{O#8mQYO,5=[OOQV,59},59}O!0zQWO,59}O#;aQWO'#IpOOQO'#Ip'#IpO!1PQ^O'#DhO!0zQWO,5:QO#;hQWO,5;iO#<OQWO,5;rO#<fQ_O,5;rOOQO,5;u,5;uO#@PQ_O,5;|O#BXQWO,5;PO!0zQWO,5<XO#B`QWO,5<ZOOQV,5<Z,5<ZO#BkQWO,5<]O!1PQ^O'#EOOOQQ'#D_'#D_O#BsQWO,59rO#BxQWO,5<`O#B}QWO,5<dOOQO,5@U,5@UO#CVQWO,5=iOOQQ'#Cv'#CvO#C[QYO,5<jO#CmQYO,5<zO#CxQYO,5<|O#DTQYO,5=_O#DcQYO,5=SO#E{QYO'#GQO#FYQYO,5=[O#FmQWO,5=[O#F{QYO,5=[O#HUQYO,5=]O#HdQWO,5=`O!1PQ^O,5=`O#HrQWO'#CnO#ITQWO'#I`OOQO'#Jy'#JyO#IfQWO'#IQO#IkQWO'#GwOOQO'#Jz'#JzO#JSQWO'#GzOOQO'#G|'#G|OOQO'#Jx'#JxO#IkQWO'#GwO#JZQWO'#GxO#J`QWO,5=aO#JeQWO,5=jO!1dQWO,5=jO#'`QWO,5=jPOOO'#Hf'#HfP#JjOpO,58}POOO,58},58}OOOO-E;g-E;gOOQV1G/T1G/TO#JuQWO1G4{O#JzQ^O'#CyPOQQ'#Cx'#CxOOQO1G/v1G/vOOQP1G.u1G.uO)xQWO1G/vO#NTQ!fO'#ETO#N[Q!fO'#EaO#NcQ!fO'#EbO$ kQWO1G1yO$!_Q_O1G1yOOQP1G5V1G5VOOQO1G1]1G1]O$&RQWO1G0oO$&WQWO'#CiO!7xQXO'#I`O!6PQYO1G.lO!5oQWO,5<_O!9SQWO,59ZO!9SQWO,59ZO!5oQWO,5?kO$&iQWO1G0uO$(vQWO1G0wO$*nQWO1G0wO$+UQWO1G0wO$-YQWO1G0wO$-aQWO1G0wO$/bQWO1G0wO$/iQWO1G0wO$1jQWO1G0wO$1qQWO1G0wO$3YQWO1G1QO$5ZQWO1G1VO$5zQ_O'#JcO$8SQWO'#JcOOQO'#Jb'#JbO$8^QWO,5;mOOQO'#Dw'#DwOOQO1G1[1G1[OOQO1G1Y1G1YO$8cQWO1G1cOOQO1G1R1G1RO$8jQ_O'#HrO$:xQWO,5@OO.YQ_O1G1dOOQO1G1d1G1dO$;QQWO1G1dO$;_QWO1G1dO$;dQWO1G1eOOQO1G1l1G1lO$;lQWO1G1lOOQP,5?^,5?^O$;vQ^O,5:kO$<aQXO,5:YO!M{QWO,5:YO!M{QWO,5:YO!1PQ^O,5:gO$=bQWO'#IyOOQO'#Ix'#IxO$=pQWO,5:ZO# ^Q^O,5:ZO$=uQWO'#DsOOQP,5:^,5:^O$>WQWO,5:fOOQP,5:h,5:hO!1PQ^O,5:hO!1PQ^O,5:mO$>]QYO,5<OO$>gQ_O'#HsO$>tQXO,5@QOOQV1G1i1G1iOOQP,5:e,5:eO$>|QXO,5<OO$?[QWO1G1hO$?dQWO'#CnO$?oQWO'#FiOOQO'#Fi'#FiO$?wQWO'#FjO.YQ_O'#FkOOQO'#Ji'#JiO$?|QWO'#JhOOQO'#Jg'#JgO$@UQWO,5<SOOQQ'#Hv'#HvO$@ZQYO,5<fOOQV,5<f,5<fO$@bQYO,5<fOOQV1G2S1G2SO$@iQWO1G2nO$@qQWO1G/^O$@vQWO1G2OO#CVQWO1G3TO$AOQYO1G2UO#CmQYO1G2fO#CxQYO1G2hO$AaQYO1G2lO!2_QWO1G2wO#DcQYO1G2nO#HUQYO1G2wO$AiQWO1G2{O$AnQWO1G3UO!1dQWO1G3UO$AsQWO1G3UOOQV1G/[1G/[O$A{QWO1G/[O$BQQ_O1G/[O#7aQWO,5=oO$BXQYO,5?OO$BmQWO,5?OO$BrQZO'#IeOOQO-E;f-E;fOOQR,59c,59cO#.WQWO,59cO#.WQWO,59cOOQR,5=n,5=nO$E_QYO'#HVO$FwQZO,5=oO!5oQWO,5={O$IZQWO,5=oO$IbQZO,5=vO$KqQYO,5=vO$>]QYO,5=vO$LRQWO'#KRO$L^QWO,5=xOOQR,5=y,5=yO$LcQWO,5=zO$>]QYO,5>PO$>]QYO,5>POOQO1G.w1G.wO$>]QYO1G.wO$LnQYO,5=pO$LvQZO,59^OOQR,59^,59^O$>]QYO,5=wO% YQZO,5=}OOQR,5=},5=}O%#lQWO1G/_O!6PQYO1G/_O#FYQYO1G2vO%#qQWO1G2vO%$PQYO1G2vOOQV1G/i1G/iO%%YQWO,5:SO%%bQ_O1G/lO%*kQWO1G1^O%+RQWO1G1hOOQO1G1h1G1hO$>]QYO1G1hO%+iQ^O'#EgOOQV1G0k1G0kOOQV1G1s1G1sO!!vQ_O1G1sO!0zQWO1G1uO!1PQ^O1G1wO!.cQ_O1G1wOOQP,5:j,5:jO$>]QYO1G/^OOQO'#Cn'#CnO%+vQWO1G1zOOQV1G2O1G2OO%,OQWO'#CnO%,WQWO1G3TO%,]QWO1G3TO%,bQYO'#GQO%,sQWO'#G]O%-UQYO'#G_O%.hQYO'#GXOOQV1G2U1G2UO%/wQWO1G2UO%/|QWO1G2UO$ARQWO1G2UOOQV1G2f1G2fO%/wQWO1G2fO#CpQWO1G2fO%0UQWO'#GdOOQV1G2h1G2hO%0gQWO1G2hO#C{QWO1G2hO%0lQYO'#GSO$>]QYO1G2lO$AdQWO1G2lOOQV1G2y1G2yO%1xQWO1G2yO%3hQ^O'#GkO%3rQWO1G2nO#DfQWO1G2nO%4QQYO,5<lO%4[QYO,5<lO%4jQYO,5<lO%5XQYO,5<lOOQQ,5<l,5<lO!1WQWO'#JuO%5dQYO,5<lO%5lQWO1G2vOOQV1G2v1G2vO%5tQWO1G2vO$>]QYO1G2vOOQV1G2w1G2wO%5tQWO1G2wO%5yQWO1G2wO#HXQWO1G2wOOQV1G2z1G2zO.YQ_O1G2zO$>]QYO1G2zO%6RQWO1G2zOOQO,5>l,5>lOOQO-E<O-E<OOOQO,5=c,5=cOOQO,5=e,5=eOOQO,5=g,5=gOOQO,5=h,5=hO%6aQWO'#J|OOQO'#J{'#J{O%6iQWO,5=fO%6nQWO,5=cO!1dQWO,5=dOOQV1G2{1G2{O$>]QYO1G3UPOOO-E;d-E;dPOOO1G.i1G.iOOQO7+*g7+*gO%7VQYO'#IcO%7nQYO'#IfO%7yQYO'#IfO%8RQYO'#IfO%8^QYO,59eOOQO7+%b7+%bOOQP7+$a7+$aO%8cQ!fO'#JTOOQS'#EX'#EXOOQS'#EY'#EYOOQS'#EZ'#EZOOQS'#JT'#JTO%;UQWO'#EWOOQS'#E`'#E`OOQS'#JR'#JROOQS'#Hn'#HnO%;ZQ!fO,5:oOOQV,5:o,5:oOOQV'#JQ'#JQO%;bQ!fO,5:{OOQV,5:{,5:{O%;iQ!fO,5:|OOQV,5:|,5:|OOQV7+'e7+'eOOQV7+&Z7+&ZO%;pQ!fO,59TOOQO,59T,59TO%>YQWO7+$WO%>_QWO1G1yOOQV1G1y1G1yO!9SQWO1G.uO%>dQWO,5?}O%>nQ_O'#HqO%@|QWO,5?}OOQO1G1X1G1XOOQO7+&}7+&}O%AUQWO,5>^OOQO-E;p-E;pO%AcQWO7+'OO.YQ_O7+'OOOQO7+'O7+'OOOQO7+'P7+'PO%AjQWO7+'POOQO7+'W7+'WOOQP1G0V1G0VO%ArQXO1G/tO!M{QWO1G/tO%BsQXO1G0RO%CkQ^O'#HlO%C{QWO,5?eOOQP1G/u1G/uO%DWQWO1G/uO%D]QWO'#D_OOQO'#Dt'#DtO%DhQWO'#DtO%DmQWO'#I{OOQO'#Iz'#IzO%DuQWO,5:_O%DzQWO'#DtO%EPQWO'#DtOOQP1G0Q1G0QOOQP1G0S1G0SOOQP1G0X1G0XO%EXQXO1G1jO%EdQXO'#FeOOQP,5>_,5>_O!1PQ^O'#FeOOQP-E;q-E;qO$>]QYO1G1jOOQO7+'S7+'SOOQO,5<T,5<TO%ErQWO,5<UO.YQ_O,5<UO%EwQWO,5<VO%FRQWO'#HtO%FdQWO,5@SOOQO1G1n1G1nOOQQ-E;t-E;tOOQV1G2Q1G2QO%FlQYO1G2QO#DcQYO7+(YO$>]QYO7+$xOOQV7+'j7+'jO%FsQWO7+(oO%FxQWO7+(oOOQV7+'p7+'pO%/wQWO7+'pO%F}QWO7+'pO%GVQWO7+'pOOQV7+(Q7+(QO%/wQWO7+(QO#CpQWO7+(QOOQV7+(S7+(SO%0gQWO7+(SO#C{QWO7+(SO$>]QYO7+(WO%GeQWO7+(WO#HUQYO7+(cO%GjQWO7+(YO#DfQWO7+(YOOQV7+(c7+(cO%5tQWO7+(cO%5yQWO7+(cO#HXQWO7+(cOOQV7+(g7+(gO$>]QYO7+(pO%GxQWO7+(pO!1dQWO7+(pOOQV7+$v7+$vO%G}QWO7+$vO%HSQZO1G3ZO%JfQWO1G4jOOQO1G4j1G4jOOQR1G.}1G.}O#.WQWO1G.}O%JkQWO'#KQOOQO'#HW'#HWO%J|QWO'#HXO%KXQWO'#KQOOQO'#KP'#KPO%KaQWO,5=qO%KfQYO'#H[O%LrQWO'#GmO%L}QYO'#CtO%MXQWO'#GmO$>]QYO1G3ZOOQR1G3g1G3gO#7aQWO1G3ZO%M^QZO1G3bO$>]QYO1G3bO& mQYO'#IVO& }QWO,5@mOOQR1G3d1G3dOOQR1G3f1G3fO.YQ_O1G3fOOQR1G3k1G3kO&!VQYO7+$cO&!_QYO'#KOOOQQ'#J}'#J}O&!gQYO1G3[O&!lQZO1G3cOOQQ7+$y7+$yO&${QWO7+$yO&%QQWO7+(bOOQV7+(b7+(bO%5tQWO7+(bO$>]QYO7+(bO#FYQYO7+(bO&%YQWO7+(bO!.cQ_O1G/nO&%hQWO7+%WO$?[QWO7+'SO&%pQWO'#EhO&%{Q^O'#EhOOQU'#Ho'#HoO&%{Q^O,5;ROOQV,5;R,5;RO&&VQWO,5;RO&&[Q^O,5;RO!0zQWO7+'_OOQV7+'a7+'aO&&iQWO7+'cO&&qQWO7+'cO&&xQWO7+$xO&'TQ!fO7+'fO&'[Q!fO7+'fOOQV7+(o7+(oO!1dQWO7+(oO&'cQYO,5<lO&'nQYO,5<lO!1dQWO'#GWO&'|QWO'#JpO&([QWO'#G^O!BxQWO'#G^O&(aQWO'#JpOOQO'#Jo'#JoO&(iQWO,5<wOOQO'#DX'#DXO&(nQYO'#JrO&)}QWO'#JrO$>]QYO'#JrOOQO'#Jq'#JqO&*YQWO,5<yO&*_QWO'#GZO#D^QWO'#G[O&*gQWO'#G[O&*oQWO'#JmOOQO'#Jl'#JlO&*zQYO'#GTOOQO,5<s,5<sO&+PQWO7+'pO&+UQWO'#JtO&+dQWO'#GeO#BxQWO'#GeO&+uQWO'#JtOOQO'#Js'#JsO&+}QWO,5=OO$>]QYO'#GUO&,SQYO'#JkOOQQ,5<n,5<nO&,kQWO7+(WOOQV7+(e7+(eO&.TQ^O'#D|O&._QWO'#GlO&.gQ^O'#JwOOQO'#Gn'#GnO&.nQWO'#JwOOQO'#Jv'#JvO&.vQWO,5=VO&.{QWO'#I`O&/]Q^O'#GmO&/dQWO'#IqO&/rQWO'#GmOOQV7+(Y7+(YO&/zQWO7+(YO$>]QYO7+(YO&0SQYO'#HxO&0hQYO1G2WOOQQ1G2W1G2WOOQQ,5<m,5<mO$>]QYO,5<qO&0pQWO,5<rO&0uQWO7+(bO&1QQWO7+(fO&1XQWO7+(fOOQV7+(f7+(fO.YQ_O7+(fO$>]QYO7+(fO&1dQWO'#IRO&1nQWO,5@hOOQO1G3Q1G3QOOQO1G2}1G2}OOQO1G3P1G3POOQO1G3R1G3ROOQO1G3S1G3SOOQO1G3O1G3OO&1vQWO7+(pO$>]QYO,59fO&2RQ^O'#ISO&2xQYO,5?QOOQR1G/P1G/PO&3QQ!bO,5:pO&3VQ!fO,5:rOOQS-E;l-E;lOOQV1G0Z1G0ZOOQV1G0g1G0gOOQV1G0h1G0hO&3^QWO'#JTOOQO1G.o1G.oOOQV<<Gr<<GrO&3iQWO1G5iO$5zQ_O,5>]O&3qQWO,5>]OOQO-E;o-E;oOOQO<<Jj<<JjO&3{QWO<<JjOOQO<<Jk<<JkO&4SQXO7+%`O&5TQWO,5>WOOQO-E;j-E;jOOQP7+%a7+%aO!1PQ^O,5:`O&5cQWO'#HmO&5wQWO,5?gOOQP1G/y1G/yOOQO,5:`,5:`O&6PQWO,5:`O%DzQWO,5:`O$>]QYO,5<PO&6UQXO,5<PO&6dQXO7+'UO.YQ_O1G1pO&6oQWO1G1pOOQO,5>`,5>`OOQO-E;r-E;rOOQV7+'l7+'lO&6yQWO<<KtO#DfQWO<<KtO&7XQWO<<HdOOQV<<LZ<<LZO!1dQWO<<LZOOQV<<K[<<K[O&7dQWO<<K[O%/wQWO<<K[O&7iQWO<<K[OOQV<<Kl<<KlO%/wQWO<<KlOOQV<<Kn<<KnO%0gQWO<<KnO&7qQWO<<KrO$>]QYO<<KrOOQV<<K}<<K}O%5tQWO<<K}O%5yQWO<<K}O#HXQWO<<K}OOQV<<Kt<<KtO&7yQWO<<KtO$>]QYO<<KtO&8RQWO<<L[O$>]QYO<<L[O&8^QWO<<L[OOQV<<Hb<<HbO$>]QYO7+(uOOQO7+*U7+*UOOQR7+$i7+$iO&8cQWO,5@lOOQO'#Gm'#GmO&8kQWO'#GmO&8vQYO'#IUO&8cQWO,5@lOOQR1G3]1G3]O&:cQYO,5=vO&;rQYO,5=XO&;|QWO,5=XOOQO,5=X,5=XOOQR7+(u7+(uO&<RQZO7+(uO&>eQZO7+(|O&@tQWO,5>qOOQO-E<T-E<TO&APQWO7+)QOOQO<<G}<<G}O&AWQYO'#ITO&AcQYO,5@jOOQQ7+(v7+(vOOQQ<<He<<HeO$>]QYO<<K|OOQV<<K|<<K|O&0uQWO<<K|O&AkQWO<<K|O%5tQWO<<K|O&AsQWO7+%YOOQV<<Hr<<HrOOQO<<Jn<<JnO.YQ_O,5;SO&AzQWO,5;SO.YQ_O'#EjO&BPQWO,5;SOOQU-E;m-E;mO&B[QWO1G0mOOQV1G0m1G0mO&%{Q^O1G0mOOQV<<Jy<<JyO!.cQ_O<<J}OOQV<<J}<<J}OOQV<<Hd<<HdO.YQ_O<<HdO&BaQWO'#FvO&BfQWO<<KQO&BnQ!fO<<KQO&BuQWO<<KQO&BzQWO<<KQO&CSQ!fO<<KQOOQV<<KQ<<KQO&CZQWO<<LZO&C`QWO,5@[O$>]QYO,5<xO&ChQWO,5<xO&CmQWO'#H{O&C`QWO,5@[OOQV1G2c1G2cO&DRQWO,5@^O$>]QYO,5@^O&D^QYO'#H|O&EsQWO,5@^OOQO1G2e1G2eO%,nQWO,5<uOOQO,5<v,5<vO&E{QYO'#HzO&G_QWO,5@XO%,bQYO,5=pO$>]QYO,5<oO&GjQWO,5@`O.YQ_O,5=PO&GrQWO,5=PO&G}QWO,5=PO&H`QWO'#H}O&GjQWO,5@`OOQV1G2j1G2jO&HtQYO,5<pO%0lQYO,5>PO&I]QYO,5@VOOQV<<Kr<<KrO&ItQWO,5=XO&KfQ^O,5:hO&KmQWO,5=XO$>]QYO,5=WO&KuQWO,5@cO&K}QWO,5@cO&MvQ^O'#IPO&KuQWO,5@cOOQO1G2q1G2qO&NTQWO,5=WO&N]QWO<<KtO&NkQYO,5>oO&NvQYO,5>dO' UQYO,5>dOOQQ,5>d,5>dOOQQ-E;v-E;vOOQQ7+'r7+'rO' aQYO1G2]O$>]QYO1G2^OOQV<<LQ<<LQO.YQ_O<<LQO' lQWO<<LQO' sQWO<<LQOOQO,5>m,5>mOOQO-E<P-E<POOQV<<L[<<L[O.YQ_O<<L[O'!OQYO1G/QO'!ZQYO,5>nOOQQ,5>n,5>nO'!fQYO,5>nOOQQ-E<Q-E<QOOQS1G0[1G0[O'$tQ!fO1G0^O'%RQ!fO1G0^O'%YQWO1G3wOOQOAN@UAN@UO'%dQWO1G/zOOQO,5>X,5>XOOQO-E;k-E;kO!1PQ^O1G/zOOQO1G/z1G/zO'%oQWO1G/zO'%tQXO1G1kO$>]QYO1G1kO'&PQWO7+'[OOQVANA`ANA`O'&ZQWOANA`O$>]QYOANA`O'&cQWOANA`OOQVAN>OAN>OO.YQ_OAN>OO'&qQWOANAuOOQVAN@vAN@vO'&vQWOAN@vOOQVANAWANAWOOQVANAYANAYOOQVANA^ANA^O'&{QWOANA^OOQVANAiANAiO%5tQWOANAiO%5yQWOANAiO''TQWOANA`OOQVANAvANAvO.YQ_OANAvO''cQWOANAvO$>]QYOANAvOOQR<<La<<LaO''nQWO1G6WO%JkQWO,5>pOOQO'#HY'#HYO''vQWO'#HZOOQO,5>p,5>pOOQO-E<S-E<SO'(RQYO1G2sO'(]QWO1G2sOOQO1G2s1G2sO$>]QYO<<LaOOQR<<Ll<<LlOOQQ,5>o,5>oOOQQ-E<R-E<RO&0uQWOANAhOOQVANAhANAhO%5tQWOANAhO$>]QYOANAhO'(bQWO1G1rO')UQ^O1G0nO.YQ_O1G0nO'*zQWO,5;UO'+RQWO1G0nP'+WQWO'#ERP&%{Q^O'#HpOOQV7+&X7+&XO'+cQWO7+&XO&&qQWOAN@iO'+hQWOAN>OO!5oQWO,5<bOOQS,5>a,5>aO'+oQWOAN@lO'+tQWOAN@lOOQS-E;s-E;sOOQVAN@lAN@lO'+|QWOAN@lOOQVANAuANAuO',UQWO1G5vO',^QWO1G2dO$>]QYO1G2dO&'|QWO,5>gOOQO,5>g,5>gOOQO-E;y-E;yO',iQWO1G5xO',qQWO1G5xO&(nQYO,5>hO',|QWO,5>hO$>]QYO,5>hOOQO-E;z-E;zO'-XQWO'#JnOOQO1G2a1G2aOOQO,5>f,5>fOOQO-E;x-E;xO&'cQYO,5<lO'-gQYO1G2ZO'.RQWO1G5zO'.ZQWO1G2kO.YQ_O1G2kO'.eQWO1G2kO&+UQWO,5>iOOQO,5>i,5>iOOQO-E;{-E;{OOQQ,5>c,5>cOOQQ-E;u-E;uO'.pQWO1G2sO'/QQWO1G2rO'/]QWO1G5}O'/eQ^O,5>kOOQO'#Go'#GoOOQO,5>k,5>kO'/lQWO,5>kOOQO-E;}-E;}O$>]QYO1G2rO'/zQYO7+'xO'0VQWOANAlOOQVANAlANAlO.YQ_OANAlO'0^QWOANAvOOQS7+%x7+%xO'0eQWO7+%xO'0pQ!fO7+%xO'0}QWO7+%fO!1PQ^O7+%fO'1YQXO7+'VOOQVG26zG26zO'1eQWOG26zO'1sQWOG26zO$>]QYOG26zO'1{QWOG23jOOQVG27aG27aOOQVG26bG26bOOQVG26xG26xOOQVG27TG27TO%5tQWOG27TO'2SQWOG27bOOQVG27bG27bO.YQ_OG27bO'2ZQWOG27bOOQO1G4[1G4[OOQO7+(_7+(_OOQRANA{ANA{OOQVG27SG27SO%5tQWOG27SO&0uQWOG27SO'2fQ^O7+&YO'4PQWO7+'^O'4sQ^O7+&YO.YQ_O7+&YP.YQ_O,5;SP'6PQWO,5;SP'6UQWO,5;SOOQV<<Is<<IsOOQVG26TG26TOOQVG23jG23jOOQO1G1|1G1|OOQVG26WG26WO'6aQWOG26WP&B}QWO'#HuO'6fQWO7+(OOOQO1G4R1G4RO'6qQWO7++dO'6yQWO1G4SO$>]QYO1G4SO%,nQWO'#HyO'7UQWO,5@YO'7dQWO7+(VO.YQ_O7+(VOOQO1G4T1G4TOOQO1G4V1G4VO'7nQWO1G4VO'7|QWO7+(^OOQVG27WG27WO'8XQWOG27WOOQS<<Id<<IdO'8`QWO<<IdO'8kQWO<<IQOOQVLD,fLD,fO'8vQWOLD,fO'9OQWOLD,fOOQVLD)ULD)UOOQVLD,oLD,oOOQVLD,|LD,|O'9^QWOLD,|O.YQ_OLD,|OOQVLD,nLD,nO%5tQWOLD,nO'9eQ^O<<ItO';OQWO<<JxO';rQ^O<<ItP'=OQWO1G0nP'=oQ^O1G0nP.YQ_O1G0nP'?bQWO1G0nOOQVLD+rLD+rO'?gQWO7+)nOOQO,5>e,5>eOOQO-E;w-E;wO'?rQWO<<KqOOQVLD,rLD,rOOQSAN?OAN?OOOQV!$(!Q!$(!QO'?|QWO!$(!QOOQV!$(!h!$(!hO'@UQWO!$(!hOOQV!$(!Y!$(!YO'@]Q^OAN?`POQU7+&Y7+&YP'AvQWO7+&YP'BgQ^O7+&YP.YQ_O7+&YOOQV!)9El!)9ElOOQV!)9FS!)9FSPOQU<<It<<ItP'DYQWO<<ItP'DyQ^O<<ItPOQUAN?`AN?`O'FlQWO'#CnO'FsQXO'#CnO'GlQWO'#I`O'IRQXO'#I`O'IxQWO'#DpO'IxQWO'#DpO!.cQ_O'#EkO'JZQ_O'#EoO'JbQ_O'#FPO'MfQ_O'#FbO'MmQXO'#I`O'NdQ_O'#E}O( gQ_O'#FWO'IxQWO,5:[O'IxQWO,5:[O!.cQ_O,5;ZO!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;fO(!jQ_O,5;kO(%nQWO,5;kO(&OQWO,5;|O(&VQYO'#CuO(&bQYO'#CvO(&mQWO'#CwO(&mQWO'#CwO('OQYO'#CtO('ZQWO,5;iO('bQWO,5;rO('iQ_O,5;rO((oQ_O,5;|O'IxQWO1G/vO((vQWO1G0uO(*eQWO1G0wO(*oQWO1G0wO(,dQWO1G0wO(,kQWO1G0wO(.]QWO1G0wO(.dQWO1G0wO(0UQWO1G0wO(0]QWO1G0wO(0dQWO1G1QO(0tQWO1G1VO(1UQYO'#IeO(&mQWO,59cO(&mQWO,59cO(1aQWO1G1^O(1hQWO1G1hO(&mQWO1G.}O(1oQWO'#DpO!.^QXO'#FbO(1tQWO,5;ZO(1{QWO'#Cw",
  stateData: "(2_~O&|OSUOS&}PQ~OPoOQ!QOSVOTVOZeO[lO^RO_RO`ROa!UOd[Og!nOsVOtVOuVOw!POyvO|!VO}mO!Q!dO!U!WO!W!XO!X!^O!Z!YO!]!pO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'Q`O'TQO'ZkO'^UO'gcO'qiO(QdO~O&}!sO~OZbX[bXdbXdlXobXwjX}bX!lbX!qbX!tbX#ObX#PbX#pbX'gbX'qbX'rbX'xbX'ybX'zbX'{bX'|bX'}bX(ObX(PbX(QbX(RbX(TbX~OybXXbX!ebX!PbXvbX#RbX~P$|OZ'SX['SXd'SXd'XXo'SXw'kXy'SX}'SX!l'SX!q'SX!t'SX#O'SX#P'SX#p'SX'g'SX'q'SX'r'SX'x'SX'y'SX'z'SX'{'SX'|'SX'}'SX(O'SX(P'SX(Q'SX(R'SX(T'SXv'SX~OX'SX!e'SX!P'SX#R'SX~P'ZOr!uO']!wO'_!uO~Od!xO~O^RO_RO`ROaRO'TQO~Od!}O~Od#PO[(SXo(SXy(SX}(SX!l(SX!q(SX!t(SX#O(SX#P(SX#p(SX'g(SX'q(SX'r(SX'x(SX'y(SX'z(SX'{(SX'|(SX'}(SX(O(SX(P(SX(Q(SX(R(SX(T(SXv(SX~OZ#OO~P*`OZ#RO[#QO~OQ!QO^#TO_#TO`#TOa#]Od#ZOg!nOyvO|!VO!Q!dO!U#^O!W!lO!]!pO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'Q#VO'T#SO~OPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdO~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!j#eO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdO~P)xO[#}Oo#xO}#zO!l#yO!q#jO!t#yO#O#xO#P#uO#p$OO'g#gO'q#yO'r#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO~OPoOQ!QOSVOTVOZeOd[OsVOtVOuVOw!PO!U#bO!W#cO!X!^O!Z!YO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO[#sXo#sXy#sX}#sX!l#sX!q#sX!t#sX#O#sX#P#sX#p#sX'g#sX'q#sX'r#sX'x#sX'y#sX'z#sX'{#sX'|#sX'}#sX(O#sX(P#sX(Q#sX(R#sX(T#sXX#sX!e#sX!P#sXv#sX#R#sX~P)xOX(SX!e(SX!P(SXw(SX#R(SX~P*`OPoOQ!QOSVOTVOX$ROZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q$UO'ZkO'^UO'gcO'qiO(QdO~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!P$XO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q$UO'ZkO'^UO'gcO'qiO(QdO~P)xOQ!QOSVOTVO[$gO^$pO_$ZO`9yOa9yOd$aOsVOtVOuVO}$eO!i$qO!l$lO!q$hO#V$lO'T$YO'^UO'g$[O~O!j$rOP(XP~P<cOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Q$uO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdO~P)xOw$vO~Oo'bX#O'bX#P'bX#p'bX'r'bX'x'bX'y'bX'z'bX'{'bX'|'bX'}'bX(O'bX(P'bX(R'bX(T'bX~OP%tXQ%tXS%tXT%tXZ%tX[%tX^%tX_%tX`%tXa%tXd%tXg%tXs%tXt%tXu%tXw%tXy%tX|%tX}%tX!Q%tX!U%tX!W%tX!X%tX!Z%tX!]%tX!l%tX!q%tX!t%tX#Y%tX#r%tX#{%tX$O%tX$b%tX$d%tX$f%tX$i%tX$m%tX$q%tX$s%tX%T%tX%V%tX%Z%tX%]%tX%^%tX%f%tX%j%tX%s%tX&z%tX'Q%tX'T%tX'Z%tX'^%tX'g%tX'q%tX(Q%tXv%tX~P@[Oy$xO['bX}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bXv'bX~P@[Ow$yO!Q(iX!U(iX!W(iX$q(iX%](iX%^(iX~Oy$zO~PEsO!Q$}O!U%UO!W!lO$m%OO$q%PO$s%QO%T%RO%V%SO%Z%TO%]!lO%^%VO%f%WO%j%XO%s%YO~O!Q!lO!U!lO!W!lO$q%[O%]!lO~O%^%VO~PGaOPoOQ!QOSVOTVOZeO[lO^RO_RO`ROa!UOd[Og!nOsVOtVOuVOw!POyvO|!VO}mO!Q!dO!U!WO!W!XO!X!^O!Z!YO!]!pO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'Q#VO'TQO'ZkO'^UO'gcO'qiO(QdO~Ov%`O~P]OQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaO!Q{X!U{X!W{X$m{X$q{X$s{X%T{X%V{X%Z{X%]{X%^{X%f{X%j{X%s{X~P'ZO!Q{X!U{X!W{X$m{X$q{X$s{X%T{X%V{X%Z{X%]{X%^{X%f{X%j{X%s{X~O}%}O'T{XQ{XZ{X[{X^{X_{X`{Xa{Xd{Xg{X!q{X$f{X&W{X'Z{X(Q{X~PMuOg&PO%f%WO!Q(iX!U(iX!W(iX$q(iX%](iX%^(iX~Ow!PO~P! yOw!PO!X&RO~PEvOPoOQ!QOSVOTVOZeO[lO^9qO_9qO`9qOa9qOd9tOsVOtVOuVOw!PO}mO!U#bO!W#cO!X:zO!Z!YO!]&UO!l9wO!q9vO!t9wO#Y!_O#r9zO#{9{O$O!]O$b!`O$d!bO$f!cO'T9oO'ZkO'^UO'gcO'q9wO(QdO~OPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdOo#qXy#qX#O#qX#P#qX#p#qX'r#qX'x#qX'y#qX'z#qX'{#qX'|#qX'}#qX(O#qX(P#qX(R#qX(T#qXX#qX!e#qX!P#qXv#qX#R#qX~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdOo#zXy#zX#O#zX#P#zX#p#zX'r#zX'x#zX'y#zX'z#zX'{#zX'|#zX'}#zX(O#zX(P#zX(R#zX(T#zXX#zX!e#zX!P#zXv#zX#R#zX~P)xO'ZkO[#}Xo#}Xy#}X}#}X!l#}X!q#}X!t#}X#O#}X#P#}X#p#}X'g#}X'q#}X'r#}X'x#}X'y#}X'z#}X'{#}X'|#}X'}#}X(O#}X(P#}X(Q#}X(R#}X(T#}XX#}X!e#}X!P#}Xv#}Xw#}X#R#}X~OPoO~OPoOQ!QOSVOTVOZeO[lO^9qO_9qO`9qOa9qOd9tOsVOtVOuVOw!PO}mO!U#bO!W#cO!X:zO!Z!YO!l9wO!q9vO!t9wO#Y!_O#r9zO#{9{O$O!]O$b!`O$d!bO$f!cO'T9oO'ZkO'^UO'gcO'q9wO(QdO~O!S&_O~Ow!PO~O!j&bO~P<cO'T&cO~PEvOZ&eO~O'T&cO~O'^UOw(^Xy(^X!Q(^X!U(^X!W(^X$q(^X%](^X%^(^X~Oa&hO~P!1iO'T&iO~O_&nO'T&cO~OQ&oOZ&pO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaO!j&uO~P<cO^&wO_&wO`&wOa&wOd'POw&|O'T&vO(Q&}O~O!i'UO!j'TO'T&cO~O&}!sO'O'VO'P'XO~Or!uO']'ZO'_!uO~OQ']O^'ia_'ia`'iaa'ia'T'ia~O['cOw'dO}'bO~OQ']O~OQ!QO^#TO_#TO`#TOa'kOd#ZO'T#SO~O['lO~OZbXdlXXbXobXPbX!SbX!ebX'rbX!PbX!ObXybX!ZbX#RbXvbX~O[bXwbX}bX~P!6mOZ'SXd'XXX'SX['SXo'SXw'SX}'SX#p'SXP'SX!S'SX!e'SX'r'SX!P'SX!O'SXy'SX!Z'SX#R'SXv'SX~O^#TO_#TO`#TOa'kO'T#SO~OZ'mO~Od'oO~OZ'SXd'XX~PMuOZ'pOX(SX!e(SX!P(SXw(SX#R(SX~P*`O[#}O}#zO(O#|O(R#fOo#_ay#_a!l#_a!q#_a!t#_a#O#_a#P#_a#p#_a'g#_a'q#_a'r#_a'x#_a'y#_a'z#_a'{#_a'|#_a'}#_a(P#_a(Q#_a(T#_aX#_a!e#_a!P#_av#_aw#_a#R#_a~Ow!PO!X&RO~Oy#caX#ca!e#ca!P#cav#ca#R#ca~P2gOPoOQ!QOSVOTVOZeOd[OsVOtVOuVOw!PO!U#bO!W#cO!X!^O!Z!YO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO[#sao#say#sa}#sa!l#sa!q#sa!t#sa#O#sa#P#sa#p#sa'g#sa'q#sa'r#sa'x#sa'y#sa'z#sa'{#sa'|#sa'}#sa(O#sa(P#sa(Q#sa(R#sa(T#saX#sa!e#sa!P#sav#sa#R#sa~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q#VO'ZkO'^UO'gcO'qiO(QdO!P(UP~P)xOu(SO#w(TO'T(RO~O[#}O}#zO!q#jO'g#gO'r#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO!l#sa!t#sa#p#sa'q#sa~Oo#xO#O#xO#P#uOy#saX#sa!e#sa!P#sav#sa#R#sa~P!B}Oy(YO!e(WOX(WX~P2gOX(ZO~OPoOQ!QOSVOTVOX(ZOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q$UO'ZkO'^UO'gcO'qiO(QdO~P)xOZ#RO~O!P(_O!e(WO~P2gOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q$UO'ZkO'^UO'gcO'qiO(QdO~P)xOZbXdlXwjX}jX!tbX'qbX~OP!RX!S!RX!e!RX'p!RX'r!RX!O!RXo!RXy!RX!P!RXX!RX!Z!RX#R!RXv!RX~P!JUOZ'SXd'XXw'kX}'kX!t'SX'q'SX~OP!`X!S!`X!e!`X'r!`X!O!`Xo!`Xy!`X!P!`XX!`X!Z!`X#R!`Xv!`X~P!KgOT(aOu(aO~O!t(bO'q(bOP!^X!S!^X!e!^X'r!^X!O!^Xo!^Xy!^X!P!^XX!^X!Z!^X#R!^Xv!^X~O^9rO_9rO`9yOa9yO'T9pO~Od(eO~O'p(fOP'hX!S'hX!e'hX'r'hX!O'hXo'hXy'hX!P'hXX'hX!Z'hX#R'hXv'hX~O!j&bO!P'lP~P<cOw(kO}(jO~O!j&bOX'lP~P<cO!j(oO~P<cOZ'pO!t(bO'q(bO~O!S(qO'r(pOP$WX!e$WX~O!e(rOP(YX~OP(tO~OP!aX!S!aX!e!aX'r!aX!O!aXo!aXy!aX!P!aXX!aX!Z!aX#R!aXv!aX~P!KgOy$UaX$Ua!e$Ua!P$Uav$Ua#R$Ua~P2gO!l(|O'Q#VO'T(xOv(ZP~OQ!QO^#TO_#TO`#TOa#]Od#ZOg!nOyvO|!VO!Q!dO!U#^O!W!lO!]!pO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'Q`O'T#SO~Ov)TO~P#$iOy)VO~PEsO%^)WO~PGaOa)ZO~P!1iO%f)`O~PEvO_)aO'T&cO~O!i)fO!j)eO'T&cO~O'^UO!Q(^X!U(^X!W(^X$q(^X%](^X%^(^X~Ov%uX~P2gOv)gO~PGyOv)gO~Ov)gO~P]OQiXQ'XXZiXd'XX}iX#piX(PiX~ORiXwiX$fiX$|iX[iXoiXyiX!liX!qiX!tiX#OiX#PiX'giX'qiX'riX'xiX'yiX'ziX'{iX'|iX'}iX(OiX(QiX(RiX(TiX!PiX!eiXXiXPiXviX!SiX#RiX~P#(kOQjXQlXRjXZjXdlX}jX#pjX(PjXwjX$fjX$|jX[jXojXyjX!ljX!qjX!tjX#OjX#PjX'gjX'qjX'rjX'xjX'yjX'zjX'{jX'|jX'}jX(OjX(QjX(RjX(TjX!PjX!ejXXjX!SjXPjXvjX#RjX~O%^)jO~PGaOQ']Od)kO~O^)mO_)mO`)mOa)mO'T%dO~Od)qO~OQ']OZ)uO})sOR'UX#p'UX(P'UXw'UX$f'UX$|'UX['UXo'UXy'UX!l'UX!q'UX!t'UX#O'UX#P'UX'g'UX'q'UX'r'UX'x'UX'y'UX'z'UX'{'UX'|'UX'}'UX(O'UX(Q'UX(R'UX(T'UX!P'UX!e'UXX'UXP'UXv'UX!S'UX#R'UX~OQ!QO^:bO_:^O`TOaTOd:aO%^)jO'T:_O~PGaOQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!j)yO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaOQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!P)|O!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaO(P*OO~OR*QO#p*RO(P*PO~OQhXQ'XXZhXd'XX}hX(PhX~ORhX#phXwhX$fhX$|hX[hXohXyhX!lhX!qhX!thX#OhX#PhX'ghX'qhX'rhX'xhX'yhX'zhX'{hX'|hX'}hX(OhX(QhX(RhX(ThX!PhX!ehXXhXPhXvhX!ShX#RhX~P#4kOQ*SO~O})sO~OQ!QO^%vO_%cO`TOaTOd%jO$f%wO%^%xO'T%dO~PGaO!Q*VO!j*VO~O^*YO`*YOa*YO!O*ZO~OQ&oOZ*[O[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaO[#}Oo:YO}#zO!l:ZO!q#jO!t:ZO#O:YO#P:VO#p$OO'g#gO'q:ZO'r#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO~Ow'dX~P#9vOy#qaX#qa!e#qa!P#qav#qa#R#qa~P2gOy#zaX#za!e#za!P#zav#za#R#za~P2gOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!S&_O!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdOo#zay#za#O#za#P#za#p#za'r#za'x#za'y#za'z#za'{#za'|#za'}#za(O#za(P#za(R#za(T#zaX#za!e#za!P#zav#za#R#za~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Q*eO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdO~P)xOw*fO~P#9vO$b*iO$d*jO$f*kO~O!O*lO'r(pO~O!S*nO~O'T*oO~Ow$yOy*qO~O'T*rO~OQ*uOw*vOy*yO}*wO$|*xO~OQ*uOw*vO$|*xO~OQ*uOw+QO$|*xO~OQ*uOo+VOy+XO!S+UO~OQ*uO}+ZO~OQ!QOZ%rO[%qO^%vO`TOaTOd%jOg%yO}%pO!U!lO!W!lO!q%oO$f%wO$q%[O%]!lO%^%xO&W%{O'T%dO'Z%eO(Q%zO~OR+bO_+^O!Q+cO~P#DkO_%cO!Q!lOw&UX$|&UX(P&UX~P#DkOw$yO$f+hO$|*xO(P*PO~OQ!QOZ*[O[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaOQ*uOw$yO!S+UO$|*xO~Oo+nOy+mO!S+oO'r(pO~OdlXy!RX#pbXv!RX!e!RX~Od'XXy(mX#p'SXv(mX!e(mX~Od+qO~O^#TO_#TO`#TOa'kOw&|O'T&vO(Q+vO~Ov(oP~P!3|O#p+{O~Oy+|O~O!S+}O~O&}!sO'O'VO'P,PO~Od,QO~OSVOTVO_%cOsVOtVOuVOw!PO!Q!lO'^UO~P#DkOS,^OT,^OZ,^O['cO_,YOd,^Oo,^Os,^Ou,^Ow'dOy,^O}'bO!S,^O!e,^O!l,^O!q,[O!t,^O!y,^O#O,^O#P,^O#Q,^O#R,^O'Q,^O'Z%eO'^UO'g,ZO'r,[O'v,_O'x,ZO'y,[O'z,[O'{,[O'|,]O'},]O(O,^O(P,`O(Q,`O(R,aO~O!P,dO~P#KkOX,gO~P#KkOv,iO~P#KkOo'tX#O'tX#P'tX#p'tX'r'tX'x'tX'y'tX'z'tX'{'tX'|'tX'}'tX(O'tX(P'tX(R'tX(T'tX~Oy,jO['tX}'tX!l'tX!q'tX!t'tX'g'tX'q'tX(Q'tXv'tX~P#NjOP$giQ$giS$giT$giZ$gi[$gi^$gi_$gi`$gia$gid$gig$gis$git$giu$giw$giy$gi|$gi}$gi!Q$gi!U$gi!W$gi!X$gi!Z$gi!]$gi!l$gi!q$gi!t$gi#Y$gi#r$gi#{$gi$O$gi$b$gi$d$gi$f$gi$i$gi$m$gi$q$gi$s$gi%T$gi%V$gi%Z$gi%]$gi%^$gi%f$gi%j$gi%s$gi&z$gi'Q$gi'T$gi'Z$gi'^$gi'g$gi'q$gi(Q$giv$gi~P#NjOX,kO~O['cOo,lOw'dO}'bOX]X~Oy#ciX#ci!e#ci!P#civ#ci#R#ci~P2gO[#}O}#zO'x#hO(O#|O(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!q#ei!t#ei#O#ei#P#ei#p#ei'q#ei'r#ei'y#ei'z#ei'{#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#R#ei~O'g#ei(P#ei~P$'PO[#}O}#zO(O#|O(R#fOo#eiy#ei!l#ei!q#ei!t#ei#O#ei#P#ei#p#ei'q#ei'r#ei'y#ei'z#ei'{#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#R#ei~O'g#ei'x#ei(P#ei(Q#ei(T#eiw#ei~P$)QO'g#gO(P#gO~P$'PO[#}O}#zO'g#gO'x#hO'y#iO'z#iO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!t#ei#O#ei#P#ei#p#ei'q#ei'r#ei'{#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#R#ei~O!q#ei~P$+`O!q#jO~P$+`O[#}O}#zO!q#jO'g#gO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!t#ei#O#ei#P#ei#p#ei'q#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#R#ei~O'r#ei~P$-hO'r#lO~P$-hO[#}O}#zO!q#jO#P#uO'g#gO'r#lO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!t#ei#O#ei#p#ei'q#ei'|#eiX#ei!e#ei!P#eiv#ei#R#ei~O'}#ei~P$/pO'}#mO~P$/pO[#}O}#zO!q#jO'g#gO'r#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO!l#ni!t#ni#p#ni'q#ni~Oo#xO#O#xO#P#uOy#niX#ni!e#ni!P#niv#ni#R#ni~P$1xO[#}O}#zO!q#jO'g#gO'r#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO!l#si!t#si#p#si'q#si~Oo#xO#O#xO#P#uOy#siX#si!e#si!P#siv#si#R#si~P$3yOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q#VO'ZkO'^UO'gcO'qiO(QdO~P)xO!e,sO!P(VX~P2gO!P,uO~OX,vO~P2gOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdOX&fX!e&fX!P&fX~P)xO!e(WOX(Wa~Oy,zO!e(WOX(WX~P2gOX,{O~O!P,|O!e(WO~O!P-OO!e(WO~P2gOSVOTVOsVOtVOuVO'^UO'g$[O~P!6POP!baZca!S!ba!e!ba!tca'qca'r!ba!O!bao!bay!ba!P!baX!ba!Z!ba#R!bav!ba~O!e-TO'r(pO!P'mXX'mX~O!P-VO~O!i-`O!j-_O!l-[O'T-XOv'nP~OX-aO~O_%cO!Q!lO~P#DkO!j-gOP&gX!e&gX~P<cO!e(rOP(Ya~O!S-iO'r(pOP$Wa!e$Wa~Ow!PO(P*PO~OvbX!S!kX!ebX~O'Q#VO'T(xO~O!S-mO~O!e-oOv([X~Ov-qO~Ov-sO~P,cOv-sO~P#$iO_-uO'T&cO~O!S-vO~Ow$yOy-wO~OQ*uOw*vOy-zO}*wO$|*xO~OQ*uOo.UO~Oy._O~O!S.`O~O!j.bO'T&cO~Ov.cO~Ov.cO~PGyOQ']O^'Wa_'Wa`'Waa'Wa'T'Wa~Od.gO~OQ'XXQ'kXR'kXZ'kXd'XX}'kX#p'kX(P'kXw'kX$f'kX$|'kX['kXo'kXy'kX!l'kX!q'kX!t'kX#O'kX#P'kX'g'kX'q'kX'r'kX'x'kX'y'kX'z'kX'{'kX'|'kX'}'kX(O'kX(Q'kX(R'kX(T'kX!P'kX!e'kXX'kXP'kXv'kX!S'kX#R'kX~OQ!QOZ%rO[%qO^.rO_%cO`TOaTOd%jOg%yO}%pO!j.sO!q.pO!t.kO#V.mO$f%wO%^%xO&W%{O'Q#VO'T%dO'Z%eO(Q%zO!P(sP~PGaO#Q.tOR%wa#p%wa(P%waw%wa$f%wa$|%wa[%wao%way%wa}%wa!l%wa!q%wa!t%wa#O%wa#P%wa'g%wa'q%wa'r%wa'x%wa'y%wa'z%wa'{%wa'|%wa'}%wa(O%wa(Q%wa(R%wa(T%wa!P%wa!e%waX%waP%wav%wa!S%wa#R%wa~O%^.vO~PGaO(P*POR&Oa#p&Oaw&Oa$f&Oa$|&Oa[&Oao&Oay&Oa}&Oa!l&Oa!q&Oa!t&Oa#O&Oa#P&Oa'g&Oa'q&Oa'r&Oa'x&Oa'y&Oa'z&Oa'{&Oa'|&Oa'}&Oa(O&Oa(Q&Oa(R&Oa(T&Oa!P&Oa!e&OaX&OaP&Oav&Oa!S&Oa#R&Oa~O_%cO!Q!lO!j.xO(P*OO~P#DkO!e.yO(P*PO!P(uX~O!P.{O~OX.|Oy.}O(P*PO~O'Z%eOR(qP~OQ']O})sORfa#pfa(Pfawfa$ffa$|fa[faofayfa!lfa!qfa!tfa#Ofa#Pfa'gfa'qfa'rfa'xfa'yfa'zfa'{fa'|fa'}fa(Ofa(Qfa(Rfa(Tfa!Pfa!efaXfaPfavfa!Sfa#Rfa~OQ']O})sOR&Va#p&Va(P&Vaw&Va$f&Va$|&Va[&Vao&Vay&Va!l&Va!q&Va!t&Va#O&Va#P&Va'g&Va'q&Va'r&Va'x&Va'y&Va'z&Va'{&Va'|&Va'}&Va(O&Va(Q&Va(R&Va(T&Va!P&Va!e&VaX&VaP&Vav&Va!S&Va#R&Va~O!P/UO~Ow$yO$f/ZO$|*xO(P*PO~OQ!QOZ/[O[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaOo/^O'r(pO~O#W/_OP!YiQ!YiS!YiT!YiZ!Yi[!Yi^!Yi_!Yi`!Yia!Yid!Yig!Yio!Yis!Yit!Yiu!Yiw!Yiy!Yi|!Yi}!Yi!Q!Yi!U!Yi!W!Yi!X!Yi!Z!Yi!]!Yi!l!Yi!q!Yi!t!Yi#O!Yi#P!Yi#Y!Yi#p!Yi#r!Yi#{!Yi$O!Yi$b!Yi$d!Yi$f!Yi$i!Yi$m!Yi$q!Yi$s!Yi%T!Yi%V!Yi%Z!Yi%]!Yi%^!Yi%f!Yi%j!Yi%s!Yi&z!Yi'Q!Yi'T!Yi'Z!Yi'^!Yi'g!Yi'q!Yi'r!Yi'x!Yi'y!Yi'z!Yi'{!Yi'|!Yi'}!Yi(O!Yi(P!Yi(Q!Yi(R!Yi(T!YiX!Yi!e!Yi!P!Yiv!Yi!i!Yi!j!Yi#V!Yi#R!Yi~Oy#ziX#zi!e#zi!P#ziv#zi#R#zi~P2gOy$UiX$Ui!e$Ui!P$Uiv$Ui#R$Ui~P2gOv/eO!j&bO'Q`O~P<cOw/nO}/mO~Oy!RX#pbX~Oy/oO~O#p/pO~OR+bO_+dO!Q/sO'T&iO'Z%eO~Oa/zO|!VO'Q#VO'T(ROv(cP~OQ!QOZ%rO[%qO^%vO_%cO`TOa/zOd%jOg%yO|!VO}%pO!q%oO$f%wO%^%xO&W%{O'Q#VO'T%dO'Z%eO(Q%zO!P(eP~PGaOQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f0VO%^%xO&W%{O'T%dO'Z%eO(Q%zOw(`Py(`P~PGaOw*vO~Oy-zO$|*xO~Oa/zO|!VO'Q#VO'T*oOv(gP~Ow+QO~OQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f0VO%^%xO&W%{O'T%dO'Z%eO(Q%zO(R0`O~PGaOy0dO~OQ!QOSVOTVO[$gO^0lO_$ZO`9yOa9yOd$aOsVOtVOuVO}$eO!i$qO!j0mO!l$lO!q0eO!t0hO'Q#VO'T$YO'Z%eO'^UO'g$[O~O#V0nO!P(jP~P%1}Ow!POy0pO#Q0rO$|*xO~OR0uO!e0sO~P#(kOR0uO!S+UO!e0sO(P*OO~OR0uOo0wO!S+UO!e0sOQ'VXZ'VX}'VX#p'VX(P'VX~OR0uOo0wO!e0sO~OR0uO!e0sO~O$f/ZO(P*PO~Ow$yO~Ow$yO$|*xO~Oo0}Oy0|O!S1OO'r(pO~O!e1POv(pX~Ov1RO~O^#TO_#TO`#TOa'kOw&|O'T&vO(Q1VO~Oo1YOQ'VXR'VXZ'VX}'VX!e'VX(P'VX~O!e1ZO(P*POR'YX~O!e1ZOR'YX~O!e1ZO(P*OOR'YX~OR1]O~O!S1^OS'wXT'wXZ'wX['wX_'wXd'wXo'wXs'wXu'wXw'wXy'wX}'wX!P'wX!e'wX!l'wX!q'wX!t'wX!y'wX#O'wX#P'wX#Q'wX#R'wX'Q'wX'Z'wX'^'wX'g'wX'r'wX'v'wX'x'wX'y'wX'z'wX'{'wX'|'wX'}'wX(O'wX(P'wX(Q'wX(R'wXX'wXv'wX~O}1_O~O!P1aO~P#KkOX1bO~P#KkOv1cO~P#KkOS,^OT,^OZ,^O['cO_1dOd,^Oo,^Os,^Ou,^Ow'dOy,^O}'bO!S,^O!e,^O!l,^O!q,[O!t,^O!y,^O#O,^O#P,^O#Q,^O#R,^O'Q,^O'Z%eO'^UO'g,ZO'r,[O'v,_O'x,ZO'y,[O'z,[O'{,[O'|,]O'},]O(O,^O(P,`O(Q,`O(R,aO~OX1fO~Oy,jO~O!e,sO!P(Va~P2gOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q#VO'ZkO'^UO'gcO'qiO(QdO!P&eX!e&eX~P)xO!e,sO!P(Va~OX&fa!e&fa!P&fa~P2gOX1kO~P2gO!P1mO!e(WO~OP!biZci!S!bi!e!bi!tci'qci'r!bi!O!bio!biy!bi!P!biX!bi!Z!bi#R!biv!bi~O'r(pOP!oi!S!oi!e!oi!O!oio!oiy!oi!P!oiX!oi!Z!oi#R!oiv!oi~O!j&bO!P&`X!e&`XX&`X~P<cO!e-TO!P'maX'ma~O!P1qO~Ov!RX!S!kX!e!RX~O!S1rO~O!e1sOv'oX~Ov1uO~O'T-XO~O!j1xO'T-XO~O(P*POP$Wi!e$Wi~O!S1yO'r(pOP$XX!e$XX~O!S1|O~Ov$_a!e$_a~P2gO!l(|O'Q#VO'T(xOv&hX!e&hX~O!e-oOv([a~Ov2QO~P,cOy2UO~O#p2VO~Oy2WO$|*xO~Ow*vOy2WO}*wO$|*xO~Oo2aO~Ow!POy2fO#Q2hO$|*xO~O!S2jO~Ov2lO~O#Q2mOR%wi#p%wi(P%wiw%wi$f%wi$|%wi[%wio%wiy%wi}%wi!l%wi!q%wi!t%wi#O%wi#P%wi'g%wi'q%wi'r%wi'x%wi'y%wi'z%wi'{%wi'|%wi'}%wi(O%wi(Q%wi(R%wi(T%wi!P%wi!e%wiX%wiP%wiv%wi!S%wi#R%wi~Od2nO~O^2qO!j.sO!q2rO'Q#VO'Z%eO~O(P*PO!P%{X!e%{X~O!e2sO!P(tX~O!P2uO~OQ!QOZ%rO[%qO^2wO_%cO`TOaTOd%jOg%yO}%pO!j2xO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaO^2yO!j2xO(P*OO~O!P%aX!e%aX~P#4kO^2yO~O(P*POR&Oi#p&Oiw&Oi$f&Oi$|&Oi[&Oio&Oiy&Oi}&Oi!l&Oi!q&Oi!t&Oi#O&Oi#P&Oi'g&Oi'q&Oi'r&Oi'x&Oi'y&Oi'z&Oi'{&Oi'|&Oi'}&Oi(O&Oi(Q&Oi(R&Oi(T&Oi!P&Oi!e&OiX&OiP&Oiv&Oi!S&Oi#R&Oi~O_%cO!Q!lO!P&yX!e&yX~P#DkO!e.yO!P(ua~OR3QO(P*PO~O!e3ROR(rX~OR3TO~O(P*POR&Pi#p&Piw&Pi$f&Pi$|&Pi[&Pio&Piy&Pi}&Pi!l&Pi!q&Pi!t&Pi#O&Pi#P&Pi'g&Pi'q&Pi'r&Pi'x&Pi'y&Pi'z&Pi'{&Pi'|&Pi'}&Pi(O&Pi(Q&Pi(R&Pi(T&Pi!P&Pi!e&PiX&PiP&Piv&Pi!S&Pi#R&Pi~O!P3UO~O$f3VO(P*PO~Ow$yO$f3VO$|*xO(P*PO~Ow!PO!Z!YO~O!Z3aO#R3_O'r(pO~O!j&bO'Q#VO~P<cOv3eO~Ov3eO!j&bO'Q`O~P<cO!O3hO'r(pO~Ow!PO~P#9vOo3kOy3jO(P*PO~O!P3oO~P%;pOv3rO~P%;pOR0uO!S+UO!e0sO~OR0uOo0wO!S+UO!e0sO~Oa/zO|!VO'Q#VO'T(RO~O!S3uO~O!e3wOv(dX~Ov3yO~OQ!QOZ%rO[%qO^%vO_%cO`TOa/zOd%jOg%yO|!VO}%pO!q%oO$f%wO%^%xO&W%{O'Q#VO'T%dO'Z%eO(Q%zO~PGaO!e3|O(P*PO!P(fX~O!P4OO~O!S4PO(P*OO~O!S+UO(P*PO~O!e4ROw(aXy(aX~OQ4TO~Oy2WO~Oa/zO|!VO'Q#VO'T*oO~Oo4WOw*vO}*wOv%XX!e%XX~O!e4ZOv(hX~Ov4]O~O(P4_Oy(_Xw(_X$|(_XR(_Xo(_X!e(_X~Oy4aO(P*PO~OQ!QOSVOTVO[$gO^4bO_$ZO`9yOa9yOd$aOsVOtVOuVO}$eO!i$qO!l$lO!q$hO#V$lO'T$YO'^UO'g$[O~O!j4cO'Z%eO~P&,sO!S4eO'r(pO~O#V4gO~P%1}O!e4hO!P(kX~O!P4jO~O!P%aX!S!aX!e%aX'r!aX~P!KgO!j&bO~P&,sO!e4hO!P(kX!S'eX'r'eX~O^2yO!j2xO~Ow!POy2fO~O_4pO!Q/sO'T&iO'Z%eOR&lX!e&lX~OR4rO!e0sO~O!S4tO~Ow$yO$|*xO(P*PO~Oy4uO~P2gOo4vOy4uO(P*PO~Ov&uX!e&uX~P!3|O!e1POv(pa~Oo4|Oy4{O(P*PO~OSVOTVO_%cOsVOtVOuVOw!PO!Q!lO'^UOR&vX!e&vX~P#DkO!e1ZOR'Ya~O!y5SO~O!P5TO~P#KkO!S1^OX'wX#R'wX~O!e,sO!P(Vi~O!P&ea!e&ea~P2gOX5WO~P2gOP!bqZcq!S!bq!e!bq!tcq'qcq'r!bq!O!bqo!bqy!bq!P!bqX!bq!Z!bq#R!bqv!bq~O'r(pO!P&`a!e&`aX&`a~O!i-`O!j-_O!l5YO'T-XOv&aX!e&aX~O!e1sOv'oa~O!S5[O~O!S5`O'r(pOP$Xa!e$Xa~O(P*POP$Wq!e$Wq~Ov$^i!e$^i~P2gOw!POy5bO#Q5dO$|*xO~Oo5gOy5fO(P*PO~Oy5iO~Oy5iO$|*xO~Oy5mO(P*PO~Ow!POy5bO~Oo5tOy5sO(P*PO~O!S5vO~O!e2sO!P(ta~O^2yO!j2xO'Z%eO~OQ!QOZ%rO[%qO^.rO_%cO`TOaTOd%jOg%yO}%pO!j.sO!q.pO!t5zO#V5|O$f%wO%^%xO&W%{O'Q#VO'T%dO'Z%eO(Q%zO!P&xX!e&xX~PGaOQ!QOZ%rO[%qO^6OO_%cO`TOaTOd%jOg%yO}%pO!j6PO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(P*OO(Q%zO~PGaO!P%aa!e%aa~P#4kO^6QO~O#Q6ROR%wq#p%wq(P%wqw%wq$f%wq$|%wq[%wqo%wqy%wq}%wq!l%wq!q%wq!t%wq#O%wq#P%wq'g%wq'q%wq'r%wq'x%wq'y%wq'z%wq'{%wq'|%wq'}%wq(O%wq(Q%wq(R%wq(T%wq!P%wq!e%wqX%wqP%wqv%wq!S%wq#R%wq~O(P*POR&Oq#p&Oqw&Oq$f&Oq$|&Oq[&Oqo&Oqy&Oq}&Oq!l&Oq!q&Oq!t&Oq#O&Oq#P&Oq'g&Oq'q&Oq'r&Oq'x&Oq'y&Oq'z&Oq'{&Oq'|&Oq'}&Oq(O&Oq(Q&Oq(R&Oq(T&Oq!P&Oq!e&OqX&OqP&Oqv&Oq!S&Oq#R&Oq~O(P*PO!P&ya!e&ya~OX6SO~P2gO'Z%eOR&wX!e&wX~O!e3ROR(ra~O$f6YO(P*PO~Ow![q~P#9vO#R6]O~O!Z3aO#R6]O'r(pO~Ov6bO~O#R6fO~Oy6gO!P6hO~O!P6hO~P%;pOy6kO~Ov6kOy6gO~Ov6kO~P%;pOy6mO~O!e3wOv(da~O!S6pO~Oa/zO|!VO'Q#VO'T(ROv&oX!e&oX~O!e3|O(P*PO!P(fa~OQ!QOZ%rO[%qO^%vO_%cO`TOa/zOd%jOg%yO|!VO}%pO!q%oO$f%wO%^%xO&W%{O'Q#VO'T%dO'Z%eO(Q%zO!P&pX!e&pX~PGaO!e3|O!P(fa~OQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f0VO%^%xO&W%{O'T%dO'Z%eO(Q%zOw&nX!e&nXy&nX~PGaO!e4ROw(aay(aa~O!e4ZOv(ha~Oo7SOv%Xa!e%Xa~Oo7SOw*vO}*wOv%Xa!e%Xa~Oa/zO|!VO'Q#VO'T*oOv&qX!e&qX~O(P*POy$xaw$xa$|$xaR$xao$xa!e$xa~O(P4_Oy(_aw(_a$|(_aR(_ao(_a!e(_a~O!P%aa!S!aX!e%aa'r!aX~P!KgOQ!QOSVOTVO[$gO_$ZO`9yOa9yOd$aOsVOtVOuVO}$eO!i$qO!j&bO!l$lO!q$hO#V$lO'T$YO'^UO'g$[O~O^7ZO~P&JUO^6QO!j6PO~O!e4hO!P(ka~O!e4hO!P(ka!S'eX'r'eX~OQ!QOSVOTVO[$gO^0lO_$ZO`9yOa9yOd$aOsVOtVOuVO}$eO!i$qO!j0mO!l$lO!q0eO!t7_O'Q#VO'T$YO'Z%eO'^UO'g$[O~O#V7aO!P&sX!e&sX~P&L]O!S7cO'r(pO~Ow!POy5bO$|*xO(P*PO~O!S+UOR&la!e&la~Oo0wO!S+UOR&la!e&la~Oo0wOR&la!e&la~O(P*POR$yi!e$yi~Oy7fO~P2gOo7gOy7fO(P*PO~O(P*PORni!eni~O(P*POR&va!e&va~O(P*OOR&va!e&va~OS,^OT,^OZ,^O_,^Od,^Oo,^Os,^Ou,^Oy,^O!S,^O!e,^O!l,^O!q,[O!t,^O!y,^O#O,^O#P,^O#Q,^O#R,^O'Q,^O'Z%eO'^UO'g,ZO'r,[O'x,ZO'y,[O'z,[O'{,[O'|,]O'},]O(O,^O~O(P7iO(Q7iO(R7iO~P'!qO!P7kO~P#KkO!P&ei!e&ei~P2gO'r(pOv!hi!e!hi~O!S7mO~O(P*POP$Xi!e$Xi~Ov$^q!e$^q~P2gOw!POy7oO~Ow!POy7oO#Q7rO$|*xO~Oy7tO~Oy7uO~Oy7vO(P*PO~Ow!POy7oO$|*xO(P*PO~Oo7{Oy7zO(P*PO~O!e2sO!P(ti~O(P*PO!P%}X!e%}X~O!P%ai!e%ai~P#4kO^8OO~O!e8TO['bXv$`i}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[OQ#[iS#[iT#[i[#[i^#[i_#[i`#[ia#[id#[is#[it#[iu#[iv$`i}#[i!i#[i!j#[i!l#[i!q#[i!t'bX#V#[i'Q#[i'T#[i'^#[i'g#[i'q'bX(Q'bX~P@[O#R#^a~P2gO#R8WO~O!Z3aO#R8XO'r(pO~Ov8[O~Oy8^O~P2gOy8`O~Oy6gO!P8aO~Ov8`Oy6gO~O!e3wOv(di~O(P*POv%Qi!e%Qi~O!e3|O!P(fi~O!e3|O(P*PO!P(fi~O(P*PO!P&pa!e&pa~O(P8hOw(bX!e(bXy(bX~O(P*PO!S$wiy$wiw$wi$|$wiR$wio$wi!e$wi~O!e4ZOv(hi~Ov%Xi!e%Xi~P2gOo8kOv%Xi!e%Xi~O!P%ai!S!aX!e%ai'r!aX~P!KgO(P*PO!P%`i!e%`i~O!e4hO!P(ki~O#V8nO~P&L]O!P&sa!S'eX!e&sa'r'eX~O(P*POR$zq!e$zq~Oy8pO~P2gOy7zO~P2gO(P8rO(Q8rO(R8rO~O(P8rO(Q8rO(R8rO~P'!qO'r(pOv!hq!e!hq~O(P*POP$Xq!e$Xq~Ow!POy8uO$|*xO(P*PO~Ow!POy8uO~Oy8xO~P2gOy8zO~P2gOo8|Oy8zO(P*PO~OQ#[qS#[qT#[q[#[q^#[q_#[q`#[qa#[qd#[qs#[qt#[qu#[qv$`q}#[q!i#[q!j#[q!l#[q!q#[q#V#[q'Q#[q'T#[q'^#[q'g#[q~O!e9PO['bXv$`q}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[Oo'bX!t'bX#O'bX#P'bX#p'bX'q'bX'r'bX'x'bX'y'bX'z'bX'{'bX'|'bX'}'bX(O'bX(P'bX(Q'bX(R'bX(T'bX~P'2fO#R9UO~O!Z3aO#R9UO'r(pO~Oy9WO~O(P*POv%Qq!e%Qq~O!e3|O!P(fq~O(P*PO!P&pi!e&pi~O(P8hOw(ba!e(bay(ba~Ov%Xq!e%Xq~P2gO!P&si!S'eX!e&si'r'eX~O(P*PO!P%`q!e%`q~Oy9]O~P2gO(P9^O(Q9^O(R9^O~O'r(pOv!hy!e!hy~Ow!POy9_O~Ow!POy9_O$|*xO(P*PO~Oy9aO~P2gOQ#[yS#[yT#[y[#[y^#[y_#[y`#[ya#[yd#[ys#[yt#[yu#[yv$`y}#[y!i#[y!j#[y!l#[y!q#[y#V#[y'Q#[y'T#[y'^#[y'g#[y~O!e9dO['bXv$`y}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[Oo'bX!t'bX#O'bX#P'bX#p'bX'q'bX'r'bX'x'bX'y'bX'z'bX'{'bX'|'bX'}'bX(O'bX(P'bX(Q'bX(R'bX(T'bX~P'9eO!e9eO['bX}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[OQ#[iS#[iT#[i[#[i^#[i_#[i`#[ia#[id#[is#[it#[iu#[i}#[i!i#[i!j#[i!l#[i!q#[i!t'bX#V#[i'Q#[i'T#[i'^#[i'g#[i'q'bX(Q'bX~P@[O#R9hO~O(P*PO!P&pq!e&pq~Ov%Xy!e%Xy~P2gOw!POy9iO~Oy9jO~P2gOQ#[!RS#[!RT#[!R[#[!R^#[!R_#[!R`#[!Ra#[!Rd#[!Rs#[!Rt#[!Ru#[!Rv$`!R}#[!R!i#[!R!j#[!R!l#[!R!q#[!R#V#[!R'Q#[!R'T#[!R'^#[!R'g#[!R~O!e9kO['bX}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[OQ#[qS#[qT#[q[#[q^#[q_#[q`#[qa#[qd#[qs#[qt#[qu#[q}#[q!i#[q!j#[q!l#[q!q#[q!t'bX#V#[q'Q#[q'T#[q'^#[q'g#[q'q'bX(Q'bX~P@[O!e9nO['bX}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[OQ#[yS#[yT#[y[#[y^#[y_#[y`#[ya#[yd#[ys#[yt#[yu#[y}#[y!i#[y!j#[y!l#[y!q#[y!t'bX#V#[y'Q#[y'T#[y'^#[y'g#[y'q'bX(Q'bX~P@[OwbX~P$|OwjX}jX!tbX'qbX~P!6mOZ'SXd'XXo'SXw'kX!t'SX'q'SX'r'SX~O['SXd'SXw'SX}'SX!l'SX!q'SX#O'SX#P'SX#p'SX'g'SX'x'SX'y'SX'z'SX'{'SX'|'SX'}'SX(O'SX(P'SX(Q'SX(R'SX(T'SX~P'GTOP'SX}'kX!S'SX!e'SX!O'SXy'SX!P'SXX'SX!Z'SX#R'SXv'SX~P'GTO^9qO_9qO`9qOa9qO'T9oO~O!j:OO~P!.cOPoOQ!QOSVOTVOZeOd9tOsVOtVOuVO!U#bO!W#cO!X:zO!Z!YO#Y!_O#r9zO#{9{O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO[#sXo#sXw#sX}#sX!l#sX!q#sX!t#sX#O#sX#P#sX#p#sX'g#sX'q#sX'r#sX'x#sX'y#sX'z#sX'{#sX'|#sX'}#sX(O#sX(P#sX(Q#sX(R#sX(T#sX~P'IxO#Q$uO~P!.cO}'kXP'SX!S'SX!e'SX!O'SXy'SX!P'SXX'SX!Z'SX#R'SXv'SX~P'GTOo#qX#O#qX#P#qX#p#qX'r#qX'x#qX'y#qX'z#qX'{#qX'|#qX'}#qX(O#qX(P#qX(R#qX(T#qX~P!.cOo#zX#O#zX#P#zX#p#zX'r#zX'x#zX'y#zX'z#zX'{#zX'|#zX'}#zX(O#zX(P#zX(R#zX(T#zX~P!.cOPoOQ!QOSVOTVOZeOd9tOsVOtVOuVO!U#bO!W#cO!X:zO!Z!YO#Y!_O#r9zO#{9{O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO[#sao#saw#sa}#sa!l#sa!q#sa!t#sa#O#sa#P#sa#p#sa'g#sa'q#sa'r#sa'x#sa'y#sa'z#sa'{#sa'|#sa'}#sa(O#sa(P#sa(Q#sa(R#sa(T#sa~P'IxOo:YO#O:YO#P:VOw#sa~P!B}Ow$Ua~P#9vOQ'XXd'XX}iX~OQlXdlX}jX~O^:sO_:sO`:sOa:sO'T:_O~OQ'XXd'XX}hX~Ow#qa~P#9vOw#za~P#9vO!S&_Oo#za#O#za#P#za#p#za'r#za'x#za'y#za'z#za'{#za'|#za'}#za(O#za(P#za(R#za(T#za~P!.cO#Q*eO~P!.cOw#ci~P#9vO[#}O}#zO'x#hO(O#|O(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!q#ei!t#ei#O#ei#P#ei#p#ei'q#ei'r#ei'y#ei'z#ei'{#ei'|#ei'}#ei~O'g#ei(P#ei~P((}O'g#gO(P#gO~P((}O[#}O}#zO'g#gO'x#hO'y#iO'z#iO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!t#ei#O#ei#P#ei#p#ei'q#ei'r#ei'{#ei'|#ei'}#ei~O!q#ei~P(*yO!q#jO~P(*yO[#}O}#zO!q#jO'g#gO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!t#ei#O#ei#P#ei#p#ei'q#ei'|#ei'}#ei~O'r#ei~P(,rO'r#lO~P(,rO[#}O}#zO!q#jO#P:VO'g#gO'r#lO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!t#ei#O#ei#p#ei'q#ei'|#ei~O'}#ei~P(.kO'}#mO~P(.kOo:YO#O:YO#P:VOw#ni~P$1xOo:YO#O:YO#P:VOw#si~P$3yOQ'XXd'XX}'kX~Ow#zi~P#9vOw$Ui~P#9vOd9}O~Ow#ca~P#9vOd:uO~OU'x_'v'P'O'^s!y'^'T'Z~",
  goto: "$Ku(vPPPPPPP(wPP)OPP)^PPPP)d-hP0f5aP7R7R8v7R>wD_DpPDvHQPPPPPPK`P! P! _PPPPP!!VP!$oP!$oPP!&oP!(rP!(w!)n!*f!*f!*f!(w!+]P!(w!.Q!.TPP!.ZP!(w!(w!(w!(wP!(w!(wP!(w!(w!.y!/dP!/dJ}J}J}PPPP!/d!.y!/sPP!$oP!0^!0a!0g!1h!1t!3t!3t!5r!7t!1t!1t!9p!;_!=O!>k!@U!Am!CS!De!1t!1tP!1tP!1t!1t!Et!1tP!Ge!1t!1tP!Ie!1tP!1t!7t!7t!1t!7t!1t!Kl!Mt!Mw!7t!1t!Mz!M}!M}!M}!NR!$oP!$oP!$oP! P! PP!N]! P! PP!Ni# }! PP! PP#!^##c##k#$Z#$_#$e#$e#$mP#&s#&s#&y#'o#'{! PP! PP#(]#(l! PP! PPP#(x#)W#)d#)|#)^! P! PP! P! P! PP#*S#*S#*Y#*`#*S#*S! P! PP#*m#*v#+Q#+Q#,x#.l#.x#.x#.{#.{5a5a5a5a5a5a5a5aP5a#/O#/U#/p#1{#2R#2b#6^#6d#6j#6|#7W#8w#9R#9b#9h#9n#9x#:S#:Y#:g#:m#:s#:}#;]#;g#=u#>R#>`#>f#>n#>u#?PPPPPPPP#?V#BaP#F^#Jx#Ls#Nr$&^P$&aPPP$)_$)h$)z$/U$1d$1m$3fP!(w$4`$7r$:i$>T$>^$>c$>fPPP$>i$A`$A|P$BaPPPPPPPPPP$BvP$EU$EX$E[$Eb$Ee$Eh$Ek$En$Et$HO$HR$HU$HX$H[$H_$Hb$He$Hh$Hk$Hn$Jt$Jw$Jz#*S$KW$K^$Ka$Kd$Kh$Kl$Ko$KrQ!tPT'V!s'Wi!SOlm!P!T$T$W$y%b)U*f/gQ'i#QR,n'l(OSOY[bfgilmop!O!P!T!Y!Z![!_!`!c!p!q!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r$y%X%_%b&U&Y&[&b&u&z&|'P'a'l'n'o'}(W(Y(b(d(e(f(j(o(p(r(|)S)U)i*Z*f*i*k*l+Z+n+z,q,s,z-R-T-g-m-t.}/^/b/d/g0e0g0m0}1P1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9s9t9u9v9w9x9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f:gS(z$v-oQ*p&eQ*t&hQ-k(yQ-y)ZW0Z+Q0Y4Z7UR4Y0[&w!RObfgilmop!O!P!T!Y!Z![!_!`!c!p#Q#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r$y%_%b&U&Y&[&b&u'l'}(W(Y(b(f(j(o(p(r(|)S)U)i*Z*f*i*k*l+Z+n,s,z-T-g-m-t.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f#r]Ofgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i+n,s,z-m.}0}1h1|3_3a3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9hb#[b#Q$y'l(b)S)U*Z-t!h$bo!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7m$b%k!Q!n$O$u%o%p%q%y%{&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g!W:y!Y!_!`*i*l/^3h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fR:|%n$_%u!Q!n$O$u%o%p%q&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g$e%l!Q!n$O$u%n%o%p%q%y%{&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g'hZOY[fgilmop!O!P!T!Y!Z![!_!`!c!p!|!}#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r%_%b%i%j&U&Y&[&b&u'a'}(W(Y(d(e(f(j(o(p(r(|)i)p)q*f*i*k*l+Z+n,s,z-R-T-g-m.i.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9s9t9u9v9w9x9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:`:a:e:f:g:t:u:x$^%l!Q!n$O$u%n%o%p%q%y%{&P&p&r(q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gQ&j!hQ&k!iQ&l!jQ&m!kQ&s!oQ)[%QQ)]%RQ)^%SQ)_%TQ)b%WQ+`&oS,R']1ZQ.W)`S/r*u4TR4n0s+yTOY[bfgilmop!O!P!Q!T!Y!Z![!_!`!c!n!p!q!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$O$T$W$`$a$e$g$h$q$r$u$y%X%_%b%i%j%n%o%p%q%y%{&P&U&Y&[&b&o&p&r&u&z&|'P']'a'l'n'o'}(W(Y(b(d(e(f(j(o(p(q(r(|)S)U)i)p)q)s)x)y*O*P*R*V*Z*[*^*e*f*i*k*l*n*w*x+U+V+Z+h+n+o+z+},q,s,z-R-T-g-i-m-t-v.U.`.i.p.t.x.y.}/Z/[/^/b/d/g/{/}0`0e0g0m0r0w0}1O1P1Y1Z1h1r1y1|2a2h2j2m2s2v3V3_3a3f3h3k3u3{3|4R4U4W4_4c4e4h4t4v4|5[5`5d5g5t5v6R6Y6]6a6p6v6x7S7^7c7g7m7r7{8W8X8g8k8|9U9h9s9t9u9v9w9x9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:`:a:e:f:g:t:u:xQ'[!xQ'h#PQ)l%gU)r%m*T*WR.f)kQ,T']R5P1Z#t%s!Q!n$O$u%p%q&P&p&r(q)x)y*O*R*V*[*^*e*n*w+V+h+o+}-i-v.U.`.t.x.y/Z/[/{/}0`0r0w1O1Y1y2a2h2j2m2v3V3u3{3|4U4e4t5`5d5v6R6Y6p6v6x7c7r8gQ)x%oQ+_&oQ,U']n,^'b'c'd,c,f,h,l/m/n1_3n3q5T5U7kS.q)s2sQ/O*PQ/Q*SQ/q*uS0Q*x4RQ0a+U[0o+Z.j0g4h5y7^Q2v.pS4d0e2rQ4m0sQ5Q1ZQ6T3RQ6z4PQ7O4TQ7X4_R9Y8h&jVOfgilmop!O!P!T!Y!Z![!_!`!c!p#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r%_%b&U&Y&[&b&u']'}(W(Y(b(f(j(o(p(r(|)i*f*i*k*l+Z+n,s,z-T-g-m.}/^/b/d/g0e0g0m0}1Z1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fU&g!g%P%[o,^'b'c'd,c,f,h,l/m/n1_3n3q5T5U7k$nsOfgilm!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y'}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9z9{:O:P:Q:R:S:T:U:V:W:X:Y:eS$tp9xS&O!W#bS&Q!X#cQ&`!bQ*_&RQ*a&VS*d&[:fQ*h&^Q,T']Q-j(wQ/i*jQ0p+[S2f.X0qQ3]/_Q3^/`Q3g/hQ3i/kQ5P1ZU5b2R2g4lU7o5c5e5rQ8]6dS8u7p7qS9_8v8wR9i9`i{Ob!O!P!T$y%_%b)S)U)i-thxOb!O!P!T$y%_%b)S)U)i-tW/v*v/t3w6qQ/}*wW0[+Q0Y4Z7UQ3{/{Q6x3|R8g6v!h$do!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mQ&d!dQ&f!fQ&n!mW&x!q%X&|1PQ'S!rQ)X$}Q)Y%OQ)a%VU)d%Y'T'UQ*s&hS+s&z'PS-Y(k1sQ-u)WQ-x)ZS.a)e)fS0x+c/sQ1S+zQ1W+{S1v-_-`Q2k.bQ3s/pQ5]1xR5h2V${sOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f$zsOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fR3]/_V&T!Y!`*i!i$lo!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7m!k$^o!c!p$e$g$h$q$r&U&b&u(b(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7m!i$co!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7m&e^Ofgilmop!O!P!T!Y!Z![!_!`!c!p#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r%_%b&U&Y&[&b&u'}(W(Y(f(j(o(p(r(|)i*f*i*k*l+Z+n,s,z-T-g-m.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fR(l$fQ-[(kR5Y1sQ(S#|S({$v-oS-Z(k1sQ-l(yW/u*v/t3w6qS1w-_-`Q3v/vR5^1xQ'e#Or,e'b'c'd'j'p)u,c,f,h,l/m/n1_3n3q5U6fR,o'mk,a'b'c'd,c,f,h,l/m/n1_3n3q5UQ'f#Or,e'b'c'd'j'p)u,c,f,h,l/m/n1_3n3q5U6fR,p'mR*g&]X/c*f/d/g3f!}aOb!O!P!T#z$v$y%_%b'}(y)S)U)i)s*f*v*w+Q+Z,s-o-t.j/b/d/g/t/{0Y0g1h2s3f3w3|4Z4h5y6a6q6v7U7^Q3`/aQ6_3bQ8Y6`R9V8Z${rOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f#nfOfglmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#z#}$T$W%_%b&Y&['}(W(Y(|)i+n,s,z-m.}0}1h1|3_3a3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h!T9u!Y!_!`*i*l/^3h9u9v9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:e:f#rfOfgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i+n,s,z-m.}0}1h1|3_3a3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h!X9u!Y!_!`*i*l/^3h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f$srOfglmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:e:f#U#oh#d$P$Q$V$s%^&W&X'q't'u'v'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9b}:P&S&]/k3[6d:[:]:c:d:h:j:k:l:m:n:o:p:q:r:v:w:{#W#ph#d$P$Q$V$s%^&W&X'q'r't'u'v'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9b!P:Q&S&]/k3[6d:[:]:c:d:h:i:j:k:l:m:n:o:p:q:r:v:w:{#S#qh#d$P$Q$V$s%^&W&X'q'u'v'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9b{:R&S&]/k3[6d:[:]:c:d:h:k:l:m:n:o:p:q:r:v:w:{#Q#rh#d$P$Q$V$s%^&W&X'q'v'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9by:S&S&]/k3[6d:[:]:c:d:h:l:m:n:o:p:q:r:v:w:{#O#sh#d$P$Q$V$s%^&W&X'q'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9bw:T&S&]/k3[6d:[:]:c:d:h:m:n:o:p:q:r:v:w:{!|#th#d$P$Q$V$s%^&W&X'q'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9bu:U&S&]/k3[6d:[:]:c:d:h:n:o:p:q:r:v:w:{!x#vh#d$P$Q$V$s%^&W&X'q'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9bq:W&S&]/k3[6d:[:]:c:d:h:p:q:r:v:w:{!v#wh#d$P$Q$V$s%^&W&X'q'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9bo:X&S&]/k3[6d:[:]:c:d:h:q:r:v:w:{$]#{h#`#d$P$Q$V$s%^&S&W&X&]'q'r's't'u'v'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n/k0z1i1l1}3P3[4w5V5a6^6d6e7R7e7h7s7y8j8q8{9[9b:[:]:c:d:h:i:j:k:l:m:n:o:p:q:r:v:w:{${jOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f$v!aOfgilmp!O!P!T!Y!Z!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fQ&Y![Q&Z!]R:e9{#rpOfgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i+n,s,z-m.}0}1h1|3_3a3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9hQ&[!^!W9x!Y!_!`*i*l/^3h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fR:f:zR$moR-f(rR$wqT(}$v-oQ/f*fS3d/d/gR6c3fQ3m/mQ3p/nQ6i3nR6l3qQ$zwQ)V${Q*q&fQ+f&qQ+i&sQ-w)YW.Z)b+j+k+lS/X*]+gW2b.W.[.].^U3W/Y/]0yU5o2c2d2eS6W3X3ZS7w5p5qS8Q6V6XQ8y7xS8}8R8SR9c9O^|O!O!P!T%_%b)iX)R$y)S)U-tQ&r!nQ*^&PQ*|&jQ+P&kQ+T&lQ+W&mQ+]&nQ+l&sQ-})[Q.Q)]Q.T)^Q.V)_Q.Y)aQ.^)bQ2S-uQ2e.WR4U0VU+a&o*u4TR4o0sQ+Y&mQ+k&sS.])b+l^0v+_+`/q/r4m4n7OS2d.W.^S4Q0R0SR5q2eS0R*x4RQ0a+UR7X4_U+d&o*u4TR4p0sQ*z&jQ+O&kQ+S&lQ+g&qQ+j&sS-{)[*|S.P)]+PS.S)^+TU.[)b+k+lQ/Y*]Q0X*{Q0q+[Q2X-|Q2Y-}Q2].QQ2_.TU2c.W.].^Q2g.XS3Z/]0yS5c2R4lQ5j2ZS5p2d2eQ6X3XS7q5e5rQ7x5qQ8R6VQ8v7pQ9O8SR9`8wQ0T*xR6|4RQ*y&jQ*}&kU-z)[*z*|U.O)]+O+PS2W-{-}S2[.P.QQ4X0ZQ5i2YQ5k2]R7T4YQ/w*vQ3t/tQ6r3wR8d6qQ*{&jS-|)[*|Q2Z-}Q4X0ZR7T4YQ+R&lU.R)^+S+TS2^.S.TR5l2_Q0]+QQ4V0YQ7V4ZR8l7UQ+[&nS.X)a+]S2R-u.YR5e2SQ0i+ZQ4f0gQ7`4hR8m7^Q.m)sQ0i+ZQ2p.jQ4f0gQ5|2sQ7`4hQ7}5yR8m7^Q0i+ZR4f0gX'O!q%X&|1PX&{!q%X&|1PW'O!q%X&|1PS+u&z'PR1U+z_|O!O!P!T%_%b)iQ%a!PS)h%_%bR.d)i$^%u!Q!n$O$u%o%p%q&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gQ*U%yR*X%{$c%n!Q!n$O$u%o%p%q%y%{&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gW)t%m%x*T*WQ.e)jR2{.vR.m)sR5|2sQ'W!sR,O'WQ!TOQ$TlQ$WmQ%b!P[%|!T$T$W%b)U/gQ)U$yR/g*f$b%i!Q!n$O$u%o%p%q%y%{&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g[)n%i)p.i:`:t:xQ)p%jQ.i)qQ:`%nQ:t:aR:x:uQ!vUR'Y!vS!OO!TU%]!O%_)iQ%_!PR)i%b#rYOfgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i+n,s,z-m.}0}1h1|3_3a3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9hh!yY!|#U$`'a'n(d,q-R9s9|:gQ!|[b#Ub#Q$y'l(b)S)U*Z-t!h$`o!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mQ'a!}Q'n#ZQ(d$aQ,q'oQ-R(e!W9s!Y!_!`*i*l/^3h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fQ9|9tR:g9}Q-U(gR1p-UQ1t-[R5Z1tQ,c'bQ,f'cQ,h'dW1`,c,f,h5UR5U1_Q/d*fS3c/d3fR3f/gfbO!O!P!T$y%_%b)S)U)i-tp#Wb'}(y.j/b/t/{0Y0g1h5y6a6q6v7U7^Q'}#zS(y$v-oQ.j)sW/b*f/d/g3fQ/t*vQ/{*wQ0Y+QQ0g+ZQ1h,sQ5y2sQ6q3wQ6v3|Q7U4ZR7^4hQ,t(OQ1g,rT1j,t1gS(X$Q([Q(^$VU,x(X(^,}R,}(`Q(s$mR-h(sQ-p)OR2P-pQ3n/mQ3q/nT6j3n3qQ)S$yS-r)S-tR-t)UQ4`0aR7Y4``0t+^+_+`+a+d/q/r7OR4q0tQ8i6zR9Z8iQ4S0TR6}4SQ3x/wQ6n3tT6s3x6nQ3}/|Q6t3zU6y3}6t8eR8e6uQ4[0]Q7Q4VT7W4[7QhzOb!O!P!T$y%_%b)S)U)i-tQ$|xW%Zz$|%f)v$b%f!Q!n$O$u%o%p%q%y%{&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gR)v%nS4i0i0nS7]4f4gT7b4i7]W&z!q%X&|1PS+r&z+zR+z'PQ1Q+wR4z1QU1[,S,T,UR5R1[S3S/Q7OR6U3SQ2t.mQ5x2pT5}2t5xQ.z)zR3O.z^_O!O!P!T%_%b)iY#Xb$y)S)U-t$l#_fgilmp!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W&Y&['}(W(Y(|*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f!h$io!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mS'j#Q'lQ-P(bR/V*Z&v!RObfgilmop!O!P!T!Y!Z![!_!`!c!p#Q#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r$y%_%b&U&Y&[&b&u'l'}(W(Y(b(f(j(o(p(r(|)S)U)i*Z*f*i*k*l+Z+n,s,z-T-g-m-t.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f[!{Y[#U#Z9s9tW&{!q%X&|1P['`!|!}'n'o9|9}S(c$`$aS+t&z'PU,X'a,q:gS-Q(d(eQ1T+zR1n-RS%t!Q&oQ&q!nQ(V$OQ(w$uS)w%o.pQ)z%pQ)}%qS*]&P&rQ+e&pQ,S']Q-d(qQ.l)sU.w)x)y2vS/O*O*PQ/P*RQ/T*VQ/W*[Q/]*^Q/`*eQ/l*nQ/|*wS0S*x4RQ0a+UQ0c+VQ0y+hQ0{+oQ1X+}Q1{-iQ2T-vQ2`.UQ2i.`Q2z.tQ2|.xQ2}.yQ3X/ZQ3Y/[S3z/{/}Q4^0`Q4l0rQ4s0wQ4x1OQ4}1YQ5O1ZQ5_1yQ5n2aQ5r2hQ5u2jQ5w2mQ5{2sQ6V3VQ6o3uQ6u3{Q6w3|Q7P4UQ7X4_Q7[4eQ7d4tQ7n5`Q7p5dQ7|5vQ8P6RQ8S6YQ8c6pS8f6v6xQ8o7cQ8w7rR9X8g$^%m!Q!n$O$u%o%p%q&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gQ)j%nQ*T%yR*W%{$y%h!Q!n$O$u%i%j%n%o%p%q%y%{&P&o&p&r'](q)p)q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.i.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g:`:a:t:u:x'pWOY[bfgilmop!O!P!T!Y!Z![!_!`!c!p!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r$y%_%b&U&Y&[&b&u'a'l'n'o'}(W(Y(b(d(e(f(j(o(p(r(|)S)U)i*Z*f*i*k*l+Z+n,q,s,z-R-T-g-m-t.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9s9t9u9v9w9x9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f:g$x%g!Q!n$O$u%i%j%n%o%p%q%y%{&P&o&p&r'](q)p)q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.i.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g:`:a:t:u:x_&y!q%X&z&|'P+z1PR,V']$zrOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f!j$]o!c!p$e$g$h$q$r&U&b&u(b(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mQ,T']R5P1Z_}O!O!P!T%_%b)i^|O!O!P!T%_%b)iQ#YbX)R$y)S)U-tbhO!O!T3_6]8W8X9U9hS#`f9uQ#dgQ$PiQ$QlQ$VmQ$spW%^!P%_%b)iU&S!Y!`*iQ&W!ZQ&X![Q&]!_Q'q#eQ'r#oS's#p:QQ't#qQ'u#rQ'v#sQ'w#tQ'x#uQ'y#vQ'z#wQ'{#xQ'|#yQ(O#zQ(U#}Q([$TQ(`$WQ*b&YQ*c&[Q,r'}Q,w(WQ,y(YQ-n(|Q/k*lQ0z+nQ1i,sQ1l,zQ1}-mQ3P.}Q3[/^Q4w0}Q5V1hQ5a1|Q6^3aQ6d3hQ6e3kQ7R4WQ7e4vQ7h4|Q7s5gQ7y5tQ8j7SQ8q7gQ8{7{Q9[8kQ9b8|Q:[9wQ:]9xQ:c9zQ:d9{Q:h:OQ:i:PQ:j:RQ:k:SQ:l:TQ:m:UQ:n:VQ:o:WQ:p:XQ:q:YQ:r:ZQ:v:eQ:w:fR:{9v^tO!O!P!T%_%b)i$`#afgilmp!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W&Y&['}(W(Y(|*i*l+n,s,z-m.}/^0}1h1|3a3h3k4W4v4|5g5t7S7g7{8k8|9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fQ6[3_Q8V6]Q9R8WQ9T8XQ9g9UR9m9hQ&V!YQ&^!`R/h*iQ$joQ&a!cQ&t!pU(g$e$g(jS(n$h0eQ(u$qQ(v$rQ*`&UQ*m&bQ+p&uQ-S(fS-b(o4cQ-c(pQ-e(rW/a*f/d/g3fQ/j*kW0f+Z0g4h7^Q1o-TQ1z-gQ3b/bQ4k0mQ5X1rQ7l5[Q8Z6aR8t7m!h$_o!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mR-P(b'qXOY[bfgilmop!O!P!T!Y!Z![!_!`!c!p!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r$y%_%b&U&Y&[&b&u'a'l'n'o'}(W(Y(b(d(e(f(j(o(p(r(|)S)U)i*Z*f*i*k*l+Z+n,q,s,z-R-T-g-m-t.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9s9t9u9v9w9x9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f:g$zqOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f!i$fo!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7m&d^Ofgilmop!O!P!T!Y!Z![!_!`!c!p#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r%_%b&U&Y&[&b&u'}(W(Y(f(j(o(p(r(|)i*f*i*k*l+Z+n,s,z-T-g-m.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f[!zY[$`$a9s9t['_!|!}(d(e9|9}W)o%i%j:`:aU,W'a-R:gW.h)p)q:t:uT2o.i:xQ(i$eQ(m$gR-W(jV(h$e$g(jR-^(kR-](k$znOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f!i$ko!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mS'g#O'pj,a'b'c'd,c,f,h,l/m/n1_3n3q5UQ,m'jQ.u)uR8_6f`,b'b'c'd,c,f,h1_5UQ1e,lX3l/m/n3n3qj,a'b'c'd,c,f,h,l/m/n1_3n3q5UQ7j5TR8s7k^uO!O!P!T%_%b)i$`#afgilmp!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W&Y&['}(W(Y(|*i*l+n,s,z-m.}/^0}1h1|3a3h3k4W4v4|5g5t7S7g7{8k8|9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fQ6Z3_Q8U6]Q9Q8WQ9S8XQ9f9UR9l9hR(Q#zR(P#zQ$SlR(]$TR$ooR$noR)Q$vR)P$vQ)O$vR2O-ohwOb!O!P!T$y%_%b)S)U)i-t$l!lz!Q!n$O$u$|%f%n%o%p%q%y%{&P&o&p&r'](q)s)v)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gR${xR0b+UR0W*xR0U*xR6{4PR/y*vR/x*vR0P*wR0O*wR0_+QR0^+Q%XyObxz!O!P!Q!T!n$O$u$y$|%_%b%f%n%o%p%q%y%{&P&o&p&r'](q)S)U)i)s)v)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-t-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gR0k+ZR0j+ZQ'R!qQ)c%XQ+w&|R4y1PX'Q!q%X&|1PR+y&|R+x&|T/S*S4TT/R*S4TR.o)sR.n)sR){%p",
  nodeNames: "⚠ | < > RawString Float LineComment BlockComment SourceFile ] InnerAttribute ! [ MetaItem self Metavariable super crate Identifier ScopedIdentifier :: QualifiedScope AbstractType impl SelfType MetaType TypeIdentifier ScopedTypeIdentifier ScopeIdentifier TypeArgList TypeBinding = Lifetime String Escape Char Boolean Integer } { Block ; ConstItem Vis pub ( in ) const BoundIdentifier : UnsafeBlock unsafe AsyncBlock async move IfExpression if LetDeclaration let LiteralPattern ArithOp MetaPattern SelfPattern ScopedIdentifier TuplePattern ScopedTypeIdentifier , StructPattern FieldPatternList FieldPattern ref mut FieldIdentifier .. RefPattern SlicePattern CapturedPattern ReferencePattern & MutPattern RangePattern ... OrPattern MacroPattern ParenthesizedTokens TokenBinding Identifier TokenRepetition ArithOp BitOp LogicOp UpdateOp CompareOp -> => ArithOp BracketedTokens BracedTokens _ else MatchExpression match MatchBlock MatchArm Attribute Guard UnaryExpression ArithOp DerefOp LogicOp ReferenceExpression TryExpression BinaryExpression ArithOp ArithOp BitOp BitOp BitOp BitOp LogicOp LogicOp AssignmentExpression TypeCastExpression as ReturnExpression return RangeExpression CallExpression ArgList AwaitExpression await FieldExpression GenericFunction BreakExpression break LoopLabel ContinueExpression continue IndexExpression ArrayExpression TupleExpression MacroInvocation UnitExpression ClosureExpression ParamList Parameter Parameter ParenthesizedExpression StructExpression FieldInitializerList ShorthandFieldInitializer FieldInitializer BaseFieldInitializer MatchArm WhileExpression while LoopExpression loop ForExpression for MacroInvocation MacroDefinition macro_rules MacroRule EmptyStatement ModItem mod DeclarationList AttributeItem ForeignModItem extern StructItem struct TypeParamList ConstrainedTypeParameter TraitBounds HigherRankedTraitBound RemovedTraitBound OptionalTypeParameter ConstParameter WhereClause where LifetimeClause TypeBoundClause FieldDeclarationList FieldDeclaration OrderedFieldDeclarationList UnionItem union EnumItem enum EnumVariantList EnumVariant TypeItem type FunctionItem default fn ParamList Parameter SelfParameter VariadicParameter VariadicParameter ImplItem TraitItem trait AssociatedType LetDeclaration UseDeclaration use ScopedIdentifier UseAsClause ScopedIdentifier UseList ScopedUseList UseWildcard ExternCrateDeclaration StaticItem static ExpressionStatement ExpressionStatement GenericType FunctionType ForLifetimes ParamList VariadicParameter Parameter VariadicParameter Parameter ReferenceType PointerType TupleType UnitType ArrayType MacroInvocation EmptyType DynamicType dyn BoundedType",
  maxTerm: 359,
  nodeProps: [
    ["group", -42, 4, 5, 14, 15, 16, 17, 18, 19, 33, 35, 36, 37, 40, 51, 53, 56, 101, 107, 111, 112, 113, 122, 123, 125, 127, 128, 130, 132, 133, 134, 137, 139, 140, 141, 142, 143, 144, 148, 149, 155, 157, 159, "Expression", -16, 22, 24, 25, 26, 27, 222, 223, 230, 231, 232, 233, 234, 235, 236, 237, 239, "Type", -20, 42, 161, 162, 165, 166, 169, 170, 172, 188, 190, 194, 196, 204, 205, 207, 208, 209, 217, 218, 220, "Statement", -17, 49, 60, 62, 63, 64, 65, 68, 74, 75, 76, 77, 78, 80, 81, 83, 84, 99, "Pattern"],
    ["openedBy", 9, "[", 38, "{", 47, "("],
    ["closedBy", 12, "]", 39, "}", 45, ")"]
  ],
  propSources: [RW],
  skippedNodes: [0, 6, 7, 240],
  repeatNodeCount: 32,
  tokenData: "#?|_R!VOX$hXY1_YZ2ZZ]$h]^1_^p$hpq1_qr2srs4qst5Ztu6Vuv9lvw;jwx=nxy!!ayz!#]z{!$X{|!&R|}!'T}!O!(P!O!P!*Q!P!Q!-|!Q!R!6X!R![!7|![!]!Jw!]!^!Lu!^!_!Mq!_!`# x!`!a##y!a!b#&Q!b!c#&|!c!}#'x!}#O#)o#O#P#*k#P#Q#1b#Q#R#2^#R#S#'x#S#T$h#T#U#'x#U#V#3`#V#f#'x#f#g#6s#g#o#'x#o#p#<Q#p#q#<|#q#r#?Q#r${$h${$|#'x$|4w$h4w5b#'x5b5i$h5i6S#'x6S~$hU$oZ'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hU%iT'_Q'OSOz%xz{&^{!P%x!P!Q'S!Q~%xS%}T'OSOz%xz{&^{!P%x!P!Q'S!Q~%xS&aTOz&pz{&^{!P&p!P!Q({!Q~&pS&sTOz%xz{&^{!P%x!P!Q'S!Q~%xS'VSOz&p{!P&p!P!Q'c!Q~&pS'fSOz'r{!P'r!P!Q'c!Q~'rS'uTOz(Uz{(l{!P(U!P!Q'c!Q~(US(]T'PS'OSOz(Uz{(l{!P(U!P!Q'c!Q~(US(oSOz'rz{(l{!P'r!Q~'rS)QO'PSU)VZ'_QOY)xYZ+hZr)xrs&psz)xz{)Q{!P)x!P!Q0w!Q#O)x#O#P&p#P~)xU)}Z'_QOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hU*uZ'_QOY)xYZ+hZr)xrs&psz)xz{+|{!P)x!P!Q,g!Q#O)x#O#P&p#P~)xU+mT'_QOz%xz{&^{!P%x!P!Q'S!Q~%xQ,RT'_QOY+|YZ,bZr+|s#O+|#P~+|Q,gO'_QU,lZ'_QOY-_YZ0cZr-_rs'rsz-_z{+|{!P-_!P!Q,g!Q#O-_#O#P'r#P~-_U-dZ'_QOY.VYZ/RZr.Vrs(Usz.Vz{/k{!P.V!P!Q,g!Q#O.V#O#P(U#P~.VU.`Z'_Q'PS'OSOY.VYZ/RZr.Vrs(Usz.Vz{/k{!P.V!P!Q,g!Q#O.V#O#P(U#P~.VU/[T'_Q'PS'OSOz(Uz{(l{!P(U!P!Q'c!Q~(UU/pZ'_QOY-_YZ0cZr-_rs'rsz-_z{/k{!P-_!P!Q+|!Q#O-_#O#P'r#P~-_U0hT'_QOz(Uz{(l{!P(U!P!Q'c!Q~(UU1OT'_Q'PSOY+|YZ,bZr+|s#O+|#P~+|_1hZ'_Q&|X'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_2dT'_Q&|X'OSOz%xz{&^{!P%x!P!Q'S!Q~%x_2|]ZX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`3u!`#O$h#O#P%x#P~$h_4OZ#PX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_4zT']Q'OS'^XOz%xz{&^{!P%x!P!Q'S!Q~%x_5dZ'QX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_6`g'_Q'vW'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!c$h!c!}7w!}#O$h#O#P%x#P#R$h#R#S7w#S#T$h#T#o7w#o${$h${$|7w$|4w$h4w5b7w5b5i$h5i6S7w6S~$h_8Qh'_Q_X'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![7w![!c$h!c!}7w!}#O$h#O#P%x#P#R$h#R#S7w#S#T$h#T#o7w#o${$h${$|7w$|4w$h4w5b7w5b5i$h5i6S7w6S~$h_9u](TP'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_:wZ#OX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_;s_!qX'_Q'OSOY$hYZ%bZr$hrs%xsv$hvw<rwz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_<{Z'}X'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_=ui'_Q'OSOY?dYZA`Zr?drsBdsw?dwx@dxz?dz{CO{!P?d!P!QDv!Q!c?d!c!}Et!}#O?d#O#PId#P#R?d#R#SEt#S#T?d#T#oEt#o${?d${$|Et$|4w?d4w5bEt5b5i?d5i6SEt6S~?d_?k]'_Q'OSOY$hYZ%bZr$hrs%xsw$hwx@dxz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_@mZ'_Q'OSsXOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_AgV'_Q'OSOw%xwxA|xz%xz{&^{!P%x!P!Q'S!Q~%x]BTT'OSsXOz%xz{&^{!P%x!P!Q'S!Q~%x]BiV'OSOw%xwxA|xz%xz{&^{!P%x!P!Q'S!Q~%x_CT]'_QOY)xYZ+hZr)xrs&psw)xwxC|xz)xz{)Q{!P)x!P!Q0w!Q#O)x#O#P&p#P~)x_DTZ'_QsXOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_D{]'_QOY)xYZ+hZr)xrs&psw)xwxC|xz)xz{+|{!P)x!P!Q,g!Q#O)x#O#P&p#P~)x_E}j'_Q'OS'ZXOY$hYZ%bZr$hrs%xsw$hwx@dxz$hz{)Q{!P$h!P!Q*p!Q![Go![!c$h!c!}Go!}#O$h#O#P%x#P#R$h#R#SGo#S#T$h#T#oGo#o${$h${$|Go$|4w$h4w5bGo5b5i$h5i6SGo6S~$h_Gxh'_Q'OS'ZXOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![Go![!c$h!c!}Go!}#O$h#O#P%x#P#R$h#R#SGo#S#T$h#T#oGo#o${$h${$|Go$|4w$h4w5bGo5b5i$h5i6SGo6S~$h]IiX'OSOzBdz{JU{!PBd!P!QKS!Q#iBd#i#jKi#j#lBd#l#mMX#m~Bd]JXVOw&pwxJnxz&pz{&^{!P&p!P!Q({!Q~&p]JsTsXOz%xz{&^{!P%x!P!Q'S!Q~%x]KVUOw&pwxJnxz&p{!P&p!P!Q'c!Q~&p]Kn['OSOz%xz{&^{!P%x!P!Q'S!Q![Ld![!c%x!c!iLd!i#T%x#T#ZLd#Z#o%x#o#pNq#p~%x]LiY'OSOz%xz{&^{!P%x!P!Q'S!Q![MX![!c%x!c!iMX!i#T%x#T#ZMX#Z~%x]M^Y'OSOz%xz{&^{!P%x!P!Q'S!Q![M|![!c%x!c!iM|!i#T%x#T#ZM|#Z~%x]NRY'OSOz%xz{&^{!P%x!P!Q'S!Q![Bd![!c%x!c!iBd!i#T%x#T#ZBd#Z~%x]NvY'OSOz%xz{&^{!P%x!P!Q'S!Q![! f![!c%x!c!i! f!i#T%x#T#Z! f#Z~%x]! k['OSOz%xz{&^{!P%x!P!Q'S!Q![! f![!c%x!c!i! f!i#T%x#T#Z! f#Z#q%x#q#rBd#r~%x_!!jZ}X'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!#fZ!PX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!$`](QX'_QOY)xYZ+hZr)xrs&psz)xz{)Q{!P)x!P!Q0w!Q!_)x!_!`!%X!`#O)x#O#P&p#P~)x_!%`Z#OX'_QOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!&[](PX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_!'^Z!eX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!(Y^'gX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`!a!)U!a#O$h#O#P%x#P~$h_!)_Z#QX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!*Z[(OX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!O$h!O!P!+P!P!Q*p!Q#O$h#O#P%x#P~$h_!+Y^!lX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!O$h!O!P!,U!P!Q*p!Q!_$h!_!`!-Q!`#O$h#O#P%x#P~$h_!,_Z!tX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hV!-ZZ'qP'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!.T]'_Q'xXOY)xYZ+hZr)xrs&psz)xz{!.|{!P)x!P!Q!/d!Q!_)x!_!`!%X!`#O)x#O#P&p#P~)x_!/TT&}]'_QOY+|YZ,bZr+|s#O+|#P~+|_!/kZ'_QUXOY!0^YZ0cZr!0^rs!3`sz!0^z{!5k{!P!0^!P!Q!/d!Q#O!0^#O#P!3`#P~!0^_!0eZ'_QUXOY!1WYZ/RZr!1Wrs!2Usz!1Wz{!4q{!P!1W!P!Q!/d!Q#O!1W#O#P!2U#P~!1W_!1cZ'_QUX'PS'OSOY!1WYZ/RZr!1Wrs!2Usz!1Wz{!4q{!P!1W!P!Q!/d!Q#O!1W#O#P!2U#P~!1W]!2_VUX'PS'OSOY!2UYZ(UZz!2Uz{!2t{!P!2U!P!Q!3z!Q~!2U]!2yVUXOY!3`YZ'rZz!3`z{!2t{!P!3`!P!Q!4f!Q~!3`]!3eVUXOY!2UYZ(UZz!2Uz{!2t{!P!2U!P!Q!3z!Q~!2U]!4PVUXOY!3`YZ'rZz!3`z{!4f{!P!3`!P!Q!3z!Q~!3`X!4kQUXOY!4fZ~!4f_!4xZ'_QUXOY!0^YZ0cZr!0^rs!3`sz!0^z{!4q{!P!0^!P!Q!5k!Q#O!0^#O#P!3`#P~!0^Z!5rV'_QUXOY!5kYZ,bZr!5krs!4fs#O!5k#O#P!4f#P~!5k_!6bhuX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![!7|![#O$h#O#P%x#P#R$h#R#S!7|#S#U$h#U#V!By#V#]$h#]#^!9_#^#c$h#c#d!Ee#d#i$h#i#j!9_#j#l$h#l#m!Gy#m~$h_!8VbuX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![!7|![#O$h#O#P%x#P#R$h#R#S!7|#S#]$h#]#^!9_#^#i$h#i#j!9_#j~$h_!9fe'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!R$h!R!S!:w!S!T$h!T!U!=y!U!W$h!W!X!>y!X!Y$h!Y!Z!<}!Z#O$h#O#P%x#P#g$h#g#h!?y#h~$h_!;O_'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!S$h!S!T!;}!T!W$h!W!X!<}!X#O$h#O#P%x#P~$h_!<U]'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!Y$h!Y!Z!<}!Z#O$h#O#P%x#P~$h_!=WZuX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!>Q]'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!S$h!S!T!<}!T#O$h#O#P%x#P~$h_!?Q]'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!U$h!U!V!<}!V#O$h#O#P%x#P~$h_!@Q]'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P#]$h#]#^!@y#^~$h_!AQ]'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P#n$h#n#o!Ay#o~$h_!BQ]'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P#X$h#X#Y!<}#Y~$h_!CQ_'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!R!DP!R!S!DP!S#O$h#O#P%x#P#R$h#R#S!DP#S~$h_!DYcuX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!R!DP!R!S!DP!S#O$h#O#P%x#P#R$h#R#S!DP#S#]$h#]#^!9_#^#i$h#i#j!9_#j~$h_!El^'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!Y!Fh!Y#O$h#O#P%x#P#R$h#R#S!Fh#S~$h_!FqbuX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!Y!Fh!Y#O$h#O#P%x#P#R$h#R#S!Fh#S#]$h#]#^!9_#^#i$h#i#j!9_#j~$h_!HQb'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![!IY![!c$h!c!i!IY!i#O$h#O#P%x#P#R$h#R#S!IY#S#T$h#T#Z!IY#Z~$h_!IcfuX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![!IY![!c$h!c!i!IY!i#O$h#O#P%x#P#R$h#R#S!IY#S#T$h#T#Z!IY#Z#]$h#]#^!9_#^#i$h#i#j!9_#j~$h_!KQ]!SX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![$h![!]!Ky!]#O$h#O#P%x#P~$h_!LSZdX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!MOZyX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!Mz^#PX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!^$h!^!_!Nv!_!`3u!`#O$h#O#P%x#P~$h_# P]'yX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_#!R^oX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`3u!`!a#!}!a#O$h#O#P%x#P~$h_##WZ#RX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#$S^#PX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`3u!`!a#%O!a#O$h#O#P%x#P~$h_#%X]'zX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_#&ZZ(RX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hV#'VZ'pP'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#(Th'_Q'OS!yW'TPOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![#'x![!c$h!c!}#'x!}#O$h#O#P%x#P#R$h#R#S#'x#S#T$h#T#o#'x#o${$h${$|#'x$|4w$h4w5b#'x5b5i$h5i6S#'x6S~$h_#)xZ[X'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hU#*pX'OSOz#+]z{#+s{!P#+]!P!Q#,X!Q#i#+]#i#j#,j#j#l#+]#l#m#.Y#m~#+]U#+dTrQ'OSOz%xz{&^{!P%x!P!Q'S!Q~%xU#+xTrQOz&pz{&^{!P&p!P!Q({!Q~&pU#,^SrQOz&p{!P&p!P!Q'c!Q~&pU#,o['OSOz%xz{&^{!P%x!P!Q'S!Q![#-e![!c%x!c!i#-e!i#T%x#T#Z#-e#Z#o%x#o#p#/r#p~%xU#-jY'OSOz%xz{&^{!P%x!P!Q'S!Q![#.Y![!c%x!c!i#.Y!i#T%x#T#Z#.Y#Z~%xU#._Y'OSOz%xz{&^{!P%x!P!Q'S!Q![#.}![!c%x!c!i#.}!i#T%x#T#Z#.}#Z~%xU#/SY'OSOz%xz{&^{!P%x!P!Q'S!Q![#+]![!c%x!c!i#+]!i#T%x#T#Z#+]#Z~%xU#/wY'OSOz%xz{&^{!P%x!P!Q'S!Q![#0g![!c%x!c!i#0g!i#T%x#T#Z#0g#Z~%xU#0l['OSOz%xz{&^{!P%x!P!Q'S!Q![#0g![!c%x!c!i#0g!i#T%x#T#Z#0g#Z#q%x#q#r#+]#r~%x_#1kZXX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#2g]'{X'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_#3kj'_Q'OS!yW'TPOY$hYZ%bZr$hrs#5]sw$hwx#5sxz$hz{)Q{!P$h!P!Q*p!Q![#'x![!c$h!c!}#'x!}#O$h#O#P%x#P#R$h#R#S#'x#S#T$h#T#o#'x#o${$h${$|#'x$|4w$h4w5b#'x5b5i$h5i6S#'x6S~$h]#5dT'OS'^XOz%xz{&^{!P%x!P!Q'S!Q~%x_#5z]'_Q'OSOY?dYZA`Zr?drsBdsw?dwx@dxz?dz{CO{!P?d!P!QDv!Q#O?d#O#PId#P~?d_#7Oi'_Q'OS!yW'TPOY$hYZ%bZr$hrs%xst#8mtz$hz{)Q{!P$h!P!Q*p!Q![#'x![!c$h!c!}#'x!}#O$h#O#P%x#P#R$h#R#S#'x#S#T$h#T#o#'x#o${$h${$|#'x$|4w$h4w5b#'x5b5i$h5i6S#'x6S~$hV#8tg'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!c$h!c!}#:]!}#O$h#O#P%x#P#R$h#R#S#:]#S#T$h#T#o#:]#o${$h${$|#:]$|4w$h4w5b#:]5b5i$h5i6S#:]6S~$hV#:fh'_Q'OS'TPOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![#:]![!c$h!c!}#:]!}#O$h#O#P%x#P#R$h#R#S#:]#S#T$h#T#o#:]#o${$h${$|#:]$|4w$h4w5b#:]5b5i$h5i6S#:]6S~$h_#<ZZwX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#=V_'rX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P#p$h#p#q#>U#q~$h_#>_Z'|X'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#?ZZvX'_Q'OSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h",
  tokenizers: [UW, VW, zW, 0, 1, 2, 3],
  topRules: { SourceFile: [0, 8] },
  specialized: [{ term: 281, get: (O) => _W[O] || -1 }],
  tokenPrec: 15596
});
var CW = Ze.define({
  name: "rust",
  parser: jW.configure({
    props: [
      Ce.add({
        IfExpression: $e({ except: /^\s*({|else\b)/ }),
        "String BlockComment": () => null,
        AttributeItem: (O) => O.continue(),
        "Statement MatchArm": $e()
      }),
      Ge.add((O) => {
        if (/(Block|edTokens|List)$/.test(O.name))
          return _t;
        if (O.name == "BlockComment")
          return (e) => ({ from: e.from + 2, to: e.to - 2 });
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:\{|\})$/,
    closeBrackets: { stringPrefixes: ["b", "r", "br"] }
  }
});
function GW() {
  return new je(CW);
}
var sf = 1;
var IW = 2;
var EW = 3;
var AW = 82;
var DW = 76;
var MW = 117;
var LW = 85;
var BW = 97;
var NW = 122;
var FW = 65;
var HW = 90;
var KW = 95;
var Ra = 48;
var of = 34;
var JW = 40;
var af = 41;
var ev = 32;
var lf = 62;
var tv = new te((O) => {
  if (O.next == DW || O.next == LW ? O.advance() : O.next == MW && (O.advance(), O.next == Ra + 8 && O.advance()), O.next != AW || (O.advance(), O.next != of))
    return;
  O.advance();
  let e = "";
  for (; O.next != JW; ) {
    if (O.next == ev || O.next <= 13 || O.next == af)
      return;
    e += String.fromCharCode(O.next), O.advance();
  }
  for (O.advance(); ; ) {
    if (O.next < 0)
      return O.acceptToken(sf);
    if (O.next == af) {
      let t = true;
      for (let i = 0; t && i < e.length; i++)
        O.peek(i + 1) != e.charCodeAt(i) && (t = false);
      if (t && O.peek(e.length + 1) == of)
        return O.acceptToken(sf, 2 + e.length);
    }
    O.advance();
  }
});
var Ov = new te((O) => {
  if (O.next == lf)
    O.peek(1) == lf && O.acceptToken(IW, 1);
  else {
    let e = false, t = 0;
    for (; ; t++) {
      if (O.next >= FW && O.next <= HW)
        e = true;
      else {
        if (O.next >= BW && O.next <= NW)
          return;
        if (O.next != KW && !(O.next >= Ra && O.next <= Ra + 9))
          break;
      }
      O.advance();
    }
    e && t > 1 && O.acceptToken(EW);
  }
}, { extend: true });
var iv = ze({
  "typedef struct union enum class typename decltype auto template operator friend noexcept namespace using requires concept import export module __attribute__ __declspec __based": c.definitionKeyword,
  "extern MsCallModifier MsPointerModifier extern static register thread_local inline const volatile restrict _Atomic mutable constexpr constinit consteval virtual explicit VirtualSpecifier Access": c.modifier,
  "if else switch for while do case default return break continue goto throw try catch": c.controlKeyword,
  "co_return co_yield co_await": c.controlKeyword,
  "new sizeof delete static_assert": c.operatorKeyword,
  "NULL nullptr": c.null,
  this: c.self,
  "True False": c.bool,
  "TypeSize PrimitiveType": c.standard(c.typeName),
  TypeIdentifier: c.typeName,
  FieldIdentifier: c.propertyName,
  "CallExpression/FieldExpression/FieldIdentifier": c.function(c.propertyName),
  "ModuleName/Identifier": c.namespace,
  PartitionName: c.labelName,
  StatementIdentifier: c.labelName,
  "Identifier DestructorName": c.variableName,
  "CallExpression/Identifier": c.function(c.variableName),
  "CallExpression/ScopedIdentifier/Identifier": c.function(c.variableName),
  "FunctionDeclarator/Identifier FunctionDeclarator/DestructorName": c.function(c.definition(c.variableName)),
  NamespaceIdentifier: c.namespace,
  OperatorName: c.operator,
  ArithOp: c.arithmeticOperator,
  LogicOp: c.logicOperator,
  BitOp: c.bitwiseOperator,
  CompareOp: c.compareOperator,
  AssignOp: c.definitionOperator,
  UpdateOp: c.updateOperator,
  LineComment: c.lineComment,
  BlockComment: c.blockComment,
  Number: c.number,
  String: c.string,
  "RawString SystemLibString": c.special(c.string),
  CharLiteral: c.character,
  EscapeSequence: c.escape,
  "UserDefinedLiteral/Identifier": c.literal,
  PreProcArg: c.meta,
  "PreprocDirectiveName #include #ifdef #ifndef #if #define #else #endif #elif": c.processingInstruction,
  MacroName: c.special(c.name),
  "( )": c.paren,
  "[ ]": c.squareBracket,
  "{ }": c.brace,
  "< >": c.angleBracket,
  ". ->": c.derefOperator,
  ", ;": c.separator
});
var nv = { __proto__: null, bool: 34, char: 34, int: 34, float: 34, double: 34, void: 34, size_t: 34, ssize_t: 34, intptr_t: 34, uintptr_t: 34, charptr_t: 34, int8_t: 34, int16_t: 34, int32_t: 34, int64_t: 34, uint8_t: 34, uint16_t: 34, uint32_t: 34, uint64_t: 34, char8_t: 34, char16_t: 34, char32_t: 34, char64_t: 34, const: 68, volatile: 70, restrict: 72, _Atomic: 74, mutable: 76, constexpr: 78, constinit: 80, consteval: 82, struct: 86, __declspec: 90, final: 148, override: 148, public: 152, private: 152, protected: 152, virtual: 154, extern: 160, static: 162, register: 164, inline: 166, thread_local: 168, __attribute__: 172, __based: 178, __restrict: 180, __uptr: 180, __sptr: 180, _unaligned: 180, __unaligned: 180, noexcept: 194, requires: 198, TRUE: 786, true: 786, FALSE: 788, false: 788, typename: 218, class: 220, template: 234, throw: 248, __cdecl: 256, __clrcall: 256, __stdcall: 256, __fastcall: 256, __thiscall: 256, __vectorcall: 256, try: 260, catch: 264, export: 284, import: 288, case: 298, default: 300, if: 310, else: 316, switch: 320, do: 324, while: 326, for: 332, return: 336, break: 340, continue: 344, goto: 348, co_return: 352, co_yield: 356, using: 364, typedef: 368, namespace: 382, new: 400, delete: 402, co_await: 404, concept: 408, enum: 412, static_assert: 416, friend: 424, union: 426, explicit: 432, operator: 446, module: 458, signed: 520, unsigned: 520, long: 520, short: 520, decltype: 530, auto: 532, sizeof: 568, NULL: 574, nullptr: 588, this: 590 };
var rv = { __proto__: null, "<": 131 };
var sv = { __proto__: null, ">": 135 };
var ov = { __proto__: null, operator: 390, new: 578, delete: 584 };
var av = qe.deserialize({
  version: 14,
  states: "$;fQ!QQVOOP'gOUOOO(XOWO'#CdO,RQUO'#CgO,]QUO'#FkO-sQbO'#CwO.UQUO'#CwO0TQUO'#K[O0[QUO'#CvO0gOpO'#DvO0oQ!dO'#D]OOQR'#JP'#JPO5XQVO'#GVO5fQUO'#JWOOQQ'#JW'#JWO8zQUO'#KnO<eQUO'#KnO>{QVO'#E^O?]QUO'#E^OOQQ'#Ed'#EdOOQQ'#Ee'#EeO?bQVO'#EfO@XQVO'#EiOBUQUO'#FPOBvQUO'#FiOOQR'#Fk'#FkOB{QUO'#FkOOQR'#LR'#LROOQR'#LQ'#LQOETQVO'#KROFxQUO'#LWOGVQUO'#KrOGkQUO'#LWOH]QUO'#LYOOQR'#HV'#HVOOQR'#HW'#HWOOQR'#HX'#HXOOQR'#K}'#K}OOQR'#J`'#J`Q!QQVOOOHkQVO'#F^OIWQUO'#EhOI_QUOOOKZQVO'#HhOKkQUO'#HhONVQUO'#KrONaQUO'#KrOOQQ'#Kr'#KrO!!_QUO'#KrOOQQ'#Jr'#JrO!!lQUO'#HyOOQQ'#K['#K[O!&^QUO'#K[O!&zQUO'#KRO!(zQVO'#I^O!(zQVO'#IaOCQQUO'#KROOQQ'#Iq'#IqOOQQ'#KR'#KRO!,}QUO'#K[OOQR'#KZ'#KZO!-UQUO'#DYO!/mQUO'#KoOOQQ'#Ko'#KoO!/tQUO'#KoO!/{QUO'#ETO!0QQUO'#EWO!0VQUO'#FRO8zQUO'#FPO!QQVO'#F_O!0[Q#vO'#FaO!0gQUO'#FlO!0oQUO'#FqO!0tQVO'#FsO!0oQUO'#FvO!3sQUO'#FwO!3xQVO'#FyO!4SQUO'#F{O!4XQUO'#F}O!4^QUO'#GPO!4cQVO'#GRO!(zQVO'#GTO!4jQUO'#GqO!4xQUO'#GZO!(zQVO'#FfO!6VQUO'#FfO!6[QVO'#GaO!6cQUO'#GbO!6nQUO'#GoO!6sQUO'#GsO!6xQUO'#G{O!7jQ&lO'#HjO!:mQUO'#GvO!:}QUO'#HYO!;YQUO'#H[O!;bQUO'#DWO!;bQUO'#HvO!;bQUO'#HwO!;yQUO'#HxO!<[QUO'#H}O!=PQUO'#IOO!>uQVO'#IcO!(zQVO'#IeO!?PQUO'#IhO!?WQVO'#IkP!@}{,UO'#CbP!6n{,UO'#CbP!AY{7[O'#CbP!6n{,UO'#CbP!A_{,UO'#CbP!AjOSO'#I{POOO)CEo)CEoOOOO'#I}'#I}O!AtOWO,59OOOQR,59O,59OO!(zQVO,59UOOQQ,59W,59WO!(zQVO,5;ROOQR,5<V,5<VO!BPQUO,59YO!(zQVO,5>rOOQR'#IY'#IYOOQR'#IZ'#IZOOQR'#I['#I[OOQR'#I]'#I]O!(zQVO,5>sO!(zQVO,5>sO!(zQVO,5>sO!(zQVO,5>sO!(zQVO,5>sO!(zQVO,5>sO!(zQVO,5>sO!(zQVO,5>sO!(zQVO,5>sO!(zQVO,5>sO!DOQVO,5>{OOQQ,5?X,5?XO!EqQVO'#ChO!IjQUO'#CyOOQQ,59c,59cOOQQ,59b,59bOOQQ,5=O,5=OO!IwQ&lO,5=nO!?PQUO,5?SO!LkQVO,5?VO!LrQbO,59cO!L}QVO'#FYOOQQ,5?Q,5?QO!M_QVO,59VO!MfO`O,5:bO!MkQbO'#D^O!M|QbO'#K_O!N[QbO,59wO!NdQbO'#CwO!NuQUO'#CwO!NzQUO'#K[O# UQUO'#CvOOQR-E<}-E<}O# aQUO,5ApO# hQVO'#EfO@XQVO'#EiOBUQUO,5;kOOQR,5<q,5<qO#$aQUO'#KRO#$hQUO'#KRO!(zQVO'#IVO8zQUO,5;kO#${Q&lO'#HjO#(SQUO'#CsO#*wQbO'#CwO#*|QUO'#CvO#.jQUO'#K[OOQQ-E=U-E=UO#0}QUO,5AYO#1XQUO'#K[O#1cQUO,5AYOOQR,5Ap,5ApOOQQ,5>m,5>mO#3gQUO'#CgO#4]QUO,5>qO#6OQUO'#IfOOQR'#JO'#JOO#6WQUO,5:xO#6tQUO,5:xO#7eQUO,5:xO#8YQUO'#CtO!0QQUO'#ClOOQQ'#JX'#JXO#6tQUO,5:xO#8bQUO,5;QO!4xQUO'#C}O#9kQUO,5;QO#9pQUO,5>RO#:|QUO'#C}O#;dQUO,5>|O#;iQUO'#KxO#<rQUO,5;TO#<zQVO,5;TO#=UQUO,5;TOOQQ,5;T,5;TO#>}QUO'#L]O#?UQUO,5>VO#?ZQbO'#CwO#?fQUO'#GdO#?kQUO'#E^O#@[QUO,5;kO#@sQUO'#LOO#@{QUO,5;rOKkQUO'#HgOBUQUO'#HhO#AQQUO'#KrO!6nQUO'#HkO#AxQUO'#CtO!0tQVO,5<TOOQQ'#Cg'#CgOOQR'#Ji'#JiO#A}QVO,5=aOOQQ,5?[,5?[O#DWQbO'#CwO#DcQUO'#GdOOQQ'#Jj'#JjOOQQ-E=h-E=hOGVQUO,5ArOGkQUO,5ArO#DhQUO,5AtO#DsQUO'#G}OOQR,5Ar,5ArO#DhQUO,5ArO#EOQUO'#HPO#EWQUO,5AtOOQR,5At,5AtOOQR,5Au,5AuO#EfQVO,5AuOOQR-E=^-E=^O#G`QVO,5;xOOQR,5;j,5;jO#IaQUO'#EjO#JfQUO'#EwO#K]QVO'#ExO#MoQUO'#EvO#MwQUO'#EyO#NvQUO'#EzOOQQ'#K{'#K{O$ mQUO,5;SO$!sQUO'#EvOOQQ,5;S,5;SO$#pQUO,5;SO$%cQUO,5:yO$'|QVO,5>QO$(WQUO'#E[O$(eQUO,5>SOOQQ,5>T,5>TO$,RQVO'#C{OOQQ-E=p-E=pOOQQ,5>e,5>eOOQQ,59`,59`O$,]QUO,5>xO$.]QUO,5>{O!6nQUO,59tO$.pQUO,5;qO$.}QUO,5<|O!0QQUO,5:oOOQQ,5:r,5:rO$/YQUO,5;mO$/_QUO'#KnOBUQUO,5;kOOQR,5;y,5;yO$0OQUO'#FcO$0^QUO'#FcO$0cQUO,5;{O$3|QVO'#FnO!0tQVO,5<WO!0oQUO,5<WO!0VQUO,5<]O$4TQVO'#GVO$7PQUO,5<_O!0tQVO,5<bO$:gQVO,5<cO$:tQUO,5<eOOQR,5<e,5<eO$;}QUO,5<eOOQR,5<g,5<gOOQR,5<i,5<iOOQQ'#Fj'#FjO$<SQUO,5<kO$<XQUO,5<mOOQR,5<m,5<mO$=_QUO,5<oO$>eQUO,5<sO$>pQUO,5=]O$>uQUO,5=]O!4xQUO,5<uO$>}QUO,5<uO$?cQUO,5<QO$@iQVO,5<QO$BzQUO,5<{OOQR,5<{,5<{O$DQQVO'#F^OOQR,5<|,5<|O$>uQUO,5<|O$DXQUO,5<|O$DdQUO,5=ZO!(zQVO,5=_O!(zQVO,5=gO#NeQUO,5=nOOQQ,5>U,5>UO$FiQUO,5>UO$FsQUO,5>UO$FxQUO,5>UO$F}QUO,5>UO!6nQUO,5>UO$H{QUO'#K[O$ISQUO,5=pO$I_QUO,5=bOKkQUO,5=pO$JXQUO,5=tOOQR,5=t,5=tO$JaQUO,5=tO$LlQVO'#H]OOQQ,5=v,5=vO!;]QUO,5=vO%#gQUO'#KkO%#nQUO'#K]O%$SQUO'#KkO%$^QUO'#DyO%$oQUO'#D|O%'lQUO'#K]OOQQ'#K]'#K]O%)_QUO'#K]O%#nQUO'#K]O%)dQUO'#K]OOQQ,59r,59rOOQQ,5>b,5>bOOQQ,5>c,5>cO%)lQUO'#H{O%)tQUO,5>dOOQQ,5>d,5>dO%-`QUO,5>dO%-kQUO,5>iO%1VQVO,5>jO%1^QUO,5>}O# hQVO'#EfO%4dQUO,5>}OOQQ,5>},5>}O%5TQUO,5?PO%7XQUO,5?SO!<[QUO,5?SO%9TQUO,5?VO%<pQVO,5?VP!A_{,UO,58|P%<w{,UO,58|P%=V{7[O,58|P%=]{,UO,58|PO{O'#Jv'#JvP%=b{,UO'#LdPOOO'#Ld'#LdP%=h{,UO'#LdPOOO,58|,58|POOO,5?g,5?gP%=mOSO,5?gOOOO-E<{-E<{OOQR1G.j1G.jO%=tQUO1G.pO%>zQUO1G0mOOQQ1G0m1G0mO%@WQUO'#CoO%BgQbO'#CwO%BrQUO'#CrO%BwQUO'#CrO%B|QUO1G.tO#AxQUO'#CqOOQQ1G.t1G.tO%EPQUO1G4^O%FVQUO1G4_O%GxQUO1G4_O%IkQUO1G4_O%K^QUO1G4_O%MPQUO1G4_O%NrQUO1G4_O&!eQUO1G4_O&$WQUO1G4_O&%yQUO1G4_O&'lQUO1G4_O&)_QUO1G4_O&+QQUO'#KQO&,ZQUO'#KQO&,cQUO,59SOOQQ,5=Q,5=QO&.kQUO,5=QO&.uQUO,5=QO&.zQUO,5=QO&/PQUO,5=QO!6nQUO,5=QO#NeQUO1G3YO&/ZQUO1G4nO!<[QUO1G4nO&1VQUO1G4qO&2xQVO1G4qOOQQ1G.}1G.}OOQQ1G.|1G.|OOQQ1G2j1G2jO!IwQ&lO1G3YO&3PQUO'#LPO@XQVO'#EiO&4YQUO'#F]OOQQ'#Jb'#JbO&4_QUO'#FZO&4jQUO'#LPO&4rQUO,5;tO&4wQUO1G.qOOQQ1G.q1G.qOOQR1G/|1G/|O&6jQ!dO'#JQO&6oQbO,59xO&9QQ!eO'#D`O&9XQ!dO'#JSO&9^QbO,5@yO&9^QbO,5@yOOQR1G/c1G/cO&9iQbO1G/cO&9nQ&lO'#GfO&:lQbO,59cOOQR1G7[1G7[O#@[QUO1G1VO&:wQUO1G1^OBUQUO1G1VO&=YQUO'#CyO#*wQbO,59cO&@{QUO1G6tOOQR-E<|-E<|O&B_QUO1G0dO#6WQUO1G0dOOQQ-E=V-E=VO#6tQUO1G0dOOQQ1G0l1G0lO&CSQUO,59iOOQQ1G3m1G3mO&CjQUO,59iO&DQQUO,59iO!M_QVO1G4hO!(zQVO'#JZO&DlQUO,5AdOOQQ1G0o1G0oO!(zQVO1G0oO!6nQUO'#JoO&DtQUO,5AwOOQQ1G3q1G3qOOQR1G1V1G1VO&J]QVO'#FOO!M_QVO,5;sOOQQ,5;s,5;sOBUQUO'#JdO&JmQUO,5AjO&JuQVO'#E[OOQR1G1^1G1^O&MdQUO'#L]OOQR1G1o1G1oOOQR-E=g-E=gOOQR1G7^1G7^O#DhQUO1G7^OGVQUO1G7^O#DhQUO1G7`OOQR1G7`1G7`O&MlQUO'#HOO&MtQUO'#LXOOQQ,5=i,5=iO&NSQUO,5=kO&NXQUO,5=lOOQR1G7a1G7aO#EfQVO1G7aO&N^QUO1G7aO' dQVO,5=lOOQR1G1U1G1UO$.vQUO'#E]O'!YQUO'#E]OOQQ'#Kz'#KzO'!sQUO'#KyO'#OQUO,5;UO'#WQUO'#ElO'#kQUO'#ElO'$OQUO'#EtOOQQ'#J]'#J]O'$TQUO,5;cO'$zQUO,5;cO'%uQUO,5;dO'&{QVO,5;dOOQQ,5;d,5;dO''VQVO,5;dO'&{QVO,5;dO''^QUO,5;bO'(ZQUO,5;eO'(fQUO'#KqO'(nQUO,5:vO'(sQUO,5;fOOQQ1G0n1G0nOOQQ'#J^'#J^O''^QUO,5;bO!4xQUO'#E}OOQQ,5;b,5;bO')nQUO'#E`O'+hQUO'#E{OHrQUO1G0nO'+mQUO'#EbOOQQ'#JY'#JYO'-VQUO'#KsOOQQ'#Ks'#KsO'.PQUO1G0eO'.wQUO1G3lO'/}QVO1G3lOOQQ1G3l1G3lO'0XQVO1G3lO'0`QUO'#L`O'1lQUO'#KYO'1zQUO'#KXO'2VQUO,59gO'2_QUO1G/`O'2dQUO'#FPOOQR1G1]1G1]OOQR1G2h1G2hO$>uQUO1G2hO'2nQUO1G2hO'2yQUO1G0ZOOQR'#Ja'#JaO'3OQVO1G1XO'8wQUO'#FTO'8|QUO1G1VO!6nQUO'#JeO'9[QUO,5;}O$0^QUO,5;}OOQQ'#Fd'#FdOOQQ,5;},5;}O'9jQUO1G1gOOQR1G1g1G1gO'9rQUO,5<YO$.vQUO'#FWOBUQUO'#FWO'9yQUO,5<YO!(zQVO,5<YO':RQUO,5<YO':WQVO1G1rO!0tQVO1G1rOOQR1G1w1G1wO'?vQUO1G1yOOQR1G1|1G1|O'?{QUO1G1}OBUQUO1G2^O'AUQVO1G1}O'CjQUO1G1}O'CoQUO'#GXO8zQUO1G2^OOQR1G2P1G2POOQR1G2V1G2VOOQR1G2X1G2XOOQR1G2Z1G2ZO'CtQUO1G2_O!4xQUO1G2_OOQR1G2w1G2wO'C|QUO1G2wO$>}QUO1G2aOOQQ'#Cu'#CuO'DRQUO'#G]O'D|QUO'#G]O'ERQUO'#LSO'EaQUO'#G`OOQQ'#LT'#LTO'EoQUO1G2aO'EtQVO1G1lO'HVQVO'#GVOBUQUO'#FWOOQR'#Jf'#JfO'EtQVO1G1lO'HaQUO'#FwOOQR1G2g1G2gOOQR,5;x,5;xO'HfQVO,5;xO'HmQUO1G2hO'HrQUO'#JhO'2nQUO1G2hO!(zQVO1G2uO'HzQUO1G2yO'JTQUO1G3RO'KZQUO1G3YOOQQ1G3p1G3pO'KoQUO1G3pOOQR1G3[1G3[O'KtQUO'#K[O'2dQUO'#LUOGkQUO'#LWOOQR'#Gz'#GzO#DhQUO'#LYOOQR'#HR'#HRO'LOQUO'#GwO'$OQUO'#GvOOQR1G2|1G2|O'L{QUO1G2|O'MrQUO1G3[O'M}QUO1G3`O'NSQUO1G3`OOQR1G3`1G3`O'N[QUO'#H^OOQR'#H^'#H^O( eQUO'#H^O!(zQVO'#HaO!(zQVO'#H`OOQR'#L['#L[O( jQUO'#L[OOQR'#Jl'#JlO( oQVO,5=wOOQQ,5=w,5=wO( vQUO'#H_O(!OQUO'#H[OOQQ1G3b1G3bO(!YQUO,5@wOOQQ,5@w,5@wO%)_QUO,5@wO%)dQUO,5@wO%$^QUO,5:eO(%wQUO'#KlO(&VQUO'#KlOOQQ,5:e,5:eOOQQ'#JT'#JTO(&bQUO'#D}O(&lQUO'#KrOGkQUO'#LWO('hQUO'#D}OOQQ'#Hq'#HqOOQQ'#Hs'#HsOOQQ'#Ht'#HtOOQQ'#Km'#KmOOQQ'#JV'#JVO('rQUO,5:hOOQQ,5:h,5:hO((oQUO'#LWO((|QUO'#HuO()dQUO,5@wO()kQUO'#H|O()vQUO'#L_O(*OQUO,5>gO(*TQUO'#L^OOQQ1G4O1G4OO(-zQUO1G4OO(.RQUO1G4OO(.YQUO1G4UO(/`QUO1G4UO(/eQUO,5A}O!6nQUO1G4iO!(zQVO'#IjOOQQ1G4n1G4nO(/jQUO1G4nO(1mQVO1G4qPOOO1G.h1G.hP!A_{,UO1G.hP(3mQUO'#LfP(3x{,UO1G.hP(3}{7[O1G.hPO{O-E=t-E=tPOOO,5BO,5BOP(4V{,UO,5BOPOOO1G5R1G5RO!(zQVO7+$[O(4[QUO'#CyOOQQ,59^,59^O(4gQbO,59cO(4rQbO,59^OOQQ,59],59]OOQQ7+)x7+)xO!M_QVO'#JuO(4}QUO,5@lOOQQ1G.n1G.nOOQQ1G2l1G2lO(5VQUO1G2lO(5[QUO7+(tOOQQ7+*Y7+*YO(7pQUO7+*YO(7wQUO7+*YO(1mQVO7+*]O#NeQUO7+(tO(8UQVO'#JcO(8iQUO,5AkO(8qQUO,5;vOOQQ'#Co'#CoOOQQ,5;w,5;wO!(zQVO'#F[OOQQ-E=`-E=`O!M_QVO,5;uOOQQ1G1`1G1`OOQQ,5?l,5?lOOQQ-E=O-E=OOOQR'#Dg'#DgOOQR'#Di'#DiOOQR'#Dl'#DlO(9zQ!eO'#K`O(:RQMkO'#K`O(:YQ!eO'#K`OOQR'#K`'#K`OOQR'#JR'#JRO(:aQ!eO,59zOOQQ,59z,59zO(:hQbO,5?nOOQQ-E=Q-E=QO(:vQbO1G6eOOQR7+$}7+$}OOQR7+&q7+&qOOQR7+&x7+&xO'8|QUO7+&qO(;RQUO7+&OO#6WQUO7+&OO(;vQUO1G/TO(<^QUO1G/TO(<xQUO7+*SOOQQ7+*W7+*WO(>kQUO,5?uOOQQ-E=X-E=XO(?tQUO7+&ZOOQQ,5@Z,5@ZOOQQ-E=m-E=mO(?yQUO'#LPO@XQVO'#EiO(AVQUO1G1_OOQQ1G1_1G1_O(B`QUO,5@OOOQQ,5@O,5@OOOQQ-E=b-E=bO(BtQUO'#KqOOQR7+,x7+,xO#DhQUO7+,xOOQR7+,z7+,zO(CRQUO,5=jO#DsQUO'#JkO(CdQUO,5AsOOQR1G3V1G3VOOQR1G3W1G3WO(CrQUO7+,{OOQR7+,{7+,{O(EjQUO,5:wO(GXQUO'#EwO!(zQVO,5;VO(GzQUO,5:wO(HUQUO'#EpO(HgQUO'#EzOOQQ,5;Z,5;ZO#K]QVO'#ExO(H}QUO,5:wO(IUQUO'#EyO#GgQUO'#J[O(JnQUO,5AeOOQQ1G0p1G0pO(JyQUO,5;WO!<[QUO,5;^O(KdQUO,5;_O(KrQUO,5;WO(NUQUO,5;`OOQQ-E=Z-E=ZO(N^QUO1G0}OOQQ1G1O1G1OO) XQUO1G1OO)!_QVO1G1OO)!fQVO1G1OO)!pQUO1G0|OOQQ1G0|1G0|OOQQ1G1P1G1PO)#mQUO'#JpO)#wQUO,5A]OOQQ1G0b1G0bOOQQ-E=[-E=[O)$PQUO,5;iO!<[QUO,5;iO)$|QVO,5:zO)%TQUO,5;gO$ mQUO7+&YOOQQ7+&Y7+&YO!(zQVO'#EfO)%[QUO,5:|OOQQ'#Kt'#KtOOQQ-E=W-E=WOOQQ,5A_,5A_OOQQ'#Jm'#JmO))PQUO7+&PPOQQ7+&P7+&POOQQ7+)W7+)WO))wQUO7+)WO)*}QVO7+)WOOQQ,5>n,5>nO$)YQVO'#JtO)+UQUO,5@sOOQQ1G/R1G/ROOQQ7+$z7+$zO)+aQUO7+(SO)+fQUO7+(SOOQR7+(S7+(SO$>uQUO7+(SOOQQ7+%u7+%uOOQR-E=_-E=_O!0VQUO,5;oOOQQ,5@P,5@POOQQ-E=c-E=cO$0^QUO1G1iOOQQ1G1i1G1iOOQR7+'R7+'ROOQR1G1t1G1tOBUQUO,5;rO),SQUO,5<ZO),ZQUO1G1tO)-dQUO1G1tO!0tQVO7+'^O)-iQVO7+'^O)3XQUO7+'eO)3^QVO7+'iO)5rQUO7+'xO)5|QUO7+'iO)7SQVO7+'iOKkQUO7+'xO$>hQUO,5<sO!4xQUO7+'yO)7ZQUO7+'yOOQR7+(c7+(cO)7`QUO7+'{O)7eQUO,5<wO'DRQUO,5<wO)8]QUO,5<wO'DRQUO,5<wOOQQ,5<x,5<xO)8nQVO,5<yO'EaQUO'#JgO)8xQUO,5AnO)9QQUO,5<zOOQR7+'{7+'{O)9]QVO7+'WO)5uQUO'#LOOOQR-E=d-E=dO);nQVO,5<cOOQR1G1d1G1dOOQQ,5@S,5@SO!6nQUO,5@SOOQQ-E=f-E=fO)>VQUO7+(aO)?]QUO7+(eO)?bQVO7+(eOOQQ7+(m7+(mOOQQ7+)[7+)[O)?jQUO'#KkO)?tQUO'#KkOOQR,5=c,5=cO)@RQUO,5=cO!;bQUO,5=cO!;bQUO,5=cO!;bQUO,5=cOOQR7+(h7+(hOOQR7+(v7+(vOOQR7+(z7+(zOOQR,5=x,5=xO)@WQUO,5={O)A^QUO,5=zOOQR,5Av,5AvOOQR-E=j-E=jOOQQ1G3c1G3cO)BdQUO,5=yO)BiQVO'#EfOOQQ1G6c1G6cO%)_QUO1G6cO%)dQUO1G6cOOQQ1G0P1G0POOQQ-E=R-E=RO)EQQUO,5AWO(%wQUO'#JUO)E]QUO,5AWO)E]QUO,5AWO)EeQUO,5:iO8zQUO,5:iOOQQ,5>^,5>^O)EoQUO,5ArO)EvQUO'#EVO)GQQUO'#EVO)GkQUO,5:iO)GuQUO'#HmO)GuQUO'#HnOOQQ'#Kp'#KpO)HdQUO'#KpO!(zQVO'#HoOOQQ,5:i,5:iO)IUQUO,5:iO!M_QVO,5:iOOQQ-E=T-E=TOOQQ1G0S1G0SOOQQ,5>a,5>aO)IZQUO1G6cO!(zQVO,5>hO)LxQUO'#JsO)MTQUO,5AyOOQQ1G4R1G4RO)M]QUO,5AxOOQQ,5Ax,5AxOOQQ7+)j7+)jO*!zQUO7+)jOOQQ7+)p7+)pO*'yQVO1G7iO*){QUO7+*TO**QQUO,5?UO*+WQUO7+*]POOO7+$S7+$SP*,yQUO'#LgP*-RQUO,5BQP*-W{,UO7+$SPOOO1G7j1G7jO*-]QUO<<GvOOQQ1G.x1G.xOOQQ'#IU'#IUO*/OQUO,5@aOOQQ,5@a,5@aOOQQ-E=s-E=sOOQQ7+(W7+(WOOQQ<<Mt<<MtO*0XQUO<<MtO*2[QUO<<MwO*3}QUO<<L`O*4cQUO,5?}OOQQ,5?},5?}OOQQ-E=a-E=aOOQQ1G1b1G1bO*5lQUO,5;vO*6rQUO1G1aOOQQ1G1a1G1aOOQR,5@z,5@zO*7{Q!eO,5@zO*8SQMkO,5@zO*8ZQ!eO,5@zOOQR-E=P-E=POOQQ1G/f1G/fO*8bQ!eO'#DwOOQQ1G5Y1G5YOOQR<<J]<<J]O*8iQUO<<IjO*9^QUO7+$oOOQQ<<Iu<<IuO(8UQVO,5;ROOQR<=!d<=!dOOQQ1G3U1G3UOOQQ,5@V,5@VOOQQ-E=i-E=iOOQR<=!g<=!gO*:ZQUO1G0cO*:bQUO'#EzO*:rQUO1G0cO*:yQUO'#JOO*<aQUO1G0qO!(zQVO1G0qOOQQ,5;[,5;[OOQQ,5;],5;]OOQQ,5?v,5?vOOQQ-E=Y-E=YO!<[QUO1G0xO*=pQUO1G0xOOQQ1G0y1G0yO*>RQUO'#ElOOQQ1G0z1G0zOOQQ7+&j7+&jO*>gQUO7+&jO*?mQVO7+&jOOQQ7+&h7+&hOOQQ,5@[,5@[OOQQ-E=n-E=nO*@iQUO1G1TO*@sQUO1G1TO*A^QUO1G0fOOQQ1G0f1G0fO*BdQUO'#K|O*BlQUO1G1ROOQQ<<It<<ItOOQQ'#Hc'#HcO'+mQUO,5=|OOQQ'#He'#HeO'+mQUO,5>OOOQQ-E=k-E=kPOQQ<<Ik<<IkPOQQ-E=l-E=lOOQQ<<Lr<<LrO*BqQUO'#LbO*C}QUO'#LaOOQQ,5@`,5@`OOQQ-E=r-E=rOOQR<<Kn<<KnO$>uQUO<<KnO*D]QUO<<KnOOQR1G1Z1G1ZOOQQ7+'T7+'TO!M_QVO1G1uO*DbQUO1G1uOOQR7+'`7+'`OOQR<<Jx<<JxO!0tQVO<<JxOOQR<<KP<<KPO*DmQUO<<KTO*EsQVO<<KTOKkQUO<<KdO!M_QVO<<KdO*EzQUO<<KTO!0tQVO<<KTO*GTQUO<<KTO*GYQUO<<KdO*GeQUO<<KeOOQR<<Ke<<KeOOQR<<Kg<<KgO*GjQUO1G2cO)7eQUO1G2cO'DRQUO1G2cO*G{QUO1G2eO*IRQVO1G2eOOQQ1G2e1G2eO*I]QVO1G2eO*IdQUO,5@ROOQQ-E=e-E=eOOQQ1G2f1G2fO*IrQUO1G1}O*J{QVO1G1}O*KSQUO1G1}OOQQ1G5n1G5nOOQR<<K{<<K{OOQR<<LP<<LPO*KXQVO<<LPO*KdQUO<<LPOOQR1G2}1G2}O*KiQUO1G2}O*KpQUO1G3fOOQR1G3e1G3eOOQQ7++}7++}O%)_QUO7++}O*K{QUO1G6rO*K{QUO1G6rO(%wQUO,5?pO*LTQUO,5?pOOQQ-E=S-E=SO*L`QUO1G0TOOQQ1G0T1G0TO*LjQUO1G0TO!M_QVO1G0TO*LoQUO1G0TOOQQ1G3x1G3xO*LyQUO,5:qO)EvQUO,5:qO*MgQUO,5:qO)EvQUO,5:qO$#uQUO,5:uO*NUQVO,5>WO)GuQUO'#JqO*N`QUO1G0TO*NqQVO1G0TOOQQ1G3v1G3vO*NxQUO,5>XO+ TQUO,5>YO+ rQUO,5>ZO+!xQUO1G0TO%)dQUO7++}O+$OQUO1G4SOOQQ,5@_,5@_OOQQ-E=q-E=qOOQQ<<MU<<MUOOQQ<<Mo<<MoO+%XQUO1G4pP+'[QUO'#JwP+'dQUO,5BRPO{O1G7l1G7lPOOO<<Gn<<GnOOQQANC`ANC`OOQR1G6f1G6fO+'lQ!eO,5:cOOQQ,5:c,5:cO+'sQUO1G0mO+)PQUO7+&]O+*`QUO7+&dO+*qQUO,5;WOOQQ<<JU<<JUO++PQUO7+&oOOQQ7+&Q7+&QO!4xQUO'#J_O++zQUO,5AhOOQQ7+&m7+&mOOQQ1G3h1G3hO+,SQUO1G3jOOQQ,5>o,5>oO+/wQUOANAYOOQRANAYANAYO+/|QUO7+'aOOQRAN@dAN@dO+1YQVOAN@oO+1aQUOAN@oO!0tQVOAN@oO+2jQUOAN@oO+2oQUOANAOO+2zQUOANAOO+4QQUOANAOOOQRAN@oAN@oO!M_QVOANAOOOQRANAPANAPO+4VQUO7+'}O)7eQUO7+'}OOQQ7+(P7+(PO+4hQUO7+(PO+5nQVO7+(PO+5uQVO7+'iO+5|QUOANAkOOQR7+(i7+(iOOQR7+)Q7+)QO+6RQUO7+)QO+6WQUO7+)QOOQQ<= i<= iO+6`QUO7+,^O+6hQUO1G5[OOQQ1G5[1G5[O+6sQUO7+%oOOQQ7+%o7+%oO+7UQUO7+%oO*NqQVO7+%oOOQQ7+)b7+)bO+7ZQUO7+%oO+8aQUO7+%oO!M_QVO7+%oO+8kQUO1G0]O*LyQUO1G0]O)EvQUO1G0]OOQQ1G0a1G0aO+9YQUO1G3rO+:`QVO1G3rOOQQ1G3r1G3rO+:jQVO1G3rO+:qQUO,5@]OOQQ-E=o-E=oOOQQ1G3s1G3sO%)_QUO<= iOOQQ7+*[7+*[POQQ,5@c,5@cPOQQ-E=u-E=uOOQQ1G/}1G/}OOQQ,5?y,5?yOOQQ-E=]-E=]OOQRG26tG26tO+;YQUOG26ZO!0tQVOG26ZO+<cQUOG26ZOOQRG26ZG26ZO!M_QVOG26jO!0tQVOG26jO+<hQUOG26jO+=nQUOG26jO+=sQUO<<KiOOQQ<<Kk<<KkOOQRG27VG27VOOQR<<Ll<<LlO+>UQUO<<LlOOQQ7+*v7+*vOOQQ<<IZ<<IZO+>ZQUO<<IZO!M_QVO<<IZO+>`QUO<<IZO+?fQUO<<IZO*NqQVO<<IZOOQQ<<L|<<L|O+?wQUO7+%wO*LyQUO7+%wOOQQ7+)^7+)^O+@fQUO7+)^O+AlQVO7+)^OOQQANETANETO!0tQVOLD+uOOQRLD+uLD+uO+AsQUOLD,UO+ByQUOLD,UOOQRLD,ULD,UO!0tQVOLD,UOOQRANBWANBWOOQQAN>uAN>uO+COQUOAN>uO+DUQUOAN>uO!M_QVOAN>uO+DZQUO<<IcOOQQ<<Lx<<LxOOQR!$( a!$( aO!0tQVO!$( pOOQR!$( p!$( pOOQQG24aG24aO+DxQUOG24aO+FOQUOG24aOOQR!)9E[!)9E[OOQQLD){LD){O+FTQUO'#CgO(dQUO'#CgO+JQQUO'#CyO+LqQUO'#CyO!E{QUO'#CyO+MjQUO'#CyO+M}QUO'#CyO,#pQUO'#CyO,$QQUO'#CyO,$_QUO'#CyO,$jQbO,59cO,$uQbO,59cO,%QQbO,59cO,%]QbO'#CwO,%nQbO'#CwO,&PQbO'#CwO,&bQUO'#CgO,(uQUO'#CgO,)SQUO'#CgO,+wQUO'#CgO,.zQUO'#CgO,/[QUO'#CgO,3TQUO'#CgO,3[QUO'#CgO,4[QUO'#CgO,6eQUO,5:xO#?kQUO,5:xO#?kQUO,5:xO#=ZQUO'#L]O,7RQbO'#CwO,7^QbO'#CwO,7iQbO'#CwO,7tQbO'#CwO#6tQUO'#E^O,8PQUO'#E^O,9^QUO'#HhO,:OQbO'#CwO,:ZQbO'#CwO,:fQUO'#CvO,:kQUO'#CvO,:pQUO'#CoO,;OQbO,59cO,;ZQbO,59cO,;fQbO,59cO,;qQbO,59cO,;|QbO,59cO,<XQbO,59cO,<dQbO,59cO,6eQUO1G0dO,<oQUO1G0dO#?kQUO1G0dO,8PQUO1G0dO,>|QUO'#K[O,?^QUO'#CyO,?lQbO,59cO,6eQUO7+&OO,<oQUO7+&OO,?wQUO'#EwO,@jQUO'#EzO,AZQUO'#E^O,A`QUO'#GdO,AeQUO'#CvO,AjQUO'#CwO,AoQUO'#CwO,AtQUO'#CvO,AyQUO'#GdO,BOQUO'#K[O,BlQUO'#K[O,BvQUO'#CvO,CRQUO'#CvO,C^QUO'#CvO,<oQUO,5:xO,8PQUO,5:xO,8PQUO,5:xO,CiQUO'#K[O,C|QbO'#CwO,DXQUO'#CrO,D^QUO'#E^",
  stateData: ",ES~O(oOSSOSTOSRPQVPQ'fPQ'hPQ'iPQ'jPQ'kPQ'lPQ'mPQ'nPQ~O*[OS~OPmO]eOa!]Od!POlTOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!TxO!VfO!X!XO!Y!WO!i!YO!opO!r!`O!s!aO!t!aO!u!bO!v!aO!x!cO!{!dO#V#QO#a#VO#b#TO#i#OO#p!xO#t!fO#v!eO$S!gO$U!hO$Z!vO$[!wO$a!iO$f!jO$h!kO$i!lO$l!mO$n!nO$p!oO$r!pO$t!qO$v!rO$x!sO$|!tO%O!uO%V!yO%`#ZO%a#[O%b#YO%d!zO%f#UO%h!{O%m#SO%p!|O%w!}O%}#PO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(sRO)QYO)TaO)V|O)W{O)XiO)Y!ZO)ZXO)icO)jdO~OR#bOV#]O'f#^O'h#_O'i#`O'j#`O'k#aO'l#aO'm#_O'n#_O~OX#dO(q#dO(r#fO~O]ZX]iXdiXlgXpZXpiXriXsiXtiXuiXviXwiXxiXyiX}iX!TiX!VZX!ViX!XZX!YZX![ZX!^ZX!_ZX!aZX!bZX!cZX!eZX!fZX!gZX!hZX!riX!siX!tiX!uiX!viX!xiX!{iX%wiX&siX&tiX(siX(vZX(w$^X(xZX(yZX)TZX)TiX)UZX)VZX)ViX)WZX)WiX)XZX)YZX)kZX~O)XiX!UZX~P(dO]#}O!V#lO!X#{O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO(x#kO(y#kO)T#mO)U#oO)V#nO)W#pO)X#jO)Y#|O~Od$RO%Z$SO']$TO'`$UO(z$OO~Ol$VO~O!T$WO])OXd)OXr)OXs)OXt)OXu)OXv)OXw)OXx)OXy)OX})OX!V)OX!r)OX!s)OX!t)OX!u)OX!v)OX!x)OX!{)OX%w)OX&s)OX&t)OX(s)OX)T)OX)V)OX)W)OX)X)OX~Ol$VO~P.ZOl$VO!g$YO)k$YO~OX$ZO)[$ZO~O!R$[O)Y)RP)^)RP~OPmO]$eOa!]Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!TxO!V$fO!X!XO!Y!WO!i!YO!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO#V#QO#a#VO#b#TO#v!eO$Z!vO$[!wO$a!iO$f!jO$h!kO$i!lO$l!mO$n!nO$p!oO$r!pO$t!qO$v!rO$x!sO%`#ZO%a#[O%b#YO%f#UO%m#SO%w$mO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO)QYO)T$kO)W$kO)XiO)Y!ZO)ZXO)icO)jdO~Ol$_O#t$lO(sRO~P0zO](^Xa'zXd(^Xl'zXl(^Xr'zXr(^Xs'zXs(^Xt'zXt(^Xu'zXu(^Xv'zXv(^Xw'zXw(^Xx'zXx(^Xy'zXy(^X{'zX}'zX!V(^X!o(^X!r'zX!r(^X!s'zX!s(^X!t'zX!t(^X!u'zX!u(^X!v'zX!v(^X!x'zX!x(^X!{(^X#a'zX#b'zX%f'zX%m'zX%p(^X%w(^X&n'zX&s'zX&t'zX(s'zX(s(^X)T(^X)V(^X)W(^X~Oa!TOl$oOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO#a#VO#b#TO%f#UO%m#SO&n!RO&s#WO&t!TO(s$nO~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O}!_O!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO&s#WO&t$wO])bXd)bXl)bX!V)bX!{)bX%w)bX(s)bX)T)bX)V)bX)W)bX~O)X$vO~P:nOPmO]eOd!POr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!VfO!X!XO!Y!WO!i!YO!{!dO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO)TaO)V|O)W{O)Y!ZO)ZXO)icO)jdO~Oa%QOl;OO!|%RO(s$xO~P<lO)T%SO~Oa!]Ol$_O{#RO#a#VO#b#TO%f#UO%m#SO&n!RO&s#WO&t!TO(s;RO~P<lOPmO]$eOa%QOl;OO!V$fO!W%_O!X!XO!Y!WO!i!YO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)T$kO)W%]O)Y!ZO)ZXO)icO)jdO)k%[O~O]%hOd!POl%bO!V%kO!{!dO%w$mO(s;SO)T%dO)V%iO)W%iO~O(w%mO~O)X#jO~O(s%nO](uX!V(uX!X(uX!Y(uX![(uX!^(uX!_(uX!a(uX!b(uX!c(uX!e(uX!f(uX!h(uX(v(uX(x(uX(y(uX)T(uX)U(uX)V(uX)W(uX)X(uX)Y(uX!g(uX)k(uX!O(uX!W(uX(w(uX!U(uXQ(uX!d(uX~OP%oO(pQO~PCQO]%hOd!POr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!V%kO!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO!{!dO%p!|O%w!}O)T;dO)V|O)W|O~Ol%rO!o%wO(s$xO~PE_O!TxO#v!eO(w%yO)k%|O])fX!V)fX~O]%hOd!POl%rO!V%kO!{!dO%w!}O(s$xO)T;dO)V|O)W|O~O!TxO#v!eO)X&PO)k&QO~O!U&TO~P!QO]&YO!TxO!V&WO)T&VO)V&ZO)W&ZO~Op&UO~PHrO]&cO!V&bO~OPmO]eOd!PO!VfO!X!XO!Y!WO!i!YO!{!dO#V#QO%`#ZO%a#[O%b#YO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO)TaO)V|O)W{O)Y!ZO)ZXO)icO)jdO~Oa%QOl;OO%w$mO(s$xO~PIgO]%hOd!POl;`O!V%kO!{!dO%w$mO(s$xO)T;dO)V|O)W|O~Op&fO](uX])fX!V(uX!V)fX!X(uX!Y(uX![(uX!^(uX!_(uX!a(uX!b(uX!c(uX!e(uX!f(uX!h(uX(v(uX(x(uX(y(uX)T(uX)U(uX)V(uX)W(uX)X(uX)Y(uX!O(uX!O)fX!U(uX~O!g$YO)k$YO~PL]O!g(uX)k(uX~PL]O](uX!V(uX!X(uX!Y(uX![(uX!^(uX!_(uX!a(uX!b(uX!c(uX!e(uX!f(uX!h(uX(v(uX(x(uX(y(uX)T(uX)U(uX)V(uX)W(uX)X(uX)Y(uX!g(uX)k(uX!O(uX!U(uX~O])fX!V)fX!O)fX~PNkOa&hO&n!RO]&mXd&mXl&mXr&mXs&mXt&mXu&mXv&mXw&mXx&mXy&mX}&mX!V&mX!r&mX!s&mX!t&mX!u&mX!v&mX!x&mX!{&mX%w&mX&s&mX&t&mX(s&mX)T&mX)V&mX)W&mX)X&mX!O&mX!T&mX!X&mX!Y&mX![&mX!^&mX!_&mX!a&mX!b&mX!c&mX!e&mX!f&mX!h&mX(v&mX(x&mX(y&mX)U&mX)Y&mX!g&mX)k&mX!W&mXQ&mX!d&mX(w&mX!U&mX#v&mX~Op&fOl)OX!O)OXQ)OX!d)OX!h)OX)Y)OX)k)OX~P.ZO!g$YO)k$YO](uX!V(uX!X(uX!Y(uX![(uX!^(uX!_(uX!a(uX!b(uX!c(uX!e(uX!f(uX!h(uX(v(uX(x(uX(y(uX)T(uX)U(uX)V(uX)W(uX)X(uX)Y(uX!O(uX!W(uX(w(uX!U(uXQ(uX!d(uX~OPmO]$eOa%QOl;OO!V$fO!X!XO!Y!WO!i!YO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)T$kO)W$kO)Y!ZO)ZXO)icO)jdO~O])OXd)OXl)OXr)OXs)OXt)OXu)OXv)OXw)OXx)OXy)OX})OX!V)OX!r)OX!s)OX!t)OX!u)OX!v)OX!x)OX!{)OX%w)OX&s)OX&t)OX(s)OX)T)OX)V)OX)W)OX)X)OX!O)OXQ)OX!d)OX!h)OX)Y)OX)k)OX~O]#}O~P!*qO]&lO~O])cXa)cXd)cXl)cXr)cXs)cXt)cXu)cXv)cXw)cXx)cXy)cX{)cX})cX!V)cX!o)cX!r)cX!s)cX!t)cX!u)cX!v)cX!x)cX!{)cX#a)cX#b)cX%f)cX%m)cX%p)cX%w)cX&n)cX&s)cX&t)cX(s)cX)T)cX)V)cX)W)cX~O(pQO~P!-ZO%V&nO~P!-ZO]&oO~O]#}O~O!TxO~O$X&wO(s%nO(w&vO~O]&xOw&zO~O]&xO~OPmO]$eOa%QOl;OO!TxO!V$fO!X!XO!Y!WO!i!YO#V#QO#p!xO#v!eO$Z!vO$[!wO$a!iO$f!jO$h!kO$i!lO$l!mO$n!nO$p!oO$r!pO$t!qO$v!rO$x!sO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s:qO)QYO)T$kO)W$kO)XiO)Y!ZO)ZXO)icO)jdO~O]'PO~O!T$WO)X'RO~P!(zO)X'TO~O)X'UO~O(s'VO~O)X'YO~P!(zOl;bO%V'^O%f'^O(s;TO~Oa!TOl$oOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO#a#VO#b#TO%f#UO%m#SO&n!RO&s#WO&t!TO(s$nO~O(w'bO~O)X'dO~P!(zO!T'eO(s%nO)k'gO~O(s%nO~O]'jO~O]'kOd%oXl%oX!V%oX!{%oX%w%oX(s%oX)T%oX)V%oX)W%oX~O]'oO!V'pO!X'mO!g'mO%['mO%]'mO%^'mO%_'mO%`'qO%a'qO%b'mO(y'nO)k'mO)y'rO~P8zO]%hOa!TOd!POr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!V%kO!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO!{!dO#a#VO#b#TO%f#UO%m#SO&n!RO&s#WO&t!TO)T;dO)V|O)W|O~Ol;cOp&UO%w$mO(s;UO~P!8jO(s%nO(w'wO)X'xO~O]&cO!T'zO~Ol$oO}!_O!T(RO!l(WO(s$nO(w(QO)QYO~Ol$oO{(_O!T([O#b(_O(s$nO~Oa!TOl$oO{#RO#a#VO#b#TO%f#UO%m#SO&n!RO&s#WO&t!TO(s$nO~O](aO~OPmOa%QOl;OO!V$fO!X!XO!Y!WO!i!YO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)T$kO)W$kO)ZXO)icO)jdO~O](cO)Y(dO~P!=UO]#}O~P!<[OPmO]$eOa%QOl;OO!V(jO!X!XO!Y!WO!i!YO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)T$kO)W$kO)Y!ZO)ZXO)icO)jdO~OY(kO(pQO(s%nO~O'g(nO~OS(rOT(oO*X(qO~O]#}O(o(uO~Q'oXX#dO(q#dO(r(wO~Od)ROl(|O&s#WO(s({O~O!Y'Ta!['Ta!^'Ta!_'Ta!a'Ta!b'Ta!c'Ta!e'Ta!f'Ta!h'Ta(v'Ta)T'Ta)U'Ta)V'Ta)W'Ta)X'Ta)Y'Ta!g'Ta)k'Ta!O'Ta!W'Ta(w'Ta!U'TaQ'Ta!d'Ta~OPmOa%QOl;OO!i!YO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)ZXO)icO)jdO]'Ta!V'Ta!X'Ta(x'Ta(y'Ta~P!B_O!T$WO!O(tP~P!(zO]nX]%XXdnXlmXpnXp%XXrnXsnXtnXunXvnXwnXxnXynX}nX!TnX!VnX!V%XX!X%XX!Y%XX![%XX!^%XX!_%XX!a%XX!b%XX!c%XX!e%XX!f%XX!gmX!h%XX!rnX!snX!tnX!unX!vnX!xnX!{nX%wnX&snX&tnX(snX(v%XX(x%XX(y%XX)TnX)T%XX)U%XX)VnX)V%XX)WnX)W%XX)X%XX)Y%XX)kmX!O%XX~O)XnX!OnX!U%XX~P!E{O])eO!V)fO!X)cO!g)cO%[)cO%])cO%^)cO%_)cO%`)gO%a)gO%b)cO(y)dO)k)cO)y)hO~P8zOPmO]$eOa%QOl;OO!X!XO!Y!WO!i!YO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)T$kO)W$kO)Y!ZO)ZXO)icO)jdO~O!V)mO~P!JwOd)pO%Z)qO(z$OO~O!T$WO!V)sO(x)tO!U)sP~P!JwO!T$WO~P!(zO)]){O~Ol)|O]!QX!h!QX)Y!QX)^!QX~O]*OO!h*PO)Y)RX)^)RX~O)Y*TO)^*SO~Od$RO%Z*UO']$TO'`$UO(z$OO~Ol*VO~Ol*VO!O)OX~P.ZOl*VO!g$YO)k$YO~O)X*WO~P:nOPmO]$eOa!]Ol$_Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO!V$fO!X!XO!Y!WO!i!YO#V#QO#a#VO#b#TO%`#ZO%a#[O%b#YO%f#UO%m#SO%w$mO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s;RO)T$kO)W$kO)Y!ZO)ZXO)icO)jdO~Op&fO~P!&zOp&fO!W(uX(w(uXQ(uX!d(uX~PNkO]'oO!V'pO!X'mO!g'mO%['mO%]'mO%^'mO%_'mO%`'qO%a'qO%b'mO(y'nO)k'mO)y'rO~O]iXdiXlgXpiXriXsiXtiXuiXviXwiXxiXyiX}iX!ViX!riX!siX!tiX!uiX!viX!xiX!{iX%wiX&siX&tiX(siX)TiX)ViX)WiX!TiX!hiX)YiX)kiX!OiX~O!liX(wiX)XiX!XiX!YiX![iX!^iX!_iX!aiX!biX!ciX!eiX!fiX(viX(xiX(yiX)UiX!giX!WiXQiX!diX!UiX#viX#TiX#ViX#piXaiX{iX!oiX#aiX#biX#iiX#tiX$|iX%diX%fiX%liX%miX%piX&niX)QiX~P#%yO(z*[O~Ol*]O~O])OXd)OXr)OXs)OXt)OXu)OXv)OXw)OXx)OXy)OX})OX!V)OX!r)OX!s)OX!t)OX!u)OX!v)OX!x)OX!{)OX%w)OX&s)OX&t)OX(s)OX)T)OX)V)OX)W)OX)X)OX!T)OX!X)OX!Y)OX![)OX!^)OX!_)OX!a)OX!b)OX!c)OX!e)OX!f)OX!h)OX(v)OX(x)OX(y)OX)U)OX)Y)OX!g)OX)k)OX!O)OX!W)OXQ)OX!d)OX(w)OX!U)OX#v)OX~Ol*]O~P#+ROr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O}!_O!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO])bad)bal)ba!V)ba!{)ba%w)ba(s)ba)T)ba)V)ba)W)baQ)ba!d)ba!h)ba)Y)ba)k)ba!O)ba!T)ba(w)ba)X)ba~O&s#WO&t$wO~P#.qOp&fOl)OX~P#+RO&s)ba~P#.qO]ZXlgXpZXpiX!TiX!VZX!XZX!YZX![ZX!^ZX!_ZX!aZX!bZX!cZX!eZX!fZX!gZX!hZX(vZX(xZX(yZX)TZX)UZX)VZX)WZX)XZX)YZX)kZX!OZX~O!WZX(wZX!UZXQZX!dZX~P#1jO]#}O!V#lO!X#{O(x#kO(y#kO~O!Y&ya![&ya!^&ya!_&ya!a&ya!b&ya!c&ya!e&ya!f&ya!g&ya!h&ya(v&ya)T&ya)U&ya)V&ya)W&ya)X&ya)Y&ya)k&ya!O&ya!W&ya(w&ya!U&yaQ&ya!d&ya~P#3zOl;lO!T$WO~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O~PKkOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!|%RO~PKkO]&cO!V&bO!O#Qa!T#Qa!h#Qa#v#Qa)X#Qa)k#QaQ#Qa!d#Qa(w#Qa~Op&fO!T$WO~O!O*dO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!O*dO~O]&cO!O*fO!V&bO~O]&YOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!V&WO&s#WO&t$wO)T&VO)V&ZO)W&ZO~O!OqXQqX!dqX!hqX)YqX)XqX~P#9{O!O*iO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h*jO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!W)lX~P#3zO!W*lO!h*mO~O!W*lO!h*mO~P!(zO!W*lO~Op&fO!g$YO!h*nO)k$YO](uX!V(uX!W(uX!W*PX!X(uX!Y(uX![(uX!^(uX!_(uX!a(uX!b(uX!c(uX!e(uX!f(uX(v(uX(x(uX(y(uX)T(uX)U(uX)V(uX)W(uX)Y(uX~O!h(uX~P#=ZO!W*pO~Od$RO%Z*UO(z:vO~Ol;oO~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!|%RO~PBUO]*wO!T*rO!V&bO!h*uO#v!eO)k*sO)X)rX~O!h*uO)X)rX~O)X*xO~Op&fO])fX!T)fX!V)fX!h)fX#v)fX)X)fX)k)fX!O)fXQ)fX!d)fX(w)fX~Op&fO~OP%oO(pQO]%ia!V%ia!X%ia!Y%ia![%ia!^%ia!_%ia!a%ia!b%ia!c%ia!e%ia!f%ia!h%ia(s%ia(v%ia(x%ia(y%ia)T%ia)U%ia)V%ia)W%ia)X%ia)Y%ia!g%ia)k%ia!O%ia!W%ia(w%ia!U%iaQ%ia!d%ia~Od$RO%Z$SO(z:sO~Ol:{O~O!TxO#v!eO)k%|O~Ol<`O&s#WO(s;kO~O$[+UO%a+VO~O!TxO#v!eO)X+WO)k+XO~OPmO]$eOa%QOl;OO!V$fO!X!XO!Y!WO!i!YO#V#QO$[+UO%`#ZO%a+ZO%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)T$kO)W$kO)Y!ZO)ZXO)icO)jdO~O!U+[O~P!QOa!TOl$oOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO#a+bO#b+cO#i+dO%f#UO%m#SO&n!RO&s#WO&t!TO(s$nO)QYO~OQ)mP!d)mP~P#GgO]&YOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!V&WO)T&VO)V&ZO)W&ZO~O!O#kX!T#kX#v#kX)X#kX)k#kXQ#kX!d#kX!h#kX)Y#kX!x#kX(w#kX~P#IkOPmO]$eOa%QOl;OOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!V$fO!W+jO!X!XO!Y!WO!i!YO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)T+kO)W$kO)Y!ZO)ZXO)icO)jdO~O]&cO!V+lO~O]&YO!V&WO)QYO)T&VO)V&ZO)W&ZO)Y+oO!O)eP~P8zO]&YO!V&WO)T&VO)V&ZO)W&ZO~O!O#nX!T#nX#v#nX)X#nX)k#nXQ#nX!d#nX!h#nX)Y#nX!x#nX(w#nX~P#NeO!TxO])oX!V)oX~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O#T+wO#p+xO(y+uO)V+sO)W+sO~O]#jX!T#jX!V#jX!O#jX#v#jX)X#jX)k#jXQ#jX!d#jX!h#jX)Y#jX!x#jX(w#jX~P$ xO#V+zO~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!l+{O#T+wO#V+zO#p+xO(y+uO)V+{O)W+{O])gP!T)gP!V)gP#v)gP(w)gP)k)gP!O)gP!h)gP)X)gP~O!x)gPQ)gP!d)gP~P$#uOPmO]$eOa%QOl;OOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!V$fO!X!XO!Y!WO!i!YO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)W$kO)Y!ZO)ZXO)icO)jdO~O!W,RO)T,SO~P$%pO)QYO)Y+oO!O)eP~P8zO]&cO!V&bO!O&[a!T&[a!h&[a#v&[a)X&[a)k&[aQ&[a!d&[a(w&[a~OPmO]$eOa!]Ol;QOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO!V$fO!X!XO!Y!WO!i!YO#V#QO#a#VO#b#TO%`#ZO%a#[O%b#YO%f#UO%m#SO%w$mO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s;VO)T$kO)W$kO)Y!ZO)ZXO)icO)jdO~OQ({P!d({P~P$)YO]#}O!V#lO(x#kO(y#kO!X'Qa!Y'Qa!['Qa!^'Qa!_'Qa!a'Qa!b'Qa!c'Qa!e'Qa!f'Qa!h'Qa(v'Qa)T'Qa)U'Qa)V'Qa)W'Qa)X'Qa)Y'Qa!g'Qa)k'Qa!O'Qa!W'Qa(w'Qa!U'QaQ'Qa!d'Qa~O]#}O!V#lO!X#{O(x#kO(y#kO~P!B_O!T'eO#t!fO)QYO~P8zO!T'eO(s%nO)k,]O~O#x,bO~OQ)bX!d)bX!h)bX)Y)bX)k)bX!O)bX!T)bX(w)bX)X)bX~P:nO(w,fO(x,dO)Q$VX)X$VX~O(s,gO~O)QYO)X,jO~OPmO]$eOa!]Ol;POr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!V$fO!X!XO!Y!WO!i!YO!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO#V#QO#a#VO#b#TO%`#ZO%a#[O%b#YO%f#UO%m#SO%w$mO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO)QYO)T$kO)W$kO)XiO)Y!ZO)ZXO)icO)jdO~O(s;WO~P$0kOPmO]$eOa%QOl;OO!TxO!V$fO!X!XO!Y!WO!i!YO#V#QO#v!eO$Z!vO$[!wO$a!iO$f!jO$h!kO$i!lO$l!mO$n!nO$p!oO$r!pO$t!qO$v!rO$x!sO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s:qO)QYO)T$kO)W$kO)XiO)Y!ZO)ZXO)icO)jdO~O$i,tO~OPmO]$eOa!]Ol;POr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!V$fO!X!XO!Y!WO!i!YO!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO#V#QO#a#VO#b#TO%O!uO%`#ZO%a#[O%b#YO%f#UO%m#SO%w$mO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO)QYO)T$kO)W$kO)Y!ZO)ZXO)icO)jdO~O$|,zO(s;RO)X,xO~P$7UO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO)T#mO)U#oO)V#nO)W#pO)X,|O)Y#|O~P#3zO)X,|O~O)X,}O~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X-OO)Y#|O~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X-PO)Y#|O~P#3zOp&fO)QYO)k-RO~O)X-SO~Ol;bO(s;TO~O]-ZO!{!dO&s#WO&t$wO(s-VO)T-WO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO(w-^O)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!TxO$a!iO$f!jO$h!kO$i!lO$l-cO$n!nO$p!oO$r!pO$t!qO$v!rO$x!sO%O!uO(s:rOd$Ya!o$Ya!{$Ya#i$Ya#p$Ya#t$Ya#v$Ya$S$Ya$U$Ya$Z$Ya$[$Ya$|$Ya%V$Ya%d$Ya%h$Ya%p$Ya%}$Ya(l$Ya)V$Ya!U$Ya$d$Ya~P$0kO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X-dO)Y#|O~P#3zO!U-eO~P!QOl-hO!T'eO)k,]O~O)k-jO~O]&^a!X&^a!Y&^a![&^a!^&^a!_&^a!a&^a!b&^a!c&^a!e&^a!f&^a!h&^a(v&^a(x&^a(y&^a)U&^a)V&^a)W&^a)X&^a)Y&^a!g&^a)k&^a!O&^a!W&^a!T&^a#v&^a(w&^a!U&^aQ&^a!d&^a~O)T-nO!V&^a~P$DiO!O-nO~O!W-nO~O!V-oO)T&^a~P$DiO])OXd)OXr)OXs)OXt)OXu)OXv)OXw)OXx)OXy)OX})OX!V)OX!r)OX!s)OX!t)OX!u)OX!v)OX!x)OX!{)OX%w)OX&s)OX&t)OX(s)OX)T)OX)V)OX)W)OX~Ol;qO~P$GXO]&cO!V&bO)X-pO~Ol;gO!o-sO#V+zO#i-xO#t!fO$|,zO%d!zO%l-wO%p!|O%w!}O(s;XO)QYO~P!8jO!n-|O(s,gO~O)QYO)X.OO~OPmO]$eOa%QOl;OO!T.TO!V$fO!X!XO!Y!WO!i!YO#V.[O#a.ZO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO(y.SO)T$kO)W$kO)X.QO)Y!ZO)ZXO)icO)jdO~O!U.YO~P$JiO])_Xd)_Xr)_Xs)_Xt)_Xu)_Xv)_Xw)_Xx)_Xy)_X})_X!T)_X!V)_X!l)_X!r)_X!s)_X!t)_X!u)_X!v)_X!x)_X!{)_X%w)_X&s)_X&t)_X(s)_X(w)_X)T)_X)V)_X)W)_X)X)_X!O)_X!h)_X)Y)_X!X)_X!Y)_X![)_X!^)_X!_)_X!a)_X!b)_X!c)_X!e)_X!f)_X(v)_X(x)_X(y)_X)U)_X!g)_X)k)_X!W)_XQ)_X!d)_X#T)_X#V)_X#p)_X#v)_Xa)_X{)_X!o)_X#a)_X#b)_X#i)_X#t)_X$|)_X%d)_X%f)_X%l)_X%m)_X%p)_X&n)_X)Q)_X!U)_X~Ol*]O~P$LsOl$oO!T(RO!l.aO(s$nO(w(QO)QYO~Op&fOl)_X~P$LsOl$oO!n.fO!o.fO(s$nO)QYO~Ol;hO!U.qO!n.sO!o.rO#i-xO$|!tO%O!uO%h!{O%l-wO%p!|O%w!}O(s;ZO)QYO~P!8jO!T(RO!l.aO(w(QO])PXd)PXl)PXr)PXs)PXt)PXu)PXv)PXw)PXx)PXy)PX})PX!V)PX!r)PX!s)PX!t)PX!u)PX!v)PX!x)PX!{)PX%w)PX&s)PX&t)PX(s)PX)T)PX)V)PX)W)PX~O)X)PX!O)PX!X)PX!Y)PX![)PX!^)PX!_)PX!a)PX!b)PX!c)PX!e)PX!f)PX!h)PX(v)PX(x)PX(y)PX)U)PX)Y)PX!g)PX)k)PX!W)PXQ)PX!d)PX!U)PX#v)PX~P%%lO!T(RO~O!T(RO(w(QO~O(s%nO!U*RP~O!T([O(w.xO]&lad&lal&lar&las&lat&lau&lav&law&lax&lay&la}&la!V&la!r&la!s&la!t&la!u&la!v&la!x&la!{&la%w&la&s&la&t&la(s&la)T&la)V&la)W&la)X&la!O&la!X&la!Y&la![&la!^&la!_&la!a&la!b&la!c&la!e&la!f&la!h&la(v&la(x&la(y&la)U&la)Y&la!g&la)k&la!W&laQ&la!d&la!U&la#v&la~Ol$oO!T([O(s$nO~O&s#WO&t$wO]&qad&qal&qar&qas&qat&qau&qav&qaw&qax&qay&qa}&qa!V&qa!r&qa!s&qa!t&qa!u&qa!v&qa!x&qa!{&qa%w&qa(s&qa)T&qa)V&qa)W&qa)X&qa!O&qa!T&qa!X&qa!Y&qa![&qa!^&qa!_&qa!a&qa!b&qa!c&qa!e&qa!f&qa!h&qa(v&qa(x&qa(y&qa)U&qa)Y&qa!g&qa)k&qa!W&qaQ&qa!d&qa(w&qa!U&qa#v&qa~O&t.}O~P!(zO!Y#qO![#rO!f#zO)T#mO!^'Va!_'Va!a'Va!b'Va!c'Va!e'Va!h'Va(v'Va)U'Va)V'Va)W'Va)X'Va)Y'Va!g'Va)k'Va!O'Va!W'Va(w'Va!U'VaQ'Va!d'Va~P#3zO!V'eX!X'eX!Y'eX!['eX!^'eX!_'eX!a'eX!b'eX!c'eX!e'eX!f'eX!h'eX(v'eX(x'eX(y'eX)T'eX)U'eX)V'eX)W'eX)Y'eX!O'eX~O]/PO)X'eX!g'eX)k'eX!W'eX(w'eX!U'eXQ'eX!d'eX~P%3PO!Y#qO![#rO!f#zO)T#mO!^'Xa!_'Xa!a'Xa!b'Xa!c'Xa!e'Xa!h'Xa(v'Xa)U'Xa)V'Xa)W'Xa)X'Xa)Y'Xa!g'Xa)k'Xa!O'Xa!W'Xa(w'Xa!U'XaQ'Xa!d'Xa~P#3zO]#}O!T$WO!V/QO&s#WO&t$wO~O!X'[a!Y'[a!['[a!^'[a!_'[a!a'[a!b'[a!c'[a!e'[a!f'[a!h'[a(v'[a(x'[a(y'[a)T'[a)U'[a)V'[a)W'[a)X'[a)Y'[a!g'[a)k'[a!O'[a!W'[a(w'[a!U'[aQ'[a!d'[a~P%6vO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!h'_a)X'_a!g'_a)k'_a!O'_a!W'_a(w'_a!U'_aQ'_a!d'_a~P#3zOPmO]$eOa%QOl;OO!V$fO!X!XO!Y!WO!i!YO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)T$kO)W%]O)Y!ZO)ZXO)icO)jdO)k%[O~O!W/TO~P%:vOS(rOT(oO]#}O*X(qO~O]/WO'g/XO*X/UO~OS/]OT(oO*X/[O~O]#}O~Q'oa!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO(w/_O)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O)X#Zi!O#Zi~P#3zO]cXlgXpcXpiX!VcX!XcX!YcX![cX!^cX!_cX!acX!bcX!ccX!ecX!fcX!gcX!hcX(vcX(xcX(ycX)TcX)UcX)VcX)WcX)XcX)YcX)kcX!OcX!WcX(wcX!TcX#vcX!UcXQcX!dcX~Od/aO%Z*UO(z/`O~Ol/bO~Ol/cO~Op&fO]bi!Vbi!Xbi!Ybi![bi!^bi!_bi!abi!bbi!cbi!ebi!fbi!gbi!hbi(vbi(xbi(ybi)Tbi)Ubi)Vbi)Wbi)Xbi)Ybi)kbi!Obi!Wbi(wbi!UbiQbi!dbi~O!W/eO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO![#rO)T#mO!Y&{i!^&{i!_&{i!a&{i!b&{i!c&{i!e&{i!f&{i!h&{i(v&{i)U&{i)V&{i)W&{i)X&{i)Y&{i!g&{i)k&{i!O&{i!W&{i(w&{i!U&{iQ&{i!d&{i~P#3zO!Y&{i![&{i!^&{i!_&{i!a&{i!b&{i!c&{i!e&{i!f&{i!h&{i(v&{i)T&{i)U&{i)V&{i)W&{i)X&{i)Y&{i!g&{i)k&{i!O&{i!W&{i(w&{i!U&{iQ&{i!d&{i~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO)T#mO)W#pO!h&{i(v&{i)U&{i)V&{i)X&{i)Y&{i!g&{i)k&{i!O&{i!W&{i(w&{i!U&{iQ&{i!d&{i~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO)T#mO)V#nO)W#pO!h&{i(v&{i)U&{i)X&{i)Y&{i!g&{i)k&{i!O&{i!W&{i(w&{i!U&{iQ&{i!d&{i~P#3zO!Y#qO![#rO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO)T#mO)W#pO!^&{i!h&{i(v&{i)U&{i)V&{i)X&{i)Y&{i!g&{i)k&{i!O&{i!W&{i(w&{i!U&{iQ&{i!d&{i~P#3zO!Y#qO![#rO!a#xO!b#yO!c#yO!e#yO!f#zO)T#mO)W#pO!^&{i!_&{i!h&{i(v&{i)U&{i)V&{i)X&{i)Y&{i!g&{i)k&{i!O&{i!W&{i(w&{i!U&{iQ&{i!d&{i~P#3zO!Y#qO![#rO!a#xO!b#yO!c#yO!e#yO!f#zO)T#mO!^&{i!_&{i!h&{i(v&{i)U&{i)V&{i)W&{i)X&{i)Y&{i!g&{i)k&{i!O&{i!W&{i(w&{i!U&{iQ&{i!d&{i~P#3zO!Y#qO![#rO!b#yO!c#yO!e#yO!f#zO)T#mO!^&{i!_&{i!a&{i!h&{i(v&{i)U&{i)V&{i)W&{i)X&{i)Y&{i!g&{i)k&{i!O&{i!W&{i(w&{i!U&{iQ&{i!d&{i~P#3zO!Y#qO![#rO!f#zO)T#mO!^&{i!_&{i!a&{i!b&{i!c&{i!e&{i!h&{i(v&{i)U&{i)V&{i)W&{i)X&{i)Y&{i!g&{i)k&{i!O&{i!W&{i(w&{i!U&{iQ&{i!d&{i~P#3zO!Y#qO![#rO)T#mO!^&{i!_&{i!a&{i!b&{i!c&{i!e&{i!f&{i!h&{i(v&{i)U&{i)V&{i)W&{i)X&{i)Y&{i!g&{i)k&{i!O&{i!W&{i(w&{i!U&{iQ&{i!d&{i~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO)T#mO)U#oO)V#nO)W#pO!h&{i(v&{i)X&{i)Y&{i!g&{i)k&{i!O&{i!W&{i(w&{i!U&{iQ&{i!d&{i~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h/fO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!O(tX~P#3zO!h/fO!O(tX~O!O/hO~O]%Yap%Ya!X%Ya!Y%Ya![%Ya!^%Ya!_%Ya!a%Ya!b%Ya!c%Ya!e%Ya!f%Ya!h%Ya(v%Ya(x%Ya(y%Ya)U%Ya)V%Ya)W%Ya)X%Ya)Y%Ya!g%Ya)k%Ya!O%Ya!W%Ya!T%Ya#v%Ya(w%Ya!U%YaQ%Ya!d%Ya~O)T/iO!V%Ya~P&,hO!O/iO~O!W/iO~O!V/jO)T%Ya~P&,hO!X'[i!Y'[i!['[i!^'[i!_'[i!a'[i!b'[i!c'[i!e'[i!f'[i!h'[i(v'[i(x'[i(y'[i)T'[i)U'[i)V'[i)W'[i)X'[i)Y'[i!g'[i)k'[i!O'[i!W'[i(w'[i!U'[iQ'[i!d'[i~P%6vO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!h'_i)X'_i!g'_i)k'_i!O'_i!W'_i(w'_i!U'_iQ'_i!d'_i~P#3zO!W/oO~P%:vO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h/qO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!U)sX~P#3zO(s/tO~O!V/vO(x)tO)k/xO~O!h/qO!U)sX~O!U/yO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO)T#mO)U#oO)V#nO)W#pO)Y#|O!h_i(v_i)X_i!g_i)k_i!O_i!W_i(w_i!U_iQ_i!d_i~P#3zO!R/zO~Ol)|O]!Qa!h!Qa)Y!Qa)^!Qa~OP0SO]0ROl0SO!R0SO!T0PO!V0QO!X0SO!Y0SO![0SO!^0SO!_0SO!a0SO!b0SO!c0SO!e0SO!f0SO!g0SO!h0SO!i0SO(pQO(w0SO(x0SO(y0SO)T/|O)U/}O)V/}O)W0OO)X0SO)Y0SO)ZXO~O!O0VO~P&7QO!R$[O~O!h*PO)Y)Ra)^)Ra~O)^0ZO~O])eO!V)fO!X)cO!g)cO%[)cO%])cO%^)cO%_)cO%`)gO%a)gO%b)cO(y)dO)k)cO)y)hO~Od)pO%Z*UO(z$OO~O)X0]O~O]nXdnXlmXpnXrnXsnXtnXunXvnXwnXxnXynX}nX!VnX!rnX!snX!tnX!unX!vnX!xnX!{nX%wnX&snX&tnX(snX)TnX)VnX)WnX!TnX!hnX)YnX!OnXQnX!dnX~O!lnX(wnX)XnX!XnX!YnX![nX!^nX!_nX!anX!bnX!cnX!enX!fnX(vnX(xnX(ynX)UnX!gnX)knX!WnX!UnX#vnX#TnX#VnX#pnXanX{nX!onX#anX#bnX#inX#tnX$|nX%dnX%fnX%lnX%mnX%pnX&nnX)QnX~P&:|Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O}!_O!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO~O])bid)bil)bi!V)bi!{)bi%w)bi(s)bi)T)bi)V)bi)W)biQ)bi!d)bi!h)bi)Y)bi)k)bi!O)bi!T)bi&s)bi(w)bi)X)bi~P&?zO]&cO!V&bO!O#Qi!T#Qi!h#Qi#v#Qi)X#Qi)k#QiQ#Qi!d#Qi(w#Qi~O!OqaQqa!dqa!hqa)Yqa)Xqa~P#9{O!OqaQqa!dqa!hqa)Yqa)Xqa~P#IkO]&cO!V+lO!OqaQqa!dqa!hqa)Yqa)Xqa~O!h*jO!W)la~O!h*nO!W*Pa~OPmO]eOa!]Od!POlTOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!X!XO!Y!WO!i!YO!opO!r!`O!s!aO!t!aO!u!bO!v!aO!x!cO!{!dO#V#QO#a#VO#b#TO#i#OO#p!xO#t!fO#v!eO$S!gO$U!hO$Z!vO$[!wO$a!iO$f!jO$h!kO$i!lO$l!mO$n!nO$p!oO$r!pO$t!qO$v!rO$x!sO$|!tO%O!uO%V!yO%`#ZO%a#[O%b#YO%d!zO%f#UO%h!{O%m#SO%p!|O%w!}O%}#PO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(sRO)QYO)TaO)V|O)W{O)XiO)Y!ZO)ZXO)icO)jdO~O!T*rO!U&TO!V0kO(x)tO~P&D|O!h*uO)X)ra~OPmO]$eOa!]Ol;QO{#RO!T$WO!V$fO!X!XO!Y!WO!i!YO#V#QO#a#VO#b#TO%`#ZO%a#[O%b#YO%f#UO%m#SO%w$mO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s;YO)QYO)T$kO)W$kO)Y0qO)ZXO)icO)jdO!O(tP!O)eP~P&?zO!h*nO!W*PX~O]#}O!T$WO~O!h0vO!T){X#v){X)k){X~O)X0xO~O)X0yO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X0{O)Y#|O~P#3zO)X0yO~P!?WO]1VOd!POl%bO!V1TO!{!dO%w$mO(s$xO)T0}O)Y1QO~O)V1RO)W1RO)k1OOQ#PX!d#PX!h#PX!O#PX~P' kO!h1WOQ)mX!d)mX~OQ1YO!d1YO~O)Y1]O)k1[OQ#`X!d#`X!h#`X~P!<[O)Y1]O)k1[OQ#`X!d#`X!h#`X~P!;bOp&UO~O!O#ka!T#ka#v#ka)X#ka)k#kaQ#ka!d#ka!h#ka)Y#ka!x#ka(w#ka~P#IkO]&cO!V+lO!O#ka!T#ka#v#ka)X#ka)k#kaQ#ka!d#ka!h#ka)Y#ka!x#ka(w#ka~O!W1bO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!W1bO)T1dO~P$%pO!W1bO~P!(zO]#ja!T#ja!V#ja!O#ja#v#ja)X#ja)k#jaQ#ja!d#ja!h#ja)Y#ja!x#ja(w#ja~P$ xO]&cO!O1hO!V+lO~O!h1iO!O)eX~O!O1kO~O]&cO!V+lO!O#na!T#na#v#na)X#na)k#naQ#na!d#na!h#na)Y#na!x#na(w#na~O]1oOr#SXs#SXt#SXu#SXv#SXw#SXx#SXy#SX!T#SX!V#SX#T#SX#p#SX(y#SX)V#SX)W#SX!l#SX!x#SX#V#SX#v#SX(w#SX)k#SX!O#SX!h#SX)X#SXQ#SX!d#SX)Y#SX~O]1pO~O]1sOl$oO!V$fO#V#QO(s$nO)icO)jdO~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!l+{O#T+wO#V+zO#p+xO(y+uO)V+{O)W+{O~O])gX!T)gX!V)gX!x)gX#v)gX(w)gX)k)gX!O)gX!h)gX)X)gXQ)gX!d)gX~P',UO!x!cO]#Ri!T#Ri!V#Ri#v#Ri(w#Ri)k#Ri!O#Ri!h#Ri)X#RiQ#Ri!d#Ri~O!W1{O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!W1{O)T1}O~P$%pO!W1{O~P!(zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|OQ*SX!d*SX!h*SX~P#3zO)Y2OOQ(|X!d(|X!h(|X~O!h2POQ({X!d({X~OQ2RO!d2RO~O!O2SO~O#t$lO)QYO~P8zOl-hO!T'eO)k2WO~O!O2XO~O#x,bOP#ui]#uia#uid#uil#uir#uis#uit#uiu#uiv#uiw#uix#uiy#ui{#ui}#ui!T#ui!V#ui!X#ui!Y#ui!i#ui!o#ui!r#ui!s#ui!t#ui!u#ui!v#ui!x#ui!{#ui#V#ui#a#ui#b#ui#i#ui#p#ui#t#ui#v#ui$S#ui$U#ui$Z#ui$[#ui$a#ui$f#ui$h#ui$i#ui$l#ui$n#ui$p#ui$r#ui$t#ui$v#ui$x#ui$|#ui%O#ui%V#ui%`#ui%a#ui%b#ui%d#ui%f#ui%h#ui%m#ui%p#ui%w#ui%}#ui&n#ui&s#ui&t#ui'R#ui'S#ui'W#ui'Z#ui'b#ui'c#ui(l#ui(p#ui(s#ui)Q#ui)T#ui)V#ui)W#ui)X#ui)Y#ui)Z#ui)i#ui)j#ui!U#ui$d#ui!n#ui%l#ui~O]&cO~O]&cO!TxO!V&bO#v!eO~O(w2^O(x,dO)Q$Va)X$Va~O)QYO)X2`O~O!O2aO~P,]O!O2aO)X#jO~O!O2aO~O$d2fOP$`i]$`ia$`id$`il$`ir$`is$`it$`iu$`iv$`iw$`ix$`iy$`i{$`i}$`i!T$`i!V$`i!X$`i!Y$`i!i$`i!o$`i!r$`i!s$`i!t$`i!u$`i!v$`i!x$`i!{$`i#V$`i#a$`i#b$`i#i$`i#p$`i#t$`i#v$`i$S$`i$U$`i$Z$`i$[$`i$a$`i$f$`i$h$`i$i$`i$l$`i$n$`i$p$`i$r$`i$t$`i$v$`i$x$`i$|$`i%O$`i%V$`i%`$`i%a$`i%b$`i%d$`i%f$`i%h$`i%m$`i%p$`i%w$`i%}$`i&n$`i&s$`i&t$`i'R$`i'S$`i'W$`i'Z$`i'b$`i'c$`i(l$`i(p$`i(s$`i)Q$`i)T$`i)V$`i)W$`i)X$`i)Y$`i)Z$`i)i$`i)j$`i!U$`i~O]1sO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO)T#mO)U#oO)V#nO)W#pO)X2iO)Y#|O~P#3zOPmO]$eOa!]Ol;PO{#RO!V$fO!X!XO!Y!WO!i!YO#V#QO#a#VO#b#TO%`#ZO%a#[O%b#YO%f#UO%m#SO%w$mO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s;RO)T$kO)W$kO)X2lO)Y!ZO)ZXO)icO)jdO~P&?zO)X2iO~O(s-VO~O)QYO)k2oO~O)X2qO~O]-ZOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!{!dO!|%RO(s-VO)T-WO~O)T2vO~O]&cO!V2xO!h2yO)X)vX~O]-ZO!{!dO(s-VO)T-WO~O)X2|O~O!TxO$a!iO$f!jO$h!kO$i!lO$l-cO$n!nO$p!oO$r!pO$t!qO$v!rO$x!sO%O!uO(s:rOd$Yi!o$Yi!{$Yi#i$Yi#p$Yi#t$Yi#v$Yi$S$Yi$U$Yi$Z$Yi$[$Yi$|$Yi%V$Yi%d$Yi%h$Yi%p$Yi%}$Yi(l$Yi)V$Yi!U$Yi$d$Yi~P$0kOl;PO(s:rO~P0zO]3QO~O!U3RO~P!QO)X2VO~O!u3TO(s%nO~O!O3WO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h3XO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!O3YO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO]&cO!V+lO!T%vi#v%vi)X%vi)k%vi~O!W3ZO~Ol:}O)X)OX~P$GXOa!TOl$oO{3aO#a#VO#b3`O#t!fO%f#UO%m3bO&n!RO&s#WO&t!TO(s$nO)QYO~P&?zOl;gO!o-sO#i-xO#t!fO$|,zO%d!zO%l-wO%p!|O%w!}O(s;XO)QYO~P!8jO]&cO!V&bO)X3dO~O)X3eO~O)QYO)X3eO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO)T#mO)U#oO)V#nO)W#pO)X3fO)Y#|O~P#3zO)X3fO~O)X3iO~O!U3kO~P$JiOl$oO(s$nO~O]3mO!T'zO~P'+pO!T(RO!l3pO(w(QO])Pad)Pal)Par)Pas)Pat)Pau)Pav)Paw)Pax)Pay)Pa})Pa!V)Pa!r)Pa!s)Pa!t)Pa!u)Pa!v)Pa!x)Pa!{)Pa%w)Pa&s)Pa&t)Pa(s)Pa)T)Pa)V)Pa)W)Pa)X)Pa!O)Pa!X)Pa!Y)Pa![)Pa!^)Pa!_)Pa!a)Pa!b)Pa!c)Pa!e)Pa!f)Pa!h)Pa(v)Pa(x)Pa(y)Pa)U)Pa)Y)Pa!g)Pa)k)Pa!W)PaQ)Pa!d)Pa!U)Pa#v)Pa~Ol$oO!n.fO!o.fO(s$nO~O!h3tO)Y3vO!T)`X~O!o3xO)QYO~P8zO)X3yO~PGVO]4OOl(|O!T$WO!{!dO%w$mO&s#WO(s({O(w4SO)T3{O)V4PO)W4PO~O)X4TO)k4VO~P(&sOl;hO!U4XO!n.sO!o.rO#i-xO$|!tO%O!uO%h!{O%l-wO%p!|O%w!}O(s;ZO)QYO~P!8jOl;hO%w!}O(s;ZO~P!8jO(w4YO~Ol$oO!T(RO(s$nO(w(QO)QYO~O!l3pO~P()RO)k4[O!U&pX!h&pX~O!h4]O!U*RX~O!U4_O~Oa4aOl$oO&n!RO(s$nO~O!T([O]&lid&lil&lir&lis&lit&liu&liv&liw&lix&liy&li}&li!V&li!r&li!s&li!t&li!u&li!v&li!x&li!{&li%w&li&s&li&t&li(s&li)T&li)V&li)W&li)X&li!O&li!X&li!Y&li![&li!^&li!_&li!a&li!b&li!c&li!e&li!f&li!h&li(v&li(x&li(y&li)U&li)Y&li!g&li)k&li!W&liQ&li!d&li!U&li#v&li~O(w&li~P(*cO(w.xO~P(*cO!O4dO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!O4dO~O!O4eO~O]#}O!T$WO!V'[i!X'[i!Y'[i!['[i!^'[i!_'[i!a'[i!b'[i!c'[i!e'[i!f'[i!h'[i(v'[i(x'[i(y'[i)T'[i)U'[i)V'[i)W'[i)X'[i)Y'[i!g'[i)k'[i!O'[i!W'[i(w'[i!U'[iQ'[i!d'[i~OPmOa%QOl;OO!X!XO!Y!WO!i!YO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)Y!ZO)ZXO)icO)jdO]#]ap#]a!T#]a!V#]a)T#]a)V#]a)W#]a~O(s%nO)Y4jO!O*ZP~O*X4iO~O'g4lO*X4iO~O*X4mO~OlmXpnXp&xX~Od4oO%Z*UO(z/`O~Od4oO%Z*UO(z4pO~O!h/fO!O(ta~O!W4tO~O]&cO!V+lO!T%vq#v%vq)X%vq)k%vq~O]#}O!T$WO!X'[q!Y'[q!['[q!^'[q!_'[q!a'[q!b'[q!c'[q!e'[q!f'[q!h'[q(v'[q(x'[q(y'[q)T'[q)U'[q)V'[q)W'[q)X'[q)Y'[q!g'[q)k'[q!O'[q!W'[q(w'[q!U'[qQ'[q!d'[q~O!V'[q~P(5pO!V/QO&s#WO&t$wO~P(5pO!T$WO!V)sO(x)tO!U(VX!h(VX~P!JwO!h/qO!U)sa~O!W4|O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h*jO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!U5QO~P&7QO!W5QO~P&7QO!O5QO~P&7QO!O5VO~P&7QO]5WO!h'va)Y'va)^'va~O!h*PO)Y)Ri)^)Ri~O]&cO!V&bO!O#Qq!T#Qq!h#Qq#v#Qq)X#Qq)k#QqQ#Qq!d#Qq(w#Qq~O!OqiQqi!dqi!hqi)Yqi)Xqi~P#IkO]&cO!V+lO!OqiQqi!dqi!hqi)Yqi)Xqi~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!h'Uq)X'Uq!g'Uq)k'Uq!O'Uq!W'Uq(w'Uq!U'UqQ'Uq!d'Uq~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!W'}a!h'}a~P#3zO!W5]O~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h5^O(v#gO)T#mO)U#oO)V#nO)W#pO)X#jO)Y#|O!U)sX~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!h#{i)X#{i~P#3zO]*wO!T$WO!V&bO)k*sO!h(Wa)X(Wa~O!h1iO]'eX!O)eX~P%3PO)Y5`O!T%ra!h%ra#v%ra)k%ra~O!h0vO!T){a#v){a)k){a~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X5cO)Y#|O~P#3zO]1VOd!POl;`O!V1TO!{!dO%w$mO(s$xO)T;|O)V5eO)W5eO~OQ#Pa!d#Pa!h#Pa!O#Pa~P(DxO]1VOd!POr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!V1TO!{!dO!|%RO%w$mO(s$xOQ#kX!d#kX!h#kX!O#kX~Ol%bO)T0}O)V;}O)W;}O~P(EzO]&cOQ#Pa!d#Pa!h#Pa!O#Pa~O!V&bO)k5iO~P(GiO(s%nOQ#dX!d#dX!h#dX!O#dX~O)V;}O)W;}OQ#nX!d#nX!h#nX!O#nX~P' kO!V+lO~P(GiO]1VOa!TOd!POl;aO{#RO!V1TO!{!dO#a#VO#b#TO%f#UO%m#SO%w$mO&n!RO&s#WO&t!TO(s;UO)QYO)T;|O)V5eO)W5eO)Y+oO!O)eP~P&?zO!h1WOQ)ma!d)ma~Op&fO)k5nOQ#`al)OX!d#`a!h#`a)Y)OX~P$GXO(s-VOQ#ga!d#ga!h#ga~Op&fO)k5nOQ#`a])_Xd)_Xl)_Xr)_Xs)_Xt)_Xu)_Xv)_Xw)_Xx)_Xy)_X})_X!T)_X!V)_X!d#`a!h#`a!l)_X!r)_X!s)_X!t)_X!u)_X!v)_X!x)_X!{)_X%w)_X&s)_X&t)_X(s)_X(w)_X)T)_X)V)_X)W)_X)Y)_X~O#a5qO#b5qO~O]&cO!V+lO!O#ki!T#ki#v#ki)X#ki)k#kiQ#ki!d#ki!h#ki)Y#ki!x#ki(w#ki~O!W5sO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!W5sO~P!(zO!W5sO)T5uO~P$%pO]#ji!T#ji!V#ji!O#ji#v#ji)X#ji)k#jiQ#ji!d#ji!h#ji)Y#ji!x#ji(w#ji~P$ xO)QYO)Y5wO~P8zO!h1iO!O)ea~O&s#WO&t$wO!T#qa!x#qa#v#qa(w#qa)k#qa!O#qa!h#qa)X#qaQ#qa!d#qa)Y#qa~P#NeO!O5|O~P!(zO!O)pP~P!4xO)U6SO)V6QO]#Ua!T#Ua!V#Ua)T#Ua)W#Uar#Uas#Uat#Uau#Uav#Uaw#Uax#Uay#Ua!l#Ua!x#Ua#T#Ua#V#Ua#p#Ua#v#Ua(w#Ua(y#Ua)k#Uaa#Uad#Ual#Ua{#Ua}#Ua!o#Ua!r#Ua!s#Ua!t#Ua!u#Ua!v#Ua!{#Ua#a#Ua#b#Ua#i#Ua#t#Ua$|#Ua%d#Ua%f#Ua%l#Ua%m#Ua%p#Ua%w#Ua&n#Ua&s#Ua&t#Ua(s#Ua)Q#Ua)X#Ua!O#Ua!h#UaQ#Ua!d#Ua~O!x!cO]#Rq!T#Rq!V#Rq#v#Rq(w#Rq)k#Rq!O#Rq!h#Rq)X#RqQ#Rq!d#Rq~O!W6XO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!W6XO~P!(zO!h2POQ({a!d({a~O)X6^O~Ol-hO!T'eO)k6_O~O]*wO!T$WO!V&bO!h*uO)X)rX~O)k6cO~P)+qO!O6eO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!O6eO~O$d6gOP$`q]$`qa$`qd$`ql$`qr$`qs$`qt$`qu$`qv$`qw$`qx$`qy$`q{$`q}$`q!T$`q!V$`q!X$`q!Y$`q!i$`q!o$`q!r$`q!s$`q!t$`q!u$`q!v$`q!x$`q!{$`q#V$`q#a$`q#b$`q#i$`q#p$`q#t$`q#v$`q$S$`q$U$`q$Z$`q$[$`q$a$`q$f$`q$h$`q$i$`q$l$`q$n$`q$p$`q$r$`q$t$`q$v$`q$x$`q$|$`q%O$`q%V$`q%`$`q%a$`q%b$`q%d$`q%f$`q%h$`q%m$`q%p$`q%w$`q%}$`q&n$`q&s$`q&t$`q'R$`q'S$`q'W$`q'Z$`q'b$`q'c$`q(l$`q(p$`q(s$`q)Q$`q)T$`q)V$`q)W$`q)X$`q)Y$`q)Z$`q)i$`q)j$`q!U$`q~O)X6hO~OPmO]$eOa!]Ol;PO{#RO!V$fO!X!XO!Y!WO!i!YO#V#QO#a#VO#b#TO%`#ZO%a#[O%b#YO%f#UO%m#SO%w$mO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s;RO)T$kO)W$kO)X6jO)Y!ZO)ZXO)icO)jdO~P&?zO(w6lO)k*sO~P)+qO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X6jO)Y#|O~P#3zO!O6nO~P!(zO)X6rO~O)X6sO~O]-ZOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!{!dO(s-VO)T-WO~O]&cO!V2xO!h%Pa)X%Pa!O%Pa~O!W6yO)T6zO~P$%pO!h2yO)X)va~O]&cO!O6}O!V2xO~O!TxO$a!iO$f!jO$h!kO$i!lO$l-cO$n!nO$p!oO$r!pO$t!qO$v!rO$x!sO%O!uO(s:rOd$Yq!o$Yq!{$Yq#i$Yq#p$Yq#t$Yq#v$Yq$S$Yq$U$Yq$Z$Yq$[$Yq$|$Yq%V$Yq%d$Yq%h$Yq%p$Yq%}$Yq(l$Yq)V$Yq!U$Yq$d$Yq~P$0kOPmO]$eOa!]Ol;PO{#RO!V$fO!X!XO!Y!WO!i!YO#V#QO#a#VO#b#TO%`#ZO%a#[O%b#YO%f#UO%m#SO%w$mO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s;RO)QYO)T$kO)W$kO)X7PO)Y!ZO)ZXO)icO)jdO~P&?zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X7SO)Y#|O~P#3zO)X7TO~OP7UO(pQO~Ol*]O)X)_X~P$GXOp&fOl)OX)X)_X~P$GXO)X7WO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O)X&Ta~P#3zO!U7YO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO)X7ZO~OPmO]$eOa!]Ol;QO{#RO!V$fO!X!XO!Y!WO!i!YO#V#QO#a#VO#b#TO%`#ZO%a#[O%b#YO%f#UO%m#SO%w$mO&n!RO&s#WO&t!TO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s;YO)QYO)T$kO)W$kO)Y0qO)ZXO)icO)jdO!O)eP~P&?zO!h3tO)Y7_O!T)`a~O!h3tO!T)`a~O)X7dO)k7fO~P(&sO)X7hO~PGVO]4OOl(|Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!{!dO!|%RO%w$mO&s#WO(s({O)T3{O)V4PO)W4PO~O)T7lO~O]&cO!T*rO!V7nO!h7oO#v!eO(w4SO~O)X7dO)k7qO~P)GVO]4OOl(|O!{!dO%w$mO&s#WO(s({O)T3{O)V4PO)W4PO~Op&fO])dX!T)dX!V)dX!h)dX#v)dX(w)dX)X)dX)k)dX!O)dX~O)X7dO~O!T(RO!l7wO(w(QO])Pid)Pil)Pir)Pis)Pit)Piu)Piv)Piw)Pix)Piy)Pi})Pi!V)Pi!r)Pi!s)Pi!t)Pi!u)Pi!v)Pi!x)Pi!{)Pi%w)Pi&s)Pi&t)Pi(s)Pi)T)Pi)V)Pi)W)Pi)X)Pi!O)Pi!X)Pi!Y)Pi![)Pi!^)Pi!_)Pi!a)Pi!b)Pi!c)Pi!e)Pi!f)Pi!h)Pi(v)Pi(x)Pi(y)Pi)U)Pi)Y)Pi!g)Pi)k)Pi!W)PiQ)Pi!d)Pi!U)Pi#v)Pi~O(s%nO!U(gX!h(gX~O!h4]O!U*Ra~Op&fO]*Qad*Qal*Qar*Qas*Qat*Qau*Qav*Qaw*Qax*Qay*Qa}*Qa!T*Qa!V*Qa!r*Qa!s*Qa!t*Qa!u*Qa!v*Qa!x*Qa!{*Qa%w*Qa&s*Qa&t*Qa(s*Qa)T*Qa)V*Qa)W*Qa)X*Qa!O*Qa!X*Qa!Y*Qa![*Qa!^*Qa!_*Qa!a*Qa!b*Qa!c*Qa!e*Qa!f*Qa!h*Qa(v*Qa(x*Qa(y*Qa)U*Qa)Y*Qa!g*Qa)k*Qa!W*QaQ*Qa!d*Qa(w*Qa!U*Qa#v*Qa~O!T([O]&lqd&lql&lqr&lqs&lqt&lqu&lqv&lqw&lqx&lqy&lq}&lq!V&lq!r&lq!s&lq!t&lq!u&lq!v&lq!x&lq!{&lq%w&lq&s&lq&t&lq(s&lq)T&lq)V&lq)W&lq)X&lq!O&lq!X&lq!Y&lq![&lq!^&lq!_&lq!a&lq!b&lq!c&lq!e&lq!f&lq!h&lq(v&lq(x&lq(y&lq)U&lq)Y&lq!g&lq)k&lq!W&lqQ&lq!d&lq(w&lq!U&lq#v&lq~OPmOa%QOl;OO!T$WO!i!YO#V#QO%`#ZO%a#[O%b#YO%w$mO'R!WO'S!WO'W#XO'Z![O'b![O'c![O(pQO(s$xO)ZXO)icO)jdO~O]*Vi!V*Vi!X*Vi!Y*Vi![*Vi!^*Vi!_*Vi!a*Vi!b*Vi!c*Vi!e*Vi!f*Vi!h*Vi(v*Vi(x*Vi(y*Vi)T*Vi)U*Vi)V*Vi)W*Vi)X*Vi)Y*Vi!g*Vi)k*Vi!O*Vi!W*Vi(w*Vi!U*ViQ*Vi!d*Vi~P*&fO!O7|O~O!W7}O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!h'_q)X'_q!g'_q)k'_q!O'_q!W'_q(w'_q!U'_qQ'_q!d'_q~P#3zO!h8OO!O*ZX~O!O8QO~O*X8RO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!h^y)X^y!g^y)k^y!O^y!W^y(w^y!U^yQ^y!d^y~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!O(ia!h(ia~P#3zO]#}O!T$WO!V'[y!X'[y!Y'[y!['[y!^'[y!_'[y!a'[y!b'[y!c'[y!e'[y!f'[y!h'[y(v'[y(x'[y(y'[y)T'[y)U'[y)V'[y)W'[y)X'[y)Y'[y!g'[y)k'[y!O'[y!W'[y(w'[y!U'[yQ'[y!d'[y~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!h'_y)X'_y!g'_y)k'_y!O'_y!W'_y(w'_y!U'_yQ'_y!d'_y~P#3zO]&cO!V+lO!T%vy#v%vy)X%vy)k%vy~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!U(Va!h(Va~P#3zO!W4|O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!U#}i!h#}i~P#3zO!U8TO~P&7QO!W8TO~P&7QO!O8TO~P&7QO!O8VO~P&7QO]&cO!V&bO!O#Qy!T#Qy!h#Qy#v#Qy)X#Qy)k#QyQ#Qy!d#Qy(w#Qy~O]&cO!V+lO!OqqQqq!dqq!hqq)Yqq)Xqq~O]&cOQ#Pi!d#Pi!h#Pi!O#Pi~O!V+lO~P*9xOQ#nX!d#nX!h#nX!O#nX~P(DxO!V&bO~P*9xOQ(PX](PXd'rXl'rXr(PXs(PXt(PXu(PXv(PXw(PXx(PXy(PX!V(PX!d(PX!h(PX!{'rX%w'rX(s'rX)T(PX)V(PX)W(PX!O(PX~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|OQ#_i!d#_i!h#_i!O#_i~P#3zO&s#WO&t$wOQ#fi!d#fi!h#fi~O(s-VO)Y1]O)k1[OQ#`X!d#`X!h#`X~O!W8[O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!W8[O~P!(zO!T#qi!x#qi#v#qi(w#qi)k#qi!O#qi!h#qi)X#qiQ#qi!d#qi)Y#qi~O]&cO!V+lO~P*?tO]&YO!V&WO&s#WO&t$wO)T&VO)V&ZO)W&ZO~P*?tO!O8^O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!h8_O!O)pX~O!O8aO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|OQ*UX!d*UX!h*UX~P#3zO)Y8dOQ*TX!d*TX!h*TX~O)X8fO~O!O$ci!h#{a)X#{a~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X8iO)Y#|O~P#3zO!O8kO~P!(zO!O8kO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!O8kO~O]&cO!V&bO(w8qO~O)X8rO~O]&cO!V2xO!h%Pi)X%Pi!O%Pi~O!W8uO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!W8uO)T8wO~P$%pO!W8uO~P!(zO]&cO!V2xO!h(Za)X(Za~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO)T#mO)U#oO)V#nO)W#pO)X8xO)Y#|O~P#3zO)X2lO~P!(zO)X8xO~OP%oO!O8yO(pQO~O!O8yO~O)X8zO~P%%lO#T8}O(y.SO)X8{O~O!h3tO!T)`i~O)Y9RO!T'xa!h'xa~O)X9TO)k9VO~P)GVO)X9TO~O)X9TO)k9ZO~P(&sOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O~P)GuO]&cO!V7nO!T!ya!h!ya#v!ya(w!ya)X!ya)k!ya!O!ya~O!W9bO)T9cO~P$%pO!T$WO!h7oO(w4SO)X9TO)k9ZO~O!T$WO~P#EfO]&cO!O9fO!V7nO~O]&cO!V7nO!T&ba!h&ba#v&ba(w&ba)X&ba)k&ba!O&ba~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O)X&ca~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X9TO)Y#|O~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!U&pi!h&pi~P#3zO!V/QO]'^i!T'^i!X'^i!Y'^i!['^i!^'^i!_'^i!a'^i!b'^i!c'^i!e'^i!f'^i!h'^i(v'^i(x'^i(y'^i)T'^i)U'^i)V'^i)W'^i)X'^i)Y'^i!g'^i)k'^i!O'^i!W'^i(w'^i!U'^iQ'^i!d'^i~O(s%nO)Y9iO~O!h8OO!O*Za~O!O9kO~P&7QO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!U(Va)X#Zi~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|OQ#_q!d#_q!h#_q!O#_q~P#3zO&s#WO&t$wOQ#fq!d#fq!h#fq~O)k5nOQ#`a!d#`a!h#`a~O]&cO!V+lO!T#qq!x#qq#v#qq(w#qq)k#qq!O#qq!h#qq)X#qqQ#qq!d#qq)Y#qq~O!h8_O!O)pa~O)V6QO]&Wi!T&Wi!V&Wi)T&Wi)U&Wi)W&Wir&Wis&Wit&Wiu&Wiv&Wiw&Wix&Wiy&Wi!l&Wi!x&Wi#T&Wi#V&Wi#p&Wi#v&Wi(w&Wi(y&Wi)k&Wia&Wid&Wil&Wi{&Wi}&Wi!o&Wi!r&Wi!s&Wi!t&Wi!u&Wi!v&Wi!{&Wi#a&Wi#b&Wi#i&Wi#t&Wi$|&Wi%d&Wi%f&Wi%l&Wi%m&Wi%p&Wi%w&Wi&n&Wi&s&Wi&t&Wi(s&Wi)Q&Wi)X&Wi!O&Wi!h&WiQ&Wi!d&Wi~O)X9nO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O!O$cq!h#{i)X#{i~P#3zO!O9pO~P!(zO!O9pO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!O9pO~O]&cO!V&bO(w9sO~O!O9tO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!O9tO~O]&cO!V2xO!h%Pq)X%Pq!O%Pq~O!W9xO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!W9xO~P!(zO)X6jO~P!(zO)X9yO~O)X9zO~O(y.SO)X9zO~O!h3tO!T)`q~O)Y9|O!T'xi!h'xi~O!T$WO!h7oO(w4SO)X9}O)k:PO~O)X9}O~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X9}O)Y#|O~P#3zO)X9}O)k:SO~P)GVO]&cO!V7nO!T!yi!h!yi#v!yi(w!yi)X!yi)k!yi!O!yi~O!W:WO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!W:WO)T:YO~P$%pO!W:WO~P!(zO]&cO!V7nO!T(ea!h(ea(w(ea)X(ea)k(ea~O!O:[O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!O:[O~O!O:aO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!O:aO~O]&cO!V2xO!h%Py)X%Py!O%Py~O)X:bO~O)X:cO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X:cO)Y#|O~P#3zO!T$WO!h7oO(w4SO)X:cO)k:fO~O]&cO!V7nO!T!yq!h!yq#v!yq(w!yq)X!yq)k!yq!O!yq~O!W:hO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!W:hO~P!(zO!O:jO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)Y#|O~P#3zO!O:jO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X:lO)Y#|O~P#3zO)X:lO~O]&cO!V7nO!T!yy!h!yy#v!yy(w!yy)X!yy)k!yy!O!yy~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(v#gO)T#mO)U#oO)V#nO)W#pO)X:pO)Y#|O~P#3zO)X:pO~O]ZXlgXpZXpiX!TiX!VZX!XZX!YZX![ZX!^ZX!_ZX!aZX!bZX!cZX!eZX!fZX!gZX!hZX(vZX(w$^X(xZX(yZX)TZX)UZX)VZX)WZX)XZX)YZX)kZX~O]%XXlmXpnXp%XX!TnX!V%XX!X%XX!Y%XX![%XX!^%XX!_%XX!a%XX!b%XX!c%XX!e%XX!f%XX!gmX!h%XX(v%XX(x%XX(y%XX)T%XX)U%XX)V%XX)W%XX)Y%XX)kmX!O%XXQ%XX!d%XX~O)X%XX!W%XX(w%XX!U%XX~P+HQO]nX]%XXdnXlmXpnXp%XXrnXsnXtnXunXvnXwnXxnXynX}nX!VnX!V%XX!rnX!snX!tnX!unX!vnX!xnX!{nX%wnX&snX&tnX(snX)TnX)VnX)WnX!OnX!O%XX!hnX)YnX~O)XnX)knX~P+JbO]%XXlmXpnXp%XX!V%XX!h%XXQ%XX!d%XX!O%XX~O!T%XX#v%XX)X%XX)k%XX(w%XX~P+L{OQnXQ%XX!TnX!X%XX!Y%XX![%XX!^%XX!_%XX!a%XX!b%XX!c%XX!dnX!d%XX!e%XX!f%XX!gmX!h%XX(v%XX(x%XX(y%XX)T%XX)U%XX)V%XX)W%XX)Y%XX)kmX~P+JbO]nX]%XXlmXpnXp%XXrnXsnXtnXunXvnXwnXxnXynX}nX!V%XX!rnX!snX!tnX!unX!vnX!xnX!{nX%wnX&snX&tnX(snX)TnX)VnX)WnX~O!TnX(wnX)XnX)knX~P, sOdnX!VnX)X%XX~P, sOlmXpnX)X%XX~Od)pO%Z)qO(z:sO~Od)pO%Z)qO(z:xO~Od)pO%Z)qO(z:tO~Od$RO%Z*UO']$TO'`$UO(z:sO~Od$RO%Z*UO']$TO'`$UO(z:uO~Od$RO%Z*UO']$TO'`$UO(z:wO~O]iXriXsiXtiXuiXviXwiXxiXyiX!OiX!ViX&siX&tiX)TiX)ViX)WiXdiX}iX!riX!siX!tiX!uiX!viX!xiX!{iX%wiX(siX~P#1jO]ZXlgXpZXpiX!VZX!hZX)XZX)kZX~O!TZX#vZX(wZX~P,(ZOlgXpiX)QiX)XZX)kiX~O]ZX]iXdiXlgXpZXpiXriXsiXtiXuiXviXwiXxiXyiX}iX!VZX!ViX!riX!siX!tiX!uiX!viX!xiX!{iX%wiX&siX&tiX(siX)TiX)ViX)WiX!OZX!OiX!hiX)YiX)kiX~O)XZX~P,)eO]ZX]iXlgXpZXpiXriXsiXtiXuiXviXwiXxiXyiX!TiX!VZX!ViX!XZX!YZX![ZX!^ZX!_ZX!aZX!bZX!cZX!eZX!fZX!gZX!hZX!hiX&siX&tiX(vZX(xZX(yZX)TZX)TiX)UZX)VZX)ViX)WZX)WiX)YZX)YiX)kZX~OQZXQiX!dZX!diX~P,,OO]iXdiXriXsiXtiXuiXviXwiXxiXyiX}iX!ViX!riX!siX!tiX!uiX!viX!xiX!{iX%wiX&siX&tiX(siX)TiX)ViX)WiX~P#1jO]ZX]iXdiXlgXpZXpiXriXsiXtiXuiXviXwiXxiXyiX}iX!VZX!ViX!riX!siX!tiX!uiX!viX!xiX!{iX%wiX&siX&tiX(siX)TiX)ViX)WiX~O)XiX~P,1QOdiX}iX!OZX!OiX!riX!siX!tiX!uiX!viX!xiX!{iX%wiX(siX)kiX~P,,OO]ZX]iXlgXpZXpiXriXsiXtiXuiXviXwiXxiXyiX}iX!TiX!VZX!riX!siX!tiX!uiX!viX!xiX!{iX%wiX&siX&tiX(siX(wiX)TiX)ViX)WiX)XiX)kiX~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O~PBUOd$RO%Z*UO(z:sO~Od$RO%Z*UO(z:tO~Od$RO%Z*UO(z:zO~Od$RO%Z*UO(z:yO~O]%hOd!POl%bOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!V%kO!{!dO!|%RO%w$mO(s$xO)T;eO)V;fO)W;fO~O]%hOd!POl%bO!V%kO!{!dO%w$mO(s$xO)T;eO)V;fO)W;fO~Od$RO%Z$SO(z:tO~Od$RO%Z$SO(z:xO~Ol:}O~Ol:|O~O]cXlgXpiX!TcX~Od)pO%Z*UO(z:sO~Od)pO%Z*UO(z:tO~Od)pO%Z*UO(z:uO~Od)pO%Z*UO(z:vO~Od)pO%Z*UO(z:wO~Od)pO%Z*UO(z:yO~Od)pO%Z*UO(z:zO~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O~P,9^O])OXr)OXs)OXt)OXu)OXv)OXw)OXx)OXy)OX})OX!r)OX!s)OX!t)OX!u)OX!v)OX!x)OX!{)OX%w)OX&s)OX&t)OX(s)OX)T)OX)V)OX)W)OX)k)OX~Ol:|O!T)OX(w)OX)X)OX~P,=]O]&xXlmXpnX!T&xX~Od4oO%Z*UO(z;xO~Ol;`O)T;|O)V5eO)W5eO~P(EzOd!POl%bO!{!dO%w$mO(s$xO~O]1VO!V1TO)T0}O)V;}O)W;}OQ#nX!d#nX!h#nX!O#nX~P,@XO)T;^O~Ol;lO~Ol;mO~Ol;nO~Ol;pO~Ol;qO~Ol;rO~Ol;pO!T$WOQ)OX!d)OX!h)OX)Y)OX!O)OX)k)OX~P$GXOl;nO!T$WO~P$GXOl;lO!g$YO)k$YO~Ol;nO!g$YO)k$YO~Ol;pO!g$YO)k$YO~Ol;mO!O)OX!h)OX)Y)OX)k)OX~P$GXOd/aO%Z*UO(z;xO~Ol;yO~O)T<^O~OV'f'i'j'h(p)Z!R(sST%[!Y!['kd%]!i'S!f]'g*['l(x!^!_'m'n'm~",
  goto: "%8]*[PPPPPP*]P*`PP.W4nP7o7o:{P:{>XP>r?U?jFdMf!&l!-UP!4Q!4u!5jP!6UPPPPPPPP!6oP!8ZPP!9n!;YP!;`PPPPPP!;cP!;cPP!;cPPPPPPPPP!;o!?XP!?[PP!?x!@mPPPPP!@qP>u!BUPP>u!D_!F`!Fn!HV!IxP!JTP!Jd!Jd!Mv##X#$q#(P#+]!F`#+gPP!F`#+n#+t#+g#+g#+wP#+{#,j#,j#,j#,j!IxP#-T#-f#/lP#0SP#1qP#1u#2P#2v#3R#5a#5i#5i#5p#1uP#1uP#6U#6[P#6fPP#7T#7t#8h#7TP#9[#9hP#7TP#7TPP#7T#7TP#7TP#7TP#7TP#7TP#7TP#7TP#9k#6f#:ZP#:rP#;Z#;Z#;Z#;Z#;h#1uP#<Q#AO#AmPPPPPPPP#BeP#BuP#BuP#CT#Fd#:hPP#Bo#FxP#G_#Gj#Gp#Gp#Bo#HfP#1u#1u#1u#1u#1uP!Jd#IS#IZ#IZ#IZ#I_!Mp#Ii!Mp#Im!Fn!Fn!Fn#Ip#N[!Fn>u>u>u$%V!@m!@m!@m!@m!@m!@m!6o!6o!6o$%jP$'X$'g!6o$'mPP!6o$)}$*Q#B[$*T:{7o$-]$/W$0w$2g7oPP7o$4Z7oP7o7oP7oP$7c7oP7oPP7o$7oPPPPPPPPP*]P$:y$;P$=h$?p$?v$@^$@h$@s$AS$AY$Bj$Ci$Cp$Cw$C}$DV$Da$Dg$Dv$D|$EV$E_$Ej$Ep$Ez$FQ$F[$Fc$Ft$Fz$GQP$GW$G`$Gg$Gu$Ie$Ik$Iq$Ix$JRPPPPPPPP$JX$J]PPPPP%#a$)}%#d%&n%(xP%)V%)YPPPPPPPPPP%)f%*i%*o%*s%,l%-{%.n%.u%1W%1^PPP%1h%1s%1v%1|%3T%3W%3d%3n%3r%4x%5m%5s#BeP%6^%6p%6s%7V%7e%7i%7o%7u$)}$*Q$*Q%7x%7{P%8V%8YR#cP'dmO[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-f-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jU%om%p7UQ&m!`Q(k#]d0S*O0P0Q0R0U5R5S5T5W8UR7U3Xf}Oaewx{!g&S'e*r-f&v$i[!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&W&b&f&x&y&|'O'P'b'j'k'z(a(c(j)m)s*i*j*m*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-j.S.T.X/Q/T/_/f/o/q/v/x1O1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jS%`f0k#d%jgnp|#O$g$|$}%S%d%h%i%w&s'u'v(R*Z*a*c*u+^,m,w-`-s-z.i.p.r0`0|0}1R1V2b2m5e6k;[;];^;d;e;f;s;t;u;v;z;{;|;}<[<]<^S%qm!YS&u!h#PQ']!tQ'h!yQ'i!zQ(k#`Q(l#]Q(m#^Q*y%kQ,X&lQ,^&nQ-T'^Q-g'gQ-n'rS.u([4]Q/i)hQ0h*nQ2T,]Q2[,dQ3S-hQ4f/PQ4j/WQ5j1QQ6`2WQ7R3TQ8e6_Q9i8OR;_1T$|#hS!]$y%Q%T%Z&j&k'Q'X'Z'a'c(b(f(i(x(y)S)T)U)V)W)X)Y)Z)[)])^)_)`)l)r)y+Y+h,P,T,k,v-k-l.P.|/s0c0e0j0l0z1c1|2d2k3V3g3h4g4h4n4q4w4y4}5O5h5t5{6Y6i6m6w7O7u7v7x8W8X8g8j8n8v9X9`9o9u:Q:X:^:d:mQ&p!dQ(h#ZQ(t#bQ)k$T[*t%e*X0n2c2j3OQ,_&oQ/R(gQ/V(lQ/^(uS/l)j/SQ0u+RS4u/m/nR8S4v'e![O[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-f-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:j'e!VO[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-f-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jQ)P#kS+R%y0vQ/u)tk4R.j3w3{4O4P7g7i7j7l7o9]9^:VQ)R#kk4Q.j3w3{4O4P7g7i7j7l7o9]9^:Vl)Q#k.j3w3{4O4P7g7i7j7l7o9]9^:VT+R%y0v`UOwx!g&S'e*r-fW$`[e$e(c#l$p_!f!u!}#R#S#T#U#V#Z$S$T$l%U&U&Y&c&m'_(O(Q(V(_(h)k)q+]+b+c+u+z,Y,l,{-R-r-w.Z.[.b.c.g.t.x1W1[1i1n1p2o3`3a3b3t3x5n6R6T7`8_![%cg$g%d%i&s*Z*u+^,m,w-`0}1R2b;[;];^;e;f;s;t;u;v;z;{;}<[<]<^Y%snp%w-s.il(}#k.j3w3{4O4P7g7i7j7l7o9]9^:VS;i'u-zU;j(R.p.r&|<Paf{|!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$f$k$|$}%S%]%h%m&Q&W&b&y&|'O'j'k'v'z(a(j)m)s*a*c*i*j*m*s+X+Z+i+k+l,Q,S,o,r-j.S.T.X/Q/T/_/f/o/q/v/x0`0k0|1O1T1d1e1o1s1}2f2l2m2x4S4V4[4e5^5e5i5u6c6g6j6k6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:j;d;|Q<Q1Vd<R&x'P'b,x-^-_-b2i2}3QW<S&f*w2P3mQ<T#O[<U!t'^'g,]2W6_T<a%y0v`VOwx!g&S'e*r-fW$a[e$e(cQ$p.x!j$q_!f!u!}#V#Z$S$T$l%U&U&Y&c&m'_(h)k)q+]+b+u,Y,l,{-R-r.g1W1[1i1n1p2o3x5n8_&^$zaf{!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$f$k%]%m&Q&W&b&y&|'O'j'k'z(a(j)m)s*i*j*m*s+X+Z+i+k+l,Q,S,o,r-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2f2l2x4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:j![%cg$g%d%i&s*Z*u+^,m,w-`0}1R2b;[;];^;e;f;s;t;u;v;z;{;}<[<]<^Y%snp%w-s.iQ's#O|'}#R#S#T#U(O(Q(V(_+c+z.Z.[.b.c.t3`3a3b3t6R6T7`l(}#k.j3w3{4O4P7g7i7j7l7o9]9^:VS-q'u-zQ3[-wU;w(R.p.rn<P|$|$}%S%h'v*a*c0`0|2m5e6k;d;|[<U!t'^'g,]2W6_W<V&f*w2P3md<W&x'P'b,x-^-_-b2i2}3QQ<_1VT<a%y0v!U!UO[ewx!g$e&S&f&x'P'b'e(c*r*w,x-^-_-b-f2P2i2}3Q3m!v$t_!f!u!}#O#V#Z$S$T$l%U&U&Y&c&m'_'u(R(h)k)q+]+u,Y,l,{-R-r-z.g.p.r1V1W1[1i1n1p2o3x5n8_&^%Paf{!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$f$k%]%m&Q&W&b&y&|'O'j'k'z(a(j)m)s*i*j*m*s+X+Z+i+k+l,Q,S,o,r-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2f2l2x4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:j$Q%lgnp|#k$g$|$}%S%d%h%i%w%y&s'^'g'v*Z*a*c*u+^,],m,w-`-s.i.j0`0v0|0}1R2W2b2m3w3{4O4P5e6_6k7g7i7j7l7o9]9^:V;[;];^;d;e;f;s;t;u;v;z;{;|;}<[<]<^Q'[!tz(P#R#S#T#U(O(Q(V(_+z.Z.[.b.c.t3`3a3b3t6R6T7`f-['`-U-W-Z2s2t2v2y6u6v8tQ1Z+bQ1^+cQ2n,zQ3]-wQ4`.xQ5p1]R8Z5q!U!UO[ewx!g$e&S&f&x'P'b'e(c*r*w,x-^-_-b-f2P2i2}3Q3m!x$t_!f!u!}#O#V#Z$S$T$l%U&U&Y&c&m'_'u(R(h)k)q+]+b+u,Y,l,{-R-r-z.g.p.r1V1W1[1i1n1p2o3x5n8_&^%Paf{!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$f$k%]%m&Q&W&b&y&|'O'j'k'z(a(j)m)s*i*j*m*s+X+Z+i+k+l,Q,S,o,r-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2f2l2x4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:j$S%lgnp|!t#k$g$|$}%S%d%h%i%w%y&s'^'g'v*Z*a*c*u+^,],m,w-`-s.i.j0`0v0|0}1R2W2b2m3w3{4O4P5e6_6k7g7i7j7l7o9]9^:V;[;];^;d;e;f;s;t;u;v;z;{;|;}<[<]<^|(P#R#S#T#U(O(Q(V(_+c+z.Z.[.b.c.t3`3a3b3t6R6T7`Q3]-wR4`.x`WOwx!g&S'e*r-fW$b[e$e(c#l$p_!f!u!}#R#S#T#U#V#Z$S$T$l%U&U&Y&c&m'_(O(Q(V(_(h)k)q+]+b+c+u+z,Y,l,{-R-r-w.Z.[.b.c.g.t.x1W1[1i1n1p2o3`3a3b3t3x5n6R6T7`8_![%cg$g%d%i&s*Z*u+^,m,w-`0}1R2b;[;];^;e;f;s;t;u;v;z;{;}<[<]<^Y%snp%w-s.il(}#k.j3w3{4O4P7g7i7j7l7o9]9^:VS;i'u-zU;j(R.p.rn<P|$|$}%S%h'v*a*c0`0|2m5e6k;d;|Q<Q1VQ<T#O[<U!t'^'g,]2W6_&^<Xaf{!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$f$k%]%m&Q&W&b&y&|'O'j'k'z(a(j)m)s*i*j*m*s+X+Z+i+k+l,Q,S,o,r-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2f2l2x4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jd<Y&x'P'b,x-^-_-b2i2}3QW<Z&f*w2P3mT<a%y0vp$PT$_$o%b%r(|;O;P;Q;`;a;b;c;g;h<`o)n$V*V*]/b:{:|:};l;m;n;o;p;q;r;yp$QT$_$o%b%r(|;O;P;Q;`;a;b;c;g;h<`o)o$V*V*]/b:{:|:};l;m;n;o;p;q;r;y^&e}!O$i$j%`%j;_d&i!U$t%P%l'[(P1Z1^3]4`V/d)P)Q4RS%Ye$eQ,U&fQ/O(cQ2p-RQ5}1pQ6Z2PQ6q2oR9l8_$R!TO[_ewx!f!g!u!}#O#V#Z$S$T$e$l%U&S&U&Y&c&f&m&x'P'_'b'e'u(R(c(h)k)q*r*w+]+b+u,Y,l,x,{-R-^-_-b-f-r-w-z.g.p.r1V1W1[1i1n1p2P2i2o2}3Q3m3x5n8_#`^O[_`wx!f!g!}#O$S$d$l$s$u&S&U&Y&c&m&r&x'P'b'e'u(R)q*^*r*w+],Y,l,x,{-^-_-b-f-r-w-z.g.p.r1V1W1i2i2}3Q3m3x_(V#R#S#T+c3`3a3b$RZO[wx!g!k#R#S#T%m&S&U&Y&c&m&w&x&y&|'O'P'['b'e'u'y(O(Q(R(V*r*w+]+c,Y,i,l,r-Q-^-_-b-f-r-w-z-}.b.g.p.t1V1W1i2f2n2}3Q3`3a3b3m6g6n8k9p9t:[:a:jQ$]YR0W*PR*R$]e0S*O0P0Q0R0U5R5S5T5W8U'd!YO[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-f-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:je0S*O0P0Q0R0U5R5S5T5W8UR5X0W^(U#R#S#T+c3`3a3bY.`(O(S(V(W7XU3o.^.a.tS7]3p4ZR9g7w^(T#R#S#T+c3`3a3b[._(O(S(U(V(W7XW3n.^.`.a.tU7[3o3p4ZS9O7]7wR:Z9gT.n(R.ph]Owx!g&S'e'u(R*r-f-z.p!v^[_`!f!}#O$S$d$l$s$u&U&Y&c&m&r&x'P'b)q*^*w+],Y,l,x,{-^-_-b-r-w.g.r1V1W1i2i2}3Q3m3xQ%tnT1x,O1y!nbOaenpwx{|!g#O$|$}%S%h%w&S'e'u'v(R*a*c*r-f-s-z.i.p.r0`0|1V2m5e6k;d;|f-X'`-U-W-Z2s2t2v2y6u6v8tj3|.j3w3{4O4P7g7i7j7l7o9]9^:Vr<Og$g%d%i&s*Z*u,m,w-`2b;[;];^;s;u;zi<b+^0}1R;e;f;t;v;{;}<[<]<^!O&^y%X&V&Y&Z'l)i*e*g+^+f+y/p0a0|0}1R1V1m5e5z;|;}z&az%O%W%e&d't*X*`,c-{0^0_0n1P2c2j3O5Z5f6p8mS'|#Q.[n+m&X*h+g+n+q-m/k0b1U1a4x5[5d5y8]Q2Z,b^2w-Y2u2{6t6{8s9we7m3}7c7k7s7t9Y9[9d:U:gS+_&U1WY+o&Y&c*w1V3mR5w1i#{!POaegnpwx{|!g#O$g$|$}%S%d%h%i%w&S&s'e'u'v(R*Z*a*c*r*u+^,m,w-`-f-s-z.i.p.r0`0|0}1R1V2b2m5e6k;[;];^;d;e;f;s;t;u;v;z;{;|;}<[<]<^doOwx!g&S'e'u*r-f-z#U!Paeg{|#O$g$|$}%S%d%h%i&s'v*Z*a*c*u+^,m,w-`0`0|0}1R1V2b2m5e6k;[;];^;d;e;f;s;t;u;v;z;{;|;}<[<]<^U%vnp-sQ+O%wS.h(R.pT3z.i.rW+s&^+m+t1fV+{&a+|7mQ+y&`U+{&a+|7mQ-z'uT.V'z.X'd![O[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-f-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jX1u+z.[6R6T'[!VO[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-f-j.S.T.X/Q/_/f/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jW1u+z.[6R6TR2h,t![jO[wx!g!k%m&S&y&|'O'b'e*r,r-^-_-b-f2f2}6g6n8k9p9t:[:a:jY%Ve$e(c1s3mQ'S!nS(z#i5^Q,n&xQ,y'PS.R'z.XQ2e,oQ6o2lQ7Q3QQ8l6jR9q8i'[![O[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-f-j.S.T.X/Q/_/f/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jX1u+z.[6R6T'eyO[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l+z,Q,S,o,r,x-^-_-b-f-j.S.T.X.[/Q/_/f/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[5^5i5u6R6T6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jQ&`yS'u#O-xR1_+dS+_&U1WR5r1_Q1S+^R5k1RR1S+^T+_&U1Wz&[%X&V&Y&Z'l)i*e*g+^+f/p0a0|0}1R1V1m5e5z;|;}Q&]yR1q+y!P&[y%X&V&Y&Z'l)i*e*g+^+f+y/p0a0|0}1R1V1m5e5z;|;}Q+v&^S+}&a7mS1g+m+tQ1w+|R5v1f![kO[wx!g!k%m&S&y&|'O'b'e*r,r-^-_-b-f2f2}6g6n8k9p9t:[:a:jS%zo.hS&Oq-uQ&_yQ&q!eQ*q%eU*|%v%{3zS+Q%x%}Q+r&]Q,s&{S0[*X,cS0r*}+OQ0t+PQ1r+yQ5Y0^Q5_0sQ6P1qQ6a2ZQ7r3}Q9W7cR:T9Y`uOwx!g&S'e*r-fQ,Z&mQ-y'uQ3^-wR3c-z|lOwx!g!k%m&S&y'O'e*r,r-f2f6g6n8k9p9t:[:a:jU$h[&|-_S%zo.hS&Oq-uQ*q%eU*|%v%{3zS+Q%x%}S0[*X,cS0r*}+OQ0t+PQ5Y0^Q5_0sQ7r3}Q9W7cR:T9YT,`&q,aauOwx!g&S'e*r-f`uOwx!g&S'e*r-fQ,Z&mQ,o&xQ,x'PW-a'b-^-b2}Q-y'uQ3^-wQ3c-zR7P3Q[%fg$g,m,w-`2bR0o*u^$XV!U$a$z%P<V<WQ'S!nS)a#}*wS)w$W*rQ)z$YY*t%e*X0n2j3OQ/R(gS/l)j/SS0d*i4eS0m*s6cQ0u+RQ4U.jQ4r/fS4u/m/nS4z/q5^Q5P/xQ6d2cU7e3w3}4VQ8S4vQ8o6lY9U7c7f7g7p7qQ9v8qW:O9S9V9Y9ZQ:_9sU:e:P:R:SR:n:fS)w$W*rT4z/q5^Z)u$W)v*r/q5^Q&t!gQ'f!yQ,Z&mS,[&n'hS2V,^-iR6^2UQ&w!hR'y#PS,h&v'wQ2_,fR6b2^|lOwx!g!k%m&S&y'O'e*r,r-f2f6g6n8k9p9t:[:a:jV$h[&|-_!]kO[wx!g!k%m&S&y&|'O'b'e*r,r-^-_-b-f2f2}6g6n8k9p9t:[:a:j![hO[wx!g!k%m&S&y&|'O'b'e*r,r-^-_-b-f2f2}6g6n8k9p9t:[:a:jR'W!q![kO[wx!g!k%m&S&y&|'O'b'e*r,r-^-_-b-f2f2}6g6n8k9p9t:[:a:jR,o&xQ&y!iQ&{!jQ'O!lR,r&zR,p&x|lOwx!g!k%m&S&y'O'e*r,r-f2f6g6n8k9p9t:[:a:jX-a'b-^-b2}`uOwx!g&S'e*r-fQ,{'PQ-y'uS.n(R.pR3c-z`uOwx!g&S'e*r-fQ,{'PW-a'b-^-b2}T.n(R.pg-['`-U-W-Z2s2t2v2y6u6v8t}lOwx!g!k%m&S&y'O'e*r,r-f2f6g6n8k9p9t:[:a:jf!OOaewx{!g&S'e*r-f&|$j[f!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&W&b&f&x&y&|'O'P'b'j'k'z(a(c(j)m)s*i*j*m*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:j#d%jgnp|#O$g$|$}%S%d%h%i%w&s'u'v(R*Z*a*c*u+^,m,w-`-s-z.i.p.r0`0|0}1R1V2b2m5e6k;[;];^;d;e;f;s;t;u;v;z;{;|;}<[<]<^Q']!tQ-T'^Q-g'gQ2T,]Q6`2WR8e6_j$RT$_%b%r;O;P;Q;`;a;b;c;g;hi)p$V*V:{:|:};l;m;n;o;p;q;rj$RT$_%b%r;O;P;Q;`;a;b;c;g;hh)p$V*V:{:|:};l;m;n;o;p;q;rS/a(|<`V4o/b/c;y`uOwx!g&S'e*r-fQ-y'uR3c-z`uOwx!g&S'e*r-fT.n(R.p'd!YO[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-f-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jR7V3X`uOwx!g&S'e*r-fQ-y'uS.n(R.pR3c-z`pOwx!g&S'e*r-fQ%wnS-s'u-zT.i(R.pS%{o.hS*}%v3zR0s+OQ+S%yR5a0vS%zo.hS&Oq-uU*|%v%{3zS+Q%x%}S0r*}+OQ0t+PQ5_0sQ7r3}Q9W7cR:T9YdqOwx!g&S'e(R*r-f.pS%xn-sU%}p.i.rQ+P%wT-u'u-zS'{#Q.[R.]'|T.U'z.XS.V'z.XQ8|7YR9{8}T6R1t8cR6T1t#d!Pgnp|#O$g$|$}%S%d%h%i%w&s'u'v(R*Z*a*c*u+^,m,w-`-s-z.i.p.r0`0|0}1R1V2b2m5e6k;[;];^;d;e;f;s;t;u;v;z;{;|;}<[<]<^f!QOaewx{!g&S'e*r-f&}![[f!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&W&b&f&x&y&|'O'P'b'j'k'z(a(c(j)m)s*i*j*m*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:j#d!Pgnp|#O$g$|$}%S%d%h%i%w&s'u'v(R*Z*a*c*u+^,m,w-`-s-z.i.p.r0`0|0}1R1V2b2m5e6k;[;];^;d;e;f;s;t;u;v;z;{;|;}<[<]<^f!QOaewx{!g&S'e*r-f&|![[f!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&W&b&f&x&y&|'O'P'b'j'k'z(a(c(j)m)s*i*j*m*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[4e5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jk4Q.j3w3{4O4P7g7i7j7l7o9]9^:VQ4U.jS7e3w3}U9U7c7g7pS:O9S9YR:e:R$Q!TO[_ewx!f!g!u!}#O#V#Z$S$T$e$l%U&S&U&Y&c&f&m&x'P'_'b'e'u(R(c(h)k)q*r*w+]+b+u,Y,l,x,{-R-^-_-b-f-r-w-z.g.p.r1V1W1[1i1n1p2P2i2o2}3Q3m3x5n8_R4a.xQ(^#US.y(](_S4b.z.{R7{4cQ.v([R7y4]$Q!TO[_ewx!f!g!u!}#O#V#Z$S$T$e$l%U&S&U&Y&c&f&m&x'P'_'b'e'u(R(c(h)k)q*r*w+]+b+u,Y,l,x,{-R-^-_-b-f-r-w-z.g.p.r1V1W1[1i1n1p2P2i2o2}3Q3m3x5n8_p$w`$d$s%X&r'`(`(g)j*e-U/n1m5o5z8Yq)O#k%y.j0v3w3{4O4P7g7i7j7l7o9]9^:VR,V&fR6[2P']!VO[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-f-j.S.T.X/Q/_/f/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:j$q#rS%T%Z'Q'X'Z'a'c(b(f(i(x(y)S)T)V)W)X)Y)Z)[)])^)_)`)l)r)y+Y+h,P,T,k,v-k-l.P.|/s0c0e0j0l0z1c1|2d2k3V3g3h4g4h4n4q4w4y4}5O5h5t5{6Y6i6m6w7O7u7v7x8W8X8g8j8n8v9X9`9o9u:Q:X:^:d:m$]#sS%T%Z'Q'X'Z'a'c(i(x(y)S)W)_)`)l)r)y+Y+h,P,T,k,v-k-l.P.|/s0c0e0j0l0z1c1|2d2k3V3g3h4g4h4n4q4w4y4}5O5h5t5{6Y6i6m6w7O7u7v7x8W8X8g8j8n8v9X9`9o9u:Q:X:^:d:m$Z#tS%T%Z'Q'X'Z'a'c(i(x(y)S)_)`)l)r)y+Y+h,P,T,k,v-k-l.P.|/s0c0e0j0l0z1c1|2d2k3V3g3h4g4h4n4q4w4y4}5O5h5t5{6Y6i6m6w7O7u7v7x8W8X8g8j8n8v9X9`9o9u:Q:X:^:d:m$c#wS%T%Z'Q'X'Z'a'c(i(x(y)S)V)W)X)Y)_)`)l)r)y+Y+h,P,T,k,v-k-l.P.|/s0c0e0j0l0z1c1|2d2k3V3g3h4g4h4n4q4w4y4}5O5h5t5{6Y6i6m6w7O7u7v7x8W8X8g8j8n8v9X9`9o9u:Q:X:^:d:m']![O[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-f-j.S.T.X/Q/_/f/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jQ/S(gQ/m)jQ4v/nR9h7}'a![O[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'e'j'k'z(a(c(j)m)s*i*j*m*r*s*w+X+Z+i+k+l,Q,S,o,r,x-^-_-b-f-j.S.T.X/Q/T/_/f/o/q/v/x0k1O1T1d1e1o1s1}2P2f2i2l2x2}3Q3m4S4V4[5^5i5u6c6g6j6l6n6x6z7P7f7n7q8i8k8q8w8x9V9Z9a9c9p9s9t:P:S:Y:[:a:f:jQ#eQR(v#eU$|a;d;|b%Ue$e&f(c-R1p2P2o8_Q'_!u!Q*_$|%U'_*a*g+i,Q0`0a1e2s6u6x7i8t9]9a:V;[;s;t;z;{<[S*a$}%SQ*g%XS+i&W1TQ,Q&bQ0`*cQ0a*eQ1e+lQ2s-WS6u2t2vQ6x2xQ7i3{Q8t6vS9]7j7lQ9a7nQ:V9^Q;[%dS;s;];^S;t<]<^Q;z;uQ;{;vT<[0};e`[Owx!g&S'e*r-fl$c[&|(O+],Y,i,l-Q-_-r-}.b.g.tl&|!k%m&y'O,r2f6g6n8k9p9t:[:a:j^(O#R#S#T+c3`3a3b`+]&U&Y&c*w1V1W1i3mS,Y&m-wQ,i&wU,l&x'P3QS-Q'[2nW-_'b-^-b2}S-r'u-zQ-}'yQ.b(QS.g(R.pR.t(VQ)}$[R/{)}Q0U*OQ5R0PQ5S0QQ5T0RY5U0U5R5S5T8UR8U5WQ*Q$]S0X*Q0YR0Y*RS.c(Q.bS3r.c7`R7`3tQ3u.dS7^3s3vU7b3u7^9PR9P7_Q.p(RR4W.p#Q_O[wx!f!g!}#O$S$l&S&U&Y&c&m&x'P'b'e'u(R)q*r*w+],Y,l,x,{-^-_-b-f-r-w-z.g.p.r1V1W1i2i2}3Q3m3xU$r_$u*^U$u`$d&rR*^$sU$}a;d;|d*b$}*c2t6v7j9^;];u;v<]Q*c%SQ2t-WQ6v2vQ7j3{Q9^7lQ;]%dQ;u;^Q;v<^T<]0};eS+|&a7mR1v+|S*k%Z/sR0f*kQ1X+`R5m1XU+f&V0};|R1`+fQ+t&^Q1f+mT1l+t1fQ8`5}R9m8`QwOU&Rw&S-fS&Sx*rR-f'eQ,a&qR2Y,aW)v$W*r/q5^R/w)vU/r)r)w0jR4{/r[*v%e%f*X2c2j3OR0p*vQ,e&uR2],eQ-b'bQ2}-^T3P-b2}Q2z-YR6|2zQ-i'hQ2U,^T3U-i2US%pm7UR*{%phnOwx!g&S'e'u(R*r-f-z.pR%unQ0w+SR5b0wQ.X'zR3j.XQ1y,OR6U1yU*o%`*y;_R0i*oS1j+o0qR5x1jQ7p3}Q9S7cU9e7p9S:RR:R9Y$S!SO[_ewx!f!g!u!}#O#V#Z$S$T$e$l%U&S&U&Y&c&f&m&x'P'_'b'e'u(R(c(h)k)q*r*w+]+b+u,Y,l,x,{-R-^-_-b-f-r-w-z.g.p.r.x1V1W1[1i1n1p2P2i2o2}3Q3m3x5n8_R&g!SQ4^.vR7z4^Q2Q,VR6]2QS/g)`)aR4s/gW(p#a(k(l/VR/Z(pQ8P4jR9j8PT)b#}*w!YSO[wx!g!k%m&S&y&|'O'b'e,r-^-_-b-f2f2}6g6n8k9p9t:[:a:jj$ya{$k%]+k,S1d1}5u6z8w9c:YY%Te$e(c1s3mY%Zf$f(j)m*mQ&j!WQ&k!XQ'Q!nQ'X!rQ'Z!sQ'a!vQ'c!xQ(b#XQ(f#YS(i#[+ZQ(x#gQ(y#iQ)S#lQ)T#qQ)U#rQ)V#sQ)W#tQ)X#uQ)Y#vQ)Z#wQ)[#xQ)]#yQ)^#zQ)_#{S)`#}*wQ)l$UQ)r$WQ)y$YQ+Y&QS+h&W1TQ,P&bQ,T&fQ,k&xQ,v'PQ-k'jQ-l'kS.P'z.XQ.|(aS/s)s0kS0c*i4eQ0e*jQ0j*rQ0l*sQ0z+XS1c+i+lQ1|,QQ2d,oS2k,x7PQ3V-jQ3g.SQ3h.TQ4g/QQ4h/TQ4n/_Q4q/fQ4w/oQ4y/qQ4}/vQ5O/xQ5h1OQ5t1eQ5{1oQ6Y2PS6i2i8xQ6m2lQ6w2xQ7O3QQ7u4SQ7v4VQ7x4[Q8W5^Q8X5iQ8g6cQ8j6jQ8n6lQ8v6xS9X7f7qQ9`7nQ9o8iQ9u8qS:Q9V9ZQ:X9aQ:^9sS:d:P:SR:m:fR,W&fh]Owx!g&S'e'u(R*r-f-z.p!v^[_`!f!}#O$S$d$l$s$u&U&Y&c&m&r&x'P'b)q*^*w+],Y,l,x,{-^-_-b-r-w.g.r1V1W1i2i2}3Q3m3x#r${ae!u$e$|$}%S%U%X%d&W&b&f'_(c*a*c*e*g+i+l,Q-R-W0`0a1T1e1p2P2o2s2t2v2x3{6u6v6x7i7j7l7n8_8t9]9^9a:V;[;];^;d;e;s;t;u;v;z;{<[<]<^Q%tnS+e&V+fW+s&^+m+t1fU+{&a+|7mQ1n+uT5g0};|d`Owx!g&S'e'u*r-f-zS$d[-rQ$s_b%Xe$e&f(c-R1p2P2o8_!h&r!f!}#O$S$l&U&Y&c&m&x'P'b(R)q*w+],Y,l,x,{-^-_-b-w.g.p.r1V1W1i2i2}3Q3m3xQ'`!uS(`#V+bQ(g#ZS)j$T(hQ*e%UQ-U'_Q/n)kQ1m+uQ5o1[Q5z1nR8Y5nS(X#R3aS(Y#S3bV(Z#T+c3`R$^Ye0T*O0P0Q0R0U5R5S5T5W8UW(S#R#S#T+cQ(]#US.^(O(VS.d(Q.bQ.{(_W1u+z.[6R6TQ3_-wQ3l.ZQ3s.cQ4Z.tU7X3`3a3bQ7a3tR9Q7`Q.e(QR3q.bT.o(R.phgOwx!g&S&m'e'u*r-f-w-zU$g[,Y-rQ&s!fQ'l!}Q'v#OQ)i$SQ*Z$l`+^&U&Y&c*w1V1W1i3mQ,m&xQ,w'PY-`'b-^-b2}3QS.j(R.pQ/p)qQ0|+]S2b,l-_S2m,x,{S3w.g.rQ6k2iR7g3xh]Owx!g&S'e'u(R*r-f-z.p!v^[_`!f!}#O$S$d$l$s$u&U&Y&c&m&r&x'P'b)q*^*w+],Y,l,x,{-^-_-b-r-w.g.r1V1W1i2i2}3Q3m3xR%tnQ3}.jQ7c3wQ7k3{Q7s4OQ7t4PQ9Y7gU9[7i7j7lQ9d7oS:U9]9^R:g:VZ+p&Y&c*w1V3mtzOnpwx!g%w&S'e'u(R*r-f-s-z.i.p.r[%Oa%d0};d;e;|U%We%h1VQ%eg^&d{|%i1R5e;f;}Q't#OQ*X$gb*`$|$}%S;[;];^<[<]<^Q,c&sQ-{'vQ0^*Z[0_*a*c;s;t;u;vQ0n*uQ1P+^Q2c,mQ2j,wS3O-`2bU5Z0`;z;{Q5f0|Q6p2mR8m6kQ,O&aR9_7mS1t+z.[Q8b6RR8c6T[%^f$f(j)m)s0kR0g*mR+a&UQ+`&UR5l1WS&Xy+yQ*h%XU+g&V0};|S+n&Y1VW+q&Z1R5e;}Q-m'lQ/k)iS0b*e*gQ1U+^Q1a+fQ4x/pQ5[0aQ5d0|Q5y1mR8]5zR6O1p^vOwx&S'e*r-fR&t!gW%gg,m,w-`T*Y$g2bT)x$W*r`uOwx!g&S'e*r-fQ&}!kQ*z%mQ,q&yQ,u'OQ2g,rQ6f2fQ8h6gQ8p6nQ9r8kQ:]9pQ:`9tQ:i:[Q:k:aR:o:j|lOwx!g!k%m&S&y'O'e*r,r-f2f6g6n8k9p9t:[:a:jU$h[&|-_X-a'b-^-b2}Q-]'`R2r-US-Y'`-UQ2u-WQ2{-ZU6t2s2t2vQ6{2yS8s6u6vR9w8t`rOwx!g&S'e*r-fS-t'u-zT.k(R.pR+T%y`sOwx!g&S'e*r-fS-v'u-zT.l(R.p`tOwx!g&S'e*r-fT.m(R.pT.W'z.XX%af%k0k1TQ.z(]R4c.{R.w([R(e#XQ(s#aS/U(k(lR4i/VR/Y(mR4k/W",
  nodeNames: "⚠ RawString > MacroName LineComment BlockComment PreprocDirective #include String EscapeSequence SystemLibString Identifier ArgumentList ( ConditionalExpression AssignmentExpression CallExpression PrimitiveType FieldExpression FieldIdentifier DestructorName TemplateMethod ScopedFieldIdentifier NamespaceIdentifier TemplateType TypeIdentifier ScopedTypeIdentifier ScopedNamespaceIdentifier :: NamespaceIdentifier TypeIdentifier TemplateArgumentList < TypeDescriptor const volatile restrict _Atomic mutable constexpr constinit consteval StructSpecifier struct MsDeclspecModifier __declspec ) Attribute AttributeName Identifier AttributeArgs { } [ ] UpdateOp ArithOp ArithOp ArithOp LogicOp BitOp BitOp BitOp CompareOp CompareOp CompareOp > CompareOp BitOp UpdateOp , Number CharLiteral AttributeArgs VirtualSpecifier BaseClassClause Access virtual FieldDeclarationList FieldDeclaration extern static register inline thread_local AttributeSpecifier __attribute__ PointerDeclarator MsBasedModifier __based MsPointerModifier FunctionDeclarator ParameterList ParameterDeclaration PointerDeclarator FunctionDeclarator Noexcept noexcept RequiresClause requires True False ParenthesizedExpression CommaExpression LambdaExpression LambdaCaptureSpecifier TemplateParameterList OptionalParameterDeclaration TypeParameterDeclaration typename class VariadicParameterDeclaration VariadicDeclarator ReferenceDeclarator OptionalTypeParameterDeclaration VariadicTypeParameterDeclaration TemplateTemplateParameterDeclaration template AbstractFunctionDeclarator AbstractPointerDeclarator AbstractArrayDeclarator AbstractParenthesizedDeclarator AbstractReferenceDeclarator ThrowSpecifier throw TrailingReturnType CompoundStatement FunctionDefinition MsCallModifier TryStatement try CatchClause catch LinkageSpecification Declaration InitDeclarator InitializerList InitializerPair SubscriptDesignator FieldDesignator DeclarationList ExportDeclaration export ImportDeclaration import ModuleName PartitionName HeaderName CaseStatement case default LabeledStatement StatementIdentifier ExpressionStatement IfStatement if ConditionClause Declaration else SwitchStatement switch DoStatement do while WhileStatement ForStatement for ReturnStatement return BreakStatement break ContinueStatement continue GotoStatement goto CoReturnStatement co_return CoYieldStatement co_yield AttributeStatement ForRangeLoop AliasDeclaration using TypeDefinition typedef PointerDeclarator FunctionDeclarator ArrayDeclarator ParenthesizedDeclarator ThrowStatement NamespaceDefinition namespace ScopedIdentifier Identifier OperatorName operator ArithOp BitOp CompareOp LogicOp new delete co_await ConceptDefinition concept UsingDeclaration enum StaticAssertDeclaration static_assert ConcatenatedString TemplateDeclaration FriendDeclaration friend union FunctionDefinition ExplicitFunctionSpecifier explicit FieldInitializerList FieldInitializer DefaultMethodClause DeleteMethodClause FunctionDefinition OperatorCast operator TemplateInstantiation FunctionDefinition FunctionDefinition Declaration ModuleDeclaration module RequiresExpression RequirementList SimpleRequirement TypeRequirement CompoundRequirement ReturnTypeRequirement ConstraintConjuction LogicOp ConstraintDisjunction LogicOp ArrayDeclarator ParenthesizedDeclarator ReferenceDeclarator TemplateFunction OperatorName StructuredBindingDeclarator ArrayDeclarator ParenthesizedDeclarator ReferenceDeclarator BitfieldClause FunctionDefinition FunctionDefinition Declaration FunctionDefinition Declaration AccessSpecifier UnionSpecifier ClassSpecifier EnumSpecifier SizedTypeSpecifier TypeSize EnumeratorList Enumerator DependentType Decltype decltype auto PlaceholderTypeSpecifier ParameterPackExpansion ParameterPackExpansion FieldIdentifier PointerExpression SubscriptExpression BinaryExpression ArithOp LogicOp LogicOp BitOp UnaryExpression LogicOp BitOp UpdateExpression CastExpression SizeofExpression sizeof CoAwaitExpression CompoundLiteralExpression NULL NewExpression new NewDeclarator DeleteExpression delete ParameterPackExpansion nullptr this UserDefinedLiteral ParamPack #define PreprocArg #if #ifdef #ifndef #else #endif #elif PreprocDirectiveName Macro Program",
  maxTerm: 426,
  nodeProps: [
    ["group", -35, 1, 8, 11, 14, 15, 16, 18, 71, 72, 100, 101, 102, 104, 192, 209, 230, 243, 244, 271, 272, 273, 278, 281, 282, 283, 285, 286, 287, 288, 291, 293, 294, 295, 296, 297, "Expression", -13, 17, 24, 25, 26, 42, 256, 257, 258, 259, 263, 264, 266, 267, "Type", -19, 126, 129, 148, 151, 153, 154, 159, 161, 164, 165, 167, 169, 171, 173, 175, 177, 179, 180, 189, "Statement"]
  ],
  propSources: [iv],
  skippedNodes: [0, 3, 4, 5, 6, 7, 10, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 348, 349],
  repeatNodeCount: 41,
  tokenData: "&*r7ZR!UOX$eXY({YZ.gZ]$e]^+P^p$epq({qr.}rs0}st2ktu$euv!7dvw!9bwx!;exy!<Yyz!=Tz{!>O{|!?R|}!AV}!O!BQ!O!P!DX!P!Q#+y!Q!R#Az!R![$(x![!]$Ag!]!^$Cc!^!_$D^!_!`%1W!`!a%2X!a!b%5_!b!c$e!c!n%6Y!n!o%7q!o!w%6Y!w!x%7q!x!}%6Y!}#O%:n#O#P%<g#P#Q%Kz#Q#R%Ms#R#S%6Y#S#T$e#T#i%6Y#i#j%Nv#j#o%6Y#o#p&!e#p#q&#`#q#r&%f#r#s&&a#s;'S$e;'S;=`(u<%lO$e&t$nY)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e&r%eW)[W'g&jOY%^Zw%^wx%}x#O%^#O#P&f#P;'S%^;'S;=`'x<%lO%^&j&SU'g&jOY%}Z#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}&j&kX'g&jOY%}YZ%}Z]%}]^'W^#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}&j']V'g&jOY%}YZ%}Z#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}&j'uP;=`<%l%}&r'{P;=`<%l%^&l(VW(qQ'g&jOY(OZr(Ors%}s#O(O#O#P&f#P;'S(O;'S;=`(o<%lO(O&l(rP;=`<%l(O&t(xP;=`<%l$e7Z)Y`)[W(qQ(o.o'g&j*[)`OX$eXY({YZ*[Z]$e]^+P^p$epq({qr$ers%^sw$ewx(Ox#O$e#O#P,^#P;'S$e;'S;=`(u<%lO$e.o*aT(o.oXY*[YZ*[]^*[pq*[#O#P*p.o*sQYZ*[]^*y.o*|PYZ*[4e+[`)[W(qQ(o.o'g&jOX$eXY+PYZ*[Z]$e]^+P^p$epq+Pqr$ers%^sw$ewx(Ox#O$e#O#P,^#P;'S$e;'S;=`(u<%lO$e4Z,cX'g&jOY%}YZ-OZ]%}]^-{^#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}4Z-V[(o.o'g&jOX%}XY-OYZ*[Z]%}]^-O^p%}pq-Oq#O%}#O#P,^#P;'S%};'S;=`'r<%lO%}4Z.QV'g&jOY%}YZ-OZ#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}7P.nT*X)`(o.oXY*[YZ*[]^*[pq*[#O#P*p3o/[[%_!b'RP)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox!_$e!_!`0Q!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o0_Y%^!b!a,g)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e6e1YY)[W(rQ(p/]'g&jOY%^Zr%^rs1xsw%^wx%}x#O%^#O#P&f#P;'S%^;'S;=`'x<%lO%^(U2RW)y!b)[W'g&jOY%^Zw%^wx%}x#O%^#O#P&f#P;'S%^;'S;=`'x<%lO%^4e2tf)[W(qQ'g&jOX$eXY2kZp$epq2kqr$ers%^sw$ewx(Ox!c$e!c!}4Y!}#O$e#O#P&f#P#T$e#T#W4Y#W#X5m#X#Y>u#Y#]4Y#]#^NZ#^#o4Y#o;'S$e;'S;=`(u<%lO$e4e4eb)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e4e5xd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#X4Y#X#Y7W#Y#o4Y#o;'S$e;'S;=`(u<%lO$e4e7cd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#Y4Y#Y#Z8q#Z#o4Y#o;'S$e;'S;=`(u<%lO$e4e8|d)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#]4Y#]#^:[#^#o4Y#o;'S$e;'S;=`(u<%lO$e4e:gd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#b4Y#b#c;u#c#o4Y#o;'S$e;'S;=`(u<%lO$e4e<Qd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#X4Y#X#Y=`#Y#o4Y#o;'S$e;'S;=`(u<%lO$e4e=mb)[W(qQ'f.o'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e4e?Qf)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#`4Y#`#a@f#a#b4Y#b#cHV#c#o4Y#o;'S$e;'S;=`(u<%lO$e4e@qf)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#]4Y#]#^BV#^#g4Y#g#hEV#h#o4Y#o;'S$e;'S;=`(u<%lO$e4eBbd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#Y4Y#Y#ZCp#Z#o4Y#o;'S$e;'S;=`(u<%lO$e4eC}b)[W(qQ'g&j'm.o'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e4eEbd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#X4Y#X#YFp#Y#o4Y#o;'S$e;'S;=`(u<%lO$e4eF}b)[W(qQ'k.o'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e4eHbd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#W4Y#W#XIp#X#o4Y#o;'S$e;'S;=`(u<%lO$e4eI{d)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#]4Y#]#^KZ#^#o4Y#o;'S$e;'S;=`(u<%lO$e4eKfd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#Y4Y#Y#ZLt#Z#o4Y#o;'S$e;'S;=`(u<%lO$e4eMRb)[W(qQ'g&j'l.o'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e4eNff)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#Y4Y#Y#Z! z#Z#b4Y#b#c!.[#c#o4Y#o;'S$e;'S;=`(u<%lO$e4e!!Xf)[W(qQ'h.o'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#W4Y#W#X!#m#X#b4Y#b#c!(W#c#o4Y#o;'S$e;'S;=`(u<%lO$e4e!#xd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#X4Y#X#Y!%W#Y#o4Y#o;'S$e;'S;=`(u<%lO$e4e!%cd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#Y4Y#Y#Z!&q#Z#o4Y#o;'S$e;'S;=`(u<%lO$e4e!'Ob)[W(qQ'i.o'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e4e!(cd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#W4Y#W#X!)q#X#o4Y#o;'S$e;'S;=`(u<%lO$e4e!)|d)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#X4Y#X#Y!+[#Y#o4Y#o;'S$e;'S;=`(u<%lO$e4e!+gd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#Y4Y#Y#Z!,u#Z#o4Y#o;'S$e;'S;=`(u<%lO$e4e!-Sb)[W(qQ'j.o'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e4e!.gd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#V4Y#V#W!/u#W#o4Y#o;'S$e;'S;=`(u<%lO$e4e!0Qd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#`4Y#`#a!1`#a#o4Y#o;'S$e;'S;=`(u<%lO$e4e!1kd)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#i4Y#i#j!2y#j#o4Y#o;'S$e;'S;=`(u<%lO$e4e!3Ud)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#W4Y#W#X!4d#X#o4Y#o;'S$e;'S;=`(u<%lO$e4e!4od)[W(qQ'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#X4Y#X#Y!5}#Y#o4Y#o;'S$e;'S;=`(u<%lO$e4e!6[b)[W(qQV.o'g&j'n.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e3o!7q[)[W(qQ%[!b![,g'g&jOY$eZr$ers%^sw$ewx(Ox!_$e!_!`!8g!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!8rY!g-y)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!9o])W,g)[W(qQ%]!b'g&jOY$eZr$ers%^sv$evw!:hwx(Ox!_$e!_!`!8g!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!:uY)V,g%_!b)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2X!;pW)]S(qQ)Z,g'g&jOY(OZr(Ors%}s#O(O#O#P&f#P;'S(O;'S;=`(o<%lO(O6i!<eY)[W(qQ]6_'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e'V!=`Y!Oa)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!>][)T,g)[W(qQ%[!b'g&jOY$eZr$ers%^sw$ewx(Ox!_$e!_!`!8g!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!?`^)[W(qQ%[!b!Y,g'g&jOY$eZr$ers%^sw$ewx(Ox{$e{|!@[|!_$e!_!`!8g!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!@gY)[W!X-y(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2a!AbY!h,k)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!B__)[W(qQ%[!b!Y,g'g&jOY$eZr$ers%^sw$ewx(Ox}$e}!O!@[!O!_$e!_!`!8g!`!a!C^!a#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!CiY(y-y)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2a!Dd^)[W(qQ'g&j(x,gOY$eZr$ers%^sw$ewx(Ox!O$e!O!P!E`!P!Q$e!Q![!GY![#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2a!Ei[)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox!O$e!O!P!F_!P#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2a!FjY)Y,k)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2]!Gen)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx!Icx!Q$e!Q![!GY![!g$e!g!h#$w!h!i#*Y!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#X$e#X#Y#$w#Y#Z#*Y#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2T!IjY(qQ'g&jOY(OZr(Ors%}s!Q(O!Q![!JY![#O(O#O#P&f#P;'S(O;'S;=`(o<%lO(O2T!Jcn(qQ!i,g'g&jOY(OZr(Ors%}sw(Owx!Icx!Q(O!Q![!JY![!g(O!g!h!La!h!i##`!i!n(O!n!o##`!o!r(O!r!s!La!s!w(O!w!x##`!x#O(O#O#P&f#P#X(O#X#Y!La#Y#Z##`#Z#`(O#`#a##`#a#d(O#d#e!La#e#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2T!Ljl(qQ!i,g'g&jOY(OZr(Ors%}s{(O{|!Nb|}(O}!O!Nb!O!Q(O!Q![# e![!c(O!c!h# e!h!i# e!i!n(O!n!o##`!o!w(O!w!x##`!x#O(O#O#P&f#P#T(O#T#Y# e#Y#Z# e#Z#`(O#`#a##`#a#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2T!Ni^(qQ'g&jOY(OZr(Ors%}s!Q(O!Q![# e![!c(O!c!i# e!i#O(O#O#P&f#P#T(O#T#Z# e#Z;'S(O;'S;=`(o<%lO(O2T# nj(qQ!i,g'g&jOY(OZr(Ors%}sw(Owx!Nbx!Q(O!Q![# e![!c(O!c!h# e!h!i# e!i!n(O!n!o##`!o!w(O!w!x##`!x#O(O#O#P&f#P#T(O#T#Y# e#Y#Z# e#Z#`(O#`#a##`#a#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2T##id(qQ!i,g'g&jOY(OZr(Ors%}s!h(O!h!i##`!i!n(O!n!o##`!o!w(O!w!x##`!x#O(O#O#P&f#P#Y(O#Y#Z##`#Z#`(O#`#a##`#a#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2]#%Sn)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx(Ox{$e{|#'Q|}$e}!O#'Q!O!Q$e!Q![#(]![!c$e!c!h#(]!h!i#(]!i!n$e!n!o#*Y!o!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#Y#(]#Y#Z#(]#Z#`$e#`#a#*Y#a#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2]#'Z`)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![#(]![!c$e!c!i#(]!i#O$e#O#P&f#P#T$e#T#Z#(]#Z;'S$e;'S;=`(u<%lO$e2]#(hj)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx!Nbx!Q$e!Q![#(]![!c$e!c!h#(]!h!i#(]!i!n$e!n!o#*Y!o!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#Y#(]#Y#Z#(]#Z#`$e#`#a#*Y#a#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2]#*ef)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx(Ox!h$e!h!i#*Y!i!n$e!n!o#*Y!o!w$e!w!x#*Y!x#O$e#O#P&f#P#Y$e#Y#Z#*Y#Z#`$e#`#a#*Y#a#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e7Z#,W`)[W(qQ%[!b![,g'g&jOY$eZr$ers%^sw$ewx(Oxz$ez{#-Y{!P$e!P!Q#:s!Q!_$e!_!`!8g!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e7Z#-c])[W(qQ'g&jOY#-YYZ#.[Zr#-Yrs#/csw#-Ywx#5wxz#-Yz{#8j{#O#-Y#O#P#2`#P;'S#-Y;'S;=`#:m<%lO#-Y1e#._TOz#.[z{#.n{;'S#.[;'S;=`#/]<%lO#.[1e#.qVOz#.[z{#.n{!P#.[!P!Q#/W!Q;'S#.[;'S;=`#/]<%lO#.[1e#/]OT1e1e#/`P;=`<%l#.[7X#/jZ)[W'g&jOY#/cYZ#.[Zw#/cwx#0]xz#/cz{#4O{#O#/c#O#P#2`#P;'S#/c;'S;=`#5q<%lO#/c7P#0bX'g&jOY#0]YZ#.[Zz#0]z{#0}{#O#0]#O#P#2`#P;'S#0];'S;=`#3x<%lO#0]7P#1SZ'g&jOY#0]YZ#.[Zz#0]z{#0}{!P#0]!P!Q#1u!Q#O#0]#O#P#2`#P;'S#0];'S;=`#3x<%lO#0]7P#1|UT1e'g&jOY%}Z#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}7P#2eZ'g&jOY#0]YZ#0]Z]#0]]^#3W^z#0]z{#0}{#O#0]#O#P#2`#P;'S#0];'S;=`#3x<%lO#0]7P#3]X'g&jOY#0]YZ#0]Zz#0]z{#0}{#O#0]#O#P#2`#P;'S#0];'S;=`#3x<%lO#0]7P#3{P;=`<%l#0]7X#4V])[W'g&jOY#/cYZ#.[Zw#/cwx#0]xz#/cz{#4O{!P#/c!P!Q#5O!Q#O#/c#O#P#2`#P;'S#/c;'S;=`#5q<%lO#/c7X#5XW)[WT1e'g&jOY%^Zw%^wx%}x#O%^#O#P&f#P;'S%^;'S;=`'x<%lO%^7X#5tP;=`<%l#/c7R#6OZ(qQ'g&jOY#5wYZ#.[Zr#5wrs#0]sz#5wz{#6q{#O#5w#O#P#2`#P;'S#5w;'S;=`#8d<%lO#5w7R#6x](qQ'g&jOY#5wYZ#.[Zr#5wrs#0]sz#5wz{#6q{!P#5w!P!Q#7q!Q#O#5w#O#P#2`#P;'S#5w;'S;=`#8d<%lO#5w7R#7zW(qQT1e'g&jOY(OZr(Ors%}s#O(O#O#P&f#P;'S(O;'S;=`(o<%lO(O7R#8gP;=`<%l#5w7Z#8s_)[W(qQ'g&jOY#-YYZ#.[Zr#-Yrs#/csw#-Ywx#5wxz#-Yz{#8j{!P#-Y!P!Q#9r!Q#O#-Y#O#P#2`#P;'S#-Y;'S;=`#:m<%lO#-Y7Z#9}Y)[W(qQT1e'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e7Z#:pP;=`<%l#-Y7Z#;OY)[W(qQS1e'g&jOY#:sZr#:srs#;nsw#:swx#@{x#O#:s#O#P#<z#P;'S#:s;'S;=`#At<%lO#:s7X#;wW)[WS1e'g&jOY#;nZw#;nwx#<ax#O#;n#O#P#<z#P;'S#;n;'S;=`#@u<%lO#;n7P#<hUS1e'g&jOY#<aZ#O#<a#O#P#<z#P;'S#<a;'S;=`#>[<%lO#<a7P#=RXS1e'g&jOY#<aYZ%}Z]#<a]^#=n^#O#<a#O#P#>b#P;'S#<a;'S;=`#>[<%lO#<a7P#=uVS1e'g&jOY#<aYZ%}Z#O#<a#O#P#<z#P;'S#<a;'S;=`#>[<%lO#<a7P#>_P;=`<%l#<a7P#>i]S1e'g&jOY#<aYZ%}Z]#<a]^#=n^#O#<a#O#P#>b#P#b#<a#b#c#<a#c#f#<a#f#g#?b#g;'S#<a;'S;=`#>[<%lO#<a7P#?iUS1e'g&jOY#<aZ#O#<a#O#P#?{#P;'S#<a;'S;=`#>[<%lO#<a7P#@SZS1e'g&jOY#<aYZ%}Z]#<a]^#=n^#O#<a#O#P#>b#P#b#<a#b#c#<a#c;'S#<a;'S;=`#>[<%lO#<a7X#@xP;=`<%l#;n7R#AUW(qQS1e'g&jOY#@{Zr#@{rs#<as#O#@{#O#P#<z#P;'S#@{;'S;=`#An<%lO#@{7R#AqP;=`<%l#@{7Z#AwP;=`<%l#:s2]#BVt)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx#Dgx!O$e!O!P$ m!P!Q$e!Q![$(x![!g$e!g!h#$w!h!i#*Y!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#U$e#U#V$+X#V#X$e#X#Y#$w#Y#Z#*Y#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j#l$e#l#m$=`#m;'S$e;'S;=`(u<%lO$e2T#DnY(qQ'g&jOY(OZr(Ors%}s!Q(O!Q![#E^![#O(O#O#P&f#P;'S(O;'S;=`(o<%lO(O2T#Egp(qQ!i,g'g&jOY(OZr(Ors%}sw(Owx#Dgx!O(O!O!P#Gk!P!Q(O!Q![#E^![!g(O!g!h!La!h!i##`!i!n(O!n!o##`!o!r(O!r!s!La!s!w(O!w!x##`!x#O(O#O#P&f#P#X(O#X#Y!La#Y#Z##`#Z#`(O#`#a##`#a#d(O#d#e!La#e#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2T#Gtn(qQ!i,g'g&jOY(OZr(Ors%}s!Q(O!Q![#Ir![!c(O!c!g#Ir!g!h#MS!h!i#Ir!i!n(O!n!o##`!o!r(O!r!s!La!s!w(O!w!x##`!x#O(O#O#P&f#P#T(O#T#X#Ir#X#Y#MS#Y#Z#Ir#Z#`(O#`#a##`#a#d(O#d#e!La#e#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2T#I{p(qQ!i,g'g&jOY(OZr(Ors%}sw(Owx#LPx!Q(O!Q![#Ir![!c(O!c!g#Ir!g!h#MS!h!i#Ir!i!n(O!n!o##`!o!r(O!r!s!La!s!w(O!w!x##`!x#O(O#O#P&f#P#T(O#T#X#Ir#X#Y#MS#Y#Z#Ir#Z#`(O#`#a##`#a#d(O#d#e!La#e#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2T#LW^(qQ'g&jOY(OZr(Ors%}s!Q(O!Q![#Ir![!c(O!c!i#Ir!i#O(O#O#P&f#P#T(O#T#Z#Ir#Z;'S(O;'S;=`(o<%lO(O2T#M]t(qQ!i,g'g&jOY(OZr(Ors%}sw(Owx#LPx{(O{|!Nb|}(O}!O!Nb!O!Q(O!Q![#Ir![!c(O!c!g#Ir!g!h#MS!h!i#Ir!i!n(O!n!o##`!o!r(O!r!s!La!s!w(O!w!x##`!x#O(O#O#P&f#P#T(O#T#X#Ir#X#Y#MS#Y#Z#Ir#Z#`(O#`#a##`#a#d(O#d#e!La#e#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2]$ xp)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![$#|![!c$e!c!g$#|!g!h$&]!h!i$#|!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#X$#|#X#Y$&]#Y#Z$#|#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2]$$Xp)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx#LPx!Q$e!Q![$#|![!c$e!c!g$#|!g!h$&]!h!i$#|!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#X$#|#X#Y$&]#Y#Z$#|#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2]$&ht)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx#LPx{$e{|#'Q|}$e}!O#'Q!O!Q$e!Q![$#|![!c$e!c!g$#|!g!h$&]!h!i$#|!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#X$#|#X#Y$&]#Y#Z$#|#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2]$)Tp)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx#Dgx!O$e!O!P$ m!P!Q$e!Q![$(x![!g$e!g!h#$w!h!i#*Y!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#X$e#X#Y#$w#Y#Z#*Y#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2]$+b_)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox!O$e!O!P$,a!P!Q$e!Q!R$-`!R![$(x![#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2]$,j[)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![!GY![#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2]$-kt)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx#Dgx!O$e!O!P$ m!P!Q$e!Q![$(x![!g$e!g!h#$w!h!i#*Y!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#U$e#U#V$/{#V#X$e#X#Y#$w#Y#Z#*Y#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j#l$e#l#m$0z#m;'S$e;'S;=`(u<%lO$e2]$0U[)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![$(x![#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2]$1T`)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![$2V![!c$e!c!i$2V!i#O$e#O#P&f#P#T$e#T#Z$2V#Z;'S$e;'S;=`(u<%lO$e2]$2br)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx$4lx!O$e!O!P$ m!P!Q$e!Q![$2V![!c$e!c!g$2V!g!h$:p!h!i$2V!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#X$2V#X#Y$:p#Y#Z$2V#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2T$4s^(qQ'g&jOY(OZr(Ors%}s!Q(O!Q![$5o![!c(O!c!i$5o!i#O(O#O#P&f#P#T(O#T#Z$5o#Z;'S(O;'S;=`(o<%lO(O2T$5xr(qQ!i,g'g&jOY(OZr(Ors%}sw(Owx$4lx!O(O!O!P#Gk!P!Q(O!Q![$5o![!c(O!c!g$5o!g!h$8S!h!i$5o!i!n(O!n!o##`!o!r(O!r!s!La!s!w(O!w!x##`!x#O(O#O#P&f#P#T(O#T#X$5o#X#Y$8S#Y#Z$5o#Z#`(O#`#a##`#a#d(O#d#e!La#e#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2T$8]u(qQ!i,g'g&jOY(OZr(Ors%}sw(Owx$4lx{(O{|!Nb|}(O}!O!Nb!O!P#Gk!P!Q(O!Q![$5o![!c(O!c!g$5o!g!h$8S!h!i$5o!i!n(O!n!o##`!o!r(O!r!s!La!s!w(O!w!x##`!x#O(O#O#P&f#P#T(O#T#X$5o#X#Y$8S#Y#Z$5o#Z#`(O#`#a##`#a#d(O#d#e!La#e#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2]$:{u)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx$4lx{$e{|#'Q|}$e}!O#'Q!O!P$ m!P!Q$e!Q![$2V![!c$e!c!g$2V!g!h$:p!h!i$2V!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#X$2V#X#Y$:p#Y#Z$2V#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2]$=ic)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox!O$e!O!P$,a!P!Q$e!Q!R$>t!R![$2V![!c$e!c!i$2V!i#O$e#O#P&f#P#T$e#T#Z$2V#Z;'S$e;'S;=`(u<%lO$e2]$?Pv)[W(qQ!i,g'g&jOY$eZr$ers%^sw$ewx$4lx!O$e!O!P$ m!P!Q$e!Q![$2V![!c$e!c!g$2V!g!h$:p!h!i$2V!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#U$2V#U#V$2V#V#X$2V#X#Y$:p#Y#Z$2V#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j#l$e#l#m$0z#m;'S$e;'S;=`(u<%lO$e4e$Ar[(w-X)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox![$e![!]$Bh!]#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3s$BsYl-})[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2]$CnY)X,g)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e7V$Dk_p,g%^!b)[W(qQ'g&jOY$EjYZ$FlZr$Ejrs$GZsw$Ejwx%)Px!^$Ej!^!_%+w!_!`%.U!`!a%0]!a#O$Ej#O#P$Ib#P;'S$Ej;'S;=`%+q<%lO$Ej*[$Es])[W(qQ'g&jOY$EjYZ$FlZr$Ejrs$GZsw$Ejwx%)Px!`$Ej!`!a%*t!a#O$Ej#O#P$Ib#P;'S$Ej;'S;=`%+q<%lO$Ejp$FoTO!`$Fl!`!a$GO!a;'S$Fl;'S;=`$GT<%lO$Flp$GTO$Xpp$GWP;=`<%l$Fl*Y$GbZ)[W'g&jOY$GZYZ$FlZw$GZwx$HTx!`$GZ!`!a%(U!a#O$GZ#O#P$Ib#P;'S$GZ;'S;=`%(y<%lO$GZ*Q$HYX'g&jOY$HTYZ$FlZ!`$HT!`!a$Hu!a#O$HT#O#P$Ib#P;'S$HT;'S;=`$Mx<%lO$HT*Q$IOU$XpY#t'g&jOY%}Z#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}*Q$Ig['g&jOY$HTYZ$HTZ]$HT]^$J]^!`$HT!`!a$NO!a#O$HT#O#P%&n#P;'S$HT;'S;=`%'f;=`<%l%$z<%lO$HT*Q$JbX'g&jOY$HTYZ$J}Z!`$HT!`!a$Hu!a#O$HT#O#P$Ib#P;'S$HT;'S;=`$Mx<%lO$HT'[$KSX'g&jOY$J}YZ$FlZ!`$J}!`!a$Ko!a#O$J}#O#P$LY#P;'S$J};'S;=`$Mr<%lO$J}'[$KvU$Xp'g&jOY%}Z#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}'[$L_Z'g&jOY$J}YZ$J}Z]$J}]^$MQ^!`$J}!`!a$Ko!a#O$J}#O#P$LY#P;'S$J};'S;=`$Mr<%lO$J}'[$MVX'g&jOY$J}YZ$J}Z!`$J}!`!a$Ko!a#O$J}#O#P$LY#P;'S$J};'S;=`$Mr<%lO$J}'[$MuP;=`<%l$J}*Q$M{P;=`<%l$HT*Q$NVW$Xp'g&jOY$NoZ!`$No!`!a% ^!a#O$No#O#P% w#P;'S$No;'S;=`%#^<%lO$No)`$NtW'g&jOY$NoZ!`$No!`!a% ^!a#O$No#O#P% w#P;'S$No;'S;=`%#^<%lO$No)`% eUY#t'g&jOY%}Z#O%}#O#P&f#P;'S%};'S;=`'r<%lO%})`% |Y'g&jOY$NoYZ$NoZ]$No]^%!l^#O$No#O#P%#d#P;'S$No;'S;=`%$[;=`<%l%$z<%lO$No)`%!qX'g&jOY$NoYZ%}Z!`$No!`!a% ^!a#O$No#O#P% w#P;'S$No;'S;=`%#^<%lO$No)`%#aP;=`<%l$No)`%#iZ'g&jOY$NoYZ%}Z]$No]^%!l^!`$No!`!a% ^!a#O$No#O#P% w#P;'S$No;'S;=`%#^<%lO$No)`%$_XOY%$zZ!`%$z!`!a%%g!a#O%$z#O#P%%l#P;'S%$z;'S;=`%&h;=`<%l$No<%lO%$z#t%$}WOY%$zZ!`%$z!`!a%%g!a#O%$z#O#P%%l#P;'S%$z;'S;=`%&h<%lO%$z#t%%lOY#t#t%%oRO;'S%$z;'S;=`%%x;=`O%$z#t%%{XOY%$zZ!`%$z!`!a%%g!a#O%$z#O#P%%l#P;'S%$z;'S;=`%&h;=`<%l%$z<%lO%$z#t%&kP;=`<%l%$z*Q%&sZ'g&jOY$HTYZ$J}Z]$HT]^$J]^!`$HT!`!a$Hu!a#O$HT#O#P$Ib#P;'S$HT;'S;=`$Mx<%lO$HT*Q%'iXOY%$zZ!`%$z!`!a%%g!a#O%$z#O#P%%l#P;'S%$z;'S;=`%&h;=`<%l$HT<%lO%$z*Y%(aW$XpY#t)[W'g&jOY%^Zw%^wx%}x#O%^#O#P&f#P;'S%^;'S;=`'x<%lO%^*Y%(|P;=`<%l$GZ*S%)WZ(qQ'g&jOY%)PYZ$FlZr%)Prs$HTs!`%)P!`!a%)y!a#O%)P#O#P$Ib#P;'S%)P;'S;=`%*n<%lO%)P*S%*UW$XpY#t(qQ'g&jOY(OZr(Ors%}s#O(O#O#P&f#P;'S(O;'S;=`(o<%lO(O*S%*qP;=`<%l%)P*[%+RY$XpY#t)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e*[%+tP;=`<%l$Ej7V%,U^)[W(qQ%]!b!f,g'g&jOY$EjYZ$FlZr$Ejrs$GZsw$Ejwx%)Px!_$Ej!_!`%-Q!`!a%*t!a#O$Ej#O#P$Ib#P;'S$Ej;'S;=`%+q<%lO$Ej7V%-]]!g-y)[W(qQ'g&jOY$EjYZ$FlZr$Ejrs$GZsw$Ejwx%)Px!`$Ej!`!a%*t!a#O$Ej#O#P$Ib#P;'S$Ej;'S;=`%+q<%lO$Ej7V%.c]%^!b!b,g)[W(qQ'g&jOY$EjYZ$FlZr$Ejrs$GZsw$Ejwx%)Px!`$Ej!`!a%/[!a#O$Ej#O#P$Ib#P;'S$Ej;'S;=`%+q<%lO$Ej7V%/mY%^!b!b,g$XpY#t)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e)j%0hYY#t)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o%1c[)k!c)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox!_$e!_!`0Q!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o%2f]%^!b)[W(qQ!d,g'g&jOY$eZr$ers%^sw$ewx(Ox!_$e!_!`%3_!`!a%4[!a#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o%3lY%^!b!b,g)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o%4i[)[W(qQ%]!b!f,g'g&jOY$eZr$ers%^sw$ewx(Ox!_$e!_!`!8g!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e&u%5jY(vP)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e7Z%6ib)[W(zS(qQ!R,f(s%y'g&jOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![%6Y![!c$e!c!}%6Y!}#O$e#O#P&f#P#R$e#R#S%6Y#S#T$e#T#o%6Y#o;'S$e;'S;=`(u<%lO$e7Z%8Qb)[W(zS(qQ!R,f(s%y'g&jOY$eZr$ers%9Ysw$ewx%9{x!Q$e!Q![%6Y![!c$e!c!}%6Y!}#O$e#O#P&f#P#R$e#R#S%6Y#S#T$e#T#o%6Y#o;'S$e;'S;=`(u<%lO$e5P%9cW)[W(p/]'g&jOY%^Zw%^wx%}x#O%^#O#P&f#P;'S%^;'S;=`'x<%lO%^2T%:UW(qQ)Z,g'g&jOY(OZr(Ors%}s#O(O#O#P&f#P;'S(O;'S;=`(o<%lO(O3o%:yZ!V-y)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox!}$e!}#O%;l#O#P&f#P;'S$e;'S;=`(u<%lO$e&u%;wY)QP)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e4e%<la'g&jOY%=qYZ%>[Z]%=q]^%?Z^!Q%=q!Q![%?w![!w%=q!w!x%AX!x#O%=q#O#P%H_#P#i%=q#i#j%Ds#j#l%=q#l#m%IR#m;'S%=q;'S;=`%Kt<%lO%=q&t%=xUXY'g&jOY%}Z#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}4e%>e[XY(o.o'g&jOX%}XY-OYZ*[Z]%}]^-O^p%}pq-Oq#O%}#O#P,^#P;'S%};'S;=`'r<%lO%}4e%?bVXY'g&jOY%}YZ-OZ#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}&t%@OWXY'g&jOY%}Z!Q%}!Q![%@h![#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}&t%@oWXY'g&jOY%}Z!Q%}!Q![%=q![#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}&t%A^['g&jOY%}Z!Q%}!Q![%BS![!c%}!c!i%BS!i#O%}#O#P&f#P#T%}#T#Z%BS#Z;'S%};'S;=`'r<%lO%}&t%BX['g&jOY%}Z!Q%}!Q![%B}![!c%}!c!i%B}!i#O%}#O#P&f#P#T%}#T#Z%B}#Z;'S%};'S;=`'r<%lO%}&t%CS['g&jOY%}Z!Q%}!Q![%Cx![!c%}!c!i%Cx!i#O%}#O#P&f#P#T%}#T#Z%Cx#Z;'S%};'S;=`'r<%lO%}&t%C}['g&jOY%}Z!Q%}!Q![%Ds![!c%}!c!i%Ds!i#O%}#O#P&f#P#T%}#T#Z%Ds#Z;'S%};'S;=`'r<%lO%}&t%Dx['g&jOY%}Z!Q%}!Q![%En![!c%}!c!i%En!i#O%}#O#P&f#P#T%}#T#Z%En#Z;'S%};'S;=`'r<%lO%}&t%Es['g&jOY%}Z!Q%}!Q![%Fi![!c%}!c!i%Fi!i#O%}#O#P&f#P#T%}#T#Z%Fi#Z;'S%};'S;=`'r<%lO%}&t%Fn['g&jOY%}Z!Q%}!Q![%Gd![!c%}!c!i%Gd!i#O%}#O#P&f#P#T%}#T#Z%Gd#Z;'S%};'S;=`'r<%lO%}&t%Gi['g&jOY%}Z!Q%}!Q![%=q![!c%}!c!i%=q!i#O%}#O#P&f#P#T%}#T#Z%=q#Z;'S%};'S;=`'r<%lO%}&t%HfXXY'g&jOY%}YZ%}Z]%}]^'W^#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}&t%IW['g&jOY%}Z!Q%}!Q![%I|![!c%}!c!i%I|!i#O%}#O#P&f#P#T%}#T#Z%I|#Z;'S%};'S;=`'r<%lO%}&t%JR['g&jOY%}Z!Q%}!Q![%Jw![!c%}!c!i%Jw!i#O%}#O#P&f#P#T%}#T#Z%Jw#Z;'S%};'S;=`'r<%lO%}&t%KO[XY'g&jOY%}Z!Q%}!Q![%Jw![!c%}!c!i%Jw!i#O%}#O#P&f#P#T%}#T#Z%Jw#Z;'S%};'S;=`'r<%lO%}&t%KwP;=`<%l%=q2a%LVZ!W,V)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P#Q%Lx#Q;'S$e;'S;=`(u<%lO$e'Y%MTY)^d)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o%NQ[)[W(qQ%]!b'g&j!_,gOY$eZr$ers%^sw$ewx(Ox!_$e!_!`!8g!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e7Z& Vd)[W(zS(qQ!R,f(s%y'g&jOY$eZr$ers%9Ysw$ewx%9{x!Q$e!Q!Y%6Y!Y!Z%7q!Z![%6Y![!c$e!c!}%6Y!}#O$e#O#P&f#P#R$e#R#S%6Y#S#T$e#T#o%6Y#o;'S$e;'S;=`(u<%lO$e2]&!pY!T,g)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o&#m^)[W(qQ%]!b'g&j!^,gOY$eZr$ers%^sw$ewx(Ox!_$e!_!`!8g!`#O$e#O#P&f#P#p$e#p#q&$i#q;'S$e;'S;=`(u<%lO$e3o&$vY)U,g%_!b)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e'V&%qY!Ua)[W(qQ'g&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e(]&&nc)[W(qQ%]!b'SP'g&jOX$eXY&'yZp$epq&'yqr$ers%^sw$ewx(Ox!c$e!c!}&)_!}#O$e#O#P&f#P#R$e#R#S&)_#S#T$e#T#o&)_#o;'S$e;'S;=`(u<%lO$e&y&(Sc)[W(qQ'g&jOX$eXY&'yZp$epq&'yqr$ers%^sw$ewx(Ox!c$e!c!}&)_!}#O$e#O#P&f#P#R$e#R#S&)_#S#T$e#T#o&)_#o;'S$e;'S;=`(u<%lO$e&y&)jb)[W(qQdT'g&jOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![&)_![!c$e!c!}&)_!}#O$e#O#P&f#P#R$e#R#S&)_#S#T$e#T#o&)_#o;'S$e;'S;=`(u<%lO$e",
  tokenizers: [tv, Ov, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
  topRules: { Program: [0, 308] },
  dynamicPrecedences: { 87: 1, 94: 1, 119: 1, 185: 1, 188: -10, 241: -10, 242: 1, 245: -1, 247: -10, 248: 1, 263: -1, 268: 2, 269: 2, 307: -10, 366: 3, 418: 1, 419: 3, 420: 1, 421: 1 },
  specialized: [{ term: 357, get: (O) => nv[O] || -1 }, { term: 32, get: (O) => rv[O] || -1 }, { term: 66, get: (O) => sv[O] || -1 }, { term: 364, get: (O) => ov[O] || -1 }],
  tokenPrec: 24905
});
var lv = Ze.define({
  name: "cpp",
  parser: av.configure({
    props: [
      Ce.add({
        IfStatement: $e({ except: /^\s*({|else\b)/ }),
        TryStatement: $e({ except: /^\s*({|catch)\b/ }),
        LabeledStatement: Wl,
        CaseStatement: (O) => O.baseIndent + O.unit,
        BlockComment: () => null,
        CompoundStatement: Ft({ closing: "}" }),
        Statement: $e({ except: /^{/ })
      }),
      Ge.add({
        "DeclarationList CompoundStatement EnumeratorList FieldDeclarationList InitializerList": _t,
        BlockComment(O) {
          return { from: O.from + 2, to: O.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\})$/,
    closeBrackets: { stringPrefixes: ["L", "u", "U", "u8", "LR", "UR", "uR", "u8R", "R"] }
  }
});
function cv() {
  return new je(lv);
}
var hv = 1;
var uv = 2;
var fv = 263;
var dv = 3;
var Qv = 264;
var cf = 265;
var $v = 266;
var pv = 4;
var mv = 5;
var gv = 6;
var Sv = 7;
var hf = 8;
var Pv = 9;
var yv = 10;
var Xv = 11;
var xv = 12;
var bv = 13;
var wv = 14;
var Tv = 15;
var Wv = 16;
var vv = 17;
var kv = 18;
var Yv = 19;
var Zv = 20;
var qv = 21;
var zv = 22;
var Uv = 23;
var Vv = 24;
var Rv = 25;
var _v = 26;
var jv = 27;
var Cv = 28;
var Gv = 29;
var Iv = 30;
var Ev = 31;
var Av = 32;
var Dv = 33;
var Mv = 34;
var Lv = 35;
var Bv = 36;
var Nv = 37;
var Fv = 38;
var Hv = 39;
var Kv = 40;
var Jv = 41;
var ek = 42;
var tk = 43;
var Ok = 44;
var ik = 45;
var nk = 46;
var rk = 47;
var sk = 48;
var ok = 49;
var ak = 50;
var lk = 51;
var ck = 52;
var hk = 53;
var uk = 54;
var fk = 55;
var dk = 56;
var Qk = 57;
var $k = 58;
var pk = 59;
var mk = 60;
var gk = 61;
var Qo = 62;
var Sk = 63;
var Pk = 64;
var yk = 65;
var Xk = {
  abstract: pv,
  and: mv,
  array: gv,
  as: Sv,
  true: hf,
  false: hf,
  break: Pv,
  case: yv,
  catch: Xv,
  clone: xv,
  const: bv,
  continue: wv,
  declare: Wv,
  default: Tv,
  do: vv,
  echo: kv,
  else: Yv,
  elseif: Zv,
  enddeclare: qv,
  endfor: zv,
  endforeach: Uv,
  endif: Vv,
  endswitch: Rv,
  endwhile: _v,
  enum: jv,
  extends: Cv,
  final: Gv,
  finally: Iv,
  fn: Ev,
  for: Av,
  foreach: Dv,
  from: Mv,
  function: Lv,
  global: Bv,
  goto: Nv,
  if: Fv,
  implements: Hv,
  include: Kv,
  include_once: Jv,
  instanceof: ek,
  insteadof: tk,
  interface: Ok,
  list: ik,
  match: nk,
  namespace: rk,
  new: sk,
  null: ok,
  or: ak,
  print: lk,
  require: ck,
  require_once: hk,
  return: uk,
  switch: fk,
  throw: dk,
  trait: Qk,
  try: $k,
  unset: pk,
  use: mk,
  var: gk,
  public: Qo,
  private: Qo,
  protected: Qo,
  while: Sk,
  xor: Pk,
  yield: yk,
  __proto__: null
};
function uf(O) {
  let e = Xk[O.toLowerCase()];
  return e ?? -1;
}
function ff(O) {
  return O == 9 || O == 10 || O == 13 || O == 32;
}
function lm(O) {
  return O >= 97 && O <= 122 || O >= 65 && O <= 90;
}
function zi(O) {
  return O == 95 || O >= 128 || lm(O);
}
function $o(O) {
  return O >= 48 && O <= 55 || O >= 97 && O <= 102 || O >= 65 && O <= 70;
}
var xk = {
  int: true,
  integer: true,
  bool: true,
  boolean: true,
  float: true,
  double: true,
  real: true,
  string: true,
  array: true,
  object: true,
  unset: true,
  __proto__: null
};
var bk = new te((O) => {
  if (O.next == 40) {
    O.advance();
    let e = 0;
    for (; ff(O.peek(e)); )
      e++;
    let t = "", i;
    for (; lm(i = O.peek(e)); )
      t += String.fromCharCode(i), e++;
    for (; ff(O.peek(e)); )
      e++;
    O.peek(e) == 41 && xk[t.toLowerCase()] && O.acceptToken(hv);
  } else if (O.next == 60 && O.peek(1) == 60 && O.peek(2) == 60) {
    for (let i = 0; i < 3; i++)
      O.advance();
    for (; O.next == 32 || O.next == 9; )
      O.advance();
    let e = O.next == 39;
    if (e && O.advance(), !zi(O.next))
      return;
    let t = String.fromCharCode(O.next);
    for (; O.advance(), !(!zi(O.next) && !(O.next >= 48 && O.next <= 55)); )
      t += String.fromCharCode(O.next);
    if (e) {
      if (O.next != 39)
        return;
      O.advance();
    }
    if (O.next != 10 && O.next != 13)
      return;
    for (; ; ) {
      let i = O.next == 10 || O.next == 13;
      if (O.advance(), O.next < 0)
        return;
      if (i) {
        for (; O.next == 32 || O.next == 9; )
          O.advance();
        let n = true;
        for (let r = 0; r < t.length; r++) {
          if (O.next != t.charCodeAt(r)) {
            n = false;
            break;
          }
          O.advance();
        }
        if (n)
          return O.acceptToken(uv);
      }
    }
  }
});
var wk = new te((O) => {
  O.next < 0 && O.acceptToken($v);
});
var Tk = new te((O, e) => {
  O.next == 63 && e.canShift(cf) && O.peek(1) == 62 && O.acceptToken(cf);
});
function Wk(O) {
  let e = O.peek(1);
  if (e == 110 || e == 114 || e == 116 || e == 118 || e == 101 || e == 102 || e == 92 || e == 36 || e == 34 || e == 123)
    return 2;
  if (e >= 48 && e <= 55) {
    let t = 2, i;
    for (; t < 5 && (i = O.peek(t)) >= 48 && i <= 55; )
      t++;
    return t;
  }
  if (e == 120 && $o(O.peek(2)))
    return $o(O.peek(3)) ? 4 : 3;
  if (e == 117 && O.peek(2) == 123)
    for (let t = 3; ; t++) {
      let i = O.peek(t);
      if (i == 125)
        return t == 2 ? 0 : t + 1;
      if (!$o(i))
        break;
    }
  return 0;
}
var vk = new te((O, e) => {
  let t = false;
  for (; !(O.next == 34 || O.next < 0 || O.next == 36 && (zi(O.peek(1)) || O.peek(1) == 123) || O.next == 123 && O.peek(1) == 36); t = true) {
    if (O.next == 92) {
      let i = Wk(O);
      if (i) {
        if (t)
          break;
        return O.acceptToken(dv, i);
      }
    } else if (!t && (O.next == 91 || O.next == 45 && O.peek(1) == 62 && zi(O.peek(2)) || O.next == 63 && O.peek(1) == 45 && O.peek(2) == 62 && zi(O.peek(3))) && e.canShift(Qv))
      break;
    O.advance();
  }
  t && O.acceptToken(fv);
});
var kk = ze({
  "Visibility abstract final static": c.modifier,
  "for foreach while do if else elseif switch try catch finally return throw break continue default case": c.controlKeyword,
  "endif endfor endforeach endswitch endwhile declare enddeclare goto match": c.controlKeyword,
  "and or xor yield unset clone instanceof insteadof": c.operatorKeyword,
  "function fn class trait implements extends const enum global interface use var": c.definitionKeyword,
  "include include_once require require_once namespace": c.moduleKeyword,
  "new from echo print array list as": c.keyword,
  null: c.null,
  Boolean: c.bool,
  VariableName: c.variableName,
  "NamespaceName/...": c.namespace,
  "NamedType/...": c.typeName,
  Name: c.name,
  "CallExpression/Name": c.function(c.variableName),
  "LabelStatement/Name": c.labelName,
  "MemberExpression/Name": c.propertyName,
  "MemberExpression/VariableName": c.special(c.propertyName),
  "ScopedExpression/ClassMemberName/Name": c.propertyName,
  "ScopedExpression/ClassMemberName/VariableName": c.special(c.propertyName),
  "CallExpression/MemberExpression/Name": c.function(c.propertyName),
  "CallExpression/ScopedExpression/ClassMemberName/Name": c.function(c.propertyName),
  "MethodDeclaration/Name": c.function(c.definition(c.variableName)),
  "FunctionDefinition/Name": c.function(c.definition(c.variableName)),
  "ClassDeclaration/Name": c.definition(c.className),
  UpdateOp: c.updateOperator,
  ArithOp: c.arithmeticOperator,
  LogicOp: c.logicOperator,
  BitOp: c.bitwiseOperator,
  CompareOp: c.compareOperator,
  ControlOp: c.controlOperator,
  AssignOp: c.definitionOperator,
  "$ ConcatOp": c.operator,
  LineComment: c.lineComment,
  BlockComment: c.blockComment,
  Integer: c.integer,
  Float: c.float,
  String: c.string,
  ShellExpression: c.special(c.string),
  "=> ->": c.punctuation,
  "( )": c.paren,
  "#[ [ ]": c.squareBracket,
  "${ { }": c.brace,
  "-> ?->": c.derefOperator,
  ", ; :: : \\": c.separator,
  "PhpOpen PhpClose": c.processingInstruction
});
var Yk = { __proto__: null, static: 311, STATIC: 311, class: 333, CLASS: 333 };
var Zk = qe.deserialize({
  version: 14,
  states: "$GSQ`OWOOQhQaOOP%oO`OOOOO#t'#H_'#H_O%tO#|O'#DtOOO#u'#Dw'#DwQ&SOWO'#DwO&XO$VOOOOQ#u'#Dx'#DxO&lQaO'#D|O(mQdO'#E}O(tQdO'#EQO*kQaO'#EWO,zQ`O'#ETO-PQ`O'#E^O/nQaO'#E^O/uQ`O'#EfO/zQ`O'#EoO*kQaO'#EoO0VQ`O'#HhO0[Q`O'#E{O0[Q`O'#E{OOQS'#Ic'#IcO0aQ`O'#EvOOQS'#IZ'#IZO2oQdO'#IWO6tQeO'#FUO*kQaO'#FeO*kQaO'#FfO*kQaO'#FgO*kQaO'#FhO*kQaO'#FhO*kQaO'#FkOOQO'#Id'#IdO7RQ`O'#FqOOQO'#Hi'#HiO7ZQ`O'#HOO7uQ`O'#FlO8QQ`O'#H]O8]Q`O'#FvO8eQaO'#FwO*kQaO'#GVO*kQaO'#GYO8}OrO'#G]OOQS'#Iq'#IqOOQS'#Ip'#IpOOQS'#IW'#IWO,zQ`O'#GdO,zQ`O'#GfO,zQ`O'#GkOhQaO'#GmO9UQ`O'#GnO9ZQ`O'#GqO9`Q`O'#GtO9eQeO'#GuO9eQeO'#GvO9eQeO'#GwO9oQ`O'#GxO9tQ`O'#GzO9yQaO'#G{O<YQ`O'#G|O<_Q`O'#G}O<dQ`O'#G}O9oQ`O'#HOO<iQ`O'#HQO<nQ`O'#HRO<sQ`O'#HSO<xQ`O'#HVO=TQ`O'#HWO9yQaO'#H[OOQ#u'#IV'#IVOOQ#u'#Ha'#HaQhQaOOO=fQ`O'#HPO7pQ`O'#HPO=kO#|O'#DrPOOO)CCw)CCwOOO#t-E;]-E;]OOO#u,5:c,5:cOOO#u'#H`'#H`O&XO$VOOO=vQ$VO'#IUOOOO'#IU'#IUQOOOOOOOQ#y,5:h,5:hO=}QaO,5:hOOQ#u,5:j,5:jO@eQaO,5:mO@lQaO,5;UO*kQaO,5;UO@sQ`O,5;VOCbQaO'#EsOOQS,5;^,5;^OCiQ`O,5;jOOQP'#F]'#F]O*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qOOQ#u'#Im'#ImOOQS,5<q,5<qOOQ#u,5:l,5:lOEbQ`O,5:rOEiQdO'#E}OF]Q`O'#FlOFeQ`O'#FlOFmQ`O,5:oOFrQaO'#E_OOQS,5:x,5:xOHyQ`O'#I]O9yQaO'#EaO9yQaO'#I]OOQS'#I]'#I]OIQQ`O'#I[OIYQ`O,5:xO-UQaO,5:xOI_QaO'#EgOOQS,5;Q,5;QOOQS,5;Z,5;ZOIiQ`O,5;ZOOQO,5>S,5>SOJ[QdO,5;gOOQO-E;f-E;fOL^Q`O,5;gOLcQpO,5;bO0aQ`O'#EyOLkQtO'#E}OOQS'#Ez'#EzOOQS'#Ib'#IbOM`QaO,5:wO*kQaO,5;nOOQS,5;p,5;pO*kQaO,5;pOMgQdO,5<POMwQdO,5<QONXQdO,5<RONiQdO,5<SO!!sQdO,5<SO!!zQdO,5<VO!#[Q`O'#FrO!#gQ`O'#IgO!#oQ`O,5<]OOQO-E;g-E;gO!#tQ`O'#IoO<_Q`O,5=iO!#|Q`O,5=iO9oQ`O,5=jO!$RQ`O,5=nO!$WQ`O,5=kO!$]Q`O,5=kO!$bQ`O'#FnO!$xQ`O,5<WO!%TQ`O,5<WO!%WQ`O,5?ZO!%]Q`O,5<WO!%eQ`O,5<bO!%mQdO'#GPO!%{QdO'#InO!&WQdO,5=wO!&`Q`O,5<bO!%WQ`O,5<bO!&hQdO,5<cO!&xQ`O,5<cO!'lQdO,5<qO!)nQdO,5<tO!*OOrO'#HsOOOQ'#It'#ItO*kQaO'#GbOOOQ'#Hs'#HsO!*pOrO,5<wOOQS,5<w,5<wO!*wQaO,5=OO!+OQ`O,5=QO!+WQeO,5=VO!+bQ`O,5=XO!+gQaO'#GoO!+WQeO,5=YO9yQaO'#GrO!+WQeO,5=]O!&WQdO,5=`O(tQdO,5=aOOQ#u,5=a,5=aO(tQdO,5=bOOQ#u,5=b,5=bO(tQdO,5=cOOQ#u,5=c,5=cO!+nQ`O,5=dO!+vQ`O,5=fO!+{QdO'#IvOOQS'#Iv'#IvO!&WQdO,5=gO>UQaO,5=hO!-eQ`O'#F}O!-jQdO'#IlO!&WQdO,5=iOOQ#u,5=j,5=jO!-uQ`O,5=lO!-xQ`O,5=mO!-}Q`O,5=nO!.YQdO,5=qOOQ#u,5=q,5=qO!.eQ`O,5=rO!.eQ`O,5=rO!.mQdO'#IwO!.{Q`O'#HXO!&WQdO,5=rO!/ZQ`O,5=rO!/fQdO'#IYO!&WQdO,5=vOOQ#u-E;_-E;_O!1RQ`O,5=kOOO#u,5:^,5:^O!1^O#|O,5:^OOO#u-E;^-E;^OOOO,5>p,5>pOOQ#y1G0S1G0SO!1fQ`O1G0XO*kQaO1G0XO!2xQ`O1G0pOOQS1G0p1G0pO!4[Q`O1G0pOOQS'#I_'#I_O*kQaO'#I_OOQS1G0q1G0qO!4cQ`O'#IaO!7lQ`O'#E}O!7yQaO'#EuOOQO'#Ia'#IaO!8TQ`O'#I`O!8]Q`O,5;_OOQS'#FQ'#FQOOQS1G1U1G1UO!8bQdO1G1]O!:dQdO1G1]O!<PQdO1G1]O!=lQdO1G1]O!?XQdO1G1]O!@tQdO1G1]O!BaQdO1G1]O!C|QdO1G1]O!EiQdO1G1]O!GUQdO1G1]O!HqQdO1G1]O!J^QdO1G1]O!KyQdO1G1]O!MfQdO1G1]O# RQdO1G1]O#!nQdO1G1]OOQT1G0^1G0^O!%WQ`O,5<WO#$ZQaO'#EXOOQS1G0Z1G0ZO#$bQ`O,5:yOFuQaO,5:yO#$gQaO,5:}O#$nQdO,5:{O#&jQdO,5>wO#(fQaO'#HdO#(vQ`O,5>vOOQS1G0d1G0dO#)OQ`O1G0dO#)TQ`O'#I^O#*mQ`O'#I^O#*uQ`O,5;ROIbQaO,5;ROOQS1G0u1G0uPOQO'#E}'#E}O#+fQdO1G1RO0aQ`O'#HgO#-hQtO,5;cO#.YQaO1G0|OOQS,5;e,5;eO#0iQtO,5;gO#0vQdO1G0cO*kQaO1G0cO#2cQdO1G1YO#4OQdO1G1[OOQO,5<^,5<^O#4`Q`O'#HjO#4nQ`O,5?ROOQO1G1w1G1wO#4vQ`O,5?ZO!&WQdO1G3TO<_Q`O1G3TOOQ#u1G3U1G3UO#4{Q`O1G3YO!1RQ`O1G3VO#5WQ`O1G3VO#5]QpO'#FoO#5kQ`O'#FoO#5{Q`O'#FoO#6WQ`O'#FoO#6`Q`O'#FsO#6eQ`O'#FtOOQO'#If'#IfO#6lQ`O'#IeO#6tQ`O,5<YOOQS1G1r1G1rO0aQ`O1G1rO#6yQ`O1G1rO#7OQ`O1G1rO!%WQ`O1G4uO#7ZQdO1G4uO!%WQ`O1G1rO#7iQ`O1G1|O!%WQ`O1G1|O9yQaO,5<kO#7qQdO'#HqO#8PQdO,5?YOOQ#u1G3c1G3cO*kQaO1G1|O0aQ`O1G1|O#8[QdO1G1}O7RQ`O'#FyO7RQ`O'#FzO#:nQ`O'#F{OOQS1G1}1G1}O!-xQ`O1G1}O!1UQ`O1G1}O!1RQ`O1G1}O#;eO`O,5<xO#;jO`O,5<xO#;uO!bO,5<yO#<TQ`O,5<|OOOQ-E;q-E;qOOQS1G2c1G2cO#<[QaO'#GeO#<uQ$VO1G2jO#AuQ`O1G2jO#BQQ`O'#GgO#B]Q`O'#GjOOQ#u1G2l1G2lO#BhQ`O1G2lOOQ#u'#Gl'#GlOOQ#u'#Iu'#IuOOQ#u1G2q1G2qO#BmQ`O1G2qO,zQ`O1G2sO#BrQaO,5=ZO#ByQ`O,5=ZOOQ#u1G2t1G2tO#COQ`O1G2tO#CTQ`O,5=^OOQ#u1G2w1G2wO#DgQ`O1G2wOOQ#u1G2z1G2zOOQ#u1G2{1G2{OOQ#u1G2|1G2|OOQ#u1G2}1G2}O#DlQ`O'#HxO9oQ`O'#HxO#DqQ$VO1G3OO#IwQ`O1G3QO9yQaO'#HwO#I|QdO,5=[OOQ#u1G3R1G3RO#JXQ`O1G3SO9yQaO,5<iO#J^QdO'#HpO#JlQdO,5?WOOQ#u1G3T1G3TOOQ#u1G3W1G3WO!-xQ`O1G3WOOQ#u1G3X1G3XO#KfQ`O'#HTOOQ#u1G3Y1G3YO#KmQ`O1G3YO0aQ`O1G3YOOQ#u1G3]1G3]O!&WQdO1G3^O#KrQ`O1G3^O#KzQdO'#HzO#L]QdO,5?cO#LhQ`O,5?cO#LmQ`O'#HYO7RQ`O'#HYO#LxQ`O'#IxO#MQQ`O,5=sOOQ#u1G3^1G3^O!.eQ`O1G3^O!.eQ`O1G3^O#MVQeO'#HbO#MgQdO,5>tOOQ#u1G3b1G3bOOQ#u1G3V1G3VO!-xQ`O1G3VO!1UQ`O1G3VOOO#u1G/x1G/xO*kQaO7+%sO#MuQdO7+%sOOQS7+&[7+&[O$ bQ`O,5>yO>UQaO,5;`O$ iQ`O,5;aO$#OQaO'#HfO$#YQ`O,5>zOOQS1G0y1G0yO$#bQ`O'#EYO$#gQ`O'#IXO$#oQ`O,5:sOOQS1G0e1G0eO$#tQ`O1G0eO$#yQ`O1G0iO9yQaO1G0iOOQO,5>O,5>OOOQO-E;b-E;bOOQS7+&O7+&OO>UQaO,5;SO$%`QaO'#HeO$%jQ`O,5>xOOQS1G0m1G0mO$%rQ`O1G0mOOQS,5>R,5>ROOQS-E;e-E;eO$%wQdO7+&hO$'yQtO1G1RO$(WQdO7+%}OOQS1G0i1G0iOOQO,5>U,5>UOOQO-E;h-E;hOOQ#u7+(o7+(oO!&WQdO7+(oOOQ#u7+(t7+(tO#KmQ`O7+(tO0aQ`O7+(tOOQ#u7+(q7+(qO!-xQ`O7+(qO!1UQ`O7+(qO!1RQ`O7+(qO$)sQ`O,5<ZO$*OQ`O,5<ZO$*WQ`O,5<_O$*]QpO,5<ZO>UQaO,5<ZOOQO,5<_,5<_O$*kQpO,5<`O$*sQ`O,5<`O$+OQ`O'#HkO$+iQ`O,5?POOQS1G1t1G1tO$+qQpO7+'^O$+yQ`O'#FuO$,UQ`O7+'^OOQS7+'^7+'^O0aQ`O7+'^O#6yQ`O7+'^O$,^QdO7+*aO0aQ`O7+*aO$,lQ`O7+'^O*kQaO7+'hO0aQ`O7+'hO$,wQ`O7+'hO$-PQdO1G2VOOQS,5>],5>]OOQS-E;o-E;oO$.iQdO7+'hO$.yQpO7+'hO$/RQdO'#IiOOQO,5<e,5<eOOQO,5<f,5<fO$/dQpO'#GOO$/lQ`O'#GOOOQO'#Ik'#IkOOQO'#Ho'#HoO$0]Q`O'#GOO<_Q`O'#F|O!&WQdO'#GOO!.YQdO'#GQO7RQ`O'#GROOQO'#Ij'#IjOOQO'#Hn'#HnO$0yQ`O,5<gOOQ#y,5<g,5<gOOQS7+'i7+'iO!-xQ`O7+'iO!1UQ`O7+'iOOOQ1G2d1G2dO$1pO`O1G2dO$1uO!bO1G2eO$2TO`O'#G`O$2YO`O1G2eOOOQ1G2h1G2hO$2_QaO,5=PO,zQ`O'#HtO$2xQ$VO7+(UOhQaO7+(UO,zQ`O'#HuO$7xQ`O7+(UO!&WQdO7+(UO$8TQ`O7+(UO$8YQaO'#GhO$:iQ`O'#GiOOQO'#Hv'#HvO$:qQ`O,5=ROOQ#u,5=R,5=RO$:|Q`O,5=UO!&WQdO7+(WO!&WQdO7+(]O!&WQdO7+(_O$;XQaO1G2uO$;`Q`O1G2uO$;eQaO1G2uO!&WQdO7+(`O9yQaO1G2xO!&WQdO7+(cO0aQ`O'#GyO9oQ`O,5>dOOQ#u,5>d,5>dOOQ#u-E;v-E;vO$;lQaO7+(lO$<TQdO,5>cOOQS-E;u-E;uO!&WQdO7+(nO$=mQdO1G2TOOQS,5>[,5>[OOQS-E;n-E;nOOQ#u7+(r7+(rO$?nQ`O'#GQO$?uQ`O'#GQO$@ZQ`O'#HUOOQO'#Hy'#HyO$@`Q`O,5=oOOQ#u,5=o,5=oO$@gQpO7+(tOOQ#u7+(x7+(xO!&WQdO7+(xO$@rQdO,5>fOOQS-E;x-E;xO$AQQdO1G4}O$A]Q`O,5=tO$AbQ`O,5=tO$AmQ`O'#H{O$BRQ`O,5?dOOQS1G3_1G3_O#KrQ`O7+(xO$BZQdO,5=|OOQS-E;`-E;`O$CvQdO<<I_OOQS1G4e1G4eO$EcQ`O1G0zOOQO,5>Q,5>QOOQO-E;d-E;dO$8YQaO,5:tO$FxQaO'#HcO$GVQ`O,5>sOOQS1G0_1G0_OOQS7+&P7+&PO$G_Q`O7+&TO$HtQ`O1G0nO$JZQ`O,5>POOQO,5>P,5>POOQO-E;c-E;cOOQS7+&X7+&XOOQS7+&T7+&TOOQ#u<<LZ<<LZOOQ#u<<L`<<L`O$@gQpO<<L`OOQ#u<<L]<<L]O!-xQ`O<<L]O!1UQ`O<<L]O>UQaO1G1uO$KsQ`O1G1uO$LOQ`O1G1yOOQO1G1y1G1yO$LTQ`O1G1uO$L]Q`O1G1uO$MrQ`O1G1zO>UQaO1G1zOOQO,5>V,5>VOOQO-E;i-E;iOOQS<<Jx<<JxO$M}Q`O'#IhO$NVQ`O'#IhO$N[Q`O,5<aO0aQ`O<<JxO$+qQpO<<JxO$NaQ`O<<JxO0aQ`O<<M{O$NiQtO<<M{O#6yQ`O<<JxO$NwQdO<<KSO% XQpO<<KSO*kQaO<<KSO0aQ`O<<KSO% aQdO'#HmO% xQdO,5?TO!&WQdO,5<jO$/dQpO,5<jO%!ZQ`O,5<jO<_Q`O,5<hO!.YQdO,5<lOOQO-E;m-E;mO!&WQdO,5<hOOQO,5<j,5<jOOQO,5<l,5<lO%!tQdO,5<mOOQO-E;l-E;lOOQ#y1G2R1G2ROOQS<<KT<<KTO!-xQ`O<<KTOOOQ7+(O7+(OO%#PO`O7+(POOOO,5<z,5<zOOOQ7+(P7+(POhQaO,5>`OOQ#u-E;r-E;rOhQaO<<KpOOQ#u<<Kp<<KpO$8TQ`O,5>aOOQO-E;s-E;sO!&WQdO<<KpO$8TQ`O<<KpO%#UQ`O<<KpO%#ZQ`O,5=SO%$pQaO,5=TOOQO-E;t-E;tOOQ#u1G2m1G2mOOQ#u<<Kr<<KrOOQ#u<<Kw<<KwOOQ#u<<Ky<<KyOOQT7+(a7+(aO%%QQ`O7+(aO%%VQaO7+(aO%%^Q`O7+(aOOQ#u<<Kz<<KzO%%cQ`O7+(dO%&xQ`O7+(dOOQ#u<<K}<<K}O%&}QpO,5=eOOQ#u1G4O1G4OO%'YQ`O<<LWOOQ#u<<LY<<LYO$?uQ`O,5<lO%'_Q`O,5=pO%'dQdO,5=pOOQO-E;w-E;wOOQ#u1G3Z1G3ZO#KmQ`O<<L`OOQ#u<<Ld<<LdO%'oQ`O1G4QO%'tQdO7+*iOOQO1G3`1G3`O%(PQ`O1G3`O%(UQ`O'#HZO7RQ`O'#HZOOQO,5>g,5>gOOQO-E;y-E;yO!&WQdO<<LdO%(aQ`O1G0`OOQO,5=},5=}OOQO-E;a-E;aO>UQaO,5;TOOQ#uANAzANAzO#KmQ`OANAzOOQ#uANAwANAwO!-xQ`OANAwO%)vQ`O7+'aO>UQaO7+'aOOQO7+'e7+'eO%+]Q`O7+'aO%+hQ`O7+'eO>UQaO7+'fO%+mQ`O7+'fO%-SQ`O'#HlO%-bQ`O,5?SO%-bQ`O,5?SOOQO1G1{1G1{O$+qQpOAN@dOOQSAN@dAN@dO0aQ`OAN@dO%-jQtOANCgO%-xQ`OAN@dO*kQaOAN@nO%.QQdOAN@nO%.bQpOAN@nOOQS,5>X,5>XOOQS-E;k-E;kOOQO1G2U1G2UO!&WQdO1G2UO$/dQpO1G2UO<_Q`O1G2SO!.YQdO1G2WO!&WQdO1G2SOOQO1G2W1G2WOOQO1G2S1G2SO%.jQaO'#GSOOQO1G2X1G2XOOQSAN@oAN@oOOOQ<<Kk<<KkOOQ#u1G3z1G3zOOQ#uANA[ANA[OOQO1G3{1G3{O%0iQ`OANA[O!&WQdOANA[O%0nQaO1G2nO%1OQaO1G2oOOQT<<K{<<K{O%1`Q`O<<K{O%1eQaO<<K{O*kQaO,5=_OOQT<<LO<<LOOOQO1G3P1G3PO%1lQ`O1G3PO!+WQeOANArO%1qQdO1G3[OOQO1G3[1G3[O%1|Q`O1G3[OOQS7+)l7+)lOOQO7+(z7+(zO%2UQ`O,5=uO%2ZQ`O,5=uOOQ#uANBOANBOO%2fQ`O1G0oOOQ#uG27fG27fOOQ#uG27cG27cO%3{Q`O<<J{O>UQaO<<J{OOQO<<KP<<KPO%5bQ`O<<KQOOQO,5>W,5>WO%6wQ`O,5>WOOQO-E;j-E;jO%6|Q`O1G4nOOQSG26OG26OO$+qQpOG26OO0aQ`OG26OO%7UQdOG26YO*kQaOG26YOOQO7+'p7+'pO!&WQdO7+'pO!&WQdO7+'nOOQO7+'r7+'rOOQO7+'n7+'nO%7fQ`OLD+tO%8uQ`O'#E}O%9PQ`O'#IZO!&WQdO'#HrO%:|QaO,5<nOOQO,5<n,5<nO!&WQdOG26vOOQ#uG26vG26vO%<{QaO7+(YOOQTANAgANAgO%=]Q`OANAgO%=bQ`O1G2yOOQO7+(k7+(kOOQ#uG27^G27^O%=iQ`OG27^OOQO7+(v7+(vO%=nQ`O7+(vO!&WQdO7+(vOOQO1G3a1G3aO%=vQ`O1G3aO%={Q`OAN@gOOQO1G3r1G3rOOQSLD+jLD+jO$+qQpOLD+jO%?bQdOLD+tOOQO<<K[<<K[OOQO<<KY<<KYO%?rQ`O,5<oO%?wQ`O,5<pOOQP,5>^,5>^OOQP-E;p-E;pOOQO1G2Y1G2YOOQ#uLD,bLD,bOOQTG27RG27RO!&WQdOLD,xO!&WQdO<<LbOOQO<<Lb<<LbOOQO7+({7+({OOQS!$( U!$( UOOQS1G2Z1G2ZOOQS1G2[1G2[O%@PQdO1G2[OOQ#u!$(!d!$(!dOOQOANA|ANA|OOQS7+'v7+'vO%@[Q`O'#E{O%@[Q`O'#E{O%@aQ`O,5;gO%@fQdO,5<cO%BbQaO,5:}O*kQaO1G0iO%BiQaO'#FwO#.YQaO'#GVO#.YQaO'#GYO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO%BpQdO'#I]O%D`QdO'#I]O#.YQaO'#EaO#.YQaO'#I]O%FbQaO,5:wO#.YQaO,5;nO#.YQaO,5;pO%FiQdO,5<PO%HeQdO,5<QO%JaQdO,5<RO%L]QdO,5<SO%NXQdO,5<SO%NoQdO,5<VO&!kQdO,5<tO#.YQaO1G0XO&$gQdO1G1]O&&cQdO1G1]O&(_QdO1G1]O&*ZQdO1G1]O&,VQdO1G1]O&.RQdO1G1]O&/}QdO1G1]O&1yQdO1G1]O&3uQdO1G1]O&5qQdO1G1]O&7mQdO1G1]O&9iQdO1G1]O&;eQdO1G1]O&=aQdO1G1]O&?]QdO1G1]O&AXQdO,5:{O&CTQdO,5>wO&EPQdO1G0cO#.YQaO1G0cO&F{QdO1G1YO&HwQdO1G1[O#.YQaO1G1|O#.YQaO7+%sO&JsQdO7+%sO&LoQdO7+%}O#.YQaO7+'hO&NkQdO7+'hO'!gQdO<<I_O'$cQdO<<KSO#.YQaO<<KSO#.YQaOAN@nO'&_QdOAN@nO'(ZQdOG26YO#.YQaOG26YO'*VQdOLD+tO',RQaO,5:}O'.QQaO1G0iO'/|QdO'#IWO'0aQeO'#FUO'4aQeO'#FUO#.YQaO'#FeO'.QQaO'#FeO#.YQaO'#FfO'.QQaO'#FfO#.YQaO'#FgO'.QQaO'#FgO#.YQaO'#FhO'.QQaO'#FhO#.YQaO'#FhO'.QQaO'#FhO#.YQaO'#FkO'.QQaO'#FkO'8gQaO,5:mO'8nQ`O,5<bO'8vQ`O1G0XO'.QQaO1G0|O':YQ`O1G1|O':bQ`O7+'hO':jQpO7+'hO':rQpO<<KSO':zQpOAN@nO';SQaO'#FwO'.QQaO'#GVO'.QQaO'#GYO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO'#EaO'.QQaO'#I]O'=RQaO,5:wO'.QQaO,5;nO'.QQaO,5;pO'?QQdO,5<PO'ASQdO,5<QO'CUQdO,5<RO'EWQdO,5<SO'GYQdO,5<SO'GvQdO,5<VO'IxQdO,5<tO'.QQaO1G0XO'KzQdO1G1]O'M|QdO1G1]O(!OQdO1G1]O($QQdO1G1]O(&SQdO1G1]O((UQdO1G1]O(*WQdO1G1]O(,YQdO1G1]O(.[QdO1G1]O(0^QdO1G1]O(2`QdO1G1]O(4bQdO1G1]O(6dQdO1G1]O(8fQdO1G1]O(:hQdO1G1]O(<jQdO,5:{O(>lQdO,5>wO(@nQdO1G0cO'.QQaO1G0cO(BpQdO1G1YO(DrQdO1G1[O'.QQaO1G1|O'.QQaO7+%sO(FtQdO7+%sO(HvQdO7+%}O'.QQaO7+'hO(JxQdO7+'hO(LzQdO<<I_O(N|QdO<<KSO'.QQaO<<KSO'.QQaOAN@nO)#OQdOAN@nO)%QQdOG26YO'.QQaOG26YO)'SQdOLD+tO))UQaO,5:}O#.YQaO1G0iO))]Q`O'#FvO))eQpO,5;bO))mQ`O,5<bO!%WQ`O,5<bO!%WQ`O1G1|O0aQ`O1G1|O0aQ`O7+'hO0aQ`O<<KSO))uQdO,5<cO)+wQdO'#I]O)-vQdO'#IWO).aQaO,5:mO).hQ`O,5<bO).pQ`O1G0XO)0SQ`O1G1|O)0[Q`O7+'hO)0dQpO7+'hO)0lQpO<<KSO)0tQpOAN@nO0aQ`O'#EvO9yQaO'#FeO9yQaO'#FfO9yQaO'#FgO9yQaO'#FhO9yQaO'#FhO9yQaO'#FkO)0|QaO'#FwO9yQaO'#GVO9yQaO'#GYO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO)1TQ`O'#FlO*kQaO'#EaO*kQaO'#I]O)1]QaO,5:wO9yQaO,5;nO9yQaO,5;pO)1dQdO,5<PO)3`QdO,5<QO)5[QdO,5<RO)7WQdO,5<SO)9SQdO,5<SO)9jQdO,5<VO);fQdO,5<cO)=bQdO,5<tO)?^Q`O'#IvO)@sQ`O'#IYO9yQaO1G0XO)BYQdO1G1]O)DUQdO1G1]O)FQQdO1G1]O)G|QdO1G1]O)IxQdO1G1]O)KtQdO1G1]O)MpQdO1G1]O* lQdO1G1]O*#hQdO1G1]O*%dQdO1G1]O*'`QdO1G1]O*)[QdO1G1]O*+WQdO1G1]O*-SQdO1G1]O*/OQdO1G1]O*0zQaO,5:}O*1RQdO,5:{O*1cQdO,5>wO*1sQaO'#HdO*2TQ`O,5>vO*2]QdO1G0cO9yQaO1G0cO*4XQdO1G1YO*6TQdO1G1[O9yQaO1G1|O>UQaO'#HwO*8PQ`O,5=[O*8XQaO'#HbO*8cQ`O,5>tO9yQaO7+%sO*8kQdO7+%sO*:gQ`O1G0iO>UQaO1G0iO*;|QdO7+%}O9yQaO7+'hO*=xQdO7+'hO*?tQ`O,5>cO*AZQ`O,5=|O*BpQdO<<I_O*DlQ`O7+&TO*FRQdO<<KSO9yQaO<<KSO9yQaOAN@nO*G}QdOAN@nO*IyQdOG26YO9yQaOG26YO*KuQdOLD+tO*MqQaO,5:}O9yQaO1G0iO*MxQdO'#I]O*NcQ`O'#FvO*NkQ`O,5<bO!%WQ`O,5<bO!%WQ`O1G1|O0aQ`O1G1|O0aQ`O7+'hO0aQ`O<<KSO*NsQdO'#IWO+ ^QeO'#FUO+ zQaO'#FUO+#sQaO'#FUO+%`QaO'#FUO>UQaO'#FeO>UQaO'#FfO>UQaO'#FgO>UQaO'#FhO>UQaO'#FhO>UQaO'#FkO+'XQaO'#FwO>UQaO'#GVO>UQaO'#GYO+'`QaO,5:mO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO+'gQ`O'#I]O$8YQaO'#EaO+)PQaOG26YO$8YQaO'#I]O+*{Q`O'#I[O++TQaO,5:wO>UQaO,5;nO>UQaO,5;pO++[Q`O,5<PO+,wQ`O,5<QO+.dQ`O,5<RO+0PQ`O,5<SO+1lQ`O,5<SO+3XQ`O,5<VO+4tQ`O,5<bO+4|Q`O,5<cO+6iQ`O,5<tO+8UQ`O1G0XO>UQaO1G0XO+9hQ`O1G1]O+;TQ`O1G1]O+<pQ`O1G1]O+>]Q`O1G1]O+?xQ`O1G1]O+AeQ`O1G1]O+CQQ`O1G1]O+DmQ`O1G1]O+FYQ`O1G1]O+GuQ`O1G1]O+IbQ`O1G1]O+J}Q`O1G1]O+LjQ`O1G1]O+NVQ`O1G1]O, rQ`O1G1]O,#_Q`O1G0cO>UQaO1G0cO,$zQ`O1G1YO,&gQ`O1G1[O,(SQ`O1G1|O>UQaO1G1|O>UQaO7+%sO,([Q`O7+%sO,)wQ`O7+%}O>UQaO7+'hO,+dQ`O7+'hO,+lQ`O7+'hO,-XQpO7+'hO,-aQ`O<<I_O,.|Q`O<<KSO,0iQpO<<KSO>UQaO<<KSO>UQaOAN@nO,0qQ`OAN@nO,2^QpOAN@nO,2fQ`OG26YO>UQaOG26YO,4RQ`OLD+tO,5nQaO,5:}O>UQaO1G0iO,5uQ`O'#I]O$8YQaO'#FeO$8YQaO'#FfO$8YQaO'#FgO$8YQaO'#FhO$8YQaO'#FhO+)PQaO'#FhO$8YQaO'#FkO,6SQaO'#FwO,6ZQaO'#FwO$8YQaO'#GVO+)PQaO'#GVO$8YQaO'#GYO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO,8YQ`O'#FlO>UQaO'#EaO>UQaO'#I]O,8bQaO,5:wO,8iQaO,5:wO$8YQaO,5;nO+)PQaO,5;nO$8YQaO,5;pO,:hQ`O,5<PO,<TQ`O,5<QO,=pQ`O,5<RO,?]Q`O,5<SO,@xQ`O,5<SO,BeQ`O,5<SO,CtQ`O,5<VO,EaQ`O,5<cO%7fQ`O,5<cO,F|Q`O,5<tO$8YQaO1G0XO+)PQaO1G0XO,HiQ`O1G1]O,JUQ`O1G1]O,KeQ`O1G1]O,MQQ`O1G1]O,NaQ`O1G1]O- |Q`O1G1]O-#]Q`O1G1]O-$xQ`O1G1]O-&XQ`O1G1]O-'tQ`O1G1]O-)TQ`O1G1]O-*pQ`O1G1]O-,PQ`O1G1]O--lQ`O1G1]O-.{Q`O1G1]O-0hQ`O1G1]O-1wQ`O1G1]O-3dQ`O1G1]O-4sQ`O1G1]O-6`Q`O1G1]O-7oQ`O1G1]O-9[Q`O1G1]O-:kQ`O1G1]O-<WQ`O1G1]O-=gQ`O1G1]O-?SQ`O1G1]O-@cQ`O1G1]O-BOQ`O1G1]O-C_Q`O1G1]O-DzQ`O1G1]O-FZQ`O,5:{O-GvQ`O,5>wO-IcQ`O1G0cO-KOQ`O1G0cO$8YQaO1G0cO+)PQaO1G0cO-L_Q`O1G1YO-MzQ`O1G1YO. ZQ`O1G1[O$8YQaO1G1|O$8YQaO7+%sO+)PQaO7+%sO.!vQ`O7+%sO.$cQ`O7+%sO.%rQ`O7+%}O.'_Q`O7+%}O$8YQaO7+'hO.(nQ`O7+'hO.*ZQ`O<<I_O.+vQ`O<<I_O.-VQ`O<<KSO$8YQaO<<KSO$8YQaOAN@nO..rQ`OAN@nO.0_Q`OG26YO$8YQaOG26YO.1zQ`OLD+tO.3gQaO,5:}O.3nQaO,5:}O$8YQaO1G0iO+)PQaO1G0iO.5mQ`O'#I]O.7PQ`O'#I]O.:fQ`O'#IWO.:vQ`O'#FvO.;OQaO,5:mO.;VQ`O,5<bO.;_Q`O,5<bO!%WQ`O,5<bO.;gQ`O1G0XO.<yQ`O,5:{O.>fQ`O,5>wO.@RQ`O1G1|O!%WQ`O1G1|O0aQ`O1G1|O0aQ`O7+'hO.@ZQ`O7+'hO.@cQpO7+'hO.@kQpO<<KSO0aQ`O<<KSO.@sQpOAN@nO.@{Q`O'#IWO.A]Q`O'#IWO.CSQaO,5:mO.CZQaO,5:mO.CbQ`O,5<bO.CjQ`O7+'hO.CrQ`O1G0XO.EUQ`O1G0XO.FhQ`O1G1|O.FpQ`O7+'hO.FxQpO7+'hO.GQQpOAN@nO.GYQpO<<KSO.GbQpOAN@nO.GjQ`O'#FvO.GrQ`O'#FlO.GzQ`O,5<bO!%WQ`O,5<bO!%WQ`O1G1|O0aQ`O1G1|O0aQ`O7+'hO0aQ`O<<KSO.HSQ`O'#FvO.H[Q`O,5<bO.HdQ`O,5<bO!%WQ`O,5<bO!%WQ`O1G1|O!%WQ`O1G1|O0aQ`O1G1|O0aQ`O<<KSO0aQ`O7+'hO0aQ`O<<KSO.HlQ`O'#FlO.HtQ`O'#FlO.H|Q`O'#Fl",
  stateData: ".Ic~O!dOS!eOS&vOS!gQQ~O!iTO&wRO~OPgOQ|OS!lOU^OW}OX!XO[mO]!_O^!WO`![Oa!SOb!]Ok!dOm!lOowOp!TOq!UOsuOt!gOu!VOv!POxkOykO|!bO}`O!O]O!P!eO!QxO!R}O!TpO!UlO!VlO!W!YO!X!QO!YzO!Z!cO![!ZO!]!^O!^!fO!`!`O!a!RO!cjO!mWO!oXO!sYO!y[O#W_O#bhO#daO#ebO#peO$ToO$]nO$^oO$aqO$drO$l!kO$zyO${!OO$}}O%O}O%V|O'g{O~O!g!mO~O&wRO!i!hX&p!hX&t!hX~O!i!pO~O!d!qO!e!qO!g!mO&t!tO&v!qO~PhO!n!vO~PhOT'VXz'VX!S'VX!b'VX!m'VX!o'VX!v'VX!y'VX#S'VX#W'VX#`'VX#a'VX#p#qX#s'VX#z'VX#{'VX#|'VX#}'VX$O'VX$Q'VX$R'VX$S'VX$T'VX$U'VX$V'VX$W'VX$z'VX&s'VX~O!q!xO~P&sOT#TOz#RO!S#UO!b#VO!m#cO!o!{O!v!yO!y!}O#S#QO#W!zO#`!|O#a!|O#s#PO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dO&s#cO~OPgOQ|OU^OW}O[mOowOs#hOxkOykO}`O!O]O!QxO!R}O!TpO!UlO!VlO!YzO!cjO!s#gO!y[O#W_O#bhO#daO#ebO#peO$ToO$]nO$^oO$aqO$zyO${!OO$}}O%O}O%V|O'g{O~O!y[O~O!y#kO~OP6]OQ|OU^OW}O[6`Oo=YOs#hOx6^Oy6^O}`O!O]O!Q6dO!R}O!T6cO!U6_O!V6_O!Y6fO!c8fO!s#gO!y[O#S#oO#U#nO#W_O#bhO#daO#ebO#peO$T6bO$]6aO$^6bO$aqO$z6eO${!OO$}}O%O}O%V|O'g{O#X'OP~O!}#sO~P-UO!y#tO~O#b#vO#daO#ebO~O#p#xO~O!s#yO~OU$PO!R$PO!s$OO!v#}O#p2XO~OT&zXz&zX!S&zX!b&zX!m&zX!o&zX!v&zX!y&zX#S&zX#W&zX#`&zX#a&zX#s&zX#z&zX#{&zX#|&zX#}&zX$O&zX$Q&zX$R&zX$S&zX$T&zX$U&zX$V&zX$W&zX$z&zX&s&zX!x&zX!n&zX~O#u$RO#w$SO~P0rOP6]OQ|OU^OW}O[6`Oo=YOs#hOx6^Oy6^O}`O!O]O!Q6dO!R}O!T6cO!U6_O!V6_O!Y6fO!c8fO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T6bO$]6aO$^6bO$aqO$z6eO${!OO$}}O%O}O%V|O'g{OT#xXz#xX!S#xX!b#xX!m#xX!o#xX!v#xX#`#xX#a#xX#s#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX&s#xX!x#xX!n#xX~Or$UO#S6yO#U6xO~P2yO!s#gO#peO~OS$gO]$bOk$eOm$gOs$aO!`$cO$drO$l$fO~O!s$kO!y$hO#S$jO~Oo$mOs$lO#b$nO~O!y$hO#S$rO~O$l$tO~P*kOR$zO!o$yO#b$xO#e$yO&q$zO~O'f$|O~P8lO!y%RO~O!y%TO~O!s%VO~O!m#cO&s#cO~P*kO!oXO~O!y%_O~OP6]OQ|OU^OW}O[6`Oo=YOs#hOx6^Oy6^O}`O!O]O!Q6dO!R}O!T6cO!U6_O!V6_O!Y6fO!c8fO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T6bO$]6aO$^6bO$aqO$z6eO${!OO$}}O%O}O%V|O'g{O~O!y%cO~O!s%dO~O]$bO~O!s%hO~O!s%iO~O!s%jO~O!oXO!s#gO#peO~O]%rOs%rO!o%pO!s#gO#p%nO~O!s%vO~O!i%wO&t%wO&wRO~O&t%zO~PhO!n%{O~PhOPgOQ|OU^OW}O[8lOo=yOs#hOx8jOy8jO}`O!O]O!Q8pO!R}O!T8oO!U8kO!V8kO!Y8rO!c8iO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T8nO$]8mO$^8nO$aqO$z8qO${!OO$}}O%O}O%V|O'g{O~O!q%}O~P>UO#X&PO~P>UO!o&SO!s&RO#b&RO~OPgOQ|OU^OW}O[8lOo=yOs#hOx8jOy8jO}`O!O]O!Q8pO!R}O!T8oO!U8kO!V8kO!Y8rO!c8iO!s&VO!y[O#U&WO#W_O#bhO#daO#ebO#peO$T8nO$]8mO$^8nO$aqO$z8qO${!OO$}}O%O}O%V|O'g{O~O!x'SP~PAOO!s&[O#b&[O~OT#TOz#RO!S#UO!b#VO!o!{O!v!yO!y!}O#S#QO#W!zO#`!|O#a!|O#s#PO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dO~O!x&nO~PCqO!x'VX!}'VX#O'VX#X'VX!n'VXV'VX!q'VX#u'VX#w'VXw'VX~P&sO!y$hO#S&oO~Oo$mOs$lO~O!o&pO~O!}&sO#S;dO#U;cO!x'OP~P9yOT6iOz6gO!S6jO!b6kO!o!{O!v8sO!y!}O#S#QO#W!zO#`!|O#a!|O#s#PO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}'PX#X'PX~O#O&tO~PGSO!}&wO#X'OX~O#X&yO~O!}'OO!x'QP~P9yO!n'PO~PCqO!m#oa!o#oa#S#oa#p#qX&s#oa!x#oa#O#oaw#oa~OT#oaz#oa!S#oa!b#oa!v#oa!y#oa#W#oa#`#oa#a#oa#s#oa#z#oa#{#oa#|#oa#}#oa$O#oa$Q#oa$R#oa$S#oa$T#oa$U#oa$V#oa$W#oa$z#oa!}#oa#X#oa!n#oaV#oa!q#oa#u#oa#w#oa~PIpO!s'RO~O!x'UO#l'SO~O!x'VX#l'VX#p#qX#S'VX#U'VX#b'VX!o'VX#O'VXw'VX!m'VX&s'VX~O#S'YO~P*kO!m$Xa&s$Xa!x$Xa!n$Xa~PCqO!m$Ya&s$Ya!x$Ya!n$Ya~PCqO!m$Za&s$Za!x$Za!n$Za~PCqO!m$[a&s$[a!x$[a!n$[a~PCqO!o!{O!y!}O#W!zO#`!|O#a!|O#s#PO$z#dOT$[a!S$[a!b$[a!m$[a!v$[a#S$[a#z$[a#{$[a#|$[a#}$[a$O$[a$Q$[a$R$[a$S$[a$T$[a$U$[a$V$[a$W$[a&s$[a!x$[a!n$[a~Oz#RO~PNyO!m$_a&s$_a!x$_a!n$_a~PCqO!y!}O!}$fX#X$fX~O!}'^O#X'ZX~O#X'`O~O!s$kO#S'aO~O]'cO~O!s'eO~O!s'fO~O$l'gO~O!`'mO#S'kO#U'lO#b'jO$drO!x'XP~P0aO!^'sO!oXO!q'rO~O!s'uO!y$hO~O!y$hO#S'wO~O!y$hO#S'yO~O#u'zO!m$sX!}$sX&s$sX~O!}'{O!m'bX&s'bX~O!m#cO&s#cO~O!q(PO#O(OO~O!m$ka&s$ka!x$ka!n$ka~PCqOl(ROw(SO!o(TO!y!}O~O!o!{O!y!}O#W!zO#`!|O#a!|O#s#PO~OT$yaz$ya!S$ya!b$ya!m$ya!v$ya#S$ya#z$ya#{$ya#|$ya#}$ya$O$ya$Q$ya$R$ya$S$ya$T$ya$U$ya$V$ya$W$ya$z$ya&s$ya!x$ya!}$ya#O$ya#X$ya!n$ya!q$yaV$ya#u$ya#w$ya~P!'WO!m$|a&s$|a!x$|a!n$|a~PCqO#W([O#`(YO#a(YO&r(ZOR&gX!o&gX#b&gX#e&gX&q&gX'f&gX~O'f(_O~P8lO!q(`O~PhO!o(cO!q(dO~O!q(`O&s(gO~PhO!a(kO~O!m(lO~P9yOZ(wOn(xO~O!s(zO~OT6iOz6gO!S6jO!b6kO!v8sO!}({O#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m'jX&s'jX~P!'WO#u)PO~O!})QO!m'`X&s'`X~Ol(RO!o(TO~Ow(SO!o)WO!q)ZO~O!m#cO!oXO&s#cO~O!o%pO!s#yO~OV)aO!})_O!m'kX&s'kX~O])cOs)cO!s#gO#peO~O!o%pO!s#gO#p)hO~OT6iOz6gO!S6jO!b6kO!v8sO!})iO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m&|X&s&|X#O&|X~P!'WOl(ROw(SO!o(TO~O!i)oO&t)oO~OT8vOz8tO!S8wO!b8xO!q)pO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#X)rO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WO!n)rO~PCqOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x'TX!}'TX~P!'WOT'VXz'VX!S'VX!b'VX!o'VX!v'VX!y'VX#S'VX#W'VX#`'VX#a'VX#p#qX#s'VX#z'VX#{'VX#|'VX#}'VX$O'VX$Q'VX$R'VX$S'VX$T'VX$U'VX$V'VX$W'VX$z'VX~O!q)tO!x'VX!}'VX~P!5xO!x#iX!}#iX~P>UO!})vO!x'SX~O!x)xO~O$z#dOT#yiz#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi$W#yi&s#yi!x#yi!}#yi#O#yi#X#yi!n#yi!q#yiV#yi#u#yi#w#yi~P!'WOz#RO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi&s#yi!x#yi!n#yi~P!'WOz#RO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi&s#yi!x#yi!n#yi~P!'WOT#TOz#RO!b#VO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dO!S#yi!m#yi&s#yi!x#yi!n#yi~P!'WOT#TOz#RO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dO!S#yi!b#yi!m#yi&s#yi!x#yi!n#yi~P!'WOz#RO#S#QO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#z#yi#{#yi&s#yi!x#yi!n#yi~P!'WOz#RO#S#QO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#z#yi#{#yi#|#yi&s#yi!x#yi!n#yi~P!'WOz#RO#S#QO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#z#yi#{#yi#|#yi#}#yi&s#yi!x#yi!n#yi~P!'WOz#RO#S#QO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#z#yi#{#yi#|#yi#}#yi$O#yi&s#yi!x#yi!n#yi~P!'WOz#RO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi&s#yi!x#yi!n#yi~P!'WOz#RO$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi&s#yi!x#yi!n#yi~P!'WOz#RO$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi&s#yi!x#yi!n#yi~P!'WOz#RO$T#`O$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi&s#yi!x#yi!n#yi~P!'WOz#RO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi&s#yi!x#yi!n#yi~P!'WOz#RO$S#_O$T#`O$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi&s#yi!x#yi!n#yi~P!'WOz#RO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi&s#yi!x#yi!n#yi~P!'WO_)yO~P9yO!x)|O~O#S*PO~P9yOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}#Ta#X#Ta#O#Ta!m#Ta&s#Ta!x#Ta!n#TaV#Ta!q#Ta~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}'Pa#X'Pa#O'Pa!m'Pa&s'Pa!x'Pa!n'PaV'Pa!q'Pa~P!'WO#S#oO#U#nO!}&WX#X&WX~P9yO!}&wO#X'Oa~O#X*SO~OT6iOz6gO!S6jO!b6kO!v8sO!}*UO#O*TO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!x'QX~P!'WO!}*UO!x'QX~O!x*WO~O!m#oi!o#oi#S#oi#p#qX&s#oi!x#oi#O#oiw#oi~OT#oiz#oi!S#oi!b#oi!v#oi!y#oi#W#oi#`#oi#a#oi#s#oi#z#oi#{#oi#|#oi#}#oi$O#oi$Q#oi$R#oi$S#oi$T#oi$U#oi$V#oi$W#oi$z#oi!}#oi#X#oi!n#oiV#oi!q#oi#u#oi#w#oi~P#*zO#l'SO!x#ka#S#ka#U#ka#b#ka!o#ka#O#kaw#ka!m#ka&s#ka~OPgOQ|OU^OW}O[4OOo5xOs#hOx3zOy3zO}`O!O]O!Q2^O!R}O!T4UO!U3|O!V3|O!Y2`O!c3xO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T4SO$]4QO$^4SO$aqO$z2_O${!OO$}}O%O}O%V|O'g{O~O#l#oa#U#oa#b#oa~PIpOz#RO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#Pi!S#Pi!b#Pi!m#Pi&s#Pi!x#Pi!n#Pi~P!'WOz#RO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#vi!S#vi!b#vi!m#vi&s#vi!x#vi!n#vi~P!'WO!m#xi&s#xi!x#xi!n#xi~PCqO!s#gO#peO!}&^X#X&^X~O!}'^O#X'Za~O!s'uO~Ow(SO!o)WO!q*fO~O!s*jO~O#S*lO#U*mO#b*kO#l'SO~O#S*lO#U*mO#b*kO$drO~P0aO#u*oO!x$cX!}$cX~O#U*mO#b*kO~O#b*pO~O#b*rO~P0aO!}*sO!x'XX~O!x*uO~O!y*wO~O!^*{O!oXO!q*zO~O!q*}O!o'ci!m'ci&s'ci~O!q+QO#O+PO~O#b$nO!m&eX!}&eX&s&eX~O!}'{O!m'ba&s'ba~OT$kiz$ki!S$ki!b$ki!m$ki!o$ki!v$ki!y$ki#S$ki#W$ki#`$ki#a$ki#s$ki#u#fa#w#fa#z$ki#{$ki#|$ki#}$ki$O$ki$Q$ki$R$ki$S$ki$T$ki$U$ki$V$ki$W$ki$z$ki&s$ki!x$ki!}$ki#O$ki#X$ki!n$ki!q$kiV$ki~OS+^O]+aOm+^Os$aO!^+dO!_+^O!`+^O!n+hO#b$nO$aqO$drO~P0aO!s+lO~O#W+nO#`+mO#a+mO~O!s+pO#b+pO$}+pO%T+oO~O!n+qO~PCqOc%XXd%XXh%XXj%XXf%XXg%XXe%XX~PhOc+uOd+sOP%WiQ%WiS%WiU%WiW%WiX%Wi[%Wi]%Wi^%Wi`%Wia%Wib%Wik%Wim%Wio%Wip%Wiq%Wis%Wit%Wiu%Wiv%Wix%Wiy%Wi|%Wi}%Wi!O%Wi!P%Wi!Q%Wi!R%Wi!T%Wi!U%Wi!V%Wi!W%Wi!X%Wi!Y%Wi!Z%Wi![%Wi!]%Wi!^%Wi!`%Wi!a%Wi!c%Wi!m%Wi!o%Wi!s%Wi!y%Wi#W%Wi#b%Wi#d%Wi#e%Wi#p%Wi$T%Wi$]%Wi$^%Wi$a%Wi$d%Wi$l%Wi$z%Wi${%Wi$}%Wi%O%Wi%V%Wi&p%Wi'g%Wi&t%Wi!n%Wih%Wij%Wif%Wig%WiY%Wi_%Wii%Wie%Wi~Oc+yOd+vOh+xO~OY+zO_+{O!n,OO~OY+zO_+{Oi%^X~Oi,QO~Oj,RO~O!m,TO~P9yO!m,VO~Of,WO~OT6iOV,XOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO~P!'WOg,YO~O!y,ZO~OZ(wOn(xOP%liQ%liS%liU%liW%liX%li[%li]%li^%li`%lia%lib%lik%lim%lio%lip%liq%lis%lit%liu%liv%lix%liy%li|%li}%li!O%li!P%li!Q%li!R%li!T%li!U%li!V%li!W%li!X%li!Y%li!Z%li![%li!]%li!^%li!`%li!a%li!c%li!m%li!o%li!s%li!y%li#W%li#b%li#d%li#e%li#p%li$T%li$]%li$^%li$a%li$d%li$l%li$z%li${%li$}%li%O%li%V%li&p%li'g%li&t%li!n%lic%lid%lih%lij%lif%lig%liY%li_%lii%lie%li~O#u,_O~O!}({O!m%da&s%da~O!x,bO~O!s%dO!m&dX!}&dX&s&dX~O!})QO!m'`a&s'`a~OS+^OY,iOm+^Os$aO!^+dO!_+^O!`+^O$aqO$drO~O!n,lO~P#JwO!o)WO~O!o%pO!s'RO~O!s#gO#peO!m&nX!}&nX&s&nX~O!})_O!m'ka&s'ka~O!s,rO~OV,sO!n%|X!}%|X~O!},uO!n'lX~O!n,wO~O!m&UX!}&UX&s&UX#O&UX~P9yO!})iO!m&|a&s&|a#O&|a~Oz#RO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT!uq!S!uq!b!uq!m!uq!v!uq&s!uq!x!uq!n!uq~P!'WO!n,|O~PCqOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#ia!}#ia~P!'WO!x&YX!}&YX~PAOO!})vO!x'Sa~O#O-QO~O!}-RO!n&{X~O!n-TO~O!x-UO~OT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}#Vi#X#Vi~P!'WO!x&XX!}&XX~P9yO!}*UO!x'Qa~O!x-[O~OT#jqz#jq!S#jq!b#jq!m#jq!v#jq#S#jq#u#jq#w#jq#z#jq#{#jq#|#jq#}#jq$O#jq$Q#jq$R#jq$S#jq$T#jq$U#jq$V#jq$W#jq$z#jq&s#jq!x#jq!}#jq#O#jq#X#jq!n#jq!q#jqV#jq~P!'WO#l#oi#U#oi#b#oi~P#*zOz#RO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#Pq!S#Pq!b#Pq!m#Pq&s#Pq!x#Pq!n#Pq~P!'WO#u-dO!x$ca!}$ca~O#U-fO#b-eO~O#b-gO~O#S-hO#U-fO#b-eO#l'SO~O#b-jO#l'SO~O#u-kO!x$ha!}$ha~O!`'mO#S'kO#U'lO#b'jO$drO!x&_X!}&_X~P0aO!}*sO!x'Xa~O!oXO#l'SO~O#S-pO#b-oO!x'[P~O!oXO!q-rO~O!q-uO!o'cq!m'cq&s'cq~O!^-wO!oXO!q-rO~O!q-{O#O-zO~OT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m$si!}$si&s$si~P!'WO!m$jq&s$jq!x$jq!n$jq~PCqO#O-zO#l'SO~O!}-|Ow']X!o']X!m']X&s']X~O#b$nO#l'SO~OS+^O].ROm+^Os$aO!_+^O!`+^O#b$nO$aqO$drO~P0aOS+^O].ROm+^Os$aO!_+^O!`+^O#b$nO$aqO~P0aOS+^O]+aOm+^Os$aO!^+dO!_+^O!`+^O!n.ZO#b$nO$aqO$drO~P0aO!s.^O~O!s._O#b._O$}._O%T+oO~O$}.`O~O#X.aO~Oc%Xad%Xah%Xaj%Xaf%Xag%Xae%Xa~PhOc.dOd+sOP%WqQ%WqS%WqU%WqW%WqX%Wq[%Wq]%Wq^%Wq`%Wqa%Wqb%Wqk%Wqm%Wqo%Wqp%Wqq%Wqs%Wqt%Wqu%Wqv%Wqx%Wqy%Wq|%Wq}%Wq!O%Wq!P%Wq!Q%Wq!R%Wq!T%Wq!U%Wq!V%Wq!W%Wq!X%Wq!Y%Wq!Z%Wq![%Wq!]%Wq!^%Wq!`%Wq!a%Wq!c%Wq!m%Wq!o%Wq!s%Wq!y%Wq#W%Wq#b%Wq#d%Wq#e%Wq#p%Wq$T%Wq$]%Wq$^%Wq$a%Wq$d%Wq$l%Wq$z%Wq${%Wq$}%Wq%O%Wq%V%Wq&p%Wq'g%Wq&t%Wq!n%Wqh%Wqj%Wqf%Wqg%WqY%Wq_%Wqi%Wqe%Wq~Oc.iOd+vOh.hO~O!q(`O~OP6]OQ|OU^OW}O[:fOo>ROs#hOx:dOy:dO}`O!O]O!Q:kO!R}O!T:jO!U:eO!V:eO!Y:oO!c8gO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T:hO$]:gO$^:hO$aqO$z:mO${!OO$}}O%O}O%V|O'g{O~O!m.lO!q.lO~OY+zO_+{O!n.nO~OY+zO_+{Oi%^a~O!x.rO~P>UO!m.tO~O!m.tO~P9yOQ|OW}O!R}O$}}O%O}O%V|O'g{O~OT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m&ka!}&ka&s&ka~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m$qi!}$qi&s$qi~P!'WOS+^Om+^Os$aO!_+^O!`+^O$aqO$drO~OY/PO~P$?VOS+^Om+^Os$aO!_+^O!`+^O$aqO~O!s/QO~O!n/SO~P#JwOw(SO!o)WO#l'SO~OV/VO!m&na!}&na&s&na~O!})_O!m'ki&s'ki~O!s/XO~OV/YO!n%|a!}%|a~O]/[Os/[O!s#gO#peO!n&oX!}&oX~O!},uO!n'la~OT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m&Ua!}&Ua&s&Ua#O&Ua~P!'WOz#RO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT!uy!S!uy!b!uy!m!uy!v!uy&s!uy!x!uy!n!uy~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#hi!}#hi~P!'WO_)yO!n&VX!}&VX~P9yO!}-RO!n&{a~OT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}#Vq#X#Vq~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#[i!}#[i~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#O/cO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!x&Xa!}&Xa~P!'WO#u/iO!x$ci!}$ci~O#b/jO~O#U/lO#b/kO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$ci!}$ci~P!'WO#u/mO!x$hi!}$hi~O!}/oO!x'[X~O#b/qO~O!x/rO~O!oXO!q/uO~O#l'SO!o'cy!m'cy&s'cy~O!m$jy&s$jy!x$jy!n$jy~PCqO#O/xO#l'SO~O!s#gO#peOw&aX!o&aX!}&aX!m&aX&s&aX~O!}-|Ow']a!o']a!m']a&s']a~OU$PO]0QO!R$PO!s$OO!v#}O#b$nO#p2XO~P$?uO!m#cO!o0VO&s#cO~O#X0YO~Oh0_O~OT:tOz:pO!S:vO!b:xO!m0`O!q0`O!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO~P!'WOY%]a_%]a!n%]ai%]a~PhO!x0bO~O!x0bO~P>UO!m0dO~OT6iOz6gO!S6jO!b6kO!v8sO!x0fO#O0eO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO~P!'WO!x0fO~O!x0gO#b0hO#l'SO~O!x0iO~O!s0jO~O!m#cO#u0lO&s#cO~O!s0mO~O!})_O!m'kq&s'kq~O!s0nO~OV0oO!n%}X!}%}X~OT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!n!|i!}!|i~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$cq!}$cq~P!'WO#u0vO!x$cq!}$cq~O#b0wO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$hq!}$hq~P!'WO#S0zO#b0yO!x&`X!}&`X~O!}/oO!x'[a~O#l'SO!o'c!R!m'c!R&s'c!R~O!oXO!q1PO~O!m$j!R&s$j!R!x$j!R!n$j!R~PCqO#O1RO#l'SO~OP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!n1^O!s1YO!y[O#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$z:nO${!OO~P$;lOh1_O~OY%[i_%[i!n%[ii%[i~PhOY%]i_%]i!n%]ii%]i~PhO!x1bO~O!x1bO~P>UO!x1eO~O!m#cO#u1iO&s#cO~O$}1jO%V1jO~O!s1kO~OV1lO!n%}a!}%}a~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#]i!}#]i~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$cy!}$cy~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$hy!}$hy~P!'WO#b1nO~O!}/oO!x'[i~O!m$j!Z&s$j!Z!x$j!Z!n$j!Z~PCqOT:uOz:qO!S:wO!b:yO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dO~P!'WOV1uO{1tO~P!5xOV1uO{1tOT&}Xz&}X!S&}X!b&}X!o&}X!v&}X!y&}X#S&}X#W&}X#`&}X#a&}X#s&}X#u&}X#w&}X#z&}X#{&}X#|&}X#}&}X$O&}X$Q&}X$R&}X$S&}X$T&}X$U&}X$V&}X$W&}X$z&}X~OP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!n1xO!s1YO!y[O#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$z:nO${!OO~P$;lOY%[q_%[q!n%[qi%[q~PhO!x1zO~O!x%gi~PCqOe1{O~O$}1|O%V1|O~O!s2OO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$c!R!}$c!R~P!'WO!m$j!c&s$j!c!x$j!c!n$j!c~PCqO!s2QO~O!`2SO!s2RO~O!s2VO!m$xi&s$xi~O!s'WO~O!s*]O~OT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$ka#u$ka#w$ka&s$ka!x$ka!n$ka!q$ka#X$ka!}$ka~P!'WO#S2]O~P*kO$l$tO~P#.YOT6iOz6gO!S6jO!b6kO!v8sO#O2[O#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m'PX&s'PX!x'PX!n'PX~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#O3uO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}'PX#X'PX#u'PX#w'PX!m'PX&s'PX!x'PX!n'PXV'PX!q'PX~P!'WO#S3dO~P#.YOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$Xa#u$Xa#w$Xa&s$Xa!x$Xa!n$Xa!q$Xa#X$Xa!}$Xa~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$Ya#u$Ya#w$Ya&s$Ya!x$Ya!n$Ya!q$Ya#X$Ya!}$Ya~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$Za#u$Za#w$Za&s$Za!x$Za!n$Za!q$Za#X$Za!}$Za~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$[a#u$[a#w$[a&s$[a!x$[a!n$[a!q$[a#X$[a!}$[a~P!'WOz2aO#u$[a#w$[a!q$[a#X$[a!}$[a~PNyOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$_a#u$_a#w$_a&s$_a!x$_a!n$_a!q$_a#X$_a!}$_a~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$|a#u$|a#w$|a&s$|a!x$|a!n$|a!q$|a#X$|a!}$|a~P!'WOz2aO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#u#yi#w#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi#u#yi#w#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOT2cOz2aO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!S#yi!m#yi#u#yi#w#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOT2cOz2aO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!S#yi!b#yi!m#yi#u#yi#w#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO#S#QO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#u#yi#w#yi#z#yi#{#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO#S#QO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#u#yi#w#yi#z#yi#{#yi#|#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO#S#QO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO#S#QO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$T2nO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$S2mO$T2nO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m#Ta#u#Ta#w#Ta&s#Ta!x#Ta!n#Ta!q#Ta#X#Ta!}#Ta~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m'Pa#u'Pa#w'Pa&s'Pa!x'Pa!n'Pa!q'Pa#X'Pa!}'Pa~P!'WOz2aO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#Pi!S#Pi!b#Pi!m#Pi#u#Pi#w#Pi&s#Pi!x#Pi!n#Pi!q#Pi#X#Pi!}#Pi~P!'WOz2aO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#vi!S#vi!b#vi!m#vi#u#vi#w#vi&s#vi!x#vi!n#vi!q#vi#X#vi!}#vi~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m#xi#u#xi#w#xi&s#xi!x#xi!n#xi!q#xi#X#xi!}#xi~P!'WOz2aO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT!uq!S!uq!b!uq!m!uq!v!uq#u!uq#w!uq&s!uq!x!uq!n!uq!q!uq#X!uq!}!uq~P!'WOz2aO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#Pq!S#Pq!b#Pq!m#Pq#u#Pq#w#Pq&s#Pq!x#Pq!n#Pq!q#Pq#X#Pq!}#Pq~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$jq#u$jq#w$jq&s$jq!x$jq!n$jq!q$jq#X$jq!}$jq~P!'WOz2aO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT!uy!S!uy!b!uy!m!uy!v!uy#u!uy#w!uy&s!uy!x!uy!n!uy!q!uy#X!uy!}!uy~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$jy#u$jy#w$jy&s$jy!x$jy!n$jy!q$jy#X$jy!}$jy~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$j!R#u$j!R#w$j!R&s$j!R!x$j!R!n$j!R!q$j!R#X$j!R!}$j!R~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$j!Z#u$j!Z#w$j!Z&s$j!Z!x$j!Z!n$j!Z!q$j!Z#X$j!Z!}$j!Z~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$j!c#u$j!c#w$j!c&s$j!c!x$j!c!n$j!c!q$j!c#X$j!c!}$j!c~P!'WOP6]OU^O[4POo8^Os#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#S3vO#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$z4bO${!OO~P$;lOP6]OU^O[4POo8^Os#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$z4bO${!OO~P$;lO#u2uO#w2vO!q&zX#X&zX!}&zX~P0rOP6]OU^O[4POo8^Or2wOs#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#S2tO#U2sO#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$z4bO${!OOT#xXz#xX!S#xX!b#xX!m#xX!o#xX!v#xX#`#xX#a#xX#s#xX#u#xX#w#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX&s#xX!x#xX!n#xX!q#xX#X#xX!}#xX~P$;lOP6]OU^O[4POo8^Or4xOs#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#S4uO#U4tO#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$z4bO${!OOT#xXz#xX!S#xX!b#xX!o#xX!v#xX!}#xX#O#xX#X#xX#`#xX#a#xX#s#xX#u#xX#w#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX!m#xX&s#xX!x#xX!n#xXV#xX!q#xX~P$;lO!q3PO~P>UO!q5}O#O3gO~OT8vOz8tO!S8wO!b8xO!q3hO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WO!q6OO#O3kO~O!q6PO#O3oO~O#O3oO#l'SO~O#O3pO#l'SO~O#O3sO#l'SO~OP6]OU^O[4POo8^Os#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$l$tO$z4bO${!OO~P$;lOP6]OU^O[4POo8^Os#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#S5eO#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$z4bO${!OO~P$;lOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$Xa#O$Xa#X$Xa#u$Xa#w$Xa!m$Xa&s$Xa!x$Xa!n$XaV$Xa!q$Xa~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$Ya#O$Ya#X$Ya#u$Ya#w$Ya!m$Ya&s$Ya!x$Ya!n$YaV$Ya!q$Ya~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$Za#O$Za#X$Za#u$Za#w$Za!m$Za&s$Za!x$Za!n$ZaV$Za!q$Za~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$[a#O$[a#X$[a#u$[a#w$[a!m$[a&s$[a!x$[a!n$[aV$[a!q$[a~P!'WOz4dO!}$[a#O$[a#X$[a#u$[a#w$[aV$[a!q$[a~PNyOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$_a#O$_a#X$_a#u$_a#w$_a!m$_a&s$_a!x$_a!n$_aV$_a!q$_a~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$|a#O$|a#X$|a#u$|a#w$|a!m$|a&s$|a!x$|a!n$|aV$|a!q$|a~P!'WOz4dO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#u#yi#w#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!}#yi#O#yi#X#yi#u#yi#w#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOT4fOz4dO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!S#yi!}#yi#O#yi#X#yi#u#yi#w#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOT4fOz4dO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!S#yi!b#yi!}#yi#O#yi#X#yi#u#yi#w#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO#S#QO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#u#yi#w#yi#z#yi#{#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO#S#QO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO#S#QO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO#S#QO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$T4qO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$S4pO$T4qO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}#Ta#O#Ta#X#Ta#u#Ta#w#Ta!m#Ta&s#Ta!x#Ta!n#TaV#Ta!q#Ta~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}'Pa#O'Pa#X'Pa#u'Pa#w'Pa!m'Pa&s'Pa!x'Pa!n'PaV'Pa!q'Pa~P!'WOz4dO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#Pi!S#Pi!b#Pi!}#Pi#O#Pi#X#Pi#u#Pi#w#Pi!m#Pi&s#Pi!x#Pi!n#PiV#Pi!q#Pi~P!'WOz4dO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#vi!S#vi!b#vi!}#vi#O#vi#X#vi#u#vi#w#vi!m#vi&s#vi!x#vi!n#viV#vi!q#vi~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}#xi#O#xi#X#xi#u#xi#w#xi!m#xi&s#xi!x#xi!n#xiV#xi!q#xi~P!'WOz4dO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT!uq!S!uq!b!uq!v!uq!}!uq#O!uq#X!uq#u!uq#w!uq!m!uq&s!uq!x!uq!n!uqV!uq!q!uq~P!'WOz4dO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#Pq!S#Pq!b#Pq!}#Pq#O#Pq#X#Pq#u#Pq#w#Pq!m#Pq&s#Pq!x#Pq!n#PqV#Pq!q#Pq~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$jq#O$jq#X$jq#u$jq#w$jq!m$jq&s$jq!x$jq!n$jqV$jq!q$jq~P!'WOz4dO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT!uy!S!uy!b!uy!v!uy!}!uy#O!uy#X!uy#u!uy#w!uy!m!uy&s!uy!x!uy!n!uyV!uy!q!uy~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$jy#O$jy#X$jy#u$jy#w$jy!m$jy&s$jy!x$jy!n$jyV$jy!q$jy~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$j!R#O$j!R#X$j!R#u$j!R#w$j!R!m$j!R&s$j!R!x$j!R!n$j!RV$j!R!q$j!R~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$j!Z#O$j!Z#X$j!Z#u$j!Z#w$j!Z!m$j!Z&s$j!Z!x$j!Z!n$j!ZV$j!Z!q$j!Z~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$j!c#O$j!c#X$j!c#u$j!c#w$j!c!m$j!c&s$j!c!x$j!c!n$j!cV$j!c!q$j!c~P!'WO#S5wO~P#.YO!y$hO#S5{O~O!x4ZO#l'SO~O!y$hO#S5|O~OT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$ka#O$ka#X$ka#u$ka#w$ka!m$ka&s$ka!x$ka!n$kaV$ka!q$ka~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#O5vO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!m'PX#u'PX#w'PX&s'PX!x'PX!n'PX!q'PX#X'PX!}'PX~P!'WO#u4vO#w4wO!}&zX#O&zX#X&zXV&zX!q&zX~P0rO!q5QO~P>UO!q8bO#O5hO~OT8vOz8tO!S8wO!b8xO!q5iO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WO!q8cO#O5lO~O!q8dO#O5pO~O#O5pO#l'SO~O#O5qO#l'SO~O#O5tO#l'SO~O$l$tO~P9yOo5zOs$lO~O#S7oO~P9yOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$Xa#O$Xa#X$Xa!m$Xa&s$Xa!x$Xa!n$XaV$Xa!q$Xa~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$Ya#O$Ya#X$Ya!m$Ya&s$Ya!x$Ya!n$YaV$Ya!q$Ya~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$Za#O$Za#X$Za!m$Za&s$Za!x$Za!n$ZaV$Za!q$Za~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$[a#O$[a#X$[a!m$[a&s$[a!x$[a!n$[aV$[a!q$[a~P!'WOz6gO!}$[a#O$[a#X$[aV$[a!q$[a~PNyOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$_a#O$_a#X$_a!m$_a&s$_a!x$_a!n$_aV$_a!q$_a~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$ka#O$ka#X$ka!m$ka&s$ka!x$ka!n$kaV$ka!q$ka~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$|a#O$|a#X$|a!m$|a&s$|a!x$|a!n$|aV$|a!q$|a~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO!}7sO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x'jX~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO!}7uO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x&|X~P!'WOz6gO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!}#yi#O#yi#X#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOT6iOz6gO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!S#yi!}#yi#O#yi#X#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOT6iOz6gO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!S#yi!b#yi!}#yi#O#yi#X#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO#S#QO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#z#yi#{#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO#S#QO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#z#yi#{#yi#|#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO#S#QO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#z#yi#{#yi#|#yi#}#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO#S#QO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$T6tO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$S6sO$T6tO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WO#S7zO~P>UO!m#Ta&s#Ta!x#Ta!n#Ta~PCqO!m'Pa&s'Pa!x'Pa!n'Pa~PCqO#S;dO#U;cO!x&WX!}&WX~P9yO!}7lO!x'Oa~Oz6gO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#Pi!S#Pi!b#Pi!}#Pi#O#Pi#X#Pi!m#Pi&s#Pi!x#Pi!n#PiV#Pi!q#Pi~P!'WOz6gO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#vi!S#vi!b#vi!}#vi#O#vi#X#vi!m#vi&s#vi!x#vi!n#viV#vi!q#vi~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}#xi#O#xi#X#xi!m#xi&s#xi!x#xi!n#xiV#xi!q#xi~P!'WO!}7sO!x%da~O!x&UX!}&UX~P>UO!}7uO!x&|a~Oz6gO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT!uq!S!uq!b!uq!v!uq!}!uq#O!uq#X!uq!m!uq&s!uq!x!uq!n!uqV!uq!q!uq~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#Vi!}#Vi~P!'WOz6gO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#Pq!S#Pq!b#Pq!}#Pq#O#Pq#X#Pq!m#Pq&s#Pq!x#Pq!n#PqV#Pq!q#Pq~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$jq#O$jq#X$jq!m$jq&s$jq!x$jq!n$jqV$jq!q$jq~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x&ka!}&ka~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x&Ua!}&Ua~P!'WOz6gO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT!uy!S!uy!b!uy!v!uy!}!uy#O!uy#X!uy!m!uy&s!uy!x!uy!n!uyV!uy!q!uy~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#Vq!}#Vq~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$jy#O$jy#X$jy!m$jy&s$jy!x$jy!n$jyV$jy!q$jy~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$j!R#O$j!R#X$j!R!m$j!R&s$j!R!x$j!R!n$j!RV$j!R!q$j!R~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$j!Z#O$j!Z#X$j!Z!m$j!Z&s$j!Z!x$j!Z!n$j!ZV$j!Z!q$j!Z~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$j!c#O$j!c#X$j!c!m$j!c&s$j!c!x$j!c!n$j!cV$j!c!q$j!c~P!'WO#S8[O~P9yO#O8ZO!m'PX&s'PX!x'PX!n'PXV'PX!q'PX~PGSO!y$hO#S8`O~O!y$hO#S8aO~O#u6zO#w6{O!}&zX#O&zX#X&zXV&zX!q&zX~P0rOr6|O#S#oO#U#nO!}#xX#O#xX#X#xXV#xX!q#xX~P2yOr;iO#S9XO#U9VOT#xXz#xX!S#xX!b#xX!m#xX!o#xX!q#xX!v#xX#`#xX#a#xX#s#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX!n#xX!}#xX~P9yOr9WO#S9WO#U9WOT#xXz#xX!S#xX!b#xX!o#xX!v#xX#`#xX#a#xX#s#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX~P9yOr9]O#S;dO#U;cOT#xXz#xX!S#xX!b#xX!o#xX!q#xX!v#xX#`#xX#a#xX#s#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX#X#xX!x#xX!}#xX~P9yO$l$tO~P>UO!q7XO~P>UOT6iOz6gO!S6jO!b6kO!v8sO#O7iO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!x'PX!}'PX~P!'WOP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$z:nO${!OO~P$;lO!}7lO!x'OX~O#S9yO~P>UOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$Xa#X$Xa!x$Xa!}$Xa~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$Ya#X$Ya!x$Ya!}$Ya~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$Za#X$Za!x$Za!}$Za~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$[a#X$[a!x$[a!}$[a~P!'WOz8tO$z#dOT$[a!S$[a!b$[a!q$[a!v$[a#S$[a#z$[a#{$[a#|$[a#}$[a$O$[a$Q$[a$R$[a$S$[a$T$[a$U$[a$V$[a$W$[a#X$[a!x$[a!}$[a~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$_a#X$_a!x$_a!}$_a~P!'WO!q=dO#O7rO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$ka#X$ka!x$ka!}$ka~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$|a#X$|a!x$|a!}$|a~P!'WOT8vOz8tO!S8wO!b8xO!q7wO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WOz8tO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#X#yi!x#yi!}#yi~P!'WOz8tO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi#X#yi!x#yi!}#yi~P!'WOT8vOz8tO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!S#yi!q#yi#X#yi!x#yi!}#yi~P!'WOT8vOz8tO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!S#yi!b#yi!q#yi#X#yi!x#yi!}#yi~P!'WOz8tO#S#QO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#z#yi#{#yi#X#yi!x#yi!}#yi~P!'WOz8tO#S#QO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#z#yi#{#yi#|#yi#X#yi!x#yi!}#yi~P!'WOz8tO#S#QO$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#z#yi#{#yi#|#yi#}#yi#X#yi!x#yi!}#yi~P!'WOz8tO#S#QO$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#z#yi#{#yi#|#yi#}#yi$O#yi#X#yi!x#yi!}#yi~P!'WOz8tO$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi#X#yi!x#yi!}#yi~P!'WOz8tO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi#X#yi!x#yi!}#yi~P!'WOz8tO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi#X#yi!x#yi!}#yi~P!'WOz8tO$T9RO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi#X#yi!x#yi!}#yi~P!'WOz8tO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi#X#yi!x#yi!}#yi~P!'WOz8tO$S9QO$T9RO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi#X#yi!x#yi!}#yi~P!'WOz8tO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi#X#yi!x#yi!}#yi~P!'WOz8tO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#Pi!S#Pi!b#Pi!q#Pi#X#Pi!x#Pi!}#Pi~P!'WOz8tO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#vi!S#vi!b#vi!q#vi#X#vi!x#vi!}#vi~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q#xi#X#xi!x#xi!}#xi~P!'WO!q=eO#O7|O~Oz8tO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT!uq!S!uq!b!uq!q!uq!v!uq#X!uq!x!uq!}!uq~P!'WOz8tO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#Pq!S#Pq!b#Pq!q#Pq#X#Pq!x#Pq!}#Pq~P!'WO!q=iO#O8TO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$jq#X$jq!x$jq!}$jq~P!'WO#O8TO#l'SO~Oz8tO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT!uy!S!uy!b!uy!q!uy!v!uy#X!uy!x!uy!}!uy~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$jy#X$jy!x$jy!}$jy~P!'WO#O8UO#l'SO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$j!R#X$j!R!x$j!R!}$j!R~P!'WO#O8XO#l'SO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$j!Z#X$j!Z!x$j!Z!}$j!Z~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$j!c#X$j!c!x$j!c!}$j!c~P!'WO#S:bO~P>UO#O:aO!q'PX!x'PX~PGSO$l$tO~P$8YOP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$l$tO$z:nO${!OO~P$;lOo8_Os$lO~O#S<jO~P$8YOP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!s#gO!y[O#S<kO#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$z:nO${!OO~P$;lOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$Xa!q$Xa!n$Xa!}$Xa~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$Ya!q$Ya!n$Ya!}$Ya~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$Za!q$Za!n$Za!}$Za~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$[a!q$[a!n$[a!}$[a~P!'WOz:pO$z#dOT$[a!S$[a!b$[a!m$[a!q$[a!v$[a#S$[a#z$[a#{$[a#|$[a#}$[a$O$[a$Q$[a$R$[a$S$[a$T$[a$U$[a$V$[a$W$[a!n$[a!}$[a~P!'WOz:qO$z#dOT$[a!S$[a!b$[a!v$[a#S$[a#z$[a#{$[a#|$[a#}$[a$O$[a$Q$[a$R$[a$S$[a$T$[a$U$[a$V$[a$W$[a~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$_a!q$_a!n$_a!}$_a~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$ka!q$ka!n$ka!}$ka~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$|a!q$|a!n$|a!}$|a~P!'WOz:pO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi!n#yi!}#yi~P!'WOz:qO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi~P!'WOz:pO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!n#yi!}#yi~P!'WOz:qO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi~P!'WOT:tOz:pO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!S#yi!m#yi!q#yi!n#yi!}#yi~P!'WOT:uOz:qO!b:yO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dO!S#yi~P!'WOT:tOz:pO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!S#yi!b#yi!m#yi!q#yi!n#yi!}#yi~P!'WOT:uOz:qO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dO!S#yi!b#yi~P!'WOz:pO#S#QO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#z#yi#{#yi!n#yi!}#yi~P!'WOz:qO#S#QO#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#z#yi#{#yi~P!'WOz:pO#S#QO#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#z#yi#{#yi#|#yi!n#yi!}#yi~P!'WOz:qO#S#QO#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#z#yi#{#yi#|#yi~P!'WOz:pO#S#QO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#z#yi#{#yi#|#yi#}#yi!n#yi!}#yi~P!'WOz:qO#S#QO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#z#yi#{#yi#|#yi#}#yi~P!'WOz:pO#S#QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#z#yi#{#yi#|#yi#}#yi$O#yi!n#yi!}#yi~P!'WOz:qO#S#QO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#z#yi#{#yi#|#yi#}#yi$O#yi~P!'WOz:pO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi!n#yi!}#yi~P!'WOz:qO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi~P!'WOz:pO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi!n#yi!}#yi~P!'WOz:qO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi~P!'WOz:pO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi!n#yi!}#yi~P!'WOz:qO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi~P!'WOz:pO$T;[O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi!n#yi!}#yi~P!'WOz:qO$T;]O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi~P!'WOz:pO$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi!n#yi!}#yi~P!'WOz:qO$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi~P!'WOz:pO$S;YO$T;[O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi!n#yi!}#yi~P!'WOz:qO$S;ZO$T;]O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi~P!'WOz:pO$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi!n#yi!}#yi~P!'WOz:qO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#Ta!}#Ta!q#Ta#X#Ta~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x'Pa!}'Pa!q'Pa#X'Pa~P!'WOz:pO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#Pi!S#Pi!b#Pi!m#Pi!q#Pi!n#Pi!}#Pi~P!'WOz:qO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#Pi!S#Pi!b#Pi~P!'WOz:pO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#vi!S#vi!b#vi!m#vi!q#vi!n#vi!}#vi~P!'WOz:qO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#vi!S#vi!b#vi~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m#xi!q#xi!n#xi!}#xi~P!'WOz:pO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT!uq!S!uq!b!uq!m!uq!q!uq!v!uq!n!uq!}!uq~P!'WOz:qO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT!uq!S!uq!b!uq!v!uq~P!'WOz:pO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#Pq!S#Pq!b#Pq!m#Pq!q#Pq!n#Pq!}#Pq~P!'WOz:qO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#Pq!S#Pq!b#Pq~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$jq!q$jq!n$jq!}$jq~P!'WOz:pO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT!uy!S!uy!b!uy!m!uy!q!uy!v!uy!n!uy!}!uy~P!'WOz:qO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT!uy!S!uy!b!uy!v!uy~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$jy!q$jy!n$jy!}$jy~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$j!R!q$j!R!n$j!R!}$j!R~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$j!Z!q$j!Z!n$j!Z!}$j!Z~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$j!c!q$j!c!n$j!c!}$j!c~P!'WO#S=TO~P$8YOP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!s#gO!y[O#S=UO#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$z:nO${!OO~P$;lOT6iOz6gO!S6jO!b6kO!v8sO#O=SO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#O=RO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m'PX!q'PX!n'PX!}'PX~P!'WOT&zXz&zX!S&zX!b&zX!o&zX!q&zX!v&zX!y&zX#S&zX#W&zX#`&zX#a&zX#s&zX#z&zX#{&zX#|&zX#}&zX$O&zX$Q&zX$R&zX$S&zX$T&zX$U&zX$V&zX$W&zX$z&zX!}&zX~O#u9ZO#w9[O#X&zX!x&zX~P.8oO!y$hO#S=^O~O!q9hO~P>UO!y$hO#S=cO~O!q>OO#O9}O~OT8vOz8tO!S8wO!b8xO!q:OO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m#Ta!q#Ta!n#Ta!}#Ta~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m'Pa!q'Pa!n'Pa!}'Pa~P!'WO!q>PO#O:RO~O!q>QO#O:YO~O#O:YO#l'SO~O#O:ZO#l'SO~O#O:_O#l'SO~O#u;eO#w;gO!m&zX!n&zX~P.8oO#u;fO#w;hOT&zXz&zX!S&zX!b&zX!o&zX!v&zX!y&zX#S&zX#W&zX#`&zX#a&zX#s&zX#z&zX#{&zX#|&zX#}&zX$O&zX$Q&zX$R&zX$S&zX$T&zX$U&zX$V&zX$W&zX$z&zX~O!q;tO~P>UO!q;uO~P>UO!q>XO#O<oO~O!q>YO#O9WO~OT8vOz8tO!S8wO!b8xO!q<pO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WOT8vOz8tO!S8wO!b8xO!q<qO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WO!q>ZO#O<vO~O!q>[O#O<{O~O#O<{O#l'SO~O#O9WO#l'SO~O#O<|O#l'SO~O#O=PO#l'SO~O!y$hO#S=|O~Oo=[Os$lO~O!y$hO#S=}O~O!y$hO#S>UO~O!y$hO#S>VO~O!y$hO#S>WO~Oo={Os$lO~Oo>TOs$lO~Oo>SOs$lO~O%O$U$}$d!d$V#b%V#e'g!s#d~",
  goto: "%&y'mPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP'nP'uPP'{(OPPP(hP(OP(O*ZP*ZPP2W:j:mPP*Z:sBpPBsPBsPP:sCSCVCZ:s:sPPPC^PP:sK^!$S!$S:s!$WP!$W!$W!%UP!.]!7pP!?oP*ZP*Z*ZPPPPP!?rPPPPPPP*Z*Z*Z*ZPP*Z*ZP!E]!GRP!GV!Gy!GR!GR!HP*Z*ZP!HY!Hl!Ib!J`!Jd!J`!Jo!J}!J}!KV!KY!KY*ZPP*ZPP!K^#%[#%[#%`P#%fP(O#%j(O#&S#&V#&V#&](O#&`(O(O#&f#&i(O#&r#&u(O(O(O(O(O#&x(O(O(O(O(O(O(O(O(O#&{!KR(O(O#'_#'o#'r(O(OP#'u#'|#(S#(o#(y#)P#)Z#)b#)h#*d#4X#5T#5Z#5a#5k#5q#5w#6]#6c#6i#6o#6u#6{#7R#7]#7g#7m#7s#7}PPPPPPPP#8T#8X#8}#NO#NR#N]$(f$(r$)X$)_$)b$)e$)k$,X$5v$>_$>b$>h$>k$>n$>w$>{$?X$?k$Bk$CO$C{$K{PP%%y%%}%&Z%&p%&vQ!nQT!qV!rQUOR%x!mRVO}!hPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1a|!hPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1aQ%^!ZQ%g!aQ%l!eQ'd$dQ'q$iQ)[%kQ*y'tQ,](xU-n*v*x+OQ.W+cQ.{,[S/t-s-tQ0T.SS0}/s/wQ1V0RQ1o1OR2P1p0u!OPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=n0t!OPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nQ#j]Q$}!PQ%O!QQ%P!RQ,S(kQ.b+sR.f+vR&q#jQ)z&pR/a-R0uhPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nR#l^k#p_j#k#s&s&w3x3y7l8f8g8h8iR#u`T&|#t'OR-Y*U0thPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nR#va-r#OZ#f#m#w$V$W$X$Y$Z$[$u$v%W%Y%[%`%s%|&O&Q&U&^&_&`&a&b&c&d&e&f&g&h&i&j&k&l&m&u&v&{'X'Z'[(](p)q)s)u*O*[*^+S+V,`,c,y,{,}-V-W-X-i-x.k.w/`/h/n/y0r0u0x1Q1X1d1m1q2q2r2x2y2z2{2|2}3O3Q3R3S3T3U3V3W3X3Y3Z3[3]3^3_3`3a3b3c3e3f3i3j3l3m3n3q3r3t4Y4y4z4{4|4}5O5P5R5S5T5U5V5W5X5Y5Z5[5]5^5_5`5a5b5c5d5f5g5j5k5m5n5o5r5s5u6R6V6}7O7P7Q7R7S7U7V7W7Y7Z7[7]7^7_7`7a7b7c7d7e7f7g7h7j7k7n7p7q7x7y7{7}8O8P8Q8R8S8V8W8Y8]9U9^9_9`9a9b9c9f9g9i9j9k9l9m9n9o9p9q9r9s9t9u9v9w9x9z9{:P:Q:T:V:W:[:^:`:c;j;k;l;m;n;o;p;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<[<]<^<_<`<a<b<c<d<e<f<g<h<i<l<m<n<r<s<t<u<w<x<y<z<}=O=Q=V=W=_=`=a=q=rQ']$]Y(Q$s7T9e;q;rS(U2Z6QR(X$tT&X!})v!w$Qg#}$h'S'i'm'r(P(T)Z*f*s*z*}+Q+]+`+g,Z-r-u-{.Q/u1P5}6O6P6]8b8c8d=d=e=i>O>P>Q>X>Y>Z>[3ZfPVX[_bgjklmnoprxyz!S!W!X!Y!]!e!f!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t#}$R$S$U$h$y$}%P%R%S%T%U%c%p%r%}&S&W&p&s&t&w'O'S'U'Y'^'i'm'r'z(O(P(R(S(T(`(l({)P)Z)_)c)i)p)t)v*P*T*U*f*o*s*z*}+P+Q+]+`+d+g+r+u+z,T,V,X,Z,u-Q-R-d-k-r-u-z-{-|.Q.b.d.l.t/[/c/i/m/u/x0V0`0a0d0e0i0v1P1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w5}6O6P6T6]6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8b8c8d8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=d=e=i=m=n>O>P>Q>X>Y>Z>[3scPVX[_bdegjklmnoprxyz!S!W!X!Y!]!e!f!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t#{#}$R$S$U$h$y$}%P%R%S%T%U%c%m%n%p%r%}&S&W&p&s&t&w'O'S'U'Y'^'i'm'r'z(O(P(R(S(T(`(l({)P)Z)^)_)c)g)h)i)p)t)v*P*T*U*f*o*s*z*}+P+Q+]+`+d+g+r+u+z,T,V,X,Z,u,x-Q-R-d-k-r-u-z-{-|.Q.b.d.l.t/[/c/i/m/u/x0V0`0a0d0e0i0v1P1R1]1a2W2X2Y2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w5}6O6P6T6]6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8b8c8d8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=d=e=i=m=n>O>P>Q>X>Y>Z>[0phPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0`0a0d0e0i0v1R1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nT1Z0V1]R&]#P!n#[Z#f#w$V$W$X$Y$[$s$v%W%Y%[&Q&_&`&a&b&c&d&e&f'X'Z'[(])q)s*^+V,{-x/y1Q1d1q7j7k!Y2j2Z2x2y2z2{2}3O3Q3R3S3T3U3V3W3X3a3b3c3e3f3i3j3l3m3n3q3r3t!^4m2r4y4z4{4|5O5P5R5S5T5U5V5W5X5Y5b5c5d5f5g5j5k5m5n5o5r5s5u6Q6R#Q6p#m%`%s&u&v&{(p*O+S,`,c,y-V-X.w2q6}7O7P7Q7S7T7U7Y7Z7[7]7^7_7`7a7n7p7q7x7{7}8Q8S8V8W8Y8]9U:c=V=W#^8}%|&O&U)u,}-W-i/h/n0r0u0x1m4Y6V7V7W7y8O8P8R9^9_9`9a9c9e9f9g9i9j9k9l9m9n9o9p9x9z9{:P:Q:T:V:W:[:^:`<f<g=_=q=r!^;S.k/`;j;k;l;m;p;q;s;v;x;z;|<O<Q<S<U<h<l<n<r<t<w<x<z<}=O=Q=`=ao;T1X;r;w;y;{;}<P<R<T<V<i<m<s<u<yS$iu#hQ$qwU't$j$l&oQ'v$kS'x$m$rQ*|'uQ+O'wQ+R'yQ4X5xS4[5z5{Q4]5|Q6U8^S6W8_8`Q6X8aQ9d=YS9|=[=^Q:S=cQ=]=yS=b={=|Q=f=}Q=o>RS=p>S>VS=s>T>UR=t>WT'n$h*s!csPVXt!S!j!r!s!w$h$}%P%S%U'i(T(`)W*s+]+g+r+u,g,k.b.d.l0`0a0i1aQ$^rR*`'^Q*x'sQ-t*{R/w-wQ(W$tQ)U%hQ)n%vQ*i'fQ+k(XR-c*jQ(V$tQ)Y%jQ)m%vQ*e'eS*h'f)nS+j(W(XS-b*i*jQ.]+kQ/T,mQ/e-`R/g-cQ(U$tQ)T%hQ)V%iQ)l%vU*g'f)m)nU+i(V(W(XQ,f)UU-a*h*i*jS.[+j+kS/f-b-cQ0X.]R0t/gT+e(T+g[%e!_$b'c+a.R0QR,d)Qb$ov(T+[+]+`+g.P.Q0PR+T'{S+e(T+gT,j)W,kR0W.XT1[0V1]0w|PVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X,_-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nT$x{${Q+p([R._+nT$z{${Q(b$}Q(j%PQ(o%SQ(r%UQ.j+yQ0].fQ0^.iR1g0iR(e%OX+|(c(d+},PR(f%OX(h%P%S%U0iR%S!T_%a!]%R(l,T,V.t0dR%U!UR.x,XR,[(wQ)X%jS*d'e)YS-_*e,mS/d-`/TR0s/eQ%q!fU)]%m%n%rU,o)^)g)hR/_,xR)d%pR/],uSSO!mR!oSQ!rVR%y!rQ!jPS!sV!rQ!wX[%u!j!s!w+r0a1aQ+r(`Q0a.lR1a0`Q)j%sS,z)j7vR7v7WQ-S)zR/b-SQ&x#qS*R&x7mR7m9YS*V&{&|R-Z*VQ)w&YR-P)w!l'T#|'h*n*q*v+W+[,m-`-s-v-y.P.z/s/v/z0P1O1p4^4_4`5y6Y6Z6[:U:X:]=g=h=j=u=v=w=xR*Z'T1^dPVX[_bjklmnoprxyz!S!W!X!Y!]!e!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%p%}&S&W&p&s&t&w'O'U'Y'^'z(O(R(S(`(l({)P)_)c)i)p)t)v*P*T*U*o+P+d+r+u+z,T,V,X,u-Q-R-d-k-z-|.b.d.l.t/[/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=n`#zd#{%m)^)g,x2W2YQ#{eQ%m!fQ)^%nQ)g%rQ,x)h!v2Wg#}$h'S'i'm'r(P(T)Z*f*s*z*}+Q+]+`+g,Z-r-u-{.Q/u1P5}6O6P6]8b8c8d=d=e=i>O>P>Q>X>Y>Z>[R2Y2X|tPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1aW$`t'i+],gS'i$h*sS+](T+gT,g)W,kQ'_$^R*a'_Q*t'oR-m*tQ/p-oS0{/p0|R0|/qQ-}+XR/|-}Q+g(TR.Y+gS+`(T+gS,h)W,kQ.Q+]W.T+`,h.Q/OR/O,gQ)R%eR,e)RQ'|$oR+U'|Q1]0VR1w1]Q${{R(^${Q+t(aR.c+tQ+w(bR.g+wQ+}(cQ,P(dT.m+},PQ(|%`S,a(|7tR7t7VQ(y%^R,^(yQ,k)WR/R,kQ)`%oS,q)`/WR/W,rQ,v)dR/^,vT!uV!rj!iPVX!j!r!s!w(`+r.l0`0a1aQ%Q!SQ(a$}W(h%P%S%U0iQ.e+uQ0Z.bR0[.d|ZPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1aQ#f[U#m_#s&wQ#wbQ$VkQ$WlQ$XmQ$YnQ$ZoQ$[pQ$sx^$uy2_4b6e8q:m:nQ$vzQ%W!WQ%Y!XQ%[!YW%`!]%R(l,VU%s!g&p-RQ%|!yQ&O!zQ&Q!{S&U!})v^&^#R2a4d6g8t:p:qQ&_#SQ&`#TQ&a#UQ&b#VQ&c#WQ&d#XQ&e#YQ&f#ZQ&g#[Q&h#]Q&i#^Q&j#_Q&k#`Q&l#aQ&m#bQ&u#nQ&v#oS&{#t'OQ'X$RQ'Z$SQ'[$UQ(]$yQ(p%TQ)q%}Q)s&SQ)u&WQ*O&tS*['U4ZQ*^'Y^*_2[3u5v8Z:a=R=SQ+S'zQ+V(OQ,`({Q,c)PQ,y)iQ,{)pQ,})tQ-V*PQ-W*TQ-X*U^-]2]3v5w8[:b=T=UQ-i*oQ-x+PQ.k+zQ.w,XQ/`-QQ/h-dQ/n-kQ/y-zQ0r/cQ0u/iQ0x/mQ1Q/xU1X0V1]9WQ1d0eQ1m0vQ1q1RQ2Z2^Q2qjQ2r3yQ2x3zQ2y3|Q2z4OQ2{4QQ2|4SQ2}4UQ3O2`Q3Q2bQ3R2cQ3S2dQ3T2eQ3U2fQ3V2gQ3W2hQ3X2iQ3Y2jQ3Z2kQ3[2lQ3]2mQ3^2nQ3_2oQ3`2pQ3a2sQ3b2tQ3c2uQ3e2vQ3f2wQ3i3PQ3j3dQ3l3gQ3m3hQ3n3kQ3q3oQ3r3pQ3t3sQ4Y4WQ4y3{Q4z3}Q4{4PQ4|4RQ4}4TQ5O4VQ5P4cQ5R4eQ5S4fQ5T4gQ5U4hQ5V4iQ5W4jQ5X4kQ5Y4lQ5Z4mQ5[4nQ5]4oQ5^4pQ5_4qQ5`4rQ5a4sQ5b4tQ5c4uQ5d4vQ5f4wQ5g4xQ5j5QQ5k5eQ5m5hQ5n5iQ5o5lQ5r5pQ5s5qQ5u5tQ6Q4aQ6R3xQ6V6TQ6}6^Q7O6_Q7P6`Q7Q6aQ7R6bQ7S6cQ7T6dQ7U6fU7V,T.t0dQ7W%cQ7Y6hQ7Z6iQ7[6jQ7]6kQ7^6lQ7_6mQ7`6nQ7a6oQ7b6pQ7c6qQ7d6rQ7e6sQ7f6tQ7g6uQ7h6vQ7j6xQ7k6yQ7n6zQ7p6{Q7q6|Q7x7XQ7y7iQ7{7oQ7}7rQ8O7sQ8P7uQ8Q7wQ8R7zQ8S7|Q8V8TQ8W8UQ8Y8XQ8]8fU9U#k&s7lQ9^8jQ9_8kQ9`8lQ9a8mQ9b8nQ9c8oQ9e8pQ9f8rQ9g8sQ9i8uQ9j8vQ9k8wQ9l8xQ9m8yQ9n8zQ9o8{Q9p8|Q9q8}Q9r9OQ9s9PQ9t9QQ9u9RQ9v9SQ9w9TQ9x9ZQ9z9[Q9{9]Q:P9hQ:Q9yQ:T9}Q:V:OQ:W:RQ:[:YQ:^:ZQ:`:_Q:c8iQ;j:dQ;k:eQ;l:fQ;m:gQ;n:hQ;o:iQ;p:jQ;q:kQ;r:lQ;s:oQ;v:rQ;w:sQ;x:tQ;y:uQ;z:vQ;{:wQ;|:xQ;}:yQ<O:zQ<P:{Q<Q:|Q<R:}Q<S;OQ<T;PQ<U;QQ<V;RQ<W;SQ<X;TQ<Y;UQ<Z;VQ<[;WQ<];XQ<^;YQ<_;ZQ<`;[Q<a;]Q<b;^Q<c;_Q<d;`Q<e;aQ<f;cQ<g;dQ<h;eQ<i;fQ<l;gQ<m;hQ<n;iQ<r;tQ<s;uQ<t<jQ<u<kQ<w<oQ<x<pQ<y<qQ<z<vQ<}<{Q=O<|Q=Q=PQ=V8hQ=W8gQ=_=ZQ=`9VQ=a9XQ=q=mR=r=nR){&pQ%t!gQ)O%cT)y&p-R$SiPVX[bklmnopxyz!S!W!X!Y!j!r!s!w!{#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b$R$S$U$y$}%P%S%U%}&S'Y(O(`)p+P+r+u-z.b.d.l/x0`0a0e0i1R1a2[2]6x6y!t3w'U2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3z3|4O4Q4S4U5v5w!x6S3u3v3x3y3{3}4P4R4T4V4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t$O8e_j!]!g#k#n#o#s#t%R%T&p&s&t&w'O'z(l({)P)i*P*U,V,X-R6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6z6{6|7X7l7o7r7w7|8T8U8X8Z8[8f8g8h8i#|=X!y!z!}%c&W)t)v*T*o,T-d-k.t/c/i/m0d0v4W6T7i7s7u7z8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9Z9[9]9h9y9}:O:R:Y:Z:_:a:b;c;d=Z=m=n!v=k+z-Q9V9X:d:e:f:g:h:j:k:m:o:p:r:t:v:x:z:|;O;Q;S;U;W;Y;[;^;`;e;g;i;t<j<o<p<v<{<|=P=R=T!]=l0V1]9W:i:l:n:q:s:u:w:y:{:};P;R;T;V;X;Z;];_;a;f;h;u<k<q=S=UQ#r_Q&r#kQ&z#sR)}&sS#q_#s^$Tj3x3y8f8g8h8iS*Q&w7lT9Y#k&sQ&}#tR*X'OR&T!|R&Z!}Q&Y!}R-O)vQ#|gQ'V#}S'h$h*sQ*Y'SQ*n'iQ*q'mQ*v'rQ+W(PS+[(T+gQ,m)ZQ-`*fQ-s*zQ-v*}Q-y+QS.P+]+`Q.z,ZQ/s-rQ/v-uQ/z-{Q0P.QQ1O/uQ1p1PQ4^5}Q4_6OQ4`6PQ5y6]Q6Y8bQ6Z8cQ6[8dQ:U=dQ:X=eQ:]=iQ=g>OQ=h>PQ=j>QQ=u>XQ=v>YQ=w>ZR=x>[0t!OPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=n!v$Pg#}$h'S'i'm'r(P(T)Z*f*s*z*}+Q+]+`+g,Z-r-u-{.Q/u1P5}6O6P6]8b8c8d=d=e=i>O>P>Q>X>Y>Z>[S$]r'^Q%k!eS%o!f%rQ)b%pU+X(R(S+dQ,p)_Q,t)cQ/Z,uQ/{-|R0p/[|vPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1a#U#i[bklmnopxyz!W!X!Y!{#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b$R$S$U$y%}&S'Y(O)p+P-z/x0e1R2[2]6x6yd+^(T)W+]+`+g,g,h,k.Q/O!t6w'U2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3z3|4O4Q4S4U5v5w!x;b3u3v3x3y3{3}4P4R4T4V4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t$O=z_j!]!g#k#n#o#s#t%R%T&p&s&t&w'O'z(l({)P)i*P*U,V,X-R6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6z6{6|7X7l7o7r7w7|8T8U8X8Z8[8f8g8h8i#|>]!y!z!}%c&W)t)v*T*o,T-d-k.t/c/i/m0d0v4W6T7i7s7u7z8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9Z9[9]9h9y9}:O:R:Y:Z:_:a:b;c;d=Z=m=n!v>^+z-Q9V9X:d:e:f:g:h:j:k:m:o:p:r:t:v:x:z:|;O;Q;S;U;W;Y;[;^;`;e;g;i;t<j<o<p<v<{<|=P=R=T!]>_0V1]9W:i:l:n:q:s:u:w:y:{:};P;R;T;V;X;Z;];_;a;f;h;u<k<q=S=UR'p$hQ'o$hR-l*sR$_rR-q*wQ+Y(RQ+Z(SR.X+dT+f(T+ge+_(T)W+]+`+g,g,h,k.Q/OQ%f!_Q'b$bQ*c'cQ.U+aQ0S.RR1U0QQ#eZQ%X!WQ%Z!XQ%]!YQ'}$pQ(s%VQ(t%WQ(u%YQ(v%[Q(}%bQ)S%fQ)[%kQ)f%qQ)k%tQ*b'bQ,n)]Q-^*cQ.V+bQ.W+cQ.e+xQ.o,QQ.p,RQ.q,SQ.v,WQ.y,YQ.},bQ/U,oQ/}.OQ0T.SQ0U.UQ0W.XQ0[.hQ0k/QQ0q/_Q1S0OQ1V0RQ1W0SQ1`0_Q1h0jQ1r1TQ1s1UQ1v1[Q1y1_Q1}1jQ2T1{R2U1|Q$pvS+b(T+gU.O+[+]+`S0O.P.QR1T0P|!aPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1aQ$dtW+c(T)W+g,kW.S+]+`,g,hT0R.Q/O0t!OPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nR.|,_0w}PVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X,_-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nT$w{${Q(i%PQ(n%SQ(q%UR1f0iQ%b!]Q(m%RQ,U(lQ.s,TQ.u,VQ0c.tR1c0dQ%q!fR)]%rR)e%p",
  nodeNames: "⚠ ( HeredocString EscapeSequence abstract LogicOp array as Boolean break case catch clone const continue default declare do echo else elseif enddeclare endfor endforeach endif endswitch endwhile enum extends final finally fn for foreach from function global goto if implements include include_once LogicOp insteadof interface list match namespace new null LogicOp print require require_once return switch throw trait try unset use var Visibility while LogicOp yield LineComment BlockComment TextInterpolation PhpClose Text PhpOpen Template TextInterpolation EmptyStatement ; } { Block : LabelStatement Name ExpressionStatement ConditionalExpression LogicOp MatchExpression ) ( ParenthesizedExpression MatchBlock MatchArm , => AssignmentExpression ArrayExpression ValueList & VariadicUnpacking ... Pair [ ] ListExpression ValueList Pair Pair SubscriptExpression MemberExpression -> ?-> VariableName DynamicVariable $ ${ CallExpression ArgList NamedArgument SpreadArgument CastExpression UnionType LogicOp OptionalType NamedType QualifiedName \\ NamespaceName ScopedExpression :: ClassMemberName AssignOp UpdateExpression UpdateOp YieldExpression BinaryExpression LogicOp LogicOp LogicOp BitOp BitOp BitOp CompareOp CompareOp BitOp ArithOp ConcatOp ArithOp ArithOp IncludeExpression RequireExpression CloneExpression UnaryExpression ControlOp LogicOp PrintIntrinsic FunctionExpression static ParamList Parameter #[ Attributes Attribute VariadicParameter PropertyParameter UseList ArrowFunction NewExpression class BaseClause ClassInterfaceClause DeclarationList ConstDeclaration VariableDeclarator PropertyDeclaration VariableDeclarator MethodDeclaration UseDeclaration UseList UseInsteadOfClause UseAsClause UpdateExpression ArithOp ShellExpression ThrowExpression Integer Float String MemberExpression SubscriptExpression UnaryExpression ArithOp Interpolation String IfStatement ColonBlock SwitchStatement Block CaseStatement DefaultStatement ColonBlock WhileStatement EmptyStatement DoStatement ForStatement ForSpec SequenceExpression ForeachStatement ForSpec Pair GotoStatement ContinueStatement BreakStatement ReturnStatement TryStatement CatchDeclarator DeclareStatement EchoStatement UnsetStatement ConstDeclaration FunctionDefinition ClassDeclaration InterfaceDeclaration TraitDeclaration EnumDeclaration EnumBody EnumCase NamespaceDefinition NamespaceUseDeclaration UseGroup UseClause UseClause GlobalDeclaration FunctionStaticDeclaration Program",
  maxTerm: 304,
  nodeProps: [
    ["group", -36, 2, 8, 49, 81, 83, 85, 88, 93, 94, 102, 106, 107, 110, 111, 114, 118, 123, 126, 130, 132, 133, 147, 148, 149, 150, 153, 154, 164, 165, 179, 181, 182, 183, 184, 185, 191, "Expression", -28, 74, 78, 80, 82, 192, 194, 199, 201, 202, 205, 208, 209, 210, 211, 212, 214, 215, 216, 217, 218, 219, 220, 221, 222, 225, 226, 230, 231, "Statement", -3, 119, 121, 122, "Type"],
    ["openedBy", 69, "phpOpen", 76, "{", 86, "(", 101, "#["],
    ["closedBy", 71, "phpClose", 77, "}", 87, ")", 158, "]"]
  ],
  propSources: [kk],
  skippedNodes: [0],
  repeatNodeCount: 29,
  tokenData: "!F|_R!]OX$zXY&^YZ'sZ]$z]^&^^p$zpq&^qr)Rrs+Pst+otu2buv5evw6rwx8Vxy>]yz>yz{?g{|@}|}Bb}!OCO!O!PDh!P!QKT!Q!R!!o!R![!$q![!]!,P!]!^!-a!^!_!-}!_!`!1S!`!a!2d!a!b!3t!b!c!7^!c!d!7z!d!e!9W!e!}!7z!}#O!;^#O#P!;z#P#Q!<h#Q#R!=U#R#S!7z#S#T!=u#T#U!7z#U#V!9W#V#o!7z#o#p!Co#p#q!D]#q#r!Er#r#s!F`#s$f$z$f$g&^$g&j!7z&j$I_$z$I_$I`&^$I`$KW$z$KW$KX&^$KX;'S$z;'S;=`&W<%l?HT$z?HT?HU&^?HUO$zP%PV&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zP%kO&wPP%nWOY$zYZ%fZ!a$z!b;'S$z;'S;=`&W<%l~$z~O$z~~%fP&ZP;=`<%l$zV&ed&wP&vUOX$zXY&^YZ'sZ]$z]^&^^p$zpq&^q!^$z!^!_%k!_$f$z$f$g&^$g$I_$z$I_$I`&^$I`$KW$z$KW$KX&^$KX;'S$z;'S;=`&W<%l?HT$z?HT?HU&^?HUO$zV'zW&wP&vUXY(dYZ(d]^(dpq(d$f$g(d$I_$I`(d$KW$KX(d?HT?HU(dU(iW&vUXY(dYZ(d]^(dpq(d$f$g(d$I_$I`(d$KW$KX(d?HT?HU(dR)YW$^Q&wPOY$zYZ%fZ!^$z!^!_%k!_!`)r!`;'S$z;'S;=`&W<%lO$zR)yW$QQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`*c!`;'S$z;'S;=`&W<%lO$zR*jV$QQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV+YV'fS&wP'gQOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV+v]&wP!dUOY,oYZ%fZ],o]^$z^!^,o!^!_-i!_!a,o!a!b/y!b!},o!}#O1f#O;'S,o;'S;=`/s<%lO,oV,vZ&wP!dUOY,oYZ%fZ],o]^$z^!^,o!^!_-i!_!a,o!a!b/y!b;'S,o;'S;=`/s<%lO,oV-nZ!dUOY,oYZ%fZ],o]^$z^!a,o!a!b.a!b;'S,o;'S;=`/s<%l~,o~O,o~~%fU.dWOY.|YZ/nZ].|]^/n^!`.|!a;'S.|;'S;=`/h<%lO.|U/RV!dUOY.|Z].|^!a.|!a!b.a!b;'S.|;'S;=`/h<%lO.|U/kP;=`<%l.|U/sO!dUV/vP;=`<%l,oV0OZ&wPOY,oYZ0qZ],o]^0x^!^,o!^!_-i!_!`,o!`!a$z!a;'S,o;'S;=`/s<%lO,oV0xO&wP!dUV1PV&wP!dUOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV1oZ&wP$dQ!dUOY,oYZ%fZ],o]^$z^!^,o!^!_-i!_!a,o!a!b/y!b;'S,o;'S;=`/s<%lO,o_2i`&wP#dQOY$zYZ%fZ!^$z!^!_%k!_!c$z!c!}3k!}#R$z#R#S3k#S#T$z#T#o3k#o#p4w#p$g$z$g&j3k&j;'S$z;'S;=`&W<%lO$z_3ra&wP#b^OY$zYZ%fZ!Q$z!Q![3k![!^$z!^!_%k!_!c$z!c!}3k!}#R$z#R#S3k#S#T$z#T#o3k#o$g$z$g&j3k&j;'S$z;'S;=`&W<%lO$zV5OV&wP#eUOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR5lW&wP$VQOY$zYZ%fZ!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zR6]V#wQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV6yY#SU&wPOY$zYZ%fZv$zvw7iw!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zR7pV#|Q&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR8^Z&wP%VQOY8VYZ9PZw8Vwx;_x!^8V!^!_;{!_#O8V#O#P<y#P;'S8V;'S;=`>V<%lO8VR9WV&wP%VQOw9mwx:Xx#O9m#O#P:^#P;'S9m;'S;=`;X<%lO9mQ9rV%VQOw9mwx:Xx#O9m#O#P:^#P;'S9m;'S;=`;X<%lO9mQ:^O%VQQ:aRO;'S9m;'S;=`:j;=`O9mQ:oW%VQOw9mwx:Xx#O9m#O#P:^#P;'S9m;'S;=`;X;=`<%l9m<%lO9mQ;[P;=`<%l9mR;fV&wP%VQOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR<Q]%VQOY8VYZ9PZw8Vwx;_x!a8V!a!b9m!b#O8V#O#P<y#P;'S8V;'S;=`>V<%l~8V~O8V~~%fR=OW&wPOY8VYZ9PZ!^8V!^!_;{!_;'S8V;'S;=`=h;=`<%l9m<%lO8VR=mW%VQOw9mwx:Xx#O9m#O#P:^#P;'S9m;'S;=`;X;=`<%l8V<%lO9mR>YP;=`<%l8VR>dV!yQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV?QV!xU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR?nY&wP$VQOY$zYZ%fZz$zz{@^{!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zR@eW$WQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zRAUY$TQ&wPOY$zYZ%fZ{$z{|At|!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zRA{V$zQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zRBiV!}Q&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$z_CXZ$TQ%TW&wPOY$zYZ%fZ}$z}!OAt!O!^$z!^!_%k!_!`6U!`!aCz!a;'S$z;'S;=`&W<%lO$zVDRV#`U&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zVDo[&wP$UQOY$zYZ%fZ!O$z!O!PEe!P!Q$z!Q![Fs![!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zVEjX&wPOY$zYZ%fZ!O$z!O!PFV!P!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zVF^V#UU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zRFz_&wP%OQOY$zYZ%fZ!Q$z!Q![Fs![!^$z!^!_%k!_!g$z!g!hGy!h#R$z#R#SJc#S#X$z#X#YGy#Y;'S$z;'S;=`&W<%lO$zRHO]&wPOY$zYZ%fZ{$z{|Hw|}$z}!OHw!O!Q$z!Q![Ii![!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zRH|X&wPOY$zYZ%fZ!Q$z!Q![Ii![!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zRIpZ&wP%OQOY$zYZ%fZ!Q$z!Q![Ii![!^$z!^!_%k!_#R$z#R#SHw#S;'S$z;'S;=`&W<%lO$zRJhX&wPOY$zYZ%fZ!Q$z!Q![Fs![!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zVK[[&wP$VQOY$zYZ%fZz$zz{LQ{!P$z!P!Q,o!Q!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zVLVX&wPOYLQYZLrZzLQz{N_{!^LQ!^!_! s!_;'SLQ;'S;=`!!i<%lOLQVLwT&wPOzMWz{Mj{;'SMW;'S;=`NX<%lOMWUMZTOzMWz{Mj{;'SMW;'S;=`NX<%lOMWUMmVOzMWz{Mj{!PMW!P!QNS!Q;'SMW;'S;=`NX<%lOMWUNXO!eUUN[P;=`<%lMWVNdZ&wPOYLQYZLrZzLQz{N_{!PLQ!P!Q! V!Q!^LQ!^!_! s!_;'SLQ;'S;=`!!i<%lOLQV! ^V!eU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV! vZOYLQYZLrZzLQz{N_{!aLQ!a!bMW!b;'SLQ;'S;=`!!i<%l~LQ~OLQ~~%fV!!lP;=`<%lLQZ!!vm&wP$}YOY$zYZ%fZ!O$z!O!PFs!P!Q$z!Q![!$q![!^$z!^!_%k!_!d$z!d!e!&o!e!g$z!g!hGy!h!q$z!q!r!(a!r!z$z!z!{!){!{#R$z#R#S!%}#S#U$z#U#V!&o#V#X$z#X#YGy#Y#c$z#c#d!(a#d#l$z#l#m!){#m;'S$z;'S;=`&W<%lO$zZ!$xa&wP$}YOY$zYZ%fZ!O$z!O!PFs!P!Q$z!Q![!$q![!^$z!^!_%k!_!g$z!g!hGy!h#R$z#R#S!%}#S#X$z#X#YGy#Y;'S$z;'S;=`&W<%lO$zZ!&SX&wPOY$zYZ%fZ!Q$z!Q![!$q![!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zZ!&tY&wPOY$zYZ%fZ!Q$z!Q!R!'d!R!S!'d!S!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zZ!'k[&wP$}YOY$zYZ%fZ!Q$z!Q!R!'d!R!S!'d!S!^$z!^!_%k!_#R$z#R#S!&o#S;'S$z;'S;=`&W<%lO$zZ!(fX&wPOY$zYZ%fZ!Q$z!Q!Y!)R!Y!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zZ!)YZ&wP$}YOY$zYZ%fZ!Q$z!Q!Y!)R!Y!^$z!^!_%k!_#R$z#R#S!(a#S;'S$z;'S;=`&W<%lO$zZ!*Q]&wPOY$zYZ%fZ!Q$z!Q![!*y![!^$z!^!_%k!_!c$z!c!i!*y!i#T$z#T#Z!*y#Z;'S$z;'S;=`&W<%lO$zZ!+Q_&wP$}YOY$zYZ%fZ!Q$z!Q![!*y![!^$z!^!_%k!_!c$z!c!i!*y!i#R$z#R#S!){#S#T$z#T#Z!*y#Z;'S$z;'S;=`&W<%lO$zR!,WX!qQ&wPOY$zYZ%fZ![$z![!]!,s!]!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!,zV#sQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV!-hV!mU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!.S[$RQOY$zYZ%fZ!^$z!^!_!.x!_!`!/i!`!a*c!a!b!0]!b;'S$z;'S;=`&W<%l~$z~O$z~~%fR!/PW$SQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zR!/pX$RQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`$z!`!a*c!a;'S$z;'S;=`&W<%lO$zP!0bR!iP!_!`!0k!r!s!0p#d#e!0pP!0pO!iPP!0sQ!j!k!0y#[#]!0yP!0|Q!r!s!0k#d#e!0kV!1ZX#uQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`)r!`!a!1v!a;'S$z;'S;=`&W<%lO$zV!1}V#OU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!2kX$RQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`!3W!`!a!.x!a;'S$z;'S;=`&W<%lO$zR!3_V$RQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV!3{[!vQ&wPOY$zYZ%fZ}$z}!O!4q!O!^$z!^!_%k!_!`$z!`!a!6P!a!b!6m!b;'S$z;'S;=`&W<%lO$zV!4vX&wPOY$zYZ%fZ!^$z!^!_%k!_!`$z!`!a!5c!a;'S$z;'S;=`&W<%lO$zV!5jV#aU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV!6WV!gU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!6tW#zQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zR!7eV$]Q&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$z_!8Ra&wP!s^OY$zYZ%fZ!Q$z!Q![!7z![!^$z!^!_%k!_!c$z!c!}!7z!}#R$z#R#S!7z#S#T$z#T#o!7z#o$g$z$g&j!7z&j;'S$z;'S;=`&W<%lO$z_!9_e&wP!s^OY$zYZ%fZr$zrs!:psw$zwx8Vx!Q$z!Q![!7z![!^$z!^!_%k!_!c$z!c!}!7z!}#R$z#R#S!7z#S#T$z#T#o!7z#o$g$z$g&j!7z&j;'S$z;'S;=`&W<%lO$zR!:wV&wP'gQOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV!;eV#WU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV!<RV#pU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!<oV#XQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!=]W$OQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zR!=zZ&wPOY!=uYZ!>mZ!^!=u!^!_!@u!_#O!=u#O#P!Aq#P#S!=u#S#T!B{#T;'S!=u;'S;=`!Ci<%lO!=uR!>rV&wPO#O!?X#O#P!?q#P#S!?X#S#T!@j#T;'S!?X;'S;=`!@o<%lO!?XQ!?[VO#O!?X#O#P!?q#P#S!?X#S#T!@j#T;'S!?X;'S;=`!@o<%lO!?XQ!?tRO;'S!?X;'S;=`!?};=`O!?XQ!@QWO#O!?X#O#P!?q#P#S!?X#S#T!@j#T;'S!?X;'S;=`!@o;=`<%l!?X<%lO!?XQ!@oO${QQ!@rP;=`<%l!?XR!@x]OY!=uYZ!>mZ!a!=u!a!b!?X!b#O!=u#O#P!Aq#P#S!=u#S#T!B{#T;'S!=u;'S;=`!Ci<%l~!=u~O!=u~~%fR!AvW&wPOY!=uYZ!>mZ!^!=u!^!_!@u!_;'S!=u;'S;=`!B`;=`<%l!?X<%lO!=uR!BcWO#O!?X#O#P!?q#P#S!?X#S#T!@j#T;'S!?X;'S;=`!@o;=`<%l!=u<%lO!?XR!CSV${Q&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!ClP;=`<%l!=uV!CvV!oU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV!DfY#}Q#lS&wPOY$zYZ%fZ!^$z!^!_%k!_!`6U!`#p$z#p#q!EU#q;'S$z;'S;=`&W<%lO$zR!E]V#{Q&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!EyV!nQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!FgV$^Q&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$z",
  tokenizers: [bk, vk, Tk, 0, 1, 2, 3, wk],
  topRules: { Template: [0, 72], Program: [1, 232] },
  dynamicPrecedences: { 284: 1 },
  specialized: [{ term: 81, get: (O, e) => uf(O) << 1, external: uf }, { term: 81, get: (O) => Yk[O] || -1 }],
  tokenPrec: 29354
});
var qk = Ze.define({
  name: "php",
  parser: Zk.configure({
    props: [
      Ce.add({
        IfStatement: $e({ except: /^\s*({|else\b|elseif\b|endif\b)/ }),
        TryStatement: $e({ except: /^\s*({|catch\b|finally\b)/ }),
        SwitchBody: (O) => {
          let e = O.textAfter, t = /^\s*\}/.test(e), i = /^\s*(case|default)\b/.test(e);
          return O.baseIndent + (t ? 0 : i ? 1 : 2) * O.unit;
        },
        ColonBlock: (O) => O.baseIndent + O.unit,
        "Block EnumBody DeclarationList": Ft({ closing: "}" }),
        ArrowFunction: (O) => O.baseIndent + O.unit,
        "String BlockComment": () => null,
        Statement: $e({ except: /^({|end(for|foreach|switch|while)\b)/ })
      }),
      Ge.add({
        "Block EnumBody DeclarationList SwitchBody ArrayExpression ValueList": _t,
        ColonBlock(O) {
          return { from: O.from + 1, to: O.to };
        },
        BlockComment(O) {
          return { from: O.from + 2, to: O.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" }, line: "//" },
    indentOnInput: /^\s*(?:case |default:|end(?:if|for(?:each)?|switch|while)|else(?:if)?|\{|\})$/,
    wordChars: "$",
    closeBrackets: { stringPrefixes: ["b", "B"] }
  }
});
function zk(O = {}) {
  let e = [], t;
  if (O.baseLanguage !== null)
    if (O.baseLanguage)
      t = O.baseLanguage;
    else {
      let i = Kl({ matchClosingTags: false });
      e.push(i.support), t = i.language;
    }
  return new je(qk.configure({
    wrap: t && xl((i) => i.type.isTop ? {
      parser: t.parser,
      overlay: (n) => n.name == "Text"
    } : null),
    top: O.plain ? "Program" : "Template"
  }), e);
}
var Uk = 36;
var df = 1;
var Vk = 2;
var Ln = 3;
var po = 4;
var Rk = 5;
var _k = 6;
var jk = 7;
var Ck = 8;
var Gk = 9;
var Ik = 10;
var Ek = 11;
var Ak = 12;
var Dk = 13;
var Mk = 14;
var Lk = 15;
var Bk = 16;
var Nk = 17;
var Qf = 18;
var Fk = 19;
var cm = 20;
var hm = 21;
var $f = 22;
var Hk = 23;
var Kk = 24;
function _a(O) {
  return O >= 65 && O <= 90 || O >= 97 && O <= 122 || O >= 48 && O <= 57;
}
function Jk(O) {
  return O >= 48 && O <= 57 || O >= 97 && O <= 102 || O >= 65 && O <= 70;
}
function uO(O, e, t) {
  for (let i = false; ; ) {
    if (O.next < 0)
      return;
    if (O.next == e && !i) {
      O.advance();
      return;
    }
    i = t && !i && O.next == 92, O.advance();
  }
}
function eY(O) {
  for (; ; ) {
    if (O.next < 0 || O.peek(1) < 0)
      return;
    if (O.next == 36 && O.peek(1) == 36) {
      O.advance(2);
      return;
    }
    O.advance();
  }
}
function um(O, e) {
  for (; !(O.next != 95 && !_a(O.next)); )
    e != null && (e += String.fromCharCode(O.next)), O.advance();
  return e;
}
function tY(O) {
  if (O.next == 39 || O.next == 34 || O.next == 96) {
    let e = O.next;
    O.advance(), uO(O, e, false);
  } else
    um(O);
}
function pf(O, e) {
  for (; O.next == 48 || O.next == 49; )
    O.advance();
  e && O.next == e && O.advance();
}
function mf(O, e) {
  for (; ; ) {
    if (O.next == 46) {
      if (e)
        break;
      e = true;
    } else if (O.next < 48 || O.next > 57)
      break;
    O.advance();
  }
  if (O.next == 69 || O.next == 101)
    for (O.advance(), (O.next == 43 || O.next == 45) && O.advance(); O.next >= 48 && O.next <= 57; )
      O.advance();
}
function gf(O) {
  for (; !(O.next < 0 || O.next == 10); )
    O.advance();
}
function YO(O, e) {
  for (let t = 0; t < e.length; t++)
    if (e.charCodeAt(t) == O)
      return true;
  return false;
}
var Sf = ` 	\r
`;
function fm(O, e, t) {
  let i = /* @__PURE__ */ Object.create(null);
  i.true = i.false = Rk, i.null = i.unknown = _k;
  for (let n of O.split(" "))
    n && (i[n] = cm);
  for (let n of e.split(" "))
    n && (i[n] = hm);
  for (let n of (t || "").split(" "))
    n && (i[n] = Kk);
  return i;
}
var OY = "array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying ";
var iY = "absolute action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded case cast catalog check close collate collation column commit condition connect connection constraint constraints constructor continue corresponding count create cross cube current current_date current_default_transform_group current_transform_group_for_type current_path current_role current_time current_timestamp current_user cursor cycle data day deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exists exit external fetch first for foreign found from free full function general get global go goto grant group grouping handle having hold hour identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local localtime localtimestamp locator loop map match method minute modifies module month names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search second section select session session_user set sets signal similar size some space specific specifictype sql sqlexception sqlstate sqlwarning start state static system_user table temporary then timezone_hour timezone_minute to trailing transaction translation treat trigger under undo union unique unnest until update usage user using value values view when whenever where while with without work write year zone ";
var ja = {
  backslashEscapes: false,
  hashComments: false,
  spaceAfterDashes: false,
  slashComments: false,
  doubleQuotedStrings: false,
  doubleDollarQuotedStrings: false,
  unquotedBitLiterals: false,
  treatBitsAsBytes: false,
  charSetCasts: false,
  operatorChars: "*+-%<>!=&|~^/",
  specialVar: "?",
  identifierQuotes: '"',
  words: fm(iY, OY)
};
function nY(O, e, t, i) {
  let n = {};
  for (let r in ja)
    n[r] = (O.hasOwnProperty(r) ? O : ja)[r];
  return e && (n.words = fm(e, t || "", i)), n;
}
function dm(O) {
  return new te((e) => {
    var t;
    let { next: i } = e;
    if (e.advance(), YO(i, Sf)) {
      for (; YO(e.next, Sf); )
        e.advance();
      e.acceptToken(Uk);
    } else if (i == 36 && e.next == 36 && O.doubleDollarQuotedStrings)
      eY(e), e.acceptToken(Ln);
    else if (i == 39 || i == 34 && O.doubleQuotedStrings)
      uO(e, i, O.backslashEscapes), e.acceptToken(Ln);
    else if (i == 35 && O.hashComments || i == 47 && e.next == 47 && O.slashComments)
      gf(e), e.acceptToken(df);
    else if (i == 45 && e.next == 45 && (!O.spaceAfterDashes || e.peek(1) == 32))
      gf(e), e.acceptToken(df);
    else if (i == 47 && e.next == 42) {
      e.advance();
      for (let n = -1, r = 1; !(e.next < 0); )
        if (e.advance(), n == 42 && e.next == 47) {
          if (r--, !r) {
            e.advance();
            break;
          }
          n = -1;
        } else
          n == 47 && e.next == 42 ? (r++, n = -1) : n = e.next;
      e.acceptToken(Vk);
    } else if ((i == 101 || i == 69) && e.next == 39)
      e.advance(), uO(e, 39, true);
    else if ((i == 110 || i == 78) && e.next == 39 && O.charSetCasts)
      e.advance(), uO(e, 39, O.backslashEscapes), e.acceptToken(Ln);
    else if (i == 95 && O.charSetCasts)
      for (let n = 0; ; n++) {
        if (e.next == 39 && n > 1) {
          e.advance(), uO(e, 39, O.backslashEscapes), e.acceptToken(Ln);
          break;
        }
        if (!_a(e.next))
          break;
        e.advance();
      }
    else if (i == 40)
      e.acceptToken(jk);
    else if (i == 41)
      e.acceptToken(Ck);
    else if (i == 123)
      e.acceptToken(Gk);
    else if (i == 125)
      e.acceptToken(Ik);
    else if (i == 91)
      e.acceptToken(Ek);
    else if (i == 93)
      e.acceptToken(Ak);
    else if (i == 59)
      e.acceptToken(Dk);
    else if (O.unquotedBitLiterals && i == 48 && e.next == 98)
      e.advance(), pf(e), e.acceptToken($f);
    else if ((i == 98 || i == 66) && (e.next == 39 || e.next == 34)) {
      const n = e.next;
      e.advance(), O.treatBitsAsBytes ? (uO(e, n, O.backslashEscapes), e.acceptToken(Hk)) : (pf(e, n), e.acceptToken($f));
    } else if (i == 48 && (e.next == 120 || e.next == 88) || (i == 120 || i == 88) && e.next == 39) {
      let n = e.next == 39;
      for (e.advance(); Jk(e.next); )
        e.advance();
      n && e.next == 39 && e.advance(), e.acceptToken(po);
    } else if (i == 46 && e.next >= 48 && e.next <= 57)
      mf(e, true), e.acceptToken(po);
    else if (i == 46)
      e.acceptToken(Mk);
    else if (i >= 48 && i <= 57)
      mf(e, false), e.acceptToken(po);
    else if (YO(i, O.operatorChars)) {
      for (; YO(e.next, O.operatorChars); )
        e.advance();
      e.acceptToken(Lk);
    } else if (YO(i, O.specialVar))
      e.next == i && e.advance(), tY(e), e.acceptToken(Nk);
    else if (YO(i, O.identifierQuotes))
      uO(e, i, false), e.acceptToken(Fk);
    else if (i == 58 || i == 44)
      e.acceptToken(Bk);
    else if (_a(i)) {
      let n = um(e, String.fromCharCode(i));
      e.acceptToken(e.next == 46 ? Qf : (t = O.words[n.toLowerCase()]) !== null && t !== void 0 ? t : Qf);
    }
  });
}
var Qm = dm(ja);
var rY = qe.deserialize({
  version: 14,
  states: "%vQ]QQOOO#wQRO'#DSO$OQQO'#CwO%eQQO'#CxO%lQQO'#CyO%sQQO'#CzOOQQ'#DS'#DSOOQQ'#C}'#C}O'UQRO'#C{OOQQ'#Cv'#CvOOQQ'#C|'#C|Q]QQOOQOQQOOO'`QQO'#DOO(xQRO,59cO)PQQO,59cO)UQQO'#DSOOQQ,59d,59dO)cQQO,59dOOQQ,59e,59eO)jQQO,59eOOQQ,59f,59fO)qQQO,59fOOQQ-E6{-E6{OOQQ,59b,59bOOQQ-E6z-E6zOOQQ,59j,59jOOQQ-E6|-E6|O+VQRO1G.}O+^QQO,59cOOQQ1G/O1G/OOOQQ1G/P1G/POOQQ1G/Q1G/QP+kQQO'#C}O+rQQO1G.}O)PQQO,59cO,PQQO'#Cw",
  stateData: ",[~OtOSPOSQOS~ORUOSUOTUOUUOVROXSOZTO]XO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O^]ORvXSvXTvXUvXVvXXvXZvX]vX_vX`vXavXbvXcvXdvXevXfvXgvXhvX~OsvX~P!jOa_Ob_Oc_O~ORUOSUOTUOUUOVROXSOZTO^tO_UO`UOa`Ob`Oc`OdUOeUOfUOgUOhUO~OWaO~P$ZOYcO~P$ZO[eO~P$ZORUOSUOTUOUUOVROXSOZTO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O]hOsoX~P%zOajObjOcjO~O^]ORkaSkaTkaUkaVkaXkaZka]ka_ka`kaakabkackadkaekafkagkahka~Oska~P'kO^]O~OWvXYvX[vX~P!jOWnO~P$ZOYoO~P$ZO[pO~P$ZO^]ORkiSkiTkiUkiVkiXkiZki]ki_ki`kiakibkickidkiekifkigkihki~Oski~P)xOWkaYka[ka~P'kO]hO~P$ZOWkiYki[ki~P)xOasObsOcsO~O",
  goto: "#hwPPPPPPPPPPPPPPPPPPPPPPPPPPx||||!Y!^!d!xPPP#[TYOZeUORSTWZbdfqT[OZQZORiZSWOZQbRQdSQfTZgWbdfqQ^PWk^lmrQl_Qm`RrseVORSTWZbdfq",
  nodeNames: "⚠ LineComment BlockComment String Number Bool Null ( ) { } [ ] ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Bits Bytes Builtin Script Statement CompositeIdentifier Parens Braces Brackets Statement",
  maxTerm: 38,
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 3,
  tokenData: "RORO",
  tokenizers: [0, Qm],
  topRules: { Script: [0, 25] },
  tokenPrec: 0
});
function Ca(O) {
  let e = O.cursor().moveTo(O.from, -1);
  for (; /Comment/.test(e.name); )
    e.moveTo(e.from, -1);
  return e.node;
}
function nn(O, e) {
  let t = O.sliceString(e.from, e.to), i = /^([`'"])(.*)\1$/.exec(t);
  return i ? i[2] : t;
}
function Jr(O) {
  return O && (O.name == "Identifier" || O.name == "QuotedIdentifier");
}
function sY(O, e) {
  if (e.name == "CompositeIdentifier") {
    let t = [];
    for (let i = e.firstChild; i; i = i.nextSibling)
      Jr(i) && t.push(nn(O, i));
    return t;
  }
  return [nn(O, e)];
}
function Pf(O, e) {
  for (let t = []; ; ) {
    if (!e || e.name != ".")
      return t;
    let i = Ca(e);
    if (!Jr(i))
      return t;
    t.unshift(nn(O, i)), e = Ca(i);
  }
}
function oY(O, e) {
  let t = B(O).resolveInner(e, -1), i = lY(O.doc, t);
  return t.name == "Identifier" || t.name == "QuotedIdentifier" || t.name == "Keyword" ? {
    from: t.from,
    quoted: t.name == "QuotedIdentifier" ? O.doc.sliceString(t.from, t.from + 1) : null,
    parents: Pf(O.doc, Ca(t)),
    aliases: i
  } : t.name == "." ? { from: e, quoted: null, parents: Pf(O.doc, t), aliases: i } : { from: e, quoted: null, parents: [], empty: true, aliases: i };
}
var aY = new Set("where group having order union intersect except all distinct limit offset fetch for".split(" "));
function lY(O, e) {
  let t;
  for (let n = e; !t; n = n.parent) {
    if (!n)
      return null;
    n.name == "Statement" && (t = n);
  }
  let i = null;
  for (let n = t.firstChild, r = false, s = null; n; n = n.nextSibling) {
    let o = n.name == "Keyword" ? O.sliceString(n.from, n.to).toLowerCase() : null, a = null;
    if (!r)
      r = o == "from";
    else if (o == "as" && s && Jr(n.nextSibling))
      a = nn(O, n.nextSibling);
    else {
      if (o && aY.has(o))
        break;
      s && Jr(n) && (a = nn(O, n));
    }
    a && (i || (i = /* @__PURE__ */ Object.create(null)), i[a] = sY(O, s)), s = /Identifier$/.test(n.name) ? n : null;
  }
  return i;
}
function cY(O, e) {
  return O ? e.map((t) => Object.assign(Object.assign({}, t), { label: O + t.label + O, apply: void 0 })) : e;
}
var hY = /^\w*$/;
var uY = /^[`'"]?\w*[`'"]?$/;
var tc = class {
  constructor() {
    this.list = [], this.children = void 0;
  }
  child(e) {
    let t = this.children || (this.children = /* @__PURE__ */ Object.create(null));
    return t[e] || (t[e] = new tc());
  }
  childCompletions(e) {
    return this.children ? Object.keys(this.children).filter((t) => t).map((t) => ({ label: t, type: e })) : [];
  }
};
function fY(O, e, t, i, n) {
  let r = new tc(), s = r.child(n || "");
  for (let o in O) {
    let a = o.indexOf("."), h2 = (a > -1 ? r.child(o.slice(0, a)) : s).child(a > -1 ? o.slice(a + 1) : o);
    h2.list = O[o].map((u) => typeof u == "string" ? { label: u, type: "property" } : u);
  }
  s.list = (e || s.childCompletions("type")).concat(i ? s.child(i).list : []);
  for (let o in r.children) {
    let a = r.child(o);
    a.list.length || (a.list = a.childCompletions("type"));
  }
  return r.list = s.list.concat(t || r.childCompletions("type")), (o) => {
    let { parents: a, from: l, quoted: h2, empty: u, aliases: f } = oY(o.state, o.pos);
    if (u && !o.explicit)
      return null;
    f && a.length == 1 && (a = f[a[0]] || a);
    let d = r;
    for (let p of a) {
      for (; !d.children || !d.children[p]; )
        if (d == r)
          d = s;
        else if (d == s && i)
          d = d.child(i);
        else
          return null;
      d = d.child(p);
    }
    let Q = h2 && o.state.sliceDoc(o.pos, o.pos + 1) == h2, $ = d.list;
    return d == r && f && ($ = $.concat(Object.keys(f).map((p) => ({ label: p, type: "constant" })))), {
      from: l,
      to: Q ? o.pos + 1 : void 0,
      options: cY(h2, $),
      validFor: h2 ? uY : hY
    };
  };
}
function dY(O, e) {
  let t = Object.keys(O).map((i) => ({
    label: e ? i.toUpperCase() : i,
    type: O[i] == hm ? "type" : O[i] == cm ? "keyword" : "variable",
    boost: -1
  }));
  return Gl(["QuotedIdentifier", "SpecialVar", "String", "LineComment", "BlockComment", "."], ps(t));
}
var QY = rY.configure({
  props: [
    Ce.add({
      Statement: $e()
    }),
    Ge.add({
      Statement(O) {
        return { from: O.firstChild.to, to: O.to };
      },
      BlockComment(O) {
        return { from: O.from + 2, to: O.to - 2 };
      }
    }),
    ze({
      Keyword: c.keyword,
      Type: c.typeName,
      Builtin: c.standard(c.name),
      Bits: c.number,
      Bytes: c.string,
      Bool: c.bool,
      Null: c.null,
      Number: c.number,
      String: c.string,
      Identifier: c.name,
      QuotedIdentifier: c.special(c.string),
      SpecialVar: c.special(c.name),
      LineComment: c.lineComment,
      BlockComment: c.blockComment,
      Operator: c.operator,
      "Semi Punctuation": c.punctuation,
      "( )": c.paren,
      "{ }": c.brace,
      "[ ]": c.squareBracket
    })
  ]
});
var Oc = class {
  constructor(e, t) {
    this.dialect = e, this.language = t;
  }
  /**
  Returns the language for this dialect as an extension.
  */
  get extension() {
    return this.language.extension;
  }
  /**
  Define a new dialect.
  */
  static define(e) {
    let t = nY(e, e.keywords, e.types, e.builtin), i = Ze.define({
      name: "sql",
      parser: QY.configure({
        tokenizers: [{ from: Qm, to: dm(t) }]
      }),
      languageData: {
        commentTokens: { line: "--", block: { open: "/*", close: "*/" } },
        closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }
      }
    });
    return new Oc(t, i);
  }
};
function $Y(O, e = false) {
  return dY(O.dialect.words, e);
}
function pY(O, e = false) {
  return O.language.data.of({
    autocomplete: $Y(O, e)
  });
}
function mY(O) {
  return O.schema ? fY(O.schema, O.tables, O.schemas, O.defaultTable, O.defaultSchema) : () => null;
}
function gY(O) {
  return O.schema ? (O.dialect || $m).language.data.of({
    autocomplete: mY(O)
  }) : [];
}
function SY(O = {}) {
  let e = O.dialect || $m;
  return new je(e.language, [gY(O), pY(e, !!O.upperCaseKeywords)]);
}
var $m = Oc.define({});
var es = class {
  constructor(e, t, i, n, r, s, o) {
    this.type = e, this.value = t, this.from = i, this.hash = n, this.end = r, this.children = s, this.positions = o, this.hashProp = [[_.contextHash, n]];
  }
  static create(e, t, i, n, r) {
    let s = n + (n << 8) + e + (t << 4) | 0;
    return new es(e, t, i, s, r, [], []);
  }
  addChild(e, t) {
    e.prop(_.contextHash) != this.hash && (e = new E(e.type, e.children, e.positions, e.length, this.hashProp)), this.children.push(e), this.positions.push(t);
  }
  toTree(e, t = this.end) {
    let i = this.children.length - 1;
    return i >= 0 && (t = Math.max(t, this.positions[i] + this.children[i].length + this.from)), new E(e.types[this.type], this.children, this.positions, t - this.from).balance({
      makeTree: (r, s, o) => new E(ue.none, r, s, o, this.hashProp)
    });
  }
};
var x;
(function(O) {
  O[O.Document = 1] = "Document", O[O.CodeBlock = 2] = "CodeBlock", O[O.FencedCode = 3] = "FencedCode", O[O.Blockquote = 4] = "Blockquote", O[O.HorizontalRule = 5] = "HorizontalRule", O[O.BulletList = 6] = "BulletList", O[O.OrderedList = 7] = "OrderedList", O[O.ListItem = 8] = "ListItem", O[O.ATXHeading1 = 9] = "ATXHeading1", O[O.ATXHeading2 = 10] = "ATXHeading2", O[O.ATXHeading3 = 11] = "ATXHeading3", O[O.ATXHeading4 = 12] = "ATXHeading4", O[O.ATXHeading5 = 13] = "ATXHeading5", O[O.ATXHeading6 = 14] = "ATXHeading6", O[O.SetextHeading1 = 15] = "SetextHeading1", O[O.SetextHeading2 = 16] = "SetextHeading2", O[O.HTMLBlock = 17] = "HTMLBlock", O[O.LinkReference = 18] = "LinkReference", O[O.Paragraph = 19] = "Paragraph", O[O.CommentBlock = 20] = "CommentBlock", O[O.ProcessingInstructionBlock = 21] = "ProcessingInstructionBlock", O[O.Escape = 22] = "Escape", O[O.Entity = 23] = "Entity", O[O.HardBreak = 24] = "HardBreak", O[O.Emphasis = 25] = "Emphasis", O[O.StrongEmphasis = 26] = "StrongEmphasis", O[O.Link = 27] = "Link", O[O.Image = 28] = "Image", O[O.InlineCode = 29] = "InlineCode", O[O.HTMLTag = 30] = "HTMLTag", O[O.Comment = 31] = "Comment", O[O.ProcessingInstruction = 32] = "ProcessingInstruction", O[O.URL = 33] = "URL", O[O.HeaderMark = 34] = "HeaderMark", O[O.QuoteMark = 35] = "QuoteMark", O[O.ListMark = 36] = "ListMark", O[O.LinkMark = 37] = "LinkMark", O[O.EmphasisMark = 38] = "EmphasisMark", O[O.CodeMark = 39] = "CodeMark", O[O.CodeText = 40] = "CodeText", O[O.CodeInfo = 41] = "CodeInfo", O[O.LinkTitle = 42] = "LinkTitle", O[O.LinkLabel = 43] = "LinkLabel";
})(x || (x = {}));
var PY = class {
  /// @internal
  constructor(e, t) {
    this.start = e, this.content = t, this.marks = [], this.parsers = [];
  }
};
var yY = class {
  constructor() {
    this.text = "", this.baseIndent = 0, this.basePos = 0, this.depth = 0, this.markers = [], this.pos = 0, this.indent = 0, this.next = -1;
  }
  /// @internal
  forward() {
    this.basePos > this.pos && this.forwardInner();
  }
  /// @internal
  forwardInner() {
    let e = this.skipSpace(this.basePos);
    this.indent = this.countIndent(e, this.pos, this.indent), this.pos = e, this.next = e == this.text.length ? -1 : this.text.charCodeAt(e);
  }
  /// Skip whitespace after the given position, return the position of
  /// the next non-space character or the end of the line if there's
  /// only space after `from`.
  skipSpace(e) {
    return Ui(this.text, e);
  }
  /// @internal
  reset(e) {
    for (this.text = e, this.baseIndent = this.basePos = this.pos = this.indent = 0, this.forwardInner(), this.depth = 1; this.markers.length; )
      this.markers.pop();
  }
  /// Move the line's base position forward to the given position.
  /// This should only be called by composite [block
  /// parsers](#BlockParser.parse) or [markup skipping
  /// functions](#NodeSpec.composite).
  moveBase(e) {
    this.basePos = e, this.baseIndent = this.countIndent(e, this.pos, this.indent);
  }
  /// Move the line's base position forward to the given _column_.
  moveBaseColumn(e) {
    this.baseIndent = e, this.basePos = this.findColumn(e);
  }
  /// Store a composite-block-level marker. Should be called from
  /// [markup skipping functions](#NodeSpec.composite) when they
  /// consume any non-whitespace characters.
  addMarker(e) {
    this.markers.push(e);
  }
  /// Find the column position at `to`, optionally starting at a given
  /// position and column.
  countIndent(e, t = 0, i = 0) {
    for (let n = t; n < e; n++)
      i += this.text.charCodeAt(n) == 9 ? 4 - i % 4 : 1;
    return i;
  }
  /// Find the position corresponding to the given column.
  findColumn(e) {
    let t = 0;
    for (let i = 0; t < this.text.length && i < e; t++)
      i += this.text.charCodeAt(t) == 9 ? 4 - i % 4 : 1;
    return t;
  }
  /// @internal
  scrub() {
    if (!this.baseIndent)
      return this.text;
    let e = "";
    for (let t = 0; t < this.basePos; t++)
      e += " ";
    return e + this.text.slice(this.basePos);
  }
};
function yf(O, e, t) {
  if (t.pos == t.text.length || O != e.block && t.indent >= e.stack[t.depth + 1].value + t.baseIndent)
    return true;
  if (t.indent >= t.baseIndent + 4)
    return false;
  let i = (O.type == x.OrderedList ? rc : nc)(t, e, false);
  return i > 0 && (O.type != x.BulletList || ic(t, e, false) < 0) && t.text.charCodeAt(t.pos + i - 1) == O.value;
}
var pm = {
  [x.Blockquote](O, e, t) {
    return t.next != 62 ? false : (t.markers.push(M(x.QuoteMark, e.lineStart + t.pos, e.lineStart + t.pos + 1)), t.moveBase(t.pos + (it(t.text.charCodeAt(t.pos + 1)) ? 2 : 1)), O.end = e.lineStart + t.text.length, true);
  },
  [x.ListItem](O, e, t) {
    return t.indent < t.baseIndent + O.value && t.next > -1 ? false : (t.moveBaseColumn(t.baseIndent + O.value), true);
  },
  [x.OrderedList]: yf,
  [x.BulletList]: yf,
  [x.Document]() {
    return true;
  }
};
function it(O) {
  return O == 32 || O == 9 || O == 10 || O == 13;
}
function Ui(O, e = 0) {
  for (; e < O.length && it(O.charCodeAt(e)); )
    e++;
  return e;
}
function Xf(O, e, t) {
  for (; e > t && it(O.charCodeAt(e - 1)); )
    e--;
  return e;
}
function mm(O) {
  if (O.next != 96 && O.next != 126)
    return -1;
  let e = O.pos + 1;
  for (; e < O.text.length && O.text.charCodeAt(e) == O.next; )
    e++;
  if (e < O.pos + 3)
    return -1;
  if (O.next == 96) {
    for (let t = e; t < O.text.length; t++)
      if (O.text.charCodeAt(t) == 96)
        return -1;
  }
  return e;
}
function gm(O) {
  return O.next != 62 ? -1 : O.text.charCodeAt(O.pos + 1) == 32 ? 2 : 1;
}
function ic(O, e, t) {
  if (O.next != 42 && O.next != 45 && O.next != 95)
    return -1;
  let i = 1;
  for (let n = O.pos + 1; n < O.text.length; n++) {
    let r = O.text.charCodeAt(n);
    if (r == O.next)
      i++;
    else if (!it(r))
      return -1;
  }
  return t && O.next == 45 && ym(O) > -1 && O.depth == e.stack.length || i < 3 ? -1 : 1;
}
function Sm(O, e) {
  for (let t = O.stack.length - 1; t >= 0; t--)
    if (O.stack[t].type == e)
      return true;
  return false;
}
function nc(O, e, t) {
  return (O.next == 45 || O.next == 43 || O.next == 42) && (O.pos == O.text.length - 1 || it(O.text.charCodeAt(O.pos + 1))) && (!t || Sm(e, x.BulletList) || O.skipSpace(O.pos + 2) < O.text.length) ? 1 : -1;
}
function rc(O, e, t) {
  let i = O.pos, n = O.next;
  for (; n >= 48 && n <= 57; ) {
    i++;
    if (i == O.text.length)
      return -1;
    n = O.text.charCodeAt(i);
  }
  return i == O.pos || i > O.pos + 9 || n != 46 && n != 41 || i < O.text.length - 1 && !it(O.text.charCodeAt(i + 1)) || t && !Sm(e, x.OrderedList) && (O.skipSpace(i + 1) == O.text.length || i > O.pos + 1 || O.next != 49) ? -1 : i + 1 - O.pos;
}
function Pm(O) {
  if (O.next != 35)
    return -1;
  let e = O.pos + 1;
  for (; e < O.text.length && O.text.charCodeAt(e) == 35; )
    e++;
  if (e < O.text.length && O.text.charCodeAt(e) != 32)
    return -1;
  let t = e - O.pos;
  return t > 6 ? -1 : t;
}
function ym(O) {
  if (O.next != 45 && O.next != 61 || O.indent >= O.baseIndent + 4)
    return -1;
  let e = O.pos + 1;
  for (; e < O.text.length && O.text.charCodeAt(e) == O.next; )
    e++;
  let t = e;
  for (; e < O.text.length && it(O.text.charCodeAt(e)); )
    e++;
  return e == O.text.length ? t : -1;
}
var Ga = /^[ \t]*$/;
var Xm = /-->/;
var xm = /\?>/;
var Ia = [
  [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
  [/^\s*<!--/, Xm],
  [/^\s*<\?/, xm],
  [/^\s*<![A-Z]/, />/],
  [/^\s*<!\[CDATA\[/, /\]\]>/],
  [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, Ga],
  [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, Ga]
];
function bm(O, e, t) {
  if (O.next != 60)
    return -1;
  let i = O.text.slice(O.pos);
  for (let n = 0, r = Ia.length - (t ? 1 : 0); n < r; n++)
    if (Ia[n][0].test(i))
      return n;
  return -1;
}
function xf(O, e) {
  let t = O.countIndent(e, O.pos, O.indent), i = O.countIndent(O.skipSpace(e), e, t);
  return i >= t + 5 ? t + 1 : i;
}
function hO(O, e, t) {
  let i = O.length - 1;
  i >= 0 && O[i].to == e && O[i].type == x.CodeText ? O[i].to = t : O.push(M(x.CodeText, e, t));
}
var Bn = {
  LinkReference: void 0,
  IndentedCode(O, e) {
    let t = e.baseIndent + 4;
    if (e.indent < t)
      return false;
    let i = e.findColumn(t), n = O.lineStart + i, r = O.lineStart + e.text.length, s = [], o = [];
    for (hO(s, n, r); O.nextLine() && e.depth >= O.stack.length; )
      if (e.pos == e.text.length) {
        hO(o, O.lineStart - 1, O.lineStart);
        for (let a of e.markers)
          o.push(a);
      } else {
        if (e.indent < t)
          break;
        {
          if (o.length) {
            for (let l of o)
              l.type == x.CodeText ? hO(s, l.from, l.to) : s.push(l);
            o = [];
          }
          hO(s, O.lineStart - 1, O.lineStart);
          for (let l of e.markers)
            s.push(l);
          r = O.lineStart + e.text.length;
          let a = O.lineStart + e.findColumn(e.baseIndent + 4);
          a < r && hO(s, a, r);
        }
      }
    return o.length && (o = o.filter((a) => a.type != x.CodeText), o.length && (e.markers = o.concat(e.markers))), O.addNode(O.buffer.writeElements(s, -n).finish(x.CodeBlock, r - n), n), true;
  },
  FencedCode(O, e) {
    let t = mm(e);
    if (t < 0)
      return false;
    let i = O.lineStart + e.pos, n = e.next, r = t - e.pos, s = e.skipSpace(t), o = Xf(e.text, e.text.length, s), a = [M(x.CodeMark, i, i + r)];
    s < o && a.push(M(x.CodeInfo, O.lineStart + s, O.lineStart + o));
    for (let l = true; O.nextLine() && e.depth >= O.stack.length; l = false) {
      let h2 = e.pos;
      if (e.indent - e.baseIndent < 4)
        for (; h2 < e.text.length && e.text.charCodeAt(h2) == n; )
          h2++;
      if (h2 - e.pos >= r && e.skipSpace(h2) == e.text.length) {
        for (let u of e.markers)
          a.push(u);
        a.push(M(x.CodeMark, O.lineStart + e.pos, O.lineStart + h2)), O.nextLine();
        break;
      } else {
        l || hO(a, O.lineStart - 1, O.lineStart);
        for (let d of e.markers)
          a.push(d);
        let u = O.lineStart + e.basePos, f = O.lineStart + e.text.length;
        u < f && hO(a, u, f);
      }
    }
    return O.addNode(O.buffer.writeElements(a, -i).finish(x.FencedCode, O.prevLineEnd() - i), i), true;
  },
  Blockquote(O, e) {
    let t = gm(e);
    return t < 0 ? false : (O.startContext(x.Blockquote, e.pos), O.addNode(x.QuoteMark, O.lineStart + e.pos, O.lineStart + e.pos + 1), e.moveBase(e.pos + t), null);
  },
  HorizontalRule(O, e) {
    if (ic(e, O, false) < 0)
      return false;
    let t = O.lineStart + e.pos;
    return O.nextLine(), O.addNode(x.HorizontalRule, t), true;
  },
  BulletList(O, e) {
    let t = nc(e, O, false);
    if (t < 0)
      return false;
    O.block.type != x.BulletList && O.startContext(x.BulletList, e.basePos, e.next);
    let i = xf(e, e.pos + 1);
    return O.startContext(x.ListItem, e.basePos, i - e.baseIndent), O.addNode(x.ListMark, O.lineStart + e.pos, O.lineStart + e.pos + t), e.moveBaseColumn(i), null;
  },
  OrderedList(O, e) {
    let t = rc(e, O, false);
    if (t < 0)
      return false;
    O.block.type != x.OrderedList && O.startContext(x.OrderedList, e.basePos, e.text.charCodeAt(e.pos + t - 1));
    let i = xf(e, e.pos + t);
    return O.startContext(x.ListItem, e.basePos, i - e.baseIndent), O.addNode(x.ListMark, O.lineStart + e.pos, O.lineStart + e.pos + t), e.moveBaseColumn(i), null;
  },
  ATXHeading(O, e) {
    let t = Pm(e);
    if (t < 0)
      return false;
    let i = e.pos, n = O.lineStart + i, r = Xf(e.text, e.text.length, i), s = r;
    for (; s > i && e.text.charCodeAt(s - 1) == e.next; )
      s--;
    (s == r || s == i || !it(e.text.charCodeAt(s - 1))) && (s = e.text.length);
    let o = O.buffer.write(x.HeaderMark, 0, t).writeElements(O.parser.parseInline(e.text.slice(i + t + 1, s), n + t + 1), -n);
    s < e.text.length && o.write(x.HeaderMark, s - i, r - i);
    let a = o.finish(x.ATXHeading1 - 1 + t, e.text.length - i);
    return O.nextLine(), O.addNode(a, n), true;
  },
  HTMLBlock(O, e) {
    let t = bm(e, O, false);
    if (t < 0)
      return false;
    let i = O.lineStart + e.pos, n = Ia[t][1], r = [], s = n != Ga;
    for (; !n.test(e.text) && O.nextLine(); ) {
      if (e.depth < O.stack.length) {
        s = false;
        break;
      }
      for (let l of e.markers)
        r.push(l);
    }
    s && O.nextLine();
    let o = n == Xm ? x.CommentBlock : n == xm ? x.ProcessingInstructionBlock : x.HTMLBlock, a = O.prevLineEnd();
    return O.addNode(O.buffer.writeElements(r, -i).finish(o, a - i), i), true;
  },
  SetextHeading: void 0
  // Specifies relative precedence for block-continue function
};
var XY = class {
  constructor(e) {
    this.stage = 0, this.elts = [], this.pos = 0, this.start = e.start, this.advance(e.content);
  }
  nextLine(e, t, i) {
    if (this.stage == -1)
      return false;
    let n = i.content + `
` + t.scrub(), r = this.advance(n);
    return r > -1 && r < n.length ? this.complete(e, i, r) : false;
  }
  finish(e, t) {
    return (this.stage == 2 || this.stage == 3) && Ui(t.content, this.pos) == t.content.length ? this.complete(e, t, t.content.length) : false;
  }
  complete(e, t, i) {
    return e.addLeafElement(t, M(x.LinkReference, this.start, this.start + i, this.elts)), true;
  }
  nextStage(e) {
    return e ? (this.pos = e.to - this.start, this.elts.push(e), this.stage++, true) : (e === false && (this.stage = -1), false);
  }
  advance(e) {
    for (; ; ) {
      if (this.stage == -1)
        return -1;
      if (this.stage == 0) {
        if (!this.nextStage(zm(e, this.pos, this.start, true)))
          return -1;
        if (e.charCodeAt(this.pos) != 58)
          return this.stage = -1;
        this.elts.push(M(x.LinkMark, this.pos + this.start, this.pos + this.start + 1)), this.pos++;
      } else if (this.stage == 1) {
        if (!this.nextStage(Zm(e, Ui(e, this.pos), this.start)))
          return -1;
      } else if (this.stage == 2) {
        let t = Ui(e, this.pos), i = 0;
        if (t > this.pos) {
          let n = qm(e, t, this.start);
          if (n) {
            let r = mo(e, n.to - this.start);
            r > 0 && (this.nextStage(n), i = r);
          }
        }
        return i || (i = mo(e, this.pos)), i > 0 && i < e.length ? i : -1;
      } else
        return mo(e, this.pos);
    }
  }
};
function mo(O, e) {
  for (; e < O.length; e++) {
    let t = O.charCodeAt(e);
    if (t == 10)
      break;
    if (!it(t))
      return -1;
  }
  return e;
}
var xY = class {
  nextLine(e, t, i) {
    let n = t.depth < e.stack.length ? -1 : ym(t), r = t.next;
    if (n < 0)
      return false;
    let s = M(x.HeaderMark, e.lineStart + t.pos, e.lineStart + n);
    return e.nextLine(), e.addLeafElement(i, M(r == 61 ? x.SetextHeading1 : x.SetextHeading2, i.start, e.prevLineEnd(), [
      ...e.parser.parseInline(i.content, i.start),
      s
    ])), true;
  }
  finish() {
    return false;
  }
};
var bY = {
  LinkReference(O, e) {
    return e.content.charCodeAt(0) == 91 ? new XY(e) : null;
  },
  SetextHeading() {
    return new xY();
  }
};
var wY = [
  (O, e) => Pm(e) >= 0,
  (O, e) => mm(e) >= 0,
  (O, e) => gm(e) >= 0,
  (O, e) => nc(e, O, true) >= 0,
  (O, e) => rc(e, O, true) >= 0,
  (O, e) => ic(e, O, true) >= 0,
  (O, e) => bm(e, O, true) >= 0
];
var TY = { text: "", end: 0 };
var WY = class {
  /// @internal
  constructor(e, t, i, n) {
    this.parser = e, this.input = t, this.ranges = n, this.line = new yY(), this.atEnd = false, this.dontInject = /* @__PURE__ */ new Set(), this.stoppedAt = null, this.rangeI = 0, this.to = n[n.length - 1].to, this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = n[0].from, this.block = es.create(x.Document, 0, this.lineStart, 0, 0), this.stack = [this.block], this.fragments = i.length ? new ZY(i, t) : null, this.readLine();
  }
  get parsedPos() {
    return this.absoluteLineStart;
  }
  advance() {
    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
      return this.finish();
    let { line: e } = this;
    for (; ; ) {
      for (; e.depth < this.stack.length; )
        this.finishContext();
      for (let i of e.markers)
        this.addNode(i.type, i.from, i.to);
      if (e.pos < e.text.length)
        break;
      if (!this.nextLine())
        return this.finish();
    }
    if (this.fragments && this.reuseFragment(e.basePos))
      return null;
    e:
      for (; ; ) {
        for (let i of this.parser.blockParsers)
          if (i) {
            let n = i(this, e);
            if (n != false) {
              if (n == true)
                return null;
              e.forward();
              continue e;
            }
          }
        break;
      }
    let t = new PY(this.lineStart + e.pos, e.text.slice(e.pos));
    for (let i of this.parser.leafBlockParsers)
      if (i) {
        let n = i(this, t);
        n && t.parsers.push(n);
      }
    e:
      for (; this.nextLine() && e.pos != e.text.length; ) {
        if (e.indent < e.baseIndent + 4) {
          for (let i of this.parser.endLeafBlock)
            if (i(this, e, t))
              break e;
        }
        for (let i of t.parsers)
          if (i.nextLine(this, e, t))
            return null;
        t.content += `
` + e.scrub();
        for (let i of e.markers)
          t.marks.push(i);
      }
    return this.finishLeaf(t), null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  reuseFragment(e) {
    if (!this.fragments.moveTo(this.absoluteLineStart + e, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
      return false;
    let t = this.fragments.takeNodes(this);
    if (!t)
      return false;
    let i = t, n = this.absoluteLineStart + t;
    for (let r = 1; r < this.ranges.length; r++) {
      let s = this.ranges[r - 1].to, o = this.ranges[r].from;
      s >= this.lineStart && o < n && (i -= o - s);
    }
    return this.lineStart += i, this.absoluteLineStart += t, this.moveRangeI(), this.absoluteLineStart < this.to ? (this.lineStart++, this.absoluteLineStart++, this.readLine()) : (this.atEnd = true, this.readLine()), true;
  }
  /// The number of parent blocks surrounding the current block.
  get depth() {
    return this.stack.length;
  }
  /// Get the type of the parent block at the given depth. When no
  /// depth is passed, return the type of the innermost parent.
  parentType(e = this.depth - 1) {
    return this.parser.nodeSet.types[this.stack[e].type];
  }
  /// Move to the next input line. This should only be called by
  /// (non-composite) [block parsers](#BlockParser.parse) that consume
  /// the line directly, or leaf block parser
  /// [`nextLine`](#LeafBlockParser.nextLine) methods when they
  /// consume the current line (and return true).
  nextLine() {
    return this.lineStart += this.line.text.length, this.absoluteLineEnd >= this.to ? (this.absoluteLineStart = this.absoluteLineEnd, this.atEnd = true, this.readLine(), false) : (this.lineStart++, this.absoluteLineStart = this.absoluteLineEnd + 1, this.moveRangeI(), this.readLine(), true);
  }
  moveRangeI() {
    for (; this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to; )
      this.rangeI++, this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
  }
  /// @internal
  scanLine(e) {
    let t = TY;
    if (t.end = e, e >= this.to)
      t.text = "";
    else if (t.text = this.lineChunkAt(e), t.end += t.text.length, this.ranges.length > 1) {
      let i = this.absoluteLineStart, n = this.rangeI;
      for (; this.ranges[n].to < t.end; ) {
        n++;
        let r = this.ranges[n].from, s = this.lineChunkAt(r);
        t.end = r + s.length, t.text = t.text.slice(0, this.ranges[n - 1].to - i) + s, i = t.end - t.text.length;
      }
    }
    return t;
  }
  /// @internal
  readLine() {
    let { line: e } = this, { text: t, end: i } = this.scanLine(this.absoluteLineStart);
    for (this.absoluteLineEnd = i, e.reset(t); e.depth < this.stack.length; e.depth++) {
      let n = this.stack[e.depth], r = this.parser.skipContextMarkup[n.type];
      if (!r)
        throw new Error("Unhandled block context " + x[n.type]);
      if (!r(n, this, e))
        break;
      e.forward();
    }
  }
  lineChunkAt(e) {
    let t = this.input.chunk(e), i;
    if (this.input.lineChunks)
      i = t == `
` ? "" : t;
    else {
      let n = t.indexOf(`
`);
      i = n < 0 ? t : t.slice(0, n);
    }
    return e + i.length > this.to ? i.slice(0, this.to - e) : i;
  }
  /// The end position of the previous line.
  prevLineEnd() {
    return this.atEnd ? this.lineStart : this.lineStart - 1;
  }
  /// @internal
  startContext(e, t, i = 0) {
    this.block = es.create(e, i, this.lineStart + t, this.block.hash, this.lineStart + this.line.text.length), this.stack.push(this.block);
  }
  /// Start a composite block. Should only be called from [block
  /// parser functions](#BlockParser.parse) that return null.
  startComposite(e, t, i = 0) {
    this.startContext(this.parser.getNodeType(e), t, i);
  }
  /// @internal
  addNode(e, t, i) {
    typeof e == "number" && (e = new E(this.parser.nodeSet.types[e], ei, ei, (i ?? this.prevLineEnd()) - t)), this.block.addChild(e, t - this.block.from);
  }
  /// Add a block element. Can be called by [block
  /// parsers](#BlockParser.parse).
  addElement(e) {
    this.block.addChild(e.toTree(this.parser.nodeSet), e.from - this.block.from);
  }
  /// Add a block element from a [leaf parser](#LeafBlockParser). This
  /// makes sure any extra composite block markup (such as blockquote
  /// markers) inside the block are also added to the syntax tree.
  addLeafElement(e, t) {
    this.addNode(this.buffer.writeElements(Aa(t.children, e.marks), -t.from).finish(t.type, t.to - t.from), t.from);
  }
  /// @internal
  finishContext() {
    let e = this.stack.pop(), t = this.stack[this.stack.length - 1];
    t.addChild(e.toTree(this.parser.nodeSet), e.from - t.from), this.block = t;
  }
  finish() {
    for (; this.stack.length > 1; )
      this.finishContext();
    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
  }
  addGaps(e) {
    return this.ranges.length > 1 ? wm(this.ranges, 0, e.topNode, this.ranges[0].from, this.dontInject) : e;
  }
  /// @internal
  finishLeaf(e) {
    for (let i of e.parsers)
      if (i.finish(this, e))
        return;
    let t = Aa(this.parser.parseInline(e.content, e.start), e.marks);
    this.addNode(this.buffer.writeElements(t, -e.start).finish(x.Paragraph, e.content.length), e.start);
  }
  elt(e, t, i, n) {
    return typeof e == "string" ? M(this.parser.getNodeType(e), t, i, n) : new vm(e, t);
  }
  /// @internal
  get buffer() {
    return new Wm(this.parser.nodeSet);
  }
};
function wm(O, e, t, i, n) {
  if (n.has(t.tree))
    return t.tree;
  let r = O[e].to, s = [], o = [], a = t.from + i;
  function l(h2, u) {
    for (; u ? h2 >= r : h2 > r; ) {
      let f = O[e + 1].from - r;
      i += f, h2 += f, e++, r = O[e].to;
    }
  }
  for (let h2 = t.firstChild; h2; h2 = h2.nextSibling) {
    l(h2.from + i, true);
    let u = h2.from + i, f;
    h2.to + i > r ? (f = wm(O, e, h2, i, n), l(h2.to + i, false)) : f = h2.toTree(), s.push(f), o.push(u - a);
  }
  return l(t.to + i, false), new E(t.type, s, o, t.to + i - a, t.tree ? t.tree.propValues : void 0);
}
var Xs = class extends ls {
  /// @internal
  constructor(e, t, i, n, r, s, o, a, l) {
    super(), this.nodeSet = e, this.blockParsers = t, this.leafBlockParsers = i, this.blockNames = n, this.endLeafBlock = r, this.skipContextMarkup = s, this.inlineParsers = o, this.inlineNames = a, this.wrappers = l, this.nodeTypes = /* @__PURE__ */ Object.create(null);
    for (let h2 of e.types)
      this.nodeTypes[h2.name] = h2.id;
  }
  createParse(e, t, i) {
    let n = new WY(this, e, t, i);
    for (let r of this.wrappers)
      n = r(n, e, t, i);
    return n;
  }
  /// Reconfigure the parser.
  configure(e) {
    let t = Ea(e);
    if (!t)
      return this;
    let { nodeSet: i, skipContextMarkup: n } = this, r = this.blockParsers.slice(), s = this.leafBlockParsers.slice(), o = this.blockNames.slice(), a = this.inlineParsers.slice(), l = this.inlineNames.slice(), h2 = this.endLeafBlock.slice(), u = this.wrappers;
    if (pi(t.defineNodes)) {
      n = Object.assign({}, n);
      let f = i.types.slice(), d;
      for (let Q of t.defineNodes) {
        let { name: $, block: p, composite: m, style: g } = typeof Q == "string" ? { name: Q } : Q;
        if (f.some((w) => w.name == $))
          continue;
        m && (n[f.length] = (w, P, z) => m(P, z, w.value));
        let b = f.length, y = m ? ["Block", "BlockContext"] : p ? b >= x.ATXHeading1 && b <= x.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"] : void 0;
        f.push(ue.define({
          id: b,
          name: $,
          props: y && [[_.group, y]]
        })), g && (d || (d = {}), Array.isArray(g) || g instanceof at ? d[$] = g : Object.assign(d, g));
      }
      i = new ni(f), d && (i = i.extend(ze(d)));
    }
    if (pi(t.props) && (i = i.extend(...t.props)), pi(t.remove))
      for (let f of t.remove) {
        let d = this.blockNames.indexOf(f), Q = this.inlineNames.indexOf(f);
        d > -1 && (r[d] = s[d] = void 0), Q > -1 && (a[Q] = void 0);
      }
    if (pi(t.parseBlock))
      for (let f of t.parseBlock) {
        let d = o.indexOf(f.name);
        if (d > -1)
          r[d] = f.parse, s[d] = f.leaf;
        else {
          let Q = f.before ? Nn(o, f.before) : f.after ? Nn(o, f.after) + 1 : o.length - 1;
          r.splice(Q, 0, f.parse), s.splice(Q, 0, f.leaf), o.splice(Q, 0, f.name);
        }
        f.endLeaf && h2.push(f.endLeaf);
      }
    if (pi(t.parseInline))
      for (let f of t.parseInline) {
        let d = l.indexOf(f.name);
        if (d > -1)
          a[d] = f.parse;
        else {
          let Q = f.before ? Nn(l, f.before) : f.after ? Nn(l, f.after) + 1 : l.length - 1;
          a.splice(Q, 0, f.parse), l.splice(Q, 0, f.name);
        }
      }
    return t.wrap && (u = u.concat(t.wrap)), new Xs(i, r, s, o, h2, n, a, l, u);
  }
  /// @internal
  getNodeType(e) {
    let t = this.nodeTypes[e];
    if (t == null)
      throw new RangeError(`Unknown node type '${e}'`);
    return t;
  }
  /// Parse the given piece of inline text at the given offset,
  /// returning an array of [`Element`](#Element) objects representing
  /// the inline content.
  parseInline(e, t) {
    let i = new kY(this, e, t);
    e:
      for (let n = t; n < i.end; ) {
        let r = i.char(n);
        for (let s of this.inlineParsers)
          if (s) {
            let o = s(i, r, n);
            if (o >= 0) {
              n = o;
              continue e;
            }
          }
        n++;
      }
    return i.resolveMarkers(0);
  }
};
function pi(O) {
  return O != null && O.length > 0;
}
function Ea(O) {
  if (!Array.isArray(O))
    return O;
  if (O.length == 0)
    return null;
  let e = Ea(O[0]);
  if (O.length == 1)
    return e;
  let t = Ea(O.slice(1));
  if (!t || !e)
    return e || t;
  let i = (s, o) => (s || ei).concat(o || ei), n = e.wrap, r = t.wrap;
  return {
    props: i(e.props, t.props),
    defineNodes: i(e.defineNodes, t.defineNodes),
    parseBlock: i(e.parseBlock, t.parseBlock),
    parseInline: i(e.parseInline, t.parseInline),
    remove: i(e.remove, t.remove),
    wrap: n ? r ? (s, o, a, l) => n(r(s, o, a, l), o, a, l) : n : r
  };
}
function Nn(O, e) {
  let t = O.indexOf(e);
  if (t < 0)
    throw new RangeError(`Position specified relative to unknown parser ${e}`);
  return t;
}
var Tm = [ue.none];
for (let O = 1, e; e = x[O]; O++)
  Tm[O] = ue.define({
    id: O,
    name: e,
    props: O >= x.Escape ? [] : [[_.group, O in pm ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]]
  });
var ei = [];
var Wm = class {
  constructor(e) {
    this.nodeSet = e, this.content = [], this.nodes = [];
  }
  write(e, t, i, n = 0) {
    return this.content.push(e, t, i, 4 + n * 4), this;
  }
  writeElements(e, t = 0) {
    for (let i of e)
      i.writeTo(this, t);
    return this;
  }
  finish(e, t) {
    return E.build({
      buffer: this.content,
      nodeSet: this.nodeSet,
      reused: this.nodes,
      topID: e,
      length: t
    });
  }
};
var rn = class {
  /// @internal
  constructor(e, t, i, n = ei) {
    this.type = e, this.from = t, this.to = i, this.children = n;
  }
  /// @internal
  writeTo(e, t) {
    let i = e.content.length;
    e.writeElements(this.children, t), e.content.push(this.type, this.from + t, this.to + t, e.content.length + 4 - i);
  }
  /// @internal
  toTree(e) {
    return new Wm(e).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
  }
};
var vm = class {
  constructor(e, t) {
    this.tree = e, this.from = t;
  }
  get to() {
    return this.from + this.tree.length;
  }
  get type() {
    return this.tree.type.id;
  }
  get children() {
    return ei;
  }
  writeTo(e, t) {
    e.nodes.push(this.tree), e.content.push(e.nodes.length - 1, this.from + t, this.to + t, -1);
  }
  toTree() {
    return this.tree;
  }
};
function M(O, e, t, i) {
  return new rn(O, e, t, i);
}
var km = { resolve: "Emphasis", mark: "EmphasisMark" };
var Ym = { resolve: "Emphasis", mark: "EmphasisMark" };
var mi = {};
var bf = {};
var lt = class {
  constructor(e, t, i, n) {
    this.type = e, this.from = t, this.to = i, this.side = n;
  }
};
var wf = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
var sn = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
  sn = new RegExp("[\\p{Pc}|\\p{Pd}|\\p{Pe}|\\p{Pf}|\\p{Pi}|\\p{Po}|\\p{Ps}]", "u");
} catch {
}
var go = {
  Escape(O, e, t) {
    if (e != 92 || t == O.end - 1)
      return -1;
    let i = O.char(t + 1);
    for (let n = 0; n < wf.length; n++)
      if (wf.charCodeAt(n) == i)
        return O.append(M(x.Escape, t, t + 2));
    return -1;
  },
  Entity(O, e, t) {
    if (e != 38)
      return -1;
    let i = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(O.slice(t + 1, t + 31));
    return i ? O.append(M(x.Entity, t, t + 1 + i[0].length)) : -1;
  },
  InlineCode(O, e, t) {
    if (e != 96 || t && O.char(t - 1) == 96)
      return -1;
    let i = t + 1;
    for (; i < O.end && O.char(i) == 96; )
      i++;
    let n = i - t, r = 0;
    for (; i < O.end; i++)
      if (O.char(i) == 96) {
        if (r++, r == n && O.char(i + 1) != 96)
          return O.append(M(x.InlineCode, t, i + 1, [
            M(x.CodeMark, t, t + n),
            M(x.CodeMark, i + 1 - n, i + 1)
          ]));
      } else
        r = 0;
    return -1;
  },
  HTMLTag(O, e, t) {
    if (e != 60 || t == O.end - 1)
      return -1;
    let i = O.slice(t + 1, O.end), n = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(i);
    if (n)
      return O.append(M(x.URL, t, t + 1 + n[0].length));
    let r = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(i);
    if (r)
      return O.append(M(x.Comment, t, t + 1 + r[0].length));
    let s = /^\?[^]*?\?>/.exec(i);
    if (s)
      return O.append(M(x.ProcessingInstruction, t, t + 1 + s[0].length));
    let o = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(i);
    return o ? O.append(M(x.HTMLTag, t, t + 1 + o[0].length)) : -1;
  },
  Emphasis(O, e, t) {
    if (e != 95 && e != 42)
      return -1;
    let i = t + 1;
    for (; O.char(i) == e; )
      i++;
    let n = O.slice(t - 1, t), r = O.slice(i, i + 1), s = sn.test(n), o = sn.test(r), a = /\s|^$/.test(n), l = /\s|^$/.test(r), h2 = !l && (!o || a || s), u = !a && (!s || l || o), f = h2 && (e == 42 || !u || s), d = u && (e == 42 || !h2 || o);
    return O.append(new lt(e == 95 ? km : Ym, t, i, (f ? 1 : 0) | (d ? 2 : 0)));
  },
  HardBreak(O, e, t) {
    if (e == 92 && O.char(t + 1) == 10)
      return O.append(M(x.HardBreak, t, t + 2));
    if (e == 32) {
      let i = t + 1;
      for (; O.char(i) == 32; )
        i++;
      if (O.char(i) == 10 && i >= t + 2)
        return O.append(M(x.HardBreak, t, i + 1));
    }
    return -1;
  },
  Link(O, e, t) {
    return e == 91 ? O.append(new lt(
      mi,
      t,
      t + 1,
      1
      /* Open */
    )) : -1;
  },
  Image(O, e, t) {
    return e == 33 && O.char(t + 1) == 91 ? O.append(new lt(
      bf,
      t,
      t + 2,
      1
      /* Open */
    )) : -1;
  },
  LinkEnd(O, e, t) {
    if (e != 93)
      return -1;
    for (let i = O.parts.length - 1; i >= 0; i--) {
      let n = O.parts[i];
      if (n instanceof lt && (n.type == mi || n.type == bf)) {
        if (!n.side || O.skipSpace(n.to) == t && !/[(\[]/.test(O.slice(t + 1, t + 2)))
          return O.parts[i] = null, -1;
        let r = O.takeContent(i), s = O.parts[i] = vY(O, r, n.type == mi ? x.Link : x.Image, n.from, t + 1);
        if (n.type == mi)
          for (let o = 0; o < i; o++) {
            let a = O.parts[o];
            a instanceof lt && a.type == mi && (a.side = 0);
          }
        return s.to;
      }
    }
    return -1;
  }
};
function vY(O, e, t, i, n) {
  let { text: r } = O, s = O.char(n), o = n;
  if (e.unshift(M(x.LinkMark, i, i + (t == x.Image ? 2 : 1))), e.push(M(x.LinkMark, n - 1, n)), s == 40) {
    let a = O.skipSpace(n + 1), l = Zm(r, a - O.offset, O.offset), h2;
    l && (a = O.skipSpace(l.to), h2 = qm(r, a - O.offset, O.offset), h2 && (a = O.skipSpace(h2.to))), O.char(a) == 41 && (e.push(M(x.LinkMark, n, n + 1)), o = a + 1, l && e.push(l), h2 && e.push(h2), e.push(M(x.LinkMark, a, o)));
  } else if (s == 91) {
    let a = zm(r, n - O.offset, O.offset, false);
    a && (e.push(a), o = a.to);
  }
  return M(t, i, o, e);
}
function Zm(O, e, t) {
  if (O.charCodeAt(e) == 60) {
    for (let n = e + 1; n < O.length; n++) {
      let r = O.charCodeAt(n);
      if (r == 62)
        return M(x.URL, e + t, n + 1 + t);
      if (r == 60 || r == 10)
        return false;
    }
    return null;
  } else {
    let n = 0, r = e;
    for (let s = false; r < O.length; r++) {
      let o = O.charCodeAt(r);
      if (it(o))
        break;
      if (s)
        s = false;
      else if (o == 40)
        n++;
      else if (o == 41) {
        if (!n)
          break;
        n--;
      } else
        o == 92 && (s = true);
    }
    return r > e ? M(x.URL, e + t, r + t) : r == O.length ? null : false;
  }
}
function qm(O, e, t) {
  let i = O.charCodeAt(e);
  if (i != 39 && i != 34 && i != 40)
    return false;
  let n = i == 40 ? 41 : i;
  for (let r = e + 1, s = false; r < O.length; r++) {
    let o = O.charCodeAt(r);
    if (s)
      s = false;
    else {
      if (o == n)
        return M(x.LinkTitle, e + t, r + 1 + t);
      o == 92 && (s = true);
    }
  }
  return null;
}
function zm(O, e, t, i) {
  for (let n = false, r = e + 1, s = Math.min(O.length, r + 999); r < s; r++) {
    let o = O.charCodeAt(r);
    if (n)
      n = false;
    else {
      if (o == 93)
        return i ? false : M(x.LinkLabel, e + t, r + 1 + t);
      if (i && !it(o) && (i = false), o == 91)
        return false;
      o == 92 && (n = true);
    }
  }
  return null;
}
var kY = class {
  /// @internal
  constructor(e, t, i) {
    this.parser = e, this.text = t, this.offset = i, this.parts = [];
  }
  /// Get the character code at the given (document-relative)
  /// position.
  char(e) {
    return e >= this.end ? -1 : this.text.charCodeAt(e - this.offset);
  }
  /// The position of the end of this inline section.
  get end() {
    return this.offset + this.text.length;
  }
  /// Get a substring of this inline section. Again uses
  /// document-relative positions.
  slice(e, t) {
    return this.text.slice(e - this.offset, t - this.offset);
  }
  /// @internal
  append(e) {
    return this.parts.push(e), e.to;
  }
  /// Add a [delimiter](#DelimiterType) at this given position. `open`
  /// and `close` indicate whether this delimiter is opening, closing,
  /// or both. Returns the end of the delimiter, for convenient
  /// returning from [parse functions](#InlineParser.parse).
  addDelimiter(e, t, i, n, r) {
    return this.append(new lt(e, t, i, (n ? 1 : 0) | (r ? 2 : 0)));
  }
  /// Add an inline element. Returns the end of the element.
  addElement(e) {
    return this.append(e);
  }
  /// Resolve markers between this.parts.length and from, wrapping matched markers in the
  /// appropriate node and updating the content of this.parts. @internal
  resolveMarkers(e) {
    for (let i = e; i < this.parts.length; i++) {
      let n = this.parts[i];
      if (!(n instanceof lt && n.type.resolve && n.side & 2))
        continue;
      let r = n.type == km || n.type == Ym, s = n.to - n.from, o, a = i - 1;
      for (; a >= e; a--) {
        let $ = this.parts[a];
        if ($ instanceof lt && $.side & 1 && $.type == n.type && // Ignore emphasis delimiters where the character count doesn't match
        !(r && (n.side & 1 || $.side & 2) && ($.to - $.from + s) % 3 == 0 && (($.to - $.from) % 3 || s % 3))) {
          o = $;
          break;
        }
      }
      if (!o)
        continue;
      let l = n.type.resolve, h2 = [], u = o.from, f = n.to;
      if (r) {
        let $ = Math.min(2, o.to - o.from, s);
        u = o.to - $, f = n.from + $, l = $ == 1 ? "Emphasis" : "StrongEmphasis";
      }
      o.type.mark && h2.push(this.elt(o.type.mark, u, o.to));
      for (let $ = a + 1; $ < i; $++)
        this.parts[$] instanceof rn && h2.push(this.parts[$]), this.parts[$] = null;
      n.type.mark && h2.push(this.elt(n.type.mark, n.from, f));
      let d = this.elt(l, u, f, h2);
      this.parts[a] = r && o.from != u ? new lt(o.type, o.from, u, o.side) : null, (this.parts[i] = r && n.to != f ? new lt(n.type, f, n.to, n.side) : null) ? this.parts.splice(i, 0, d) : this.parts[i] = d;
    }
    let t = [];
    for (let i = e; i < this.parts.length; i++) {
      let n = this.parts[i];
      n instanceof rn && t.push(n);
    }
    return t;
  }
  /// Find an opening delimiter of the given type. Returns `null` if
  /// no delimiter is found, or an index that can be passed to
  /// [`takeContent`](#InlineContext.takeContent) otherwise.
  findOpeningDelimiter(e) {
    for (let t = this.parts.length - 1; t >= 0; t--) {
      let i = this.parts[t];
      if (i instanceof lt && i.type == e)
        return t;
    }
    return null;
  }
  /// Remove all inline elements and delimiters starting from the
  /// given index (which you should get from
  /// [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),
  /// resolve delimiters inside of them, and return them as an array
  /// of elements.
  takeContent(e) {
    let t = this.resolveMarkers(e);
    return this.parts.length = e, t;
  }
  /// Skip space after the given (document) position, returning either
  /// the position of the next non-space character or the end of the
  /// section.
  skipSpace(e) {
    return Ui(this.text, e - this.offset) + this.offset;
  }
  elt(e, t, i, n) {
    return typeof e == "string" ? M(this.parser.getNodeType(e), t, i, n) : new vm(e, t);
  }
};
function Aa(O, e) {
  if (!e.length)
    return O;
  if (!O.length)
    return e;
  let t = O.slice(), i = 0;
  for (let n of e) {
    for (; i < t.length && t[i].to < n.to; )
      i++;
    if (i < t.length && t[i].from < n.from) {
      let r = t[i];
      r instanceof rn && (t[i] = new rn(r.type, r.from, r.to, Aa(r.children, [n])));
    } else
      t.splice(i++, 0, n);
  }
  return t;
}
var YY = [x.CodeBlock, x.ListItem, x.OrderedList, x.BulletList];
var ZY = class {
  constructor(e, t) {
    this.fragments = e, this.input = t, this.i = 0, this.fragment = null, this.fragmentEnd = -1, this.cursor = null, e.length && (this.fragment = e[this.i++]);
  }
  nextFragment() {
    this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null, this.cursor = null, this.fragmentEnd = -1;
  }
  moveTo(e, t) {
    for (; this.fragment && this.fragment.to <= e; )
      this.nextFragment();
    if (!this.fragment || this.fragment.from > (e ? e - 1 : 0))
      return false;
    if (this.fragmentEnd < 0) {
      let r = this.fragment.to;
      for (; r > 0 && this.input.read(r - 1, r) != `
`; )
        r--;
      this.fragmentEnd = r ? r - 1 : 0;
    }
    let i = this.cursor;
    i || (i = this.cursor = this.fragment.tree.cursor(), i.firstChild());
    let n = e + this.fragment.offset;
    for (; i.to <= n; )
      if (!i.parent())
        return false;
    for (; ; ) {
      if (i.from >= n)
        return this.fragment.from <= t;
      if (!i.childAfter(n))
        return false;
    }
  }
  matches(e) {
    let t = this.cursor.tree;
    return t && t.prop(_.contextHash) == e;
  }
  takeNodes(e) {
    let t = this.cursor, i = this.fragment.offset, n = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0), r = e.absoluteLineStart, s = r, o = e.block.children.length, a = s, l = o;
    for (; ; ) {
      if (t.to - i > n) {
        if (t.type.isAnonymous && t.firstChild())
          continue;
        break;
      }
      if (e.dontInject.add(t.tree), e.addNode(t.tree, t.from - i), t.type.is("Block") && (YY.indexOf(t.type.id) < 0 ? (s = t.to - i, o = e.block.children.length) : (s = a, o = l, a = t.to - i, l = e.block.children.length)), !t.nextSibling())
        break;
    }
    for (; e.block.children.length > o; )
      e.block.children.pop(), e.block.positions.pop();
    return s - r;
  }
};
var qY = ze({
  "Blockquote/...": c.quote,
  HorizontalRule: c.contentSeparator,
  "ATXHeading1/... SetextHeading1/...": c.heading1,
  "ATXHeading2/... SetextHeading2/...": c.heading2,
  "ATXHeading3/...": c.heading3,
  "ATXHeading4/...": c.heading4,
  "ATXHeading5/...": c.heading5,
  "ATXHeading6/...": c.heading6,
  "Comment CommentBlock": c.comment,
  Escape: c.escape,
  Entity: c.character,
  "Emphasis/...": c.emphasis,
  "StrongEmphasis/...": c.strong,
  "Link/... Image/...": c.link,
  "OrderedList/... BulletList/...": c.list,
  "BlockQuote/...": c.quote,
  "InlineCode CodeText": c.monospace,
  URL: c.url,
  "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": c.processingInstruction,
  "CodeInfo LinkLabel": c.labelName,
  LinkTitle: c.string,
  Paragraph: c.content
});
var zY = new Xs(new ni(Tm).extend(qY), Object.keys(Bn).map((O) => Bn[O]), Object.keys(Bn).map((O) => bY[O]), Object.keys(Bn), wY, pm, Object.keys(go).map((O) => go[O]), Object.keys(go), []);
function UY(O, e, t) {
  let i = [];
  for (let n = O.firstChild, r = e; ; n = n.nextSibling) {
    let s = n ? n.from : t;
    if (s > r && i.push({ from: r, to: s }), !n)
      break;
    r = n.to;
  }
  return i;
}
function VY(O) {
  let { codeParser: e, htmlParser: t } = O;
  return { wrap: xl((n, r) => {
    let s = n.type.id;
    if (e && (s == x.CodeBlock || s == x.FencedCode)) {
      let o = "";
      if (s == x.FencedCode) {
        let l = n.node.getChild(x.CodeInfo);
        l && (o = r.read(l.from, l.to));
      }
      let a = e(o);
      if (a)
        return { parser: a, overlay: (l) => l.type.id == x.CodeText };
    } else if (t && (s == x.HTMLBlock || s == x.HTMLTag))
      return { parser: t, overlay: UY(n.node, n.from, n.to) };
    return null;
  }) };
}
var RY = { resolve: "Strikethrough", mark: "StrikethroughMark" };
var _Y = {
  defineNodes: [{
    name: "Strikethrough",
    style: { "Strikethrough/...": c.strikethrough }
  }, {
    name: "StrikethroughMark",
    style: c.processingInstruction
  }],
  parseInline: [{
    name: "Strikethrough",
    parse(O, e, t) {
      if (e != 126 || O.char(t + 1) != 126 || O.char(t + 2) == 126)
        return -1;
      let i = O.slice(t - 1, t), n = O.slice(t + 2, t + 3), r = /\s|^$/.test(i), s = /\s|^$/.test(n), o = sn.test(i), a = sn.test(n);
      return O.addDelimiter(RY, t, t + 2, !s && (!a || r || o), !r && (!o || s || a));
    },
    after: "Emphasis"
  }]
};
function Vi(O, e, t = 0, i, n = 0) {
  let r = 0, s = true, o = -1, a = -1, l = false, h2 = () => {
    i.push(O.elt("TableCell", n + o, n + a, O.parser.parseInline(e.slice(o, a), n + o)));
  };
  for (let u = t; u < e.length; u++) {
    let f = e.charCodeAt(u);
    f == 124 && !l ? ((!s || o > -1) && r++, s = false, i && (o > -1 && h2(), i.push(O.elt("TableDelimiter", u + n, u + n + 1))), o = a = -1) : (l || f != 32 && f != 9) && (o < 0 && (o = u), a = u + 1), l = !l && f == 92;
  }
  return o > -1 && (r++, i && h2()), r;
}
function Tf(O, e) {
  for (let t = e; t < O.length; t++) {
    let i = O.charCodeAt(t);
    if (i == 124)
      return true;
    i == 92 && t++;
  }
  return false;
}
var Um = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
var Wf = class {
  constructor() {
    this.rows = null;
  }
  nextLine(e, t, i) {
    if (this.rows == null) {
      this.rows = false;
      let n;
      if ((t.next == 45 || t.next == 58 || t.next == 124) && Um.test(n = t.text.slice(t.pos))) {
        let r = [];
        Vi(e, i.content, 0, r, i.start) == Vi(e, n, t.pos) && (this.rows = [
          e.elt("TableHeader", i.start, i.start + i.content.length, r),
          e.elt("TableDelimiter", e.lineStart + t.pos, e.lineStart + t.text.length)
        ]);
      }
    } else if (this.rows) {
      let n = [];
      Vi(e, t.text, t.pos, n, e.lineStart), this.rows.push(e.elt("TableRow", e.lineStart + t.pos, e.lineStart + t.text.length, n));
    }
    return false;
  }
  finish(e, t) {
    return this.rows ? (e.addLeafElement(t, e.elt("Table", t.start, t.start + t.content.length, this.rows)), true) : false;
  }
};
var jY = {
  defineNodes: [
    { name: "Table", block: true },
    { name: "TableHeader", style: { "TableHeader/...": c.heading } },
    "TableRow",
    { name: "TableCell", style: c.content },
    { name: "TableDelimiter", style: c.processingInstruction }
  ],
  parseBlock: [{
    name: "Table",
    leaf(O, e) {
      return Tf(e.content, 0) ? new Wf() : null;
    },
    endLeaf(O, e, t) {
      if (t.parsers.some((n) => n instanceof Wf) || !Tf(e.text, e.basePos))
        return false;
      let i = O.scanLine(O.absoluteLineEnd + 1).text;
      return Um.test(i) && Vi(O, e.text, e.basePos) == Vi(O, i, e.basePos);
    },
    before: "SetextHeading"
  }]
};
var CY = class {
  nextLine() {
    return false;
  }
  finish(e, t) {
    return e.addLeafElement(t, e.elt("Task", t.start, t.start + t.content.length, [
      e.elt("TaskMarker", t.start, t.start + 3),
      ...e.parser.parseInline(t.content.slice(3), t.start + 3)
    ])), true;
  }
};
var GY = {
  defineNodes: [
    { name: "Task", block: true, style: c.list },
    { name: "TaskMarker", style: c.atom }
  ],
  parseBlock: [{
    name: "TaskList",
    leaf(O, e) {
      return /^\[[ xX]\]/.test(e.content) && O.parentType().name == "ListItem" ? new CY() : null;
    },
    after: "SetextHeading"
  }]
};
var IY = [jY, GY, _Y];
function Vm(O, e, t) {
  return (i, n, r) => {
    if (n != O || i.char(r + 1) == O)
      return -1;
    let s = [i.elt(t, r, r + 1)];
    for (let o = r + 1; o < i.end; o++) {
      let a = i.char(o);
      if (a == O)
        return i.addElement(i.elt(e, r, o + 1, s.concat(i.elt(t, o, o + 1))));
      if (a == 92 && s.push(i.elt("Escape", o, o++ + 2)), it(a))
        break;
    }
    return -1;
  };
}
var EY = {
  defineNodes: [
    { name: "Superscript", style: c.special(c.content) },
    { name: "SuperscriptMark", style: c.processingInstruction }
  ],
  parseInline: [{
    name: "Superscript",
    parse: Vm(94, "Superscript", "SuperscriptMark")
  }]
};
var AY = {
  defineNodes: [
    { name: "Subscript", style: c.special(c.content) },
    { name: "SubscriptMark", style: c.processingInstruction }
  ],
  parseInline: [{
    name: "Subscript",
    parse: Vm(126, "Subscript", "SubscriptMark")
  }]
};
var DY = {
  defineNodes: [{ name: "Emoji", style: c.character }],
  parseInline: [{
    name: "Emoji",
    parse(O, e, t) {
      let i;
      return e != 58 || !(i = /^[a-zA-Z_0-9]+:/.exec(O.slice(t + 1, O.end))) ? -1 : O.addElement(O.elt("Emoji", t, t + 1 + i[0].length));
    }
  }]
};
var Rm = bl({ block: { open: "<!--", close: "-->" } });
var _m = zY.configure({
  props: [
    Ge.add((O) => {
      if (!(!O.is("Block") || O.is("Document")))
        return (e, t) => ({ from: t.doc.lineAt(e.from).to, to: e.to });
    }),
    Ce.add({
      Document: () => null
    }),
    XO.add({
      Document: Rm
    })
  ]
});
function sc(O) {
  return new Le(Rm, O, [], "markdown");
}
var MY = sc(_m);
var LY = _m.configure([IY, AY, EY, DY]);
var jm = sc(LY);
function BY(O, e) {
  return (t) => {
    if (t && O) {
      let i = null;
      if (t = /\S*/.exec(t)[0], typeof O == "function" ? i = O(t) : i = Ur.matchLanguageName(O, t, true), i instanceof Ur)
        return i.support ? i.support.language.parser : xO.getSkippingParser(i.load());
      if (i)
        return i.parser;
    }
    return e ? e.parser : null;
  };
}
var Fn = class {
  constructor(e, t, i, n, r, s, o) {
    this.node = e, this.from = t, this.to = i, this.spaceBefore = n, this.spaceAfter = r, this.type = s, this.item = o;
  }
  blank(e, t = true) {
    let i = this.spaceBefore + (this.node.name == "Blockquote" ? ">" : "");
    if (e != null) {
      for (; i.length < e; )
        i += " ";
      return i;
    } else {
      for (let n = this.to - this.from - i.length - this.spaceAfter.length; n > 0; n--)
        i += " ";
      return i + (t ? this.spaceAfter : "");
    }
  }
  marker(e, t) {
    let i = this.node.name == "OrderedList" ? String(+Gm(this.item, e)[2] + t) : "";
    return this.spaceBefore + i + this.type + this.spaceAfter;
  }
};
function Cm(O, e) {
  let t = [];
  for (let n = O; n && n.name != "Document"; n = n.parent)
    (n.name == "ListItem" || n.name == "Blockquote" || n.name == "FencedCode") && t.push(n);
  let i = [];
  for (let n = t.length - 1; n >= 0; n--) {
    let r = t[n], s, o = e.lineAt(r.from), a = r.from - o.from;
    if (r.name == "FencedCode")
      i.push(new Fn(r, a, a, "", "", "", null));
    else if (r.name == "Blockquote" && (s = /^[ \t]*>( ?)/.exec(o.text.slice(a))))
      i.push(new Fn(r, a, a + s[0].length, "", s[1], ">", null));
    else if (r.name == "ListItem" && r.parent.name == "OrderedList" && (s = /^([ \t]*)\d+([.)])([ \t]*)/.exec(o.text.slice(a)))) {
      let l = s[3], h2 = s[0].length;
      l.length >= 4 && (l = l.slice(0, l.length - 4), h2 -= 4), i.push(new Fn(r.parent, a, a + h2, s[1], l, s[2], r));
    } else if (r.name == "ListItem" && r.parent.name == "BulletList" && (s = /^([ \t]*)([-+*])([ \t]{1,4}\[[ xX]\])?([ \t]+)/.exec(o.text.slice(a)))) {
      let l = s[4], h2 = s[0].length;
      l.length > 4 && (l = l.slice(0, l.length - 4), h2 -= 4);
      let u = s[2];
      s[3] && (u += s[3].replace(/[xX]/, " ")), i.push(new Fn(r.parent, a, a + h2, s[1], l, u, r));
    }
  }
  return i;
}
function Gm(O, e) {
  return /^(\s*)(\d+)(?=[.)])/.exec(e.sliceString(O.from, O.from + 10));
}
function So(O, e, t, i = 0) {
  for (let n = -1, r = O; ; ) {
    if (r.name == "ListItem") {
      let o = Gm(r, e), a = +o[2];
      if (n >= 0) {
        if (a != n + 1)
          return;
        t.push({ from: r.from + o[1].length, to: r.from + o[0].length, insert: String(n + 2 + i) });
      }
      n = a;
    }
    let s = r.nextSibling;
    if (!s)
      break;
    r = s;
  }
}
var NY = ({ state: O, dispatch: e }) => {
  let t = B(O), { doc: i } = O, n = null, r = O.changeByRange((s) => {
    if (!s.empty || !jm.isActiveAt(O, s.from))
      return n = { range: s };
    let o = s.from, a = i.lineAt(o), l = Cm(t.resolveInner(o, -1), i);
    for (; l.length && l[l.length - 1].from > o - a.from; )
      l.pop();
    if (!l.length)
      return n = { range: s };
    let h2 = l[l.length - 1];
    if (h2.to - h2.spaceAfter.length > o - a.from)
      return n = { range: s };
    let u = o >= h2.to - h2.spaceAfter.length && !/\S/.test(a.text.slice(h2.to));
    if (h2.item && u)
      if (h2.node.firstChild.to >= o || a.from > 0 && !/[^\s>]/.test(i.lineAt(a.from - 1).text)) {
        let p = l.length > 1 ? l[l.length - 2] : null, m, g = "";
        p && p.item ? (m = a.from + p.from, g = p.marker(i, 1)) : m = a.from + (p ? p.to : 0);
        let b = [{ from: m, to: o, insert: g }];
        return h2.node.name == "OrderedList" && So(h2.item, i, b, -2), p && p.node.name == "OrderedList" && So(p.item, i, b), { range: S.cursor(m + g.length), changes: b };
      } else {
        let p = "";
        for (let m = 0, g = l.length - 2; m <= g; m++)
          p += l[m].blank(m < g ? l[m + 1].from - p.length : null, m < g);
        return p += O.lineBreak, { range: S.cursor(o + p.length), changes: { from: a.from, insert: p } };
      }
    if (h2.node.name == "Blockquote" && u && a.from) {
      let p = i.lineAt(a.from - 1), m = />\s*$/.exec(p.text);
      if (m && m.index == h2.from) {
        let g = O.changes([
          { from: p.from + m.index, to: p.to },
          { from: a.from + h2.from, to: a.to }
        ]);
        return { range: s.map(g), changes: g };
      }
    }
    let f = [];
    h2.node.name == "OrderedList" && So(h2.item, i, f);
    let d = h2.item && h2.item.from < a.from, Q = "";
    if (!d || /^[\s\d.)\-+*>]*/.exec(a.text)[0].length >= h2.to)
      for (let p = 0, m = l.length - 1; p <= m; p++)
        Q += p == m && !d ? l[p].marker(i, 1) : l[p].blank(p < m ? l[p + 1].from - Q.length : null);
    let $ = o;
    for (; $ > a.from && /\s/.test(a.text.charAt($ - a.from - 1)); )
      $--;
    return Q = O.lineBreak + Q, f.push({ from: $, to: o, insert: Q }), { range: S.cursor($ + Q.length), changes: f };
  });
  return n ? false : (e(O.update(r, { scrollIntoView: true, userEvent: "input" })), true);
};
function vf(O) {
  return O.name == "QuoteMark" || O.name == "ListMark";
}
function FY(O, e) {
  let t = O.resolveInner(e, -1), i = e;
  vf(t) && (i = t.from, t = t.parent);
  for (let n; n = t.childBefore(i); )
    if (vf(n))
      i = n.from;
    else if (n.name == "OrderedList" || n.name == "BulletList")
      t = n.lastChild, i = t.to;
    else
      break;
  return t;
}
var HY = ({ state: O, dispatch: e }) => {
  let t = B(O), i = null, n = O.changeByRange((r) => {
    let s = r.from, { doc: o } = O;
    if (r.empty && jm.isActiveAt(O, r.from)) {
      let a = o.lineAt(s), l = Cm(FY(t, s), o);
      if (l.length) {
        let h2 = l[l.length - 1], u = h2.to - h2.spaceAfter.length + (h2.spaceAfter ? 1 : 0);
        if (s - a.from > u && !/\S/.test(a.text.slice(u, s - a.from)))
          return {
            range: S.cursor(a.from + u),
            changes: { from: a.from + u, to: s }
          };
        if (s - a.from == u) {
          let f = a.from + h2.from;
          if (h2.item && h2.node.from < h2.item.from && /\S/.test(a.text.slice(h2.from, h2.to)))
            return { range: r, changes: { from: f, to: a.from + h2.to, insert: h2.blank(h2.to - h2.from) } };
          if (f < s)
            return { range: S.cursor(f), changes: { from: f, to: s } };
        }
      }
    }
    return i = { range: r };
  });
  return i ? false : (e(O.update(n, { scrollIntoView: true, userEvent: "delete" })), true);
};
var KY = [
  { key: "Enter", run: NY },
  { key: "Backspace", run: HY }
];
var kf = Kl({ matchClosingTags: false });
function JY(O = {}) {
  let { codeLanguages: e, defaultCodeLanguage: t, addKeymap: i = true, base: { parser: n } = MY } = O;
  if (!(n instanceof Xs))
    throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
  let r = O.extensions ? [O.extensions] : [], s = [kf.support], o;
  t instanceof je ? (s.push(t.support), o = t.language) : t && (o = t);
  let a = e || o ? BY(e, o) : void 0;
  return r.push(VY({ codeParser: a, htmlParser: kf.language.parser })), i && s.push(rO.high(ii.of(KY))), new je(sc(n.configure(r)), s);
}
var eZ = ze({
  null: c.null,
  instanceof: c.operatorKeyword,
  this: c.self,
  "new super assert open to with void": c.keyword,
  "class interface extends implements enum var": c.definitionKeyword,
  "module package import": c.moduleKeyword,
  "switch while for if else case default do break continue return try catch finally throw": c.controlKeyword,
  ["requires exports opens uses provides public private protected static transitive abstract final strictfp synchronized native transient volatile throws"]: c.modifier,
  IntegerLiteral: c.integer,
  FloatingPointLiteral: c.float,
  "StringLiteral TextBlock": c.string,
  CharacterLiteral: c.character,
  LineComment: c.lineComment,
  BlockComment: c.blockComment,
  BooleanLiteral: c.bool,
  PrimitiveType: c.standard(c.typeName),
  TypeName: c.typeName,
  Identifier: c.variableName,
  "MethodName/Identifier": c.function(c.variableName),
  Definition: c.definition(c.variableName),
  ArithOp: c.arithmeticOperator,
  LogicOp: c.logicOperator,
  BitOp: c.bitwiseOperator,
  CompareOp: c.compareOperator,
  AssignOp: c.definitionOperator,
  UpdateOp: c.updateOperator,
  Asterisk: c.punctuation,
  Label: c.labelName,
  "( )": c.paren,
  "[ ]": c.squareBracket,
  "{ }": c.brace,
  ".": c.derefOperator,
  ", ;": c.separator
});
var tZ = { __proto__: null, true: 34, false: 34, null: 42, void: 46, byte: 48, short: 48, int: 48, long: 48, char: 48, float: 48, double: 48, boolean: 48, extends: 62, super: 64, class: 76, this: 78, new: 84, public: 100, protected: 102, private: 104, abstract: 106, static: 108, final: 110, strictfp: 112, default: 114, synchronized: 116, native: 118, transient: 120, volatile: 122, throws: 150, implements: 160, interface: 166, enum: 176, instanceof: 236, open: 265, module: 267, requires: 272, transitive: 274, exports: 276, to: 278, opens: 280, uses: 282, provides: 284, with: 286, package: 290, import: 294, if: 306, else: 308, while: 312, for: 316, var: 323, assert: 330, switch: 334, case: 340, do: 344, break: 348, continue: 352, return: 356, throw: 362, try: 366, catch: 370, finally: 378 };
var OZ = qe.deserialize({
  version: 14,
  states: "#!hQ]QPOOO&tQQO'#H[O(xQQO'#CbOOQO'#Cb'#CbO)PQPO'#CaO)XOSO'#CpOOQO'#Ha'#HaOOQO'#Cu'#CuO*tQPO'#D_O+_QQO'#HkOOQO'#Hk'#HkO-sQQO'#HfO-zQQO'#HfOOQO'#Hf'#HfOOQO'#He'#HeO0OQPO'#DUO0]QPO'#GlO3TQPO'#D_O3[QPO'#DzO)PQPO'#E[O3}QPO'#E[OOQO'#DV'#DVO5]QQO'#H_O7dQQO'#EeO7kQPO'#EdO7pQPO'#EfOOQO'#H`'#H`O5sQQO'#H`O8sQQO'#FgO8zQPO'#EwO9PQPO'#E|O9PQPO'#FOOOQO'#H_'#H_OOQO'#HW'#HWOOQO'#Gf'#GfOOQO'#HV'#HVO:aQPO'#FhOOQO'#HU'#HUOOQO'#Ge'#GeQ]QPOOOOQO'#Hq'#HqO:fQPO'#HqO:kQPO'#D{O:kQPO'#EVO:kQPO'#EQO:sQPO'#HnO;UQQO'#EfO)PQPO'#C`O;^QPO'#C`O)PQPO'#FbO;cQPO'#FdO;nQPO'#FjO;nQPO'#FmO:kQPO'#FrO;sQPO'#FoO9PQPO'#FvO;nQPO'#FxO]QPO'#F}O;xQPO'#GPO<TQPO'#GRO<`QPO'#GTO;nQPO'#GVO9PQPO'#GWO<gQPO'#GYOOQO'#H['#H[O=WQQO,58{OOQO'#HY'#HYOOOO'#Gg'#GgO>yOSO,59[OOQO,59[,59[OOQO'#Hg'#HgO?jQPO,59eO@lQPO,59yOOQO-E:d-E:dO)PQPO,58zOA`QPO,58zO)PQPO,5;|OAeQPO'#DQOAjQPO'#DQOOQO'#Gi'#GiOBjQQO,59jOOQO'#Dm'#DmODRQPO'#HsOD]QPO'#DlODkQPO'#HrODsQPO,5<^ODxQPO,59^OEcQPO'#CxOOQO,59c,59cOEjQPO,59bOGrQQO'#H[OJVQQO'#CbOJmQPO'#D_OKrQQO'#HkOLSQQO,59pOLZQPO'#DvOLiQPO'#HzOLqQPO,5:`OLvQPO,5:`OM^QPO,5;mOMiQPO'#IROMtQPO,5;dOMyQPO,5=WOOQO-E:j-E:jOOQO,5:f,5:fO! aQPO,5:fO! hQPO,5:vO! mQPO,5<^O)PQPO,5:vO:kQPO,5:gO:kQPO,5:qO:kQPO,5:lO:kQPO,5<^O!!^QPO,59qO9PQPO,5:}O!!eQPO,5;QO9PQPO,59TO!!sQPO'#DXOOQO,5;O,5;OOOQO'#El'#ElOOQO'#En'#EnO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;eOOQO,5;h,5;hOOQO,5<R,5<RO!!zQPO,5;aO!#]QPO,5;cO!!zQPO'#CyO!#dQQO'#HkO!#rQQO,5;jO]QPO,5<SOOQO-E:c-E:cOOQO,5>],5>]O!%SQPO,5:gO!%bQPO,5:qO!%jQPO,5:lO!%uQPO,5>YOLZQPO,5>YO! {QPO,59UO!&QQQO,58zO!&YQQO,5;|O!&bQQO,5<OO)PQPO,5<OO9PQPO'#DUO]QPO,5<UO]QPO,5<XO!&jQPO'#FqO]QPO,5<ZO]QPO,5<`O!&zQQO,5<bO!'UQPO,5<dO!'ZQPO,5<iOOQO'#Fi'#FiOOQO,5<k,5<kO!'`QPO,5<kOOQO,5<m,5<mO!'eQPO,5<mO!'jQQO,5<oOOQO,5<o,5<oO<jQPO,5<qO!'qQQO,5<rO!'xQPO'#GcO!)OQPO,5<tO<jQPO,5<|O)PQPO,58}O!,|QPO'#ChOOQO1G.k1G.kOOOO-E:e-E:eOOQO1G.v1G.vO!-WQPO,59jO!&QQQO1G.fO)PQPO1G.fO!-eQQO1G1hOOQO,59l,59lO!-mQPO,59lOOQO-E:g-E:gO!-rQPO,5>_O!.ZQPO,5:WO:kQPO'#GnO!.bQPO,5>^OOQO1G1x1G1xOOQO1G.x1G.xO!.{QPO'#CyO!/kQPO'#HkO!/uQPO'#CzO!0TQPO'#HjO!0]QPO,59dOOQO1G.|1G.|OEjQPO1G.|O!0sQPO,59eO!1QQQO'#H[O!1cQQO'#CbOOQO,5:b,5:bO:kQPO,5:cOOQO,5:a,5:aO!1tQQO,5:aOOQO1G/[1G/[O!1yQPO,5:bO!2[QPO'#GqO!2oQPO,5>fOOQO1G/z1G/zO!2wQPO'#DvO!3YQPO'#D_O!3aQPO1G/zO!!zQPO'#GoO!3fQPO1G1XO9PQPO1G1XO:kQPO'#GwO!3nQPO,5>mOOQO1G1O1G1OOOQO1G0Q1G0QO!3vQPO'#E]OOQO1G0b1G0bO!4gQPO1G1xO! hQPO1G0bO!%SQPO1G0RO!%bQPO1G0]O!%jQPO1G0WOOQO1G/]1G/]O!4lQQO1G.pO7kQPO1G0jO)PQPO1G0jO:sQPO'#HnO!6`QQO1G.pOOQO1G.p1G.pO!6eQQO1G0iOOQO1G0l1G0lO!6lQPO1G0lO!6wQQO1G.oO!7_QQO'#HoO!7lQPO,59sO!8{QQO1G0pO!:dQQO1G0pO!;rQQO1G0pO!<PQQO1G0pO!=UQQO1G0pO!=lQQO1G0pO!=vQQO1G1PO!=}QQO'#HkOOQO1G0{1G0{O!?QQQO1G0}OOQO1G0}1G0}OOQO1G1n1G1nO! pQPO'#DqO!ARQPO'#D[O!!zQPO'#D|O!!zQPO'#D}OOQO1G0R1G0RO!AYQPO1G0RO!A_QPO1G0RO!AgQPO1G0RO!ArQPO'#EXOOQO1G0]1G0]O!BVQPO1G0]O!B[QPO'#ETO!!zQPO'#ESOOQO1G0W1G0WO!CUQPO1G0WO!CZQPO1G0WO!CcQPO'#EhO!CjQPO'#EhOOQO'#Gv'#GvO!CrQQO1G0mO!EcQQO1G3tO7kQPO1G3tO!GbQPO'#FWOOQO1G.f1G.fOOQO1G1h1G1hO!GiQPO1G1jOOQO1G1j1G1jO!GtQQO1G1jO!G|QPO1G1pOOQO1G1s1G1sO)aQPO'#D_O+_QQO,5<aO!KtQPO,5<aO!LVQPO,5<]O!L^QPO,5<]OOQO1G1u1G1uOOQO1G1z1G1zOOQO1G1|1G1|O9PQPO1G1|O#!QQPO'#FzOOQO1G2O1G2OO;nQPO1G2TOOQO1G2V1G2VOOQO1G2X1G2XOOQO1G2Z1G2ZOOQO1G2]1G2]OOQO1G2^1G2^O#!XQQO'#H[O##SQQO'#CbO+_QQO'#HkO##}QQOOO#$kQQO'#EeO#$YQQO'#H`OLZQPO'#GdO#$rQPO,5<}OOQO'#HO'#HOO#$zQPO1G2`O#(xQPO'#G[O<jQPO'#G`OOQO1G2`1G2`O#(}QPO1G2hOOQO1G.i1G.iO#.SQQO'#EeO#.dQQO'#H^O#.tQPO'#FSOOQO'#H^'#H^O#/OQPO'#H^O#/mQPO'#IUO#/uQPO,59SOOQO7+$Q7+$QO!&QQQO7+$QOOQO7+'S7+'SOOQO1G/W1G/WO#/zQPO'#DoO#0UQQO'#HtOOQO'#Ht'#HtOOQO1G/r1G/rOOQO,5=Y,5=YOOQO-E:l-E:lO#0fQWO,58{O#0mQPO,59fOOQO,59f,59fO!!zQPO'#HmOD}QPO'#GhO#0{QPO,5>UOOQO1G/O1G/OOOQO7+$h7+$hOOQO1G/{1G/{O#1TQQO1G/{OOQO1G/}1G/}O#1YQPO1G/{OOQO1G/|1G/|O:kQPO1G/}OOQO,5=],5=]OOQO-E:o-E:oOOQO7+%f7+%fOOQO,5=Z,5=ZOOQO-E:m-E:mO9PQPO7+&sOOQO7+&s7+&sOOQO,5=c,5=cOOQO-E:u-E:uO#1_QPO'#EUO#1mQPO'#EUOOQO'#Gu'#GuO#2UQPO,5:wOOQO,5:w,5:wOOQO7+'d7+'dOOQO7+%|7+%|OOQO7+%m7+%mO!AYQPO7+%mO!A_QPO7+%mO!AgQPO7+%mOOQO7+%w7+%wO!BVQPO7+%wOOQO7+%r7+%rO!CUQPO7+%rO!CZQPO7+%rOOQO7+&U7+&UOOQO'#Ee'#EeO7kQPO7+&UO7kQPO,5>YO#2uQPO7+$[OOQO7+&T7+&TOOQO7+&W7+&WO9PQPO'#GjO#3TQPO,5>ZOOQO1G/_1G/_O9PQPO7+&kO#3`QQO,59eO#4cQPO'#DrO! pQPO'#DrO#4nQPO'#HwO#4vQPO,5:]O#5aQQO'#HgO#5|QQO'#CuO! mQPO'#HvO#6lQPO'#DpO#6vQPO'#HvO#7XQPO'#DpO#7aQPO'#IPO#7fQPO'#E`OOQO'#Hp'#HpOOQO'#Gk'#GkO#7nQPO,59vOOQO,59v,59vO#7uQPO'#HqOOQO,5:h,5:hO#9]QPO'#H|OOQO'#EP'#EPOOQO,5:i,5:iO#9hQPO'#EYO:kQPO'#EYO#9yQPO'#H}O#:UQPO,5:sO! mQPO'#HvO!!zQPO'#HvO#:^QPO'#DpOOQO'#Gs'#GsO#:eQPO,5:oOOQO,5:o,5:oOOQO,5:n,5:nOOQO,5;S,5;SO#;_QQO,5;SO#;fQPO,5;SOOQO-E:t-E:tOOQO7+&X7+&XOOQO7+)`7+)`O#;mQQO7+)`OOQO'#Gz'#GzO#=ZQPO,5;rOOQO,5;r,5;rO#=bQPO'#FXO)PQPO'#FXO)PQPO'#FXO)PQPO'#FXO#=pQPO7+'UO#=uQPO7+'UOOQO7+'U7+'UO]QPO7+'[O#>QQPO1G1{O! mQPO1G1{O#>`QQO1G1wO!!sQPO1G1wO#>gQPO1G1wO#>nQQO7+'hOOQO'#G}'#G}O#>uQPO,5<fOOQO,5<f,5<fO#>|QPO'#HqO9PQPO'#F{O#?UQPO7+'oO#?ZQPO,5=OO! mQPO,5=OO#?`QPO1G2iO#@iQPO1G2iOOQO1G2i1G2iOOQO-E:|-E:|OOQO7+'z7+'zO!2[QPO'#G^O<jQPO,5<vOOQO,5<z,5<zO#@qQPO7+(SOOQO7+(S7+(SO#DoQPO,59TO#DvQPO'#ITO#EOQPO,5;nO)PQPO'#GyO#ETQPO,5>pOOQO1G.n1G.nOOQO<<Gl<<GlO#E]QPO'#HuO#EeQPO,5:ZOOQO1G/Q1G/QOOQO,5>X,5>XOOQO,5=S,5=SOOQO-E:f-E:fO#EjQPO7+%gOOQO7+%g7+%gOOQO7+%i7+%iOOQO<<J_<<J_O#FQQPO'#H[O#FXQPO'#CbO#F`QPO,5:pO#FeQPO,5:xO#1_QPO,5:pOOQO-E:s-E:sOOQO1G0c1G0cOOQO<<IX<<IXO!AYQPO<<IXO!A_QPO<<IXOOQO<<Ic<<IcOOQO<<I^<<I^O!CUQPO<<I^OOQO<<Ip<<IpO#FjQQO<<GvO7kQPO<<IpO)PQPO<<IpOOQO<<Gv<<GvO#H^QQO,5=UOOQO-E:h-E:hO#HkQQO<<JVOOQO,5:^,5:^O!!zQPO'#DsO#IRQPO,5:^O! pQPO'#GpO#I^QPO,5>cOOQO1G/w1G/wO#IfQPO'#HsO#ImQPO,59xO#IrQPO,5>bO! mQPO,59xO#I}QPO,5:[O#7fQPO,5:zO! mQPO,5>bO!!zQPO,5>bO#7aQPO,5>kOOQO,5:[,5:[OLvQPO'#DtOOQO,5>k,5>kO#JVQPO'#EaOOQO,5:z,5:zO#MWQPO,5:zO!!zQPO'#DxOOQO-E:i-E:iOOQO1G/b1G/bOOQO,5:y,5:yO!!zQPO'#GrO#M]QPO,5>hOOQO,5:t,5:tO#MhQPO,5:tO#MvQPO,5:tO#NXQPO'#GtO#NoQPO,5>iO#NzQPO'#EZOOQO1G0_1G0_O$ RQPO1G0_O! mQPO,5:pOOQO-E:q-E:qOOQO1G0Z1G0ZOOQO1G0n1G0nO$ WQQO1G0nOOQO<<Lz<<LzOOQO-E:x-E:xOOQO1G1^1G1^O$ _QQO,5;sOOQO'#G{'#G{O#=bQPO,5;sOOQO'#IV'#IVO$ gQQO,5;sO$ xQQO,5;sOOQO<<Jp<<JpO$!QQPO<<JpOOQO<<Jv<<JvO9PQPO7+'gO$!VQPO7+'gO!!sQPO7+'cO$!eQPO7+'cO$!jQQO7+'cOOQO<<KS<<KSOOQO-E:{-E:{OOQO1G2Q1G2QOOQO,5<g,5<gO$!qQQO,5<gOOQO<<KZ<<KZO9PQPO1G2jO$!xQPO1G2jOOQO,5=l,5=lOOQO7+(T7+(TO$!}QPO7+(TOOQO-E;O-E;OO$$lQWO'#HfO$$WQWO'#HfO$$sQPO'#G_O:kQPO,5<xOLZQPO,5<xOOQO1G2b1G2bOOQO<<Kn<<KnO$%UQQO1G.oOOQO1G1Z1G1ZO$%`QPO'#GxO$%mQPO,5>oOOQO1G1Y1G1YO$%uQPO'#FTOOQO,5=e,5=eOOQO-E:w-E:wO$%zQPO'#GmO$&XQPO,5>aOOQO1G/u1G/uOOQO<<IR<<IROOQO1G0[1G0[O$&aQPO1G0dO$&fQPO1G0[O$&kQPO1G0dOOQOAN>sAN>sO!AYQPOAN>sOOQOAN>xAN>xOOQOAN?[AN?[O7kQPOAN?[O$&pQPO,5:_OOQO1G/x1G/xOOQO,5=[,5=[OOQO-E:n-E:nO$&{QPO,5>eOOQO1G/d1G/dOOQO1G3|1G3|O$'^QPO1G/dOOQO1G/v1G/vOOQO1G0f1G0fO#MWQPO1G0fO#7aQPO'#HyO$'cQPO1G3|O! mQPO1G3|OOQO1G4V1G4VOK^QPO'#DvOJmQPO'#D_OOQO,5:{,5:{O$'nQPO,5:{O$'nQPO,5:{O$'uQQO'#H_O$'|QQO'#H`O$(WQQO'#EbO$(cQPO'#EbOOQO,5:d,5:dOOQO,5=^,5=^OOQO-E:p-E:pOOQO1G0`1G0`O$(kQPO1G0`OOQO,5=`,5=`OOQO-E:r-E:rO$(yQPO,5:uOOQO7+%y7+%yOOQO7+&Y7+&YOOQO1G1_1G1_O$)QQQO1G1_OOQO-E:y-E:yO$)YQQO'#IWO$)TQPO1G1_O$ mQPO1G1_O)PQPO1G1_OOQOAN@[AN@[O$)eQQO<<KRO9PQPO<<KRO$)lQPO<<J}OOQO<<J}<<J}O!!sQPO<<J}OOQO1G2R1G2RO$)qQQO7+(UO9PQPO7+(UOOQO<<Ko<<KoP!'xQPO'#HQOLZQPO'#HPO$){QPO,5<yO$*WQPO1G2dO:kQPO1G2dOOQO,5=d,5=dOOQO-E:v-E:vO#DoQPO,5;oOOQO,5=X,5=XOOQO-E:k-E:kO$*]QPO7+&OOOQO7+%v7+%vO$*kQPO7+&OOOQOG24_G24_OOQOG24vG24vO$*pQPO1G/yO$*{QPO1G4POOQO7+%O7+%OOOQO7+&Q7+&QOOQO7+)h7+)hO$+^QPO7+)hO!0bQPO,5:aOOQO1G0g1G0gO$+iQPO1G0gO$+pQPO,59qO$,UQPO,5:|O7kQPO,5:|OOQO7+%z7+%zOOQO7+&y7+&yO)PQPO'#G|O$,ZQPO,5>rO$,cQPO7+&yO$,hQQO'#IXOOQOAN@mAN@mO$,sQQOAN@mOOQOAN@iAN@iO$,zQPOAN@iO$-PQQO<<KpO$-ZQPO,5=kOOQO-E:}-E:}OOQO7+(O7+(OO$-lQPO7+(OO$-qQPO<<IjOOQO<<Ij<<IjO#DoQPO<<IjO$-qQPO<<IjOOQO<<MS<<MSOOQO7+&R7+&RO$.PQPO1G0jO$.[QQO1G0hOOQO1G0h1G0hO$.dQPO1G0hO$.iQQO,5=hOOQO-E:z-E:zOOQO<<Je<<JeO$.tQPO,5>sOOQOG26XG26XOOQOG26TG26TOOQO<<Kj<<KjOOQOAN?UAN?UO#DoQPOAN?UO$.|QPOAN?UO$/RQPOAN?UO7kQPO7+&SO$/aQPO7+&SOOQO7+&S7+&SO$/fQPOG24pOOQOG24pG24pO#DoQPOG24pO$/kQPO<<InOOQO<<In<<InOOQOLD*[LD*[O$/pQPOLD*[OOQOAN?YAN?YOOQO!$'Mv!$'MvO)PQPO'#CaO$/uQQO'#H[O$0YQQO'#CbO!!zQPO'#Cy",
  stateData: "$0u~OPOSQOS%wOS~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOvzOwjOz}O}bO!PuO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO![!_O!]xO!^xO!_xO!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&rcO~OWiXW&OXZ&OXuiXu&OX!P&OX!b&OX#]&OX#_&OX#a&OX#c&OX#d&OX#e&OX#f&OX#g&OX#h&OX#j&OX#n&OX#q&OX%{iX%}iX&PiX&[&OX&]iX&]&OX&l&OX&tiX&t&OX&v!aX~O#o$]X~P$wOWUXW&ZXZUXuUXu&ZX!PUX!bUX#]UX#_UX#aUX#cUX#dUX#eUX#fUX#gUX#hUX#jUX#nUX#qUX%{&ZX%}&ZX&P&ZX&[UX&]UX&]&ZX&lUX&tUX&t&ZX&v!aX~O#o$]X~P&{O%}RO&P!bO~O&U!gO&W!eO~Og]Oh]O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO%{SO%}!hO&PVOg!RXh!RX$g!RX%}!RX&P!RX~O#x!mO#y!lO$V!nOv!RX!u!RX!z!RX&r!RX~P)aOW!xOu!oO%{SO%}!sO&P!sO&t&_X~OW!{Ou&YX%{&YX%}&YX&P&YX&t&YXY&YXw&YX&l&YX&o&YXZ&YXq&YX&[&YX!P&YX#_&YX#a&YX#c&YX#d&YX#e&YX#f&YX#g&YX#h&YX#j&YX#n&YX#q&YX}&YX!r&YX#o&YXs&YX|&YX~O&]!yO~P+sO&]&YX~P+sOZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO#eoO#qnO#soO#toO%{SO&VTO~O%}!}O&P!|OY&nP~P.RO%{SOg%`Xh%`Xv%`X!S%`X!T%`X!U%`X!V%`X!W%`X!X%`X!Y%`X!Z%`X!]%`X!^%`X!_%`X!u%`X!z%`X$g%`X%}%`X&P%`X&r%`X&]%`X~O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xOg!RXh!RXv!RX!u!RX!z!RX%}!RX&P!RX&r!RX&]!RX~O$g!RX~P1sO|#[O~P]Og]Oh]Ov#aO!u#cO!z#bO%}!hO&PVO&r#`O~O$g#dO~P3cOu#fO&t#gO!P&RX#_&RX#a&RX#c&RX#d&RX#e&RX#f&RX#g&RX#h&RX#j&RX#n&RX#q&RX&[&RX&]&RX&l&RX~OW#eOY&RX#o&RXs&RXq&RX|&RX~P4UO!b#hO#]#hOW&SXu&SX!P&SX#_&SX#a&SX#c&SX#d&SX#e&SX#f&SX#g&SX#h&SX#j&SX#n&SX#q&SX&[&SX&]&SX&l&SX&t&SXY&SX#o&SXs&SXq&SX|&SX~OZ#XX~P5sOZ#iO~O&t#gO~O#_#mO#a#nO#c#oO#d#oO#e#pO#f#qO#g#rO#h#rO#j#vO#n#sO#q#tO&[#kO&]#kO&l#lO~O!P#uO~P7uO&v#wO~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O#eoO#qnO#soO#toO%{SO%}0iO&P0hO&VTO~O#o#{O~O![#}O~O%}!sO&P!sO~Og]Oh]O%}!hO&PVO&]!yO~OW$TO&t#gO~O#y!lO~O!W$XO%}RO&P!bO~OZ$YO~OZ$]O~O!P$dO%}$cO&P$cO~O!P$fO%}$cO&P$cO~O!P$iO~P9POZ$lO}bO~OW$oOZ$pOgTahTa%{Ta%}Ta&PTa~OvTa!STa!TTa!UTa!VTa!WTa!XTa!YTa!ZTa!]Ta!^Ta!_Ta!uTa!zTa#xTa#yTa$VTa$gTa&rTauTaYTa&]TaqTa|Ta!PTa~P<oO&U$sO&W!eO~Ou!oO%{SOqma&[maYma&lma!Pma~O&tma}ma!rma~P?RO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO~Og!Rah!Rav!Ra!u!Ra!z!Ra$g!Ra%}!Ra&P!Ra&r!Ra&]!Ra~P?wO#y$vO~Os$xO~Ou$yO%{SO~Ou!oO%{ra%}ra&Pra&traYrawra&lra&ora!Pra&[raqra~OWra#_ra#ara#cra#dra#era#fra#gra#hra#jra#nra#qra&]ra#orasra|ra~PArOu!oO%{SOq&gX!P&gX!b&gX~OY&gX#o&gX~PCpO!b$|Oq!`X!P!`XY!`X~Oq$}O!P&fX~O!P%PO~Ov%QO~Og]Oh]O%{0gO%}!hO&PVO&`%TO~O&[&^P~PD}O%{SO%}!hO&PVO~OWiXW&OXY&OXZ&OXuiXu&OX!b&OX#]&OX#_&OX#a&OX#c&OX#d&OX#e&OX#f&OX#g&OX#h&OX#j&OX#n&OX#q&OX%{iX%}iX&PiX&[&OX&]iX&]&OX&l&OX&tiX&t&OX&v!aX~OYiXY!aXq!aXwiX&liX&oiX~PEuOWUXW&ZXYUXZUXuUXu&ZX!bUX#]UX#_UX#aUX#cUX#dUX#eUX#fUX#gUX#hUX#jUX#nUX#qUX%{&ZX%}&ZX&P&ZX&[UX&]UX&]&ZX&lUX&tUX&t&ZX&v!aX~OY!aXY&ZXq!aXw&ZX&l&ZX&o&ZX~PHYOg]Oh]O%{SO%}!hO&PVOg!RXh!RX%}!RX&P!RX~P?wOu!oOw%_O%{SO%}%[O&P%ZO&o%^O~OW!xOY&_X&l&_X&t&_X~PK^OY%aO~P7uOg]Oh]O%}!hO&PVO~Oq%cOY&nX~OY%eO~Og]Oh]O%{SO%}!hO&PVOY&nP~P?wOY%kO&l%iO&t#gO~Oq%lO&v#wOY&uX~OY%nO~O%{SOg%`ah%`av%`a!S%`a!T%`a!U%`a!V%`a!W%`a!X%`a!Y%`a!Z%`a!]%`a!^%`a!_%`a!u%`a!z%`a$g%`a%}%`a&P%`a&r%`a&]%`a~O|%oO~P]O}%pO~Ou!oO%{SO%}!sO&P!sO~Op%|Ow%}O%}RO&P!bO&]!yO~Oz%{O~P! {Oz&PO%}RO&P!bO&]!yO~OY&cP~P9POg]Oh]O%{SO%}!hO&PVO~O}bO~P9POW!xOu!oO%{SO&t&_X~O#q#tO!P#ra#_#ra#a#ra#c#ra#d#ra#e#ra#f#ra#g#ra#h#ra#j#ra#n#ra&[#ra&]#ra&l#raY#ra#o#ras#raq#ra|#ra~Oo&dO}&cO!r&eO&]&bO~O}&jO!r&eO~Oo&nO}&mO&]&bO~OZ#iOu&rO%{SO~OW$oO}&xO~OW$oO!P&zO~OW&{O!P&|O~O$g!VO%}0iO&P0hO!P&cP~P.RO!P'XO#o'YO~P7uO}'ZO~O$b']O~O!P'^O~O!P'_O~O!P'`O~P7uO!P'bO~P7uOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wO%P'mO%T'nOZ$|a_$|a`$|aa$|ab$|ac$|ae$|ag$|ah$|ap$|av$|aw$|az$|a}$|a!P$|a!S$|a!T$|a!U$|a!V$|a!W$|a!X$|a!Y$|a!Z$|a![$|a!]$|a!^$|a!_$|a!u$|a!z$|a#e$|a#q$|a#s$|a#t$|a#x$|a#y$|a$V$|a$X$|a$_$|a$b$|a$d$|a$g$|a$k$|a$m$|a$r$|a$t$|a$v$|a$x$|a${$|a$}$|a%u$|a%{$|a%}$|a&P$|a&V$|a&r$|a|$|a$`$|a$p$|a~O}'tOY&xP~P9PO}ra!rra&|ra~PArOW$oO!P'{O~Os'|O~Ou!oO%{SOq&ga!P&ga!b&gaY&ga#o&ga~O}'}O~P9POq$}O!P&fa~Og]Oh]O%{0gO%}!hO&PVO~O&`(UO~P!.jOu!oO%{SOq&_X&[&_XY&_X&l&_X!P&_X~O}&_X!r&_X~P!/SOo(WOp(WOqnX&[nX~Oq(XO&[&^X~O&[(ZO~Ou!oOw(]O%{SO%}RO&P!bO~OYma&lma&tma~P!0bOW&OXY!aXq!aXu!aX%{!aX~OWUXY!aXq!aXu!aX%{!aX~OW(`O~Ou!oO%{SO%}!sO&P!sO&o(bO~Og]Oh]O%{SO%}!hO&PVO~P?wOq%cOY&na~Ou!oO%{SO%}!sO&P!sO&o%^O~O%{SO~P1sOY(eO~OY(hO&l%iO~Oq%lOY&ua~Og]Oh]OvzO|(pO!u|O%{SO%}!hO&PVO&rcO~P?wO!P(qO~OW^iZ#XXu^i!P^i!b^i#]^i#_^i#a^i#c^i#d^i#e^i#f^i#g^i#h^i#j^i#n^i#q^i&[^i&]^i&l^i&t^iY^i#o^is^iq^i|^i~OW)QO~Os)RO~P7uOz)SO%}RO&P!bO~O!P]iY]i#o]is]iq]i|]i~P7uOq)TOY&cX!P&cX~P7uOY)VO~O#q#tO!P#^i#_#^i#a#^i#c#^i#d#^i#e#^i#f#^i#j#^i#n#^i&[#^i&]#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#g#rO#h#rO~P!7qO#_#mO#f#qO#g#rO#h#rO#j#vO#q#tO&[#kO&]#kO!P#^i#a#^i#c#^i#d#^i#n#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#e#pO~P!9VO#_#mO#f#qO#g#rO#h#rO#j#vO#q#tO&[#kO&]#kO!P#^i#c#^i#d#^i#n#^iY#^i#o#^is#^iq#^i|#^i~O#a#nO#e#pO&l#lO~P!:kO#e#^i~P!9VO#q#tO!P#^i#a#^i#c#^i#d#^i#e#^i#f#^i#n#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#_#mO#g#rO#h#rO#j#vO&[#kO&]#kO~P!<WO#g#^i#h#^i~P!7qO#o)WO~P7uO#_&_X#a&_X#c&_X#d&_X#e&_X#f&_X#g&_X#h&_X#j&_X#n&_X#q&_X&]&_X#o&_Xs&_X|&_X~P!/SO!P#kiY#ki#o#kis#kiq#ki|#ki~P7uOg]Oh]OvzO}bO!P)fO!SxO!TxO!UxO!VxO!W)jO!XxO!YxO!ZyO!]xO!^xO!_xO!u|O!z{O%{SO%})^O&P)_O&]&bO&rcO~O|)iO~P!?hO}&cO~O}&cO!r&eO~Oo&dO}&cO!r&eO~O%{SO%}!sO&P!sO|&qP!P&qP~P?wO}&jO~Og]Oh]OvzO|)xO!P)vO!u|O!z{O%{SO%}!hO&PVO&]&bO&rcO~P?wO}&mO~Oo&nO}&mO~Os)zO~P9POu)|O%{SO~Ou&rO}'}O%{SOW#Zi!P#Zi#_#Zi#a#Zi#c#Zi#d#Zi#e#Zi#f#Zi#g#Zi#h#Zi#j#Zi#n#Zi#q#Zi&[#Zi&]#Zi&l#Zi&t#ZiY#Zi#o#Zis#Ziq#Zi|#Zi~O}&cOW&biu&bi!P&bi#_&bi#a&bi#c&bi#d&bi#e&bi#f&bi#g&bi#h&bi#j&bi#n&bi#q&bi&[&bi&]&bi&l&bi&t&biY&bi#o&bis&biq&bi|&bi~O#|*UO$O*VO$Q*VO$R*WO$S*XO~O|*TO~P!GPO$Y*YO%}RO&P!bO~OW*ZO!P*[O~O$`*]OZ$^i_$^i`$^ia$^ib$^ic$^ie$^ig$^ih$^ip$^iv$^iw$^iz$^i}$^i!P$^i!S$^i!T$^i!U$^i!V$^i!W$^i!X$^i!Y$^i!Z$^i![$^i!]$^i!^$^i!_$^i!u$^i!z$^i#e$^i#q$^i#s$^i#t$^i#x$^i#y$^i$V$^i$X$^i$_$^i$b$^i$d$^i$g$^i$k$^i$m$^i$r$^i$t$^i$v$^i$x$^i${$^i$}$^i%u$^i%{$^i%}$^i&P$^i&V$^i&r$^i|$^i$p$^i~Og]Oh]O$g#dO%}!hO&PVO~O!P*aO~P9PO!P*bO~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOvzOwjOz}O}bO!PuO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!Z*gO![!_O!]xO!^xO!_xO!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$p*hO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&rcO~O|*fO~P!LcOWiXW&OXY&OXZ&OXuiXu&OX!P&OX%{iX%}iX&PiX&]iX&tiX&t&OX~OWUXW&ZXYUXZUXuUXu&ZX!PUX%{&ZX%}&ZX&P&ZX&]&ZX&tUX&t&ZX~OW#eOu#fO&t#gO~OW&SXY%WXu&SX!P%WX&t&SX~OZ#XX~P#$YOY*nO!P*lO~O%P'mO%T'nOZ$|i_$|i`$|ia$|ib$|ic$|ie$|ig$|ih$|ip$|iv$|iw$|iz$|i}$|i!P$|i!S$|i!T$|i!U$|i!V$|i!W$|i!X$|i!Y$|i!Z$|i![$|i!]$|i!^$|i!_$|i!u$|i!z$|i#e$|i#q$|i#s$|i#t$|i#x$|i#y$|i$V$|i$X$|i$_$|i$b$|i$d$|i$g$|i$k$|i$m$|i$r$|i$t$|i$v$|i$x$|i${$|i$}$|i%u$|i%{$|i%}$|i&P$|i&V$|i&r$|i|$|i$`$|i$p$|i~OZ*qO~O%P'mO%T'nOZ%Ui_%Ui`%Uia%Uib%Uic%Uie%Uig%Uih%Uip%Uiv%Uiw%Uiz%Ui}%Ui!P%Ui!S%Ui!T%Ui!U%Ui!V%Ui!W%Ui!X%Ui!Y%Ui!Z%Ui![%Ui!]%Ui!^%Ui!_%Ui!u%Ui!z%Ui#e%Ui#q%Ui#s%Ui#t%Ui#x%Ui#y%Ui$V%Ui$X%Ui$_%Ui$b%Ui$d%Ui$g%Ui$k%Ui$m%Ui$r%Ui$t%Ui$v%Ui$x%Ui${%Ui$}%Ui%u%Ui%{%Ui%}%Ui&P%Ui&V%Ui&r%Ui|%Ui$`%Ui$p%Ui~OW&SXu&SX#_&SX#a&SX#c&SX#d&SX#e&SX#f&SX#g&SX#h&SX#j&SX#n&SX#q&SX&[&SX&]&SX&l&SX&t&SX~O!b*vO#]#hOY&SXZ#XX~P#,{OY&QXq&QX|&QX!P&QX~P7uO}'tO|&wP~P9POY&QXg%YXh%YX%{%YX%}%YX&P%YXq&QX|&QX!P&QX~Oq*yOY&xX~OY*{O~O}'}O|&iP~P9POq&hX!P&hX|&hXY&hX~P7uO&`Ta~P<oOo(WOp(WOqna&[na~Oq(XO&[&^a~OW+TO~Ow+UO~Ou!oO%{SO%}+YO&P+XO~Og]Oh]Ov#aO!u#cO%}!hO&PVO&r#`O~Og]Oh]OvzO|+_O!u|O%{SO%}!hO&PVO&rcO~P?wOw+jO%}RO&P!bO&]!yO~Oq)TOY&ca!P&ca~O#_ma#ama#cma#dma#ema#fma#gma#hma#jma#nma#qma&]ma#omasma|ma~P?ROo+oOq!fX&[!fX~Oq+qO&[&kX~O&[+sO~OW&ZXu&ZX%{&ZX%}&ZX&P&ZX&]&ZX~OZ!aX~P#4{OWiXuiX%{iX%}iX&PiX&]iX~OZ!aX~P#5hOg]Oh]Ov#aO!u#cO!z#bO&]&bO&r#`O~O%})^O&P)_O~P#6TOg]Oh]O%{SO%})^O&P)_O~O}bO!P+}O~OZ,OO~O},QO!m,TO~O|,VO~P!?hO}bOg&eXh&eXv&eX!S&eX!T&eX!U&eX!V&eX!W&eX!X&eX!Y&eX!Z&eX!]&eX!^&eX!_&eX!u&eX!z&eX%{&eX%}&eX&P&eX&]&eX&r&eX~Oq,XO}&pX!P&pX~OZ#iO}&cOq!|X|!|X!P!|X~Oq,^O|&qX!P&qX~O|,aO!P,`O~O&]&bO~P3cOg]Oh]OvzO|,eO!P)vO!u|O!z{O%{SO%}!hO&PVO&]&bO&rcO~P?wOs,fO~P7uOs,fO~P9PO}&cOW&bqu&bq!P&bq#_&bq#a&bq#c&bq#d&bq#e&bq#f&bq#g&bq#h&bq#j&bq#n&bq#q&bq&[&bq&]&bq&l&bq&t&bqY&bq#o&bqs&bqq&bq|&bq~O|,jO~P!GPO!W,nO#},nO%}RO&P!bO~O!P,qO~O$Y,rO%}RO&P!bO~O!b$|O#o,tOq!`X!P!`X~O!P,vO~P7uO!P,vO~P9PO!P,yO~P7uO|,{O~P!LcO![#}O#o,|O~O!P-OO~O!b-PO~OY-SOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wOY-SO!P-TO~O%P'mO%T'nOZ%Uq_%Uq`%Uqa%Uqb%Uqc%Uqe%Uqg%Uqh%Uqp%Uqv%Uqw%Uqz%Uq}%Uq!P%Uq!S%Uq!T%Uq!U%Uq!V%Uq!W%Uq!X%Uq!Y%Uq!Z%Uq![%Uq!]%Uq!^%Uq!_%Uq!u%Uq!z%Uq#e%Uq#q%Uq#s%Uq#t%Uq#x%Uq#y%Uq$V%Uq$X%Uq$_%Uq$b%Uq$d%Uq$g%Uq$k%Uq$m%Uq$r%Uq$t%Uq$v%Uq$x%Uq${%Uq$}%Uq%u%Uq%{%Uq%}%Uq&P%Uq&V%Uq&r%Uq|%Uq$`%Uq$p%Uq~O}'tO~P9POq-`O|&wX~O|-bO~Oq*yOY&xa~Oq-fO|&iX~O|-hO~Ow-iO~Oq!aXu!aX!P!aX!b!aX%{!aX~OZ&OX~P#EoOZUX~P#EoO!P-jO~OZ-kO~OW^yZ#XXu^y!P^y!b^y#]^y#_^y#a^y#c^y#d^y#e^y#f^y#g^y#h^y#j^y#n^y#q^y&[^y&]^y&l^y&t^yY^y#o^ys^yq^y|^y~OY%^aq%^a!P%^a~P7uO!P#myY#my#o#mys#myq#my|#my~P7uOo+oOq!fa&[!fa~Oq+qO&[&ka~OZ,OO~PCpO!P-xO~O!m,TO}&ja!P&ja~O}bO!P-{O~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op.ZOvzOw.YOz}O|.UO}bO!PuO![!_O!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&]!yO&rcO~P?wO},QO~Oq,XO}&pa!P&pa~O}&cOq!|a|!|a!P!|a~OZ#iO}&cOq!|a|!|a!P!|a~O%{SO%}!sO&P!sOq%hX|%hX!P%hX~P?wOq,^O|&qa!P&qa~O|!}X~P!?hO|.eO~Os.fO~P7uOW$oO!P.gO~OW$oO$P.lO%}RO&P!bO!P&zP~OW$oO$T.mO~O!P.nO~O!b$|O#o.pOq!`X!P!`X~OY.rO~O!P.sO~P7uO#o.tO~P7uO!b.vO~OY.wOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wOW!{Ou&YX%{&YX%}&YX&P&YX&|&YX~O&]!yO~P$$WOu!oO%{SO&|.yO%}%RX&P%RX~OY&QXq&QX~P7uO}'tOq%lX|%lX~P9POq-`O|&wa~O!b/PO~O}'}Oq%aX|%aX~P9POq-fO|&ia~OY/SO~O!P/TO~OZ/UO~O&l%iOq!ga&[!ga~Ou!oO%{SO}&ma!P&ma!m&ma~O!P/ZO~O!m,TO}&ji!P&ji~O|/`O~P]OW/bO~P4UOZ#iO!P&SX~P#,{OW$TOZ#iO&t#gO~Op/dOw/dO~O}&cOq!|i|!|i!P!|i~O|!}a~P!?hOW$oO!P/fO~OW$oOq/gO!P&zX~OY/kO~P7uOY/mO~OY%Wq!P%Wq~P7uO&|.yO%}%Ra&P%Ra~OY/rO~Ou!oO!P/uO!Z/vO%{SO~OY/wO~O&l%iOq!gi&[!gi~Ou!oO%{SO}&mi!P&mi!m&mi~O!m,TO}&jq!P&jq~O|/yO~P]Op/{Ow%}Oz%{O%}RO&P!bO&]!yO~O!P/|O~Oq/gO!P&za~O!P0QO~OW$oOq/gO!P&{X~OY0SO~P7uOY0TO~OY%Wy!P%Wy~P7uOu!oO%{SO%}%sa&P%sa&|%sa~OY0UO~Ou!oO!P0VO!Z0WO%{SO~Op0ZO%}RO&P!bO~OW)QOZ#iO~O!P0]O~OW$oOq%pa!P%pa~Oq/gO!P&{a~O!P0_O~Ou!oO!P0_O!Z0`O%{SO~O!P0bO~O!P0cO~O!P0eO~O!P0fO~O#o&OXY&OXs&OXq&OX|&OX~P$wO#oUXYUXsUXqUX|UX~P&{O`Q_P#f&Vc~",
  goto: "#(V&|PPPP&}'b*q-tP'bPP.Y.^/rPPPPP1^P2vPP4`7P9j<T<m>bPPP>hP@|PPPAv2vPCoPPDjPEaEgPPPPPPPPPPPPFpGXPJ_JgJqKZKaKgMVMZMZMcPMrNx! k! uP!![NxP!!b!!l!!{!#TP!#r!#|!$SNx!$V!$]EaEa!$a!$k!$n2v!&Y2v2v!(RP.^P!(VP!(vPPPPPP.^P.^!)d.^PP.^P.^PP.^!*x!+SPP!+Y!+cPPPPPPPP&}P&}PP!+g!+g!+z!+gPP!+gP!+gP!,e!,hP!+g!-O!+gP!+gP!-R!-UP!+gP!+gP!+gP!+gP!+g!+gP!+gP!-YP!-`!-c!-iP!+g!-u!-x!.Q!.d!2a!2g!2m!3s!3y!4T!5X!5_!5e!5o!5u!5{!6R!6X!6_!6e!6k!6q!6w!6}!7T!7Z!7e!7k!7u!7{PPP!8R!+g!8vP!<XP!=]P!?n!@U!CQ2vPPP!Dn!HY!JwPP!Mb!MeP# n# t##b##q##w#$w#%a#&[#&e#&h#&tP#&w#'TP#'[#'cP#'fP#'oP#'r#'u#'x#'|#(SssObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/a'kqOWX_`bnow!X!Z!^!`!i!p!t!y!{#O#P#U#Y#]#_#f#h#i#m#n#o#p#q#r#s#v#w#x#y#{$R$Y$Z$[$]$^$_$l$p${$|%R%S%X%Y%b%c%f%g%i%k%p&]&b&c&d&e&j&m&n&r&s&u'Q'R'T'Y'Z'e't'}(W(X(h(l(o)T)W)X)Z)`)b)h)s)t)w)|*]*_*a*b*e*h*k*l*q*v+]+o+q+t+w+z+{,O,Q,T,X,^,`,c,t,v-P-T-X-`-f-w.Q.S.T.V.W.d.p.s.v.x/P/S/Y/_/a/p/t/v/w0W0Y0`0j#rgO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`t!dS!P!R!S!l!n$X$v*U*V*W*X,m,o.l.m/g0gQ#^cS%`#P.SQ%s#`U%x#e$T/bQ&P#gW'g$l*l-T.xU'q$o&{*ZQ'r$pS(^%Y/_U(}%z+i/zQ)S&QQ+[(lQ+g)QQ-c*yR-m+]u!dS!P!R!S!l!n$X$v*U*V*W*X,m,o.l.m/g0gT$q!c(T#upO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`#tkO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`X'h$l*l-T.x#}UO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`#}jO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`%tZOW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jQ%W!{Q([%XV-V*q-Z.y%tZOW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jV-V*q-Z.y%t[OW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jV-W*q-Z.yS!zZ-VS$S}%{S%z#e$TQ&Q#gQ+i)QQ.[,QR/z/b$eYO_bnow!X!Z!^!`!y#]#f#h#i#m#n#o#p#q#r#s#v#w#{$Y$Z$[$]$^$_$l$p$|%i%k&d&e&n&r'T'Y'Z't'}(W(X(h)T)W)|*]*a*b*e*h*l*v+o,Q,T,X,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q%U!yR+R(X%u^OW_bdnow!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0j!o!qX!i!r!t#P#_#y$t${%S%Y%b%f&]'R'e(l)X)`)s*_*k+]+t+w+z,c-X-w.Q.S/S/Y/_/p/t/w0Y#|jO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q$Z!TQ$[!UQ$a!YQ$j!_R*i']Q#jhS&v$R)PQ(|%yQ*Q&wQ+f)OQ,[)oQ-q+hQ.a,]Q/W-rS/c.Y.ZQ/}/dQ0[/{R0a0ZQ&f$OW(s%t&g&h&iQ*P&vU+`(t(u(vQ,Z)oQ,h*QS-n+a+bS.`,[,]Q/V-oR/e.aX)f&c)h,`.drdObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW#R_#U%c,OQ'S$]W'i$l*l-T.xS(m%p(oW)a&c)h,`.dS)p&j,^S)u&m)wR-Z*qh!vX!V#_#d'R(l)`)s*_+]+w,cQ(R$}Q(_%^R+V(b#rmObnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`v!tX!V#P#_#d$}%^%b%f'R'e(b(l*_*k+]-Y.S.|Q#W_Q$OzQ$P{Q$Q|Q%t#aQ%u#bQ%v#cQ(j%lS)Y&b+qY)d&c)a)h,`.dS)o&j,^Q+p)ZW+t)`)s+w,cQ+|)bQ,])pT.O+z.QU(P$|'}-fR*O&uW)f&c)h,`.dT)v&m)wQ&i$OQ&q$QQ(v%tQ({%vY)b&c)a)h,`.dV)t&m)u)wQ)[&bR-u+qQ+n)YR-t+p#tmO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`Q,P)dS-w+t.OR.R+|T#U_,OU#S_#U,OR(c%cQ,S)eQ-y+vQ-}+yQ/].PR/x/^ruObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aQ$m!aQ&`#wQ'a$jQ'p$nW)f&c)h,`.dQ*s'nQ+})cQ,W)jQ-[*rR-{+xrsObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aS(n%p(oW)f&c)h,`.dT)v&m)wQ&h$OS(u%t&iR+b(vQ&g$OQ&l$PU(t%t&h&iQ(x%uS+a(u(vR-o+bQ)n&eR)y&nQ&p$QS(z%v&qR+e({Q&o$QU(y%v&p&qS+d(z({R-p+eS(n%p(oT)v&m)wrsObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW)f&c)h,`.dT)v&m)wQ&k$PS(w%u&lR+c(xQ)q&jR.b,^R,b)rQ%q#^R(r%sT(n%p(oQ,R)eS-|+y,SR/[-}R.W,QWj$l*l-T.x#ukO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`#|hO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`U%y#e$T/bS)O%z/zQ+h)QR-r+iT&t$R&u!]#ml#Q$`$h$k&O&R&S&V&W&X&Y&[&_'s(O){*`*c+k+m,g,x,}-^.o.u/l/o!V#nl#Q$`$h$k&O&R&S&W&[&_'s(O){*`*c+k+m,g,x,}-^.o.u/l/o#umO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`a'u$p't*v-`/P/v0W0`Q'w$pR-d*yQ&y$UQ'y$uR*|'zT*R&x*SsuObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/artObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aQ$e![R$g!]R$^!WruObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aR'T$]R$_!WR'[$aT*d'Z*eX'k$m'l'p*tR*r'mQ-Y*qR.|-ZQ'o$mQ*p'lQ*u'pR-]*tR$n!aQ'j$lV-R*l-T.xQwOQ#]bW#|w#].V/aQ.V,QR/a.WrWObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/al!kW!p#O#Y#x%R%X%g&s'Q)Z+{.T0j!j!pX!i!t#P#_#y${%S%Y%b%f&]'R'e(l)X)`)s*_*k+]+t+w+z,c-X-w.Q.S/S/Y/_/p/t/w0YQ#O_Q#Y`#^#xno!X!^!`#f#h#i#m#n#o#p#q#r#s#w$Y$p$|%i%k&d&e&n&r'T'Y't'}(W(h)T)W)|*a*b*h*v+o,T,X,t,v-P-`-f.p.s.v/P/v0W0`S%R!y(XQ%X!{j%g#U%c%p&c&j&m(o)h)w*q,^,`.dS&s$R&uY'Q$]$l*l-T.xS)Z&b+qS+{)b)tQ.T,OR0j#vQ!fTR$r!fQ(Y%UR+S(Y^!rX#P#y&]'R'e)Xx$t!i#_%S%Y%b%f(l)`)s*_*k+]+w+z,c-X.Q.S/_/p[$z!r$t${/Y/t0YS${!t+tQ/Y-wQ/t/SR0Y/wQ)U&SR+l)UQ)h&cS,U)h.dR.d,`!laO_bw!Z#U#]#{$Z$[$]$^$_$l%c%p&c&j&m'Z(o)h)w*]*e*l*q,O,Q,^,`-T.V.W.d.x/aY!jW#O%g'Q.TT#Za!jQ-g*}R/R-gQ%O!vR(S%OQ%j#VS(g%j/XR/X-sQ+r)[R-v+rQ%d#SR(d%dQ,Y)lR._,YQ)w&mR,d)wQ,_)qR.c,_Q(o%pR+^(oQ&u$RR)}&uQ%m#WR(k%mQ-a*wR/O-aQ*z'wR-e*zQ*S&xR,i*SQ,m*UR.i,mQ/h.jS0P/h0RR0R/jQ*e'ZR,z*eQ'l$mS*o'l*tR*t'pQ.z-XR/q.zQ*m'jR-U*m`vObw#],Q.V.W/aQ$b!ZQ&a#{Q'O$ZQ'P$[Q'V$^Q'W$_S*d'Z*eR,s*]'YrOWX_`bnow!X!Z!^!`!i!p!t!y!{#O#P#U#Y#]#_#f#h#i#m#n#o#p#q#r#s#v#w#x#y#{$R$Y$Z$[$]$^$_$l${$|%R%S%X%Y%b%c%f%g%i%k%p&]&b&c&d&e&j&m&n&r&s&u'Q'R'T'Y'Z'e'}(W(X(h(l(o)T)W)X)Z)`)b)h)s)t)w)|*]*_*a*b*e*h*k*l*q+]+o+q+t+w+z+{,O,Q,T,X,^,`,c,t,v-P-T-X-f-w.Q.S.T.V.W.d.p.s.v.x/S/Y/_/a/p/t/w0Y0ja'v$p't*v-`/P/v0W0`Q!cSQ$U!PQ$V!RQ$W!SQ$u!lQ$w!nQ&}$XQ'z$vQ(T0gS,k*U*WQ,o*VQ,p*XQ.h,mS.j,o.lQ/j.mR0O/g%oROS_bcnow!P!R!S!X!Z!^!`!l!n#P#]#`#e#f#g#h#i#m#n#o#p#q#r#s#w#{$T$X$Y$Z$[$]$^$_$l$o$p$v$|%Y%k%z&Q&r&{'T'Y'Z't'}(h(l)Q)T)W)|*U*V*W*X*Z*]*a*b*e*h*l*v*y+]+i,Q,m,o,t,v-P-T-`-f.S.V.W.l.m.p.s.v.x/P/_/a/b/g/v/z0W0`0gQ'x$pQ*w'tS-_*v/PQ.}-`Q0X/vQ0^0WR0d0`rlObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aS#Q_$YQ#tnQ#zoQ$`!XQ$h!^Q$k!`Q&O#fQ&R#hY&S#i$]*a,v.sQ&U#mQ&V#nQ&W#oQ&X#pQ&Y#qQ&Z#rQ&[#sQ&_#w^'s$p't-`/P/v0W0`U(O$|'}-fQ(i%kQ){&rQ*`'TQ*c'YQ+W(hQ+k)TQ+m)WQ,g)|Q,x*bQ,}*hQ-^*vQ.o,tQ.u-PQ/l.pR/o.v#rfO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`W'f$l*l-T.xR.X,QrXObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW!iW#x%R'QQ#P_Q#_d!|#yno!X!^!`#f#h#i#m#n#o#p#q#r#s#w$Y$p$|%k&r'T'Y't'}(h)T)W)|*a*b*h*v,t,v-P-`-f.p.s.v/P/v0W0`d%S!y%i&d&e&n(W(X+o,T,XQ%Y#OQ%b#RS%f#U%cQ&]#vQ'R$]W'e$l*l-T.xS(l%p(oQ)X0jW)`&c)h,`.dS)s&m)wQ*_'SQ*k'iQ+](mQ+w)aS+z)b)tQ,c)uS-X*q-ZQ.Q+{Q.S,OQ/_.TR/p.y%t^OW_bdnow!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0jQ$R}Q&w$SR)P%{&PVOW_bdnow}!X!Z!^!`!y!{#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%X%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0jR%V!y#ziObnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q#V_Q%U!yQ&^#vQ(f%iQ)k&dU)l&e&n,TQ+Q(WQ+R(XQ-s+oR.^,XQ(V%TR+P(U#|eO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`T%w#e/bQ&T#iQ'U$]Q,w*aQ.q,vR/n.sX)g&c)h,`.d!{`OW_abw!Z!j#O#U#]#{$Z$[$]$^$_$l%c%g%p&c&j&m'Q'Z(o)h)w*]*e*l*q,O,Q,^,`-T.T.V.W.d.x/aU!wX!V'RU%r#_#d*_S+Z(l)sQ+u)`S-l+],cR-z+wj!uX!V#_#d$}%^(b(l)`)s+]+w,cU%]#P%f.SQ(a%bQ*^'RQ*j'eQ,u*_Q-Q*kQ.{-YR/s.|Q(Q$|Q*}'}R/Q-fR+O'}[)c&c&m)h)w,`.dT+x)a)uR)]&bW+v)`)s+w,cQ.P+zR/^.QS#T_,OR%h#US)m&e&nR.],TR)r&jW)e&c)h,`.dR+y)aR#X_R*x'tR'x$pT,l*U,mQ.k,oR/i.lR/i.m",
  nodeNames: "⚠ LineComment BlockComment Program ModuleDeclaration MarkerAnnotation Identifier ScopedIdentifier . Annotation ) ( AnnotationArgumentList AssignmentExpression FieldAccess IntegerLiteral FloatingPointLiteral BooleanLiteral CharacterLiteral StringLiteral TextBlock null ClassLiteral void PrimitiveType TypeName ScopedTypeName GenericType TypeArguments AnnotatedType Wildcard extends super , ArrayType ] Dimension [ class this ParenthesizedExpression ObjectCreationExpression new ArgumentList } { ClassBody ; FieldDeclaration Modifiers public protected private abstract static final strictfp default synchronized native transient volatile VariableDeclarator Definition AssignOp ArrayInitializer MethodDeclaration TypeParameters TypeParameter TypeBound FormalParameters ReceiverParameter FormalParameter SpreadParameter Throws throws Block ClassDeclaration Superclass SuperInterfaces implements InterfaceTypeList InterfaceDeclaration interface ExtendsInterfaces InterfaceBody ConstantDeclaration EnumDeclaration enum EnumBody EnumConstant EnumBodyDeclarations AnnotationTypeDeclaration AnnotationTypeBody AnnotationTypeElementDeclaration StaticInitializer ConstructorDeclaration ConstructorBody ExplicitConstructorInvocation ArrayAccess MethodInvocation MethodName MethodReference ArrayCreationExpression Dimension AssignOp BinaryExpression CompareOp CompareOp LogicOp BitOp BitOp LogicOp ArithOp ArithOp ArithOp BitOp InstanceofExpression instanceof LambdaExpression InferredParameters TernaryExpression LogicOp : UpdateExpression UpdateOp UnaryExpression LogicOp BitOp CastExpression ElementValueArrayInitializer ElementValuePair open module ModuleBody ModuleDirective requires transitive exports to opens uses provides with PackageDeclaration package ImportDeclaration import Asterisk ExpressionStatement LabeledStatement Label IfStatement if else WhileStatement while ForStatement for ForSpec LocalVariableDeclaration var EnhancedForStatement ForSpec AssertStatement assert SwitchStatement switch SwitchBlock SwitchLabel case DoStatement do BreakStatement break ContinueStatement continue ReturnStatement return SynchronizedStatement ThrowStatement throw TryStatement try CatchClause catch CatchFormalParameter CatchType FinallyClause finally TryWithResourcesStatement ResourceSpecification Resource",
  maxTerm: 274,
  nodeProps: [
    ["group", -26, 4, 47, 76, 77, 82, 87, 92, 144, 146, 149, 150, 152, 155, 157, 160, 162, 164, 166, 171, 173, 175, 177, 179, 180, 182, 190, "Statement", -25, 6, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 39, 40, 41, 99, 100, 102, 103, 106, 117, 119, 121, 124, 126, 129, "Expression", -7, 23, 24, 25, 26, 27, 29, 34, "Type"],
    ["openedBy", 10, "(", 44, "{"],
    ["closedBy", 11, ")", 45, "}"]
  ],
  propSources: [eZ],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 28,
  tokenData: "##[_R!_OX%QXY'fYZ)bZ^'f^p%Qpq'fqr*|rs,^st%Qtu4euv5qvw7Rwx8ixy@zyzAhz{BU{|Bz|}Db}!OEO!O!PFi!P!QNe!Q!R!+Z!R![!/R![!]!=]!]!^!>m!^!_!?Z!_!`!@t!`!a!Ah!a!b!CU!b!c!Ct!c!}!Jp!}#O!K|#O#P%Q#P#Q!Lj#Q#R!MW#R#S4e#S#T%Q#T#o4e#o#p!Mz#p#q!Nh#q#r#!Q#r#s#!n#s#y%Q#y#z'f#z$f%Q$f$g'f$g#BY%Q#BY#BZ'f#BZ$IS%Q$IS$I_'f$I_$I|%Q$I|$JO'f$JO$JT%Q$JT$JU'f$JU$KV%Q$KV$KW'f$KW&FU%Q&FU&FV'f&FV;'S%Q;'S;=`&s<%lO%QS%VV&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QS%qO&WSS%tVOY&ZYZ%lZr&Zrs&ys;'S&Z;'S;=`'`<%lO&ZS&^VOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QS&vP;=`<%l%QS&|UOY&ZYZ%lZr&Zs;'S&Z;'S;=`'`<%lO&ZS'cP;=`<%l&Z_'mk&WS%wZOX%QXY'fYZ)bZ^'f^p%Qpq'fqr%Qrs%qs#y%Q#y#z'f#z$f%Q$f$g'f$g#BY%Q#BY#BZ'f#BZ$IS%Q$IS$I_'f$I_$I|%Q$I|$JO'f$JO$JT%Q$JT$JU'f$JU$KV%Q$KV$KW'f$KW&FU%Q&FU&FV'f&FV;'S%Q;'S;=`&s<%lO%Q_)iY&WS%wZX^*Xpq*X#y#z*X$f$g*X#BY#BZ*X$IS$I_*X$I|$JO*X$JT$JU*X$KV$KW*X&FU&FV*XZ*^Y%wZX^*Xpq*X#y#z*X$f$g*X#BY#BZ*X$IS$I_*X$I|$JO*X$JT$JU*X$KV$KW*X&FU&FV*XV+TX#sP&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`;'S%Q;'S;=`&s<%lO%QU+wV#_Q&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT,aXOY,|YZ%lZr,|rs3Ys#O,|#O#P2d#P;'S,|;'S;=`3S<%lO,|T-PXOY-lYZ%lZr-lrs.^s#O-l#O#P.x#P;'S-l;'S;=`2|<%lO-lT-qX&WSOY-lYZ%lZr-lrs.^s#O-l#O#P.x#P;'S-l;'S;=`2|<%lO-lT.cVcPOY&ZYZ%lZr&Zrs&ys;'S&Z;'S;=`'`<%lO&ZT.}V&WSOY-lYZ/dZr-lrs1]s;'S-l;'S;=`2|<%lO-lT/iW&WSOY0RZr0Rrs0ns#O0R#O#P0s#P;'S0R;'S;=`1V<%lO0RP0UWOY0RZr0Rrs0ns#O0R#O#P0s#P;'S0R;'S;=`1V<%lO0RP0sOcPP0vTOY0RYZ0RZ;'S0R;'S;=`1V<%lO0RP1YP;=`<%l0RT1`XOY,|YZ%lZr,|rs1{s#O,|#O#P2d#P;'S,|;'S;=`3S<%lO,|T2QUcPOY&ZYZ%lZr&Zs;'S&Z;'S;=`'`<%lO&ZT2gVOY-lYZ/dZr-lrs1]s;'S-l;'S;=`2|<%lO-lT3PP;=`<%l-lT3VP;=`<%l,|T3_VcPOY&ZYZ%lZr&Zrs3ts;'S&Z;'S;=`'`<%lO&ZT3yR&USXY4SYZ4`pq4SP4VRXY4SYZ4`pq4SP4eO&VP_4la%}Z&WSOY%QYZ%lZr%Qrs%qst%Qtu4eu!Q%Q!Q![4e![!c%Q!c!}4e!}#R%Q#R#S4e#S#T%Q#T#o4e#o;'S%Q;'S;=`&s<%lO%QU5xX#gQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QU6lV#]Q&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV7YZ&lR&WSOY%QYZ%lZr%Qrs%qsv%Qvw7{w!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QU8SV#aQ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT8nZ&WSOY9aYZ%lZr9ars:Xsw9awx%Qx#O9a#O#P<a#P;'S9a;'S;=`>t<%lO9aT9fZ&WSOY9aYZ%lZr9ars:Xsw9awx;sx#O9a#O#P<a#P;'S9a;'S;=`>t<%lO9aT:[ZOY:}YZ%lZr:}rs>zsw:}wx?px#O:}#O#P@[#P;'S:};'S;=`@t<%lO:}T;QZOY9aYZ%lZr9ars:Xsw9awx;sx#O9a#O#P<a#P;'S9a;'S;=`>t<%lO9aT;zVbP&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT<fV&WSOY9aYZ<{Zr9ars:Xs;'S9a;'S;=`>t<%lO9aT=QW&WSOY=jZw=jwx>Vx#O=j#O#P>[#P;'S=j;'S;=`>n<%lO=jP=mWOY=jZw=jwx>Vx#O=j#O#P>[#P;'S=j;'S;=`>n<%lO=jP>[ObPP>_TOY=jYZ=jZ;'S=j;'S;=`>n<%lO=jP>qP;=`<%l=jT>wP;=`<%l9aT>}ZOY:}YZ%lZr:}rs=jsw:}wx?px#O:}#O#P@[#P;'S:};'S;=`@t<%lO:}T?uVbPOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT@_VOY9aYZ<{Zr9ars:Xs;'S9a;'S;=`>t<%lO9aT@wP;=`<%l:}_ARVZZ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVAoVYR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVB_X$YP&WS#fQOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QVCRZ#eR&WSOY%QYZ%lZr%Qrs%qs{%Q{|Ct|!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QVC{V#qR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVDiVqR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVEV[#eR&WSOY%QYZ%lZr%Qrs%qs}%Q}!OCt!O!_%Q!_!`6e!`!aE{!a;'S%Q;'S;=`&s<%lO%QVFSV&vR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_FpZWY&WSOY%QYZ%lZr%Qrs%qs!O%Q!O!PGc!P!Q%Q!Q![Hq![;'S%Q;'S;=`&s<%lO%QVGhX&WSOY%QYZ%lZr%Qrs%qs!O%Q!O!PHT!P;'S%Q;'S;=`&s<%lO%QVH[V&oR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QTHxc&WS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hq![!f%Q!f!gJT!g!hJq!h!iJT!i#R%Q#R#SMs#S#W%Q#W#XJT#X#YJq#Y#ZJT#Z;'S%Q;'S;=`&s<%lO%QTJ[V&WS`POY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QTJv]&WSOY%QYZ%lZr%Qrs%qs{%Q{|Ko|}%Q}!OKo!O!Q%Q!Q![La![;'S%Q;'S;=`&s<%lO%QTKtX&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![La![;'S%Q;'S;=`&s<%lO%QTLhc&WS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![La![!f%Q!f!gJT!g!h%Q!h!iJT!i#R%Q#R#SKo#S#W%Q#W#XJT#X#Y%Q#Y#ZJT#Z;'S%Q;'S;=`&s<%lO%QTMxX&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hq![;'S%Q;'S;=`&s<%lO%Q_Nl]&WS#fQOY%QYZ%lZr%Qrs%qsz%Qz{! e{!P%Q!P!Q!(W!Q!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%Q_! jX&WSOY! eYZ!!VZr! ers!#rsz! ez{!%Q{;'S! e;'S;=`!&f<%lO! e_!![T&WSOz!!kz{!!}{;'S!!k;'S;=`!#l<%lO!!kZ!!nTOz!!kz{!!}{;'S!!k;'S;=`!#l<%lO!!kZ!#QVOz!!kz{!!}{!P!!k!P!Q!#g!Q;'S!!k;'S;=`!#l<%lO!!kZ!#lOQZZ!#oP;=`<%l!!k_!#uXOY!$bYZ!!VZr!$brs!&lsz!$bz{!'[{;'S!$b;'S;=`!(Q<%lO!$b_!$eXOY! eYZ!!VZr! ers!#rsz! ez{!%Q{;'S! e;'S;=`!&f<%lO! e_!%VZ&WSOY! eYZ!!VZr! ers!#rsz! ez{!%Q{!P! e!P!Q!%x!Q;'S! e;'S;=`!&f<%lO! e_!&PV&WSQZOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!&iP;=`<%l! e_!&oXOY!$bYZ!!VZr!$brs!!ksz!$bz{!'[{;'S!$b;'S;=`!(Q<%lO!$b_!'_ZOY! eYZ!!VZr! ers!#rsz! ez{!%Q{!P! e!P!Q!%x!Q;'S! e;'S;=`!&f<%lO! e_!(TP;=`<%l!$b_!(_V&WSPZOY!(WYZ%lZr!(Wrs!(ts;'S!(W;'S;=`!)z<%lO!(W_!(yVPZOY!)`YZ%lZr!)`rs!*Qs;'S!)`;'S;=`!+T<%lO!)`_!)eVPZOY!(WYZ%lZr!(Wrs!(ts;'S!(W;'S;=`!)z<%lO!(W_!)}P;=`<%l!(W_!*VVPZOY!)`YZ%lZr!)`rs!*ls;'S!)`;'S;=`!+T<%lO!)`Z!*qSPZOY!*lZ;'S!*l;'S;=`!*}<%lO!*lZ!+QP;=`<%l!*l_!+WP;=`<%l!)`T!+bu&WS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!-u!P!Q%Q!Q![!/R![!d%Q!d!e!2V!e!f%Q!f!gJT!g!hJq!h!iJT!i!n%Q!n!o!0w!o!q%Q!q!r!4T!r!z%Q!z!{!5{!{#R%Q#R#S!1e#S#U%Q#U#V!2V#V#W%Q#W#XJT#X#YJq#Y#ZJT#Z#`%Q#`#a!0w#a#c%Q#c#d!4T#d#l%Q#l#m!5{#m;'S%Q;'S;=`&s<%lO%QT!-|a&WS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hq![!f%Q!f!gJT!g!hJq!h!iJT!i#W%Q#W#XJT#X#YJq#Y#ZJT#Z;'S%Q;'S;=`&s<%lO%QT!/Yi&WS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!-u!P!Q%Q!Q![!/R![!f%Q!f!gJT!g!hJq!h!iJT!i!n%Q!n!o!0w!o#R%Q#R#S!1e#S#W%Q#W#XJT#X#YJq#Y#ZJT#Z#`%Q#`#a!0w#a;'S%Q;'S;=`&s<%lO%QT!1OV&WS_POY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT!1jX&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!/R![;'S%Q;'S;=`&s<%lO%QT!2[Y&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q!R!2z!R!S!2z!S;'S%Q;'S;=`&s<%lO%QT!3R`&WS_POY%QYZ%lZr%Qrs%qs!Q%Q!Q!R!2z!R!S!2z!S!n%Q!n!o!0w!o#R%Q#R#S!2V#S#`%Q#`#a!0w#a;'S%Q;'S;=`&s<%lO%QT!4YX&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q!Y!4u!Y;'S%Q;'S;=`&s<%lO%QT!4|_&WS_POY%QYZ%lZr%Qrs%qs!Q%Q!Q!Y!4u!Y!n%Q!n!o!0w!o#R%Q#R#S!4T#S#`%Q#`#a!0w#a;'S%Q;'S;=`&s<%lO%QT!6Q_&WSOY%QYZ%lZr%Qrs%qs!O%Q!O!P!7P!P!Q%Q!Q![!9_![!c%Q!c!i!9_!i#T%Q#T#Z!9_#Z;'S%Q;'S;=`&s<%lO%QT!7U]&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!7}![!c%Q!c!i!7}!i#T%Q#T#Z!7}#Z;'S%Q;'S;=`&s<%lO%QT!8Sc&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!7}![!c%Q!c!i!7}!i!r%Q!r!sJq!s#R%Q#R#S!7P#S#T%Q#T#Z!7}#Z#d%Q#d#eJq#e;'S%Q;'S;=`&s<%lO%QT!9fi&WS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!;T!P!Q%Q!Q![!9_![!c%Q!c!i!9_!i!n%Q!n!o!0w!o!r%Q!r!sJq!s#R%Q#R#S!<_#S#T%Q#T#Z!9_#Z#`%Q#`#a!0w#a#d%Q#d#eJq#e;'S%Q;'S;=`&s<%lO%QT!;Ya&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!7}![!c%Q!c!i!7}!i!r%Q!r!sJq!s#T%Q#T#Z!7}#Z#d%Q#d#eJq#e;'S%Q;'S;=`&s<%lO%QT!<d]&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!9_![!c%Q!c!i!9_!i#T%Q#T#Z!9_#Z;'S%Q;'S;=`&s<%lO%QV!=dX#oR&WSOY%QYZ%lZr%Qrs%qs![%Q![!]!>P!];'S%Q;'S;=`&s<%lO%QV!>WV&tR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV!>tV!PR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!?bY&]Z&WSOY%QYZ%lZr%Qrs%qs!^%Q!^!_!@Q!_!`+p!`;'S%Q;'S;=`&s<%lO%QU!@XX#hQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QV!@{X!bR&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`;'S%Q;'S;=`&s<%lO%QV!AoY&[R&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`!a!B_!a;'S%Q;'S;=`&s<%lO%QU!BfY#hQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`!a!@Q!a;'S%Q;'S;=`&s<%lO%Q_!C_V&`X#nQ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!C{X%{Z&WSOY%QYZ%lZr%Qrs%qs#]%Q#]#^!Dh#^;'S%Q;'S;=`&s<%lO%QV!DmX&WSOY%QYZ%lZr%Qrs%qs#b%Q#b#c!EY#c;'S%Q;'S;=`&s<%lO%QV!E_X&WSOY%QYZ%lZr%Qrs%qs#h%Q#h#i!Ez#i;'S%Q;'S;=`&s<%lO%QV!FPX&WSOY%QYZ%lZr%Qrs%qs#X%Q#X#Y!Fl#Y;'S%Q;'S;=`&s<%lO%QV!FqX&WSOY%QYZ%lZr%Qrs%qs#f%Q#f#g!G^#g;'S%Q;'S;=`&s<%lO%QV!GcX&WSOY%QYZ%lZr%Qrs%qs#Y%Q#Y#Z!HO#Z;'S%Q;'S;=`&s<%lO%QV!HTX&WSOY%QYZ%lZr%Qrs%qs#T%Q#T#U!Hp#U;'S%Q;'S;=`&s<%lO%QV!HuX&WSOY%QYZ%lZr%Qrs%qs#V%Q#V#W!Ib#W;'S%Q;'S;=`&s<%lO%QV!IgX&WSOY%QYZ%lZr%Qrs%qs#X%Q#X#Y!JS#Y;'S%Q;'S;=`&s<%lO%QV!JZV&rR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!Jwa&PZ&WSOY%QYZ%lZr%Qrs%qst%Qtu!Jpu!Q%Q!Q![!Jp![!c%Q!c!}!Jp!}#R%Q#R#S!Jp#S#T%Q#T#o!Jp#o;'S%Q;'S;=`&s<%lO%Q_!LTVuZ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV!LqVsR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QU!M_X#cQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QV!NRV}R&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!NqZ&|X#cQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`#p%Q#p#q# d#q;'S%Q;'S;=`&s<%lO%QU# kV#dQ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV#!XV|R&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT#!uV#tP&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q",
  tokenizers: [0, 1, 2, 3],
  topRules: { Program: [0, 3] },
  dynamicPrecedences: { 27: 1, 230: -1, 241: -1 },
  specialized: [{ term: 229, get: (O) => tZ[O] || -1 }],
  tokenPrec: 7067
});
var iZ = Ze.define({
  name: "java",
  parser: OZ.configure({
    props: [
      Ce.add({
        IfStatement: $e({ except: /^\s*({|else\b)/ }),
        TryStatement: $e({ except: /^\s*({|catch|finally)\b/ }),
        LabeledStatement: Wl,
        SwitchBlock: (O) => {
          let e = O.textAfter, t = /^\s*\}/.test(e), i = /^\s*(case|default)\b/.test(e);
          return O.baseIndent + (t ? 0 : i ? 1 : 2) * O.unit;
        },
        Block: Ft({ closing: "}" }),
        BlockComment: () => null,
        Statement: $e({ except: /^{/ })
      }),
      Ge.add({
        ["Block SwitchBlock ClassBody ElementValueArrayInitializer ModuleBody EnumBody ConstructorBody InterfaceBody ArrayInitializer"]: _t,
        BlockComment(O) {
          return { from: O.from + 2, to: O.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\})$/
  }
});
function nZ() {
  return new je(iZ);
}
var Da = 1;
var rZ = 2;
var sZ = 3;
var oZ = 4;
var aZ = 5;
var lZ = 35;
var cZ = 36;
var hZ = 37;
var uZ = 11;
var fZ = 13;
function dZ(O) {
  return O == 45 || O == 46 || O == 58 || O >= 65 && O <= 90 || O == 95 || O >= 97 && O <= 122 || O >= 161;
}
function QZ(O) {
  return O == 9 || O == 10 || O == 13 || O == 32;
}
var Yf = null;
var Zf = null;
var qf = 0;
function Ma(O, e) {
  let t = O.pos + e;
  if (Zf == O && qf == t)
    return Yf;
  for (; QZ(O.peek(e)); )
    e++;
  let i = "";
  for (; ; ) {
    let n = O.peek(e);
    if (!dZ(n))
      break;
    i += String.fromCharCode(n), e++;
  }
  return Zf = O, qf = t, Yf = i || null;
}
function zf(O, e) {
  this.name = O, this.parent = e, this.hash = e ? e.hash : 0;
  for (let t = 0; t < O.length; t++)
    this.hash += (this.hash << 4) + O.charCodeAt(t) + (O.charCodeAt(t) << 8);
}
var $Z = new Ss({
  start: null,
  shift(O, e, t, i) {
    return e == Da ? new zf(Ma(i, 1) || "", O) : O;
  },
  reduce(O, e) {
    return e == uZ && O ? O.parent : O;
  },
  reuse(O, e, t, i) {
    let n = e.type.id;
    return n == Da || n == fZ ? new zf(Ma(i, 1) || "", O) : O;
  },
  hash(O) {
    return O ? O.hash : 0;
  },
  strict: false
});
var pZ = new te((O, e) => {
  if (O.next == 60) {
    if (O.advance(), O.next == 47) {
      O.advance();
      let t = Ma(O, 0);
      if (!t)
        return O.acceptToken(aZ);
      if (e.context && t == e.context.name)
        return O.acceptToken(rZ);
      for (let i = e.context; i; i = i.parent)
        if (i.name == t)
          return O.acceptToken(sZ, -2);
      O.acceptToken(oZ);
    } else if (O.next != 33 && O.next != 63)
      return O.acceptToken(Da);
  }
}, { contextual: true });
function oc(O, e) {
  return new te((t) => {
    for (let i = 0, n = 0; ; n++) {
      if (t.next < 0) {
        n && t.acceptToken(O);
        break;
      }
      if (t.next == e.charCodeAt(i)) {
        if (i++, i == e.length) {
          n >= e.length && t.acceptToken(O, 1 - e.length);
          break;
        }
      } else
        i = t.next == e.charCodeAt(0) ? 1 : 0;
      t.advance();
    }
  });
}
var mZ = oc(lZ, "-->");
var gZ = oc(cZ, "?>");
var SZ = oc(hZ, "]]>");
var PZ = ze({
  Text: c.content,
  "StartTag StartCloseTag EndTag SelfCloseEndTag": c.angleBracket,
  TagName: c.tagName,
  "MismatchedCloseTag/Tagname": [c.tagName, c.invalid],
  AttributeName: c.attributeName,
  AttributeValue: c.attributeValue,
  Is: c.definitionOperator,
  "EntityReference CharacterReference": c.character,
  Comment: c.blockComment,
  ProcessingInst: c.processingInstruction,
  DoctypeDecl: c.documentMeta,
  Cdata: c.special(c.string)
});
var yZ = qe.deserialize({
  version: 14,
  states: ",SOQOaOOOrOxO'#CfOzOpO'#CiO!tOaO'#CgOOOP'#Cg'#CgO!{OrO'#CrO#TOtO'#CsO#]OpO'#CtOOOP'#DS'#DSOOOP'#Cv'#CvQQOaOOOOOW'#Cw'#CwO#eOxO,59QOOOP,59Q,59QOOOO'#Cx'#CxO#mOpO,59TO#uO!bO,59TOOOP'#C{'#C{O$TOaO,59RO$[OpO'#CoOOOP,59R,59ROOOQ'#C|'#C|O$dOrO,59^OOOP,59^,59^OOOS'#C}'#C}O$lOtO,59_OOOP,59_,59_O$tOpO,59`O$|OpO,59`OOOP-E6t-E6tOOOW-E6u-E6uOOOP1G.l1G.lOOOO-E6v-E6vO%UO!bO1G.oO%UO!bO1G.oO%dOpO'#CkO%lO!bO'#CyO%zO!bO1G.oOOOP1G.o1G.oOOOP1G.w1G.wOOOP-E6y-E6yOOOP1G.m1G.mO&VOpO,59ZO&_OpO,59ZOOOQ-E6z-E6zOOOP1G.x1G.xOOOS-E6{-E6{OOOP1G.y1G.yO&gOpO1G.zO&gOpO1G.zOOOP1G.z1G.zO&oO!bO7+$ZO&}O!bO7+$ZOOOP7+$Z7+$ZOOOP7+$c7+$cO'YOpO,59VO'bOpO,59VO'jO!bO,59eOOOO-E6w-E6wO'xOpO1G.uO'xOpO1G.uOOOP1G.u1G.uO(QOpO7+$fOOOP7+$f7+$fO(YO!bO<<GuOOOP<<Gu<<GuOOOP<<G}<<G}O'bOpO1G.qO'bOpO1G.qO(eO#tO'#CnOOOO1G.q1G.qO(sOpO7+$aOOOP7+$a7+$aOOOP<<HQ<<HQOOOPAN=aAN=aOOOPAN=iAN=iO'bOpO7+$]OOOO7+$]7+$]OOOO'#Cz'#CzO({O#tO,59YOOOO,59Y,59YOOOP<<G{<<G{OOOO<<Gw<<GwOOOO-E6x-E6xOOOO1G.t1G.t",
  stateData: ")Z~OPQOSVOTWOVWOWWOXWOiXOxPO}TO!PUO~OuZOw]O~O^`Oy^O~OPQOQcOSVOTWOVWOWWOXWOxPO}TO!PUO~ORdO~P!SOseO|gO~OthO!OjO~O^lOy^O~OuZOwoO~O^qOy^O~O[vO`sOdwOy^O~ORyO~P!SO^{Oy^O~OseO|}O~OthO!O!PO~O^!QOy^O~O[!SOy^O~O[!VO`sOd!WOy^O~Oa!YOy^O~Oy^O[mX`mXdmX~O[!VO`sOd!WO~O^!]Oy^O~O[!_Oy^O~O[!aOy^O~O[!cO`sOd!dOy^O~O[!cO`sOd!dO~Oa!eOy^O~Oy^Oz!gO~Oy^O[ma`madma~O[!jOy^O~O[!kOy^O~O[!lO`sOd!mO~OW!pOX!pOz!rO{!pO~O[!sOy^O~OW!pOX!pOz!vO{!pO~O",
  goto: "%[wPPPPPPPPPPxxP!OP!UPP!_!iP!oxxxP!u!{#R$Z$j$p$v$|PPPP%SXWORYbXRORYb_t`qru!T!U!bQ!h!YS!o!e!fR!t!nQdRRybXSORYbQYORmYQ[PRn[Q_QQkVjp_krz!R!T!X!Z!^!`!f!i!nQr`QzcQ!RlQ!TqQ!XsQ!ZtQ!^{Q!`!QQ!f!YQ!i!]R!n!eQu`S!UqrU![u!U!bR!b!TQ!q!gR!u!qQbRRxbQfTR|fQiUR!OiSXOYTaRb",
  nodeNames: "⚠ StartTag StartCloseTag MissingCloseTag StartCloseTag StartCloseTag Document Text EntityReference CharacterReference Cdata Element EndTag OpenTag TagName Attribute AttributeName Is AttributeValue CloseTag SelfCloseEndTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag DoctypeDecl",
  maxTerm: 47,
  context: $Z,
  nodeProps: [
    ["closedBy", 1, "SelfCloseEndTag EndTag", 13, "CloseTag MissingCloseTag"],
    ["openedBy", 12, "StartTag StartCloseTag", 19, "OpenTag", 20, "StartTag"]
  ],
  propSources: [PZ],
  skippedNodes: [0],
  repeatNodeCount: 8,
  tokenData: "IX~R!XOX$nXY&kYZ&kZ]$n]^&k^p$npq&kqr$nrs'ssv$nvw(Zw}$n}!O*l!O!P$n!P!Q,{!Q![$n![!].e!]!^$n!^!_1v!_!`Cz!`!aDm!a!bE`!b!c$n!c!}.e!}#P$n#P#QFx#Q#R$n#R#S.e#S#T$n#T#o.e#o%W$n%W%o.e%o%p$n%p&a.e&a&b$n&b1p.e1p4U$n4U4d.e4d4e$n4e$IS.e$IS$I`$n$I`$Ib.e$Ib$Kh$n$Kh%#t.e%#t&/x$n&/x&Et.e&Et&FV$n&FV;'S.e;'S;:j1p;:j;=`&e<%l?&r$n?&r?Ah.e?Ah?BY$n?BY?Mn.e?MnO$nX$uWVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nP%dTVPOv%_w!^%_!_;'S%_;'S;=`%s<%lO%_P%vP;=`<%l%_W&OT{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yW&bP;=`<%l%yX&hP;=`<%l$n_&t_VP{WyUOX$nXY&kYZ&kZ]$n]^&k^p$npq&kqr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZ'zTzYVPOv%_w!^%_!_;'S%_;'S;=`%s<%lO%_~(^VOp(sqs(sst)ht!](s!^;'S(s;'S;=`)b<%lO(s~(vVOp(sqs(st!](s!]!^)]!^;'S(s;'S;=`)b<%lO(s~)bOW~~)eP;=`<%l(s~)kTOp)zq!])z!^;'S)z;'S;=`*f<%lO)z~)}UOp)zq!])z!]!^*a!^;'S)z;'S;=`*f<%lO)z~*fOX~~*iP;=`<%l)zZ*sYVP{WOr$nrs%_sv$nw}$n}!O+c!O!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZ+jYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!a,Y!a;'S$n;'S;=`&e<%lO$nZ,cW|QVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n]-SYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!a-r!a;'S$n;'S;=`&e<%lO$n]-{WdSVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n_.p!O`S^QVP{WOr$nrs%_sv$nw}$n}!O.e!O!P.e!P!Q$n!Q![.e![!].e!]!^$n!^!_%y!_!c$n!c!}.e!}#R$n#R#S.e#S#T$n#T#o.e#o$}$n$}%O.e%O%W$n%W%o.e%o%p$n%p&a.e&a&b$n&b1p.e1p4U.e4U4d.e4d4e$n4e$IS.e$IS$I`$n$I`$Ib.e$Ib$Je$n$Je$Jg.e$Jg$Kh$n$Kh%#t.e%#t&/x$n&/x&Et.e&Et&FV$n&FV;'S.e;'S;:j1p;:j;=`&e<%l?&r$n?&r?Ah.e?Ah?BY$n?BY?Mn.e?MnO$n_1sP;=`<%l.eX1{W{WOq%yqr2esv%yw!a%y!a!bCd!b;'S%y;'S;=`&_<%lO%yX2j]{WOr%ysv%yw}%y}!O3c!O!f%y!f!g4e!g!}%y!}#O9t#O#W%y#W#X@Q#X;'S%y;'S;=`&_<%lO%yX3hV{WOr%ysv%yw}%y}!O3}!O;'S%y;'S;=`&_<%lO%yX4UT}P{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yX4jV{WOr%ysv%yw!q%y!q!r5P!r;'S%y;'S;=`&_<%lO%yX5UV{WOr%ysv%yw!e%y!e!f5k!f;'S%y;'S;=`&_<%lO%yX5pV{WOr%ysv%yw!v%y!v!w6V!w;'S%y;'S;=`&_<%lO%yX6[V{WOr%ysv%yw!{%y!{!|6q!|;'S%y;'S;=`&_<%lO%yX6vV{WOr%ysv%yw!r%y!r!s7]!s;'S%y;'S;=`&_<%lO%yX7bV{WOr%ysv%yw!g%y!g!h7w!h;'S%y;'S;=`&_<%lO%yX7|X{WOr7wrs8isv7wvw8iw!`7w!`!a9W!a;'S7w;'S;=`9n<%lO7wP8lTO!`8i!`!a8{!a;'S8i;'S;=`9Q<%lO8iP9QOiPP9TP;=`<%l8iX9_TiP{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yX9qP;=`<%l7wX9yX{WOr%ysv%yw!e%y!e!f:f!f#V%y#V#W=t#W;'S%y;'S;=`&_<%lO%yX:kV{WOr%ysv%yw!f%y!f!g;Q!g;'S%y;'S;=`&_<%lO%yX;VV{WOr%ysv%yw!c%y!c!d;l!d;'S%y;'S;=`&_<%lO%yX;qV{WOr%ysv%yw!v%y!v!w<W!w;'S%y;'S;=`&_<%lO%yX<]V{WOr%ysv%yw!c%y!c!d<r!d;'S%y;'S;=`&_<%lO%yX<wV{WOr%ysv%yw!}%y!}#O=^#O;'S%y;'S;=`&_<%lO%yX=eT{WxPOr%ysv%yw;'S%y;'S;=`&_<%lO%yX=yV{WOr%ysv%yw#W%y#W#X>`#X;'S%y;'S;=`&_<%lO%yX>eV{WOr%ysv%yw#T%y#T#U>z#U;'S%y;'S;=`&_<%lO%yX?PV{WOr%ysv%yw#h%y#h#i?f#i;'S%y;'S;=`&_<%lO%yX?kV{WOr%ysv%yw#T%y#T#U<r#U;'S%y;'S;=`&_<%lO%yX@VV{WOr%ysv%yw#c%y#c#d@l#d;'S%y;'S;=`&_<%lO%yX@qV{WOr%ysv%yw#V%y#V#WAW#W;'S%y;'S;=`&_<%lO%yXA]V{WOr%ysv%yw#h%y#h#iAr#i;'S%y;'S;=`&_<%lO%yXAwV{WOr%ysv%yw#m%y#m#nB^#n;'S%y;'S;=`&_<%lO%yXBcV{WOr%ysv%yw#d%y#d#eBx#e;'S%y;'S;=`&_<%lO%yXB}V{WOr%ysv%yw#X%y#X#Y7w#Y;'S%y;'S;=`&_<%lO%yXCkT!PP{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yZDTWaQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n_DvW[UVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZEgYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!aFV!a;'S$n;'S;=`&e<%lO$nZF`W!OQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZGPYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_#P$n#P#QGo#Q;'S$n;'S;=`&e<%lO$nZGvYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!aHf!a;'S$n;'S;=`&e<%lO$nZHoWwQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n",
  tokenizers: [pZ, mZ, gZ, SZ, 0, 1, 2, 3],
  topRules: { Document: [0, 6] },
  tokenPrec: 0
});
function dr(O, e) {
  let t = e && e.getChild("TagName");
  return t ? O.sliceString(t.from, t.to) : "";
}
function Po(O, e) {
  let t = e && e.firstChild;
  return !t || t.name != "OpenTag" ? "" : dr(O, t);
}
function XZ(O, e, t) {
  let i = e && e.getChildren("Attribute").find((r) => r.from <= t && r.to >= t), n = i && i.getChild("AttributeName");
  return n ? O.sliceString(n.from, n.to) : "";
}
function yo(O) {
  for (let e = O && O.parent; e; e = e.parent)
    if (e.name == "Element")
      return e;
  return null;
}
function xZ(O, e) {
  var t;
  let i = B(O).resolveInner(e, -1), n = null;
  for (let r = i; !n && r.parent; r = r.parent)
    (r.name == "OpenTag" || r.name == "CloseTag" || r.name == "SelfClosingTag" || r.name == "MismatchedCloseTag") && (n = r);
  if (n && (n.to > e || n.lastChild.type.isError)) {
    let r = n.parent;
    if (i.name == "TagName")
      return n.name == "CloseTag" || n.name == "MismatchedCloseTag" ? { type: "closeTag", from: i.from, context: r } : { type: "openTag", from: i.from, context: yo(r) };
    if (i.name == "AttributeName")
      return { type: "attrName", from: i.from, context: n };
    if (i.name == "AttributeValue")
      return { type: "attrValue", from: i.from, context: n };
    let s = i == n || i.name == "Attribute" ? i.childBefore(e) : i;
    return (s == null ? void 0 : s.name) == "StartTag" ? { type: "openTag", from: e, context: yo(r) } : (s == null ? void 0 : s.name) == "StartCloseTag" && s.to <= e ? { type: "closeTag", from: e, context: r } : (s == null ? void 0 : s.name) == "Is" ? { type: "attrValue", from: e, context: n } : s ? { type: "attrName", from: e, context: n } : null;
  } else if (i.name == "StartCloseTag")
    return { type: "closeTag", from: e, context: i.parent };
  for (; i.parent && i.to == e && !(!((t = i.lastChild) === null || t === void 0) && t.type.isError); )
    i = i.parent;
  return i.name == "Element" || i.name == "Text" || i.name == "Document" ? { type: "tag", from: e, context: i.name == "Element" ? i : yo(i) } : null;
}
var bZ = class {
  constructor(e, t, i) {
    this.attrs = t, this.attrValues = i, this.children = [], this.name = e.name, this.completion = Object.assign(Object.assign({ type: "type" }, e.completion || {}), { label: this.name }), this.openCompletion = Object.assign(Object.assign({}, this.completion), { label: "<" + this.name }), this.closeCompletion = Object.assign(Object.assign({}, this.completion), { label: "</" + this.name + ">", boost: 2 }), this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), { label: this.name + ">" }), this.text = e.textContent ? e.textContent.map((n) => ({ label: n, type: "text" })) : [];
  }
};
var Xo = /^[:\-\.\w\u00b7-\uffff]*$/;
function Uf(O) {
  return Object.assign(Object.assign({ type: "property" }, O.completion || {}), { label: O.name });
}
function Vf(O) {
  return typeof O == "string" ? { label: `"${O}"`, type: "constant" } : /^"/.test(O.label) ? O : Object.assign(Object.assign({}, O), { label: `"${O.label}"` });
}
function wZ(O, e) {
  let t = [], i = [], n = /* @__PURE__ */ Object.create(null);
  for (let a of e) {
    let l = Uf(a);
    t.push(l), a.global && i.push(l), a.values && (n[a.name] = a.values.map(Vf));
  }
  let r = [], s = [], o = /* @__PURE__ */ Object.create(null);
  for (let a of O) {
    let l = i, h2 = n;
    a.attributes && (l = l.concat(a.attributes.map((f) => typeof f == "string" ? t.find((d) => d.label == f) || { label: f, type: "property" } : (f.values && (h2 == n && (h2 = Object.create(h2)), h2[f.name] = f.values.map(Vf)), Uf(f)))));
    let u = new bZ(a, l, h2);
    o[u.name] = u, r.push(u), a.top && s.push(u);
  }
  s.length || (s = r);
  for (let a = 0; a < r.length; a++) {
    let l = O[a], h2 = r[a];
    if (l.children)
      for (let u of l.children)
        o[u] && h2.children.push(o[u]);
    else
      h2.children = r;
  }
  return (a) => {
    var l;
    let { doc: h2 } = a.state, u = xZ(a.state, a.pos);
    if (!u || u.type == "tag" && !a.explicit)
      return null;
    let { type: f, from: d, context: Q } = u;
    if (f == "openTag") {
      let $ = s, p = Po(h2, Q);
      if (p) {
        let m = o[p];
        $ = (m == null ? void 0 : m.children) || r;
      }
      return {
        from: d,
        options: $.map((m) => m.completion),
        validFor: Xo
      };
    } else if (f == "closeTag") {
      let $ = Po(h2, Q);
      return $ ? {
        from: d,
        to: a.pos + (h2.sliceString(a.pos, a.pos + 1) == ">" ? 1 : 0),
        options: [((l = o[$]) === null || l === void 0 ? void 0 : l.closeNameCompletion) || { label: $ + ">", type: "type" }],
        validFor: Xo
      } : null;
    } else if (f == "attrName") {
      let $ = o[dr(h2, Q)];
      return {
        from: d,
        options: ($ == null ? void 0 : $.attrs) || i,
        validFor: Xo
      };
    } else if (f == "attrValue") {
      let $ = XZ(h2, Q, d);
      if (!$)
        return null;
      let p = o[dr(h2, Q)], m = ((p == null ? void 0 : p.attrValues) || n)[$];
      return !m || !m.length ? null : {
        from: d,
        to: a.pos + (h2.sliceString(a.pos, a.pos + 1) == '"' ? 1 : 0),
        options: m,
        validFor: /^"[^"]*"?$/
      };
    } else if (f == "tag") {
      let $ = Po(h2, Q), p = o[$], m = [], g = Q && Q.lastChild;
      $ && (!g || g.name != "CloseTag" || dr(h2, g) != $) && m.push(p ? p.closeCompletion : { label: "</" + $ + ">", type: "type", boost: 2 });
      let b = m.concat(((p == null ? void 0 : p.children) || (Q ? r : s)).map((y) => y.openCompletion));
      if (Q && (p != null && p.text.length)) {
        let y = Q.firstChild;
        y.to > a.pos - 20 && !/\S/.test(a.state.sliceDoc(y.to, a.pos)) && (b = b.concat(p.text));
      }
      return {
        from: d,
        options: b,
        validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/
      };
    } else
      return null;
  };
}
var Rf = Ze.define({
  name: "xml",
  parser: yZ.configure({
    props: [
      Ce.add({
        Element(O) {
          let e = /^\s*<\//.test(O.textAfter);
          return O.lineIndent(O.node.from) + (e ? 0 : O.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(O) {
          return O.column(O.node.from) + O.unit;
        }
      }),
      Ge.add({
        Element(O) {
          let e = O.firstChild, t = O.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: t.name == "CloseTag" ? t.from : O.to };
        }
      }),
      kl.add({
        "OpenTag CloseTag": (O) => O.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/$/
  }
});
function TZ(O = {}) {
  return new je(Rf, Rf.data.of({
    autocomplete: wZ(O.elements || [], O.attributes || [])
  }));
}
var WZ = ze({
  String: c.string,
  Number: c.number,
  "True False": c.bool,
  PropertyName: c.propertyName,
  Null: c.null,
  ",": c.separator,
  "[ ]": c.squareBracket,
  "{ }": c.brace
});
var vZ = qe.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
  stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
  goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "⚠ JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["openedBy", 7, "{", 12, "["],
    ["closedBy", 8, "}", 13, "]"]
  ],
  propSources: [WZ],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(p~RaXY!WYZ!W]^!Wpq!Wrs!]|}$i}!O$n!Q!R$w!R![&V![!]&h!}#O&m#P#Q&r#Y#Z&w#b#c'f#h#i'}#o#p(f#q#r(k~!]Oc~~!`Upq!]qr!]rs!rs#O!]#O#P!w#P~!]~!wOe~~!zXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#g~#jR!Q![#s!c!i#s#T#Z#s~#vR!Q![$P!c!i$P#T#Z$P~$SR!Q![$]!c!i$]#T#Z$]~$`R!Q![!]!c!i!]#T#Z!]~$nOh~~$qQ!Q!R$w!R![&V~$|RT~!O!P%V!g!h%k#X#Y%k~%YP!Q![%]~%bRT~!Q![%]!g!h%k#X#Y%k~%nR{|%w}!O%w!Q![%}~%zP!Q![%}~&SPT~!Q![%}~&[ST~!O!P%V!Q![&V!g!h%k#X#Y%k~&mOg~~&rO]~~&wO[~~&zP#T#U&}~'QP#`#a'T~'WP#g#h'Z~'^P#X#Y'a~'fOR~~'iP#i#j'l~'oP#`#a'r~'uP#`#a'x~'}OS~~(QP#f#g(T~(WP#i#j(Z~(^P#X#Y(a~(fOQ~~(kOW~~(pOV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
});
var kZ = Ze.define({
  name: "json",
  parser: vZ.configure({
    props: [
      Ce.add({
        Object: $e({ except: /^\s*\}/ }),
        Array: $e({ except: /^\s*\]/ })
      }),
      Ge.add({
        "Object Array": _t
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function YZ() {
  return new je(kZ);
}
var ZZ = { __proto__: null, anyref: 34, dataref: 34, eqref: 34, externref: 34, i31ref: 34, funcref: 34, i8: 34, i16: 34, i32: 34, i64: 34, f32: 34, f64: 34 };
var qZ = qe.deserialize({
  version: 14,
  states: "!^Q]QPOOOqQPO'#CbOOQO'#Cd'#CdOOQO'#Cl'#ClOOQO'#Ch'#ChQ]QPOOOOQO,58|,58|OxQPO,58|OOQO-E6f-E6fOOQO1G.h1G.h",
  stateData: "!P~O_OSPOSQOS~OTPOVROXROYROZROaQO~OSUO~P]OSXO~P]O",
  goto: "xaPPPPPPbPbPPPhPPPrXROPTVQTOQVPTWTVXSOPTV",
  nodeNames: "⚠ LineComment BlockComment Module ) ( App Identifier Type Keyword Number String",
  maxTerm: 17,
  nodeProps: [
    ["openedBy", 4, "("],
    ["closedBy", 5, ")"],
    ["group", -6, 6, 7, 8, 9, 10, 11, "Expression"]
  ],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 1,
  tokenData: "/Q~R^XY}YZ}]^}pq}rs!Stu!qxy&Vyz'S{|'X}!O'X!Q!R'b!R![)_!]!^,{#T#o-^~!SO_~~!VTOr!Srs!fs#O!S#O#P!k#P~!S~!kOZ~~!nPO~!S~!tiqr$cst$ctu$cuv$cvw$cwx$cz{$c{|$c}!O$c!O!P$c!P!Q$c!Q![$c![!]$c!^!_$c!_!`$c!`!a$c!a!b$c!b!c$c!c!}$c#Q#R$c#R#S$c#S#T$c#T#o$c#p#q$c#r#s$c~$hiV~qr$cst$ctu$cuv$cvw$cwx$cz{$c{|$c}!O$c!O!P$c!P!Q$c!Q![$c![!]$c!^!_$c!_!`$c!`!a$c!a!b$c!b!c$c!c!}$c#Q#R$c#R#S$c#S#T$c#T#o$c#p#q$c#r#s$c~&[PT~!]!^&_~&bRO!]&_!]!^&k!^~&_~&nTOy&_yz&}z!]&_!]!^&k!^~&_~'SOQ~~'XOS~~'[Q!Q!R'b!R![)_~'gUY~!O!P'y!Q![)_!g!h(j#R#S)s#X#Y(j#l#m)y~(ORY~!Q![(X!g!h(j#X#Y(j~(^SY~!Q![(X!g!h(j#R#S)X#X#Y(j~(mR{|(v}!O(v!Q![(|~(yP!Q![(|~)RQY~!Q![(|#R#S(v~)[P!Q![(X~)dTY~!O!P'y!Q![)_!g!h(j#R#S)s#X#Y(j~)vP!Q![)_~)|R!Q![*V!c!i*V#T#Z*V~*[VY~!O!P*q!Q![*V!c!i*V!r!s+n#R#S)y#T#Z*V#d#e+n~*vTY~!Q![+V!c!i+V!r!s+n#T#Z+V#d#e+n~+[UY~!Q![+V!c!i+V!r!s+n#R#S,o#T#Z+V#d#e+n~+qT{|,Q}!O,Q!Q![,^!c!i,^#T#Z,^~,TR!Q![,^!c!i,^#T#Z,^~,cSY~!Q![,^!c!i,^#R#S,Q#T#Z,^~,rR!Q![+V!c!i+V#T#Z+V~-OP!]!^-R~-WQP~OY-RZ~-R~-ciX~qr-^st-^tu-^uv-^vw-^wx-^z{-^{|-^}!O-^!O!P-^!P!Q-^!Q![-^![!]-^!^!_-^!_!`-^!`!a-^!a!b-^!b!c-^!c!}-^#Q#R-^#R#S-^#S#T-^#T#o-^#p#q-^#r#s-^",
  tokenizers: [0],
  topRules: { Module: [0, 3] },
  specialized: [{ term: 9, get: (O) => ZZ[O] || -1 }],
  tokenPrec: 0
});
var zZ = Ze.define({
  name: "wast",
  parser: qZ.configure({
    props: [
      Ce.add({
        App: Ft({ closing: ")", align: false })
      }),
      Ge.add({
        App: _t,
        BlockComment(O) {
          return { from: O.from + 2, to: O.to - 2 };
        }
      }),
      ze({
        Keyword: c.keyword,
        Type: c.typeName,
        Number: c.number,
        String: c.string,
        Identifier: c.variableName,
        LineComment: c.lineComment,
        BlockComment: c.blockComment,
        "( )": c.paren
      })
    ]
  }),
  languageData: {
    commentTokens: { line: ";;", block: { open: "(;", close: ";)" } },
    closeBrackets: { brackets: ["(", '"'] }
  }
});
function UZ() {
  return new je(zZ);
}
function VZ(O) {
  return new RegExp("^(?:" + O.join("|") + ")", "i");
}
function xs(O) {
  return new RegExp("^(?:" + O.join("|") + ")$", "i");
}
var RZ = xs([
  "_G",
  "_VERSION",
  "assert",
  "collectgarbage",
  "dofile",
  "error",
  "getfenv",
  "getmetatable",
  "ipairs",
  "load",
  "loadfile",
  "loadstring",
  "module",
  "next",
  "pairs",
  "pcall",
  "print",
  "rawequal",
  "rawget",
  "rawset",
  "require",
  "select",
  "setfenv",
  "setmetatable",
  "tonumber",
  "tostring",
  "type",
  "unpack",
  "xpcall",
  "coroutine.create",
  "coroutine.resume",
  "coroutine.running",
  "coroutine.status",
  "coroutine.wrap",
  "coroutine.yield",
  "debug.debug",
  "debug.getfenv",
  "debug.gethook",
  "debug.getinfo",
  "debug.getlocal",
  "debug.getmetatable",
  "debug.getregistry",
  "debug.getupvalue",
  "debug.setfenv",
  "debug.sethook",
  "debug.setlocal",
  "debug.setmetatable",
  "debug.setupvalue",
  "debug.traceback",
  "close",
  "flush",
  "lines",
  "read",
  "seek",
  "setvbuf",
  "write",
  "io.close",
  "io.flush",
  "io.input",
  "io.lines",
  "io.open",
  "io.output",
  "io.popen",
  "io.read",
  "io.stderr",
  "io.stdin",
  "io.stdout",
  "io.tmpfile",
  "io.type",
  "io.write",
  "math.abs",
  "math.acos",
  "math.asin",
  "math.atan",
  "math.atan2",
  "math.ceil",
  "math.cos",
  "math.cosh",
  "math.deg",
  "math.exp",
  "math.floor",
  "math.fmod",
  "math.frexp",
  "math.huge",
  "math.ldexp",
  "math.log",
  "math.log10",
  "math.max",
  "math.min",
  "math.modf",
  "math.pi",
  "math.pow",
  "math.rad",
  "math.random",
  "math.randomseed",
  "math.sin",
  "math.sinh",
  "math.sqrt",
  "math.tan",
  "math.tanh",
  "os.clock",
  "os.date",
  "os.difftime",
  "os.execute",
  "os.exit",
  "os.getenv",
  "os.remove",
  "os.rename",
  "os.setlocale",
  "os.time",
  "os.tmpname",
  "package.cpath",
  "package.loaded",
  "package.loaders",
  "package.loadlib",
  "package.path",
  "package.preload",
  "package.seeall",
  "string.byte",
  "string.char",
  "string.dump",
  "string.find",
  "string.format",
  "string.gmatch",
  "string.gsub",
  "string.len",
  "string.lower",
  "string.match",
  "string.rep",
  "string.reverse",
  "string.sub",
  "string.upper",
  "table.concat",
  "table.insert",
  "table.maxn",
  "table.remove",
  "table.sort"
]);
var _Z = xs([
  "and",
  "break",
  "elseif",
  "false",
  "nil",
  "not",
  "or",
  "return",
  "true",
  "function",
  "end",
  "if",
  "then",
  "else",
  "do",
  "while",
  "repeat",
  "until",
  "for",
  "in",
  "local"
]);
var jZ = xs(["function", "if", "repeat", "do", "\\(", "{"]);
var CZ = xs(["end", "until", "\\)", "}"]);
var GZ = VZ(["end", "until", "\\)", "}", "else", "elseif"]);
function _f(O) {
  for (var e = 0; O.eat("="); )
    ++e;
  return O.eat("["), e;
}
function ac(O, e) {
  var t = O.next();
  return t == "-" && O.eat("-") ? O.eat("[") && O.eat("[") ? (e.cur = jf(_f(O), "comment"))(O, e) : (O.skipToEnd(), "comment") : t == '"' || t == "'" ? (e.cur = IZ(t))(O, e) : t == "[" && /[\[=]/.test(O.peek()) ? (e.cur = jf(_f(O), "string"))(O, e) : /\d/.test(t) ? (O.eatWhile(/[\w.%]/), "number") : /[\w_]/.test(t) ? (O.eatWhile(/[\w\\\-_.]/), "variable") : null;
}
function jf(O, e) {
  return function(t, i) {
    for (var n = null, r; (r = t.next()) != null; )
      if (n == null)
        r == "]" && (n = 0);
      else if (r == "=")
        ++n;
      else if (r == "]" && n == O) {
        i.cur = ac;
        break;
      } else
        n = null;
    return e;
  };
}
function IZ(O) {
  return function(e, t) {
    for (var i = false, n; (n = e.next()) != null && !(n == O && !i); )
      i = !i && n == "\\";
    return i || (t.cur = ac), "string";
  };
}
var EZ = {
  name: "lua",
  startState: function() {
    return { basecol: 0, indentDepth: 0, cur: ac };
  },
  token: function(O, e) {
    if (O.eatSpace())
      return null;
    var t = e.cur(O, e), i = O.current();
    return t == "variable" && (_Z.test(i) ? t = "keyword" : RZ.test(i) && (t = "builtin")), t != "comment" && t != "string" && (jZ.test(i) ? ++e.indentDepth : CZ.test(i) && --e.indentDepth), t;
  },
  indent: function(O, e, t) {
    var i = GZ.test(e);
    return O.basecol + t.unit * (O.indentDepth - (i ? 1 : 0));
  },
  languageData: {
    indentOnInput: /^\s*(?:end|until|else|\)|\})$/,
    commentTokens: { line: "--", block: { open: "--[[", close: "]]--" } }
  }
};
function lc(O) {
  for (var e = {}, t = 0, i = O.length; t < i; ++t)
    e[O[t]] = true;
  return e;
}
var Im = [
  "alias",
  "and",
  "BEGIN",
  "begin",
  "break",
  "case",
  "class",
  "def",
  "defined?",
  "do",
  "else",
  "elsif",
  "END",
  "end",
  "ensure",
  "false",
  "for",
  "if",
  "in",
  "module",
  "next",
  "not",
  "or",
  "redo",
  "rescue",
  "retry",
  "return",
  "self",
  "super",
  "then",
  "true",
  "undef",
  "unless",
  "until",
  "when",
  "while",
  "yield",
  "nil",
  "raise",
  "throw",
  "catch",
  "fail",
  "loop",
  "callcc",
  "caller",
  "lambda",
  "proc",
  "public",
  "protected",
  "private",
  "require",
  "load",
  "require_relative",
  "extend",
  "autoload",
  "__END__",
  "__FILE__",
  "__LINE__",
  "__dir__"
];
var AZ = lc(Im);
var DZ = lc([
  "def",
  "class",
  "case",
  "for",
  "while",
  "until",
  "module",
  "catch",
  "loop",
  "proc",
  "begin"
]);
var MZ = lc(["end", "until"]);
var Cf = { "[": "]", "{": "}", "(": ")" };
var LZ = { "]": "[", "}": "{", ")": "(" };
var st;
function ZO(O, e, t) {
  return t.tokenize.push(O), O(e, t);
}
function ts(O, e) {
  if (O.sol() && O.match("=begin") && O.eol())
    return e.tokenize.push(HZ), "comment";
  if (O.eatSpace())
    return null;
  var t = O.next(), i;
  if (t == "`" || t == "'" || t == '"')
    return ZO(gi(t, "string", t == '"' || t == "`"), O, e);
  if (t == "/")
    return BZ(O) ? ZO(gi(t, "string.special", true), O, e) : "operator";
  if (t == "%") {
    var n = "string", r = true;
    O.eat("s") ? n = "atom" : O.eat(/[WQ]/) ? n = "string" : O.eat(/[r]/) ? n = "string.special" : O.eat(/[wxq]/) && (n = "string", r = false);
    var s = O.eat(/[^\w\s=]/);
    return s ? (Cf.propertyIsEnumerable(s) && (s = Cf[s]), ZO(gi(s, n, r, true), O, e)) : "operator";
  } else {
    if (t == "#")
      return O.skipToEnd(), "comment";
    if (t == "<" && (i = O.match(/^<([-~])[\`\"\']?([a-zA-Z_?]\w*)[\`\"\']?(?:;|$)/)))
      return ZO(FZ(i[2], i[1]), O, e);
    if (t == "0")
      return O.eat("x") ? O.eatWhile(/[\da-fA-F]/) : O.eat("b") ? O.eatWhile(/[01]/) : O.eatWhile(/[0-7]/), "number";
    if (/\d/.test(t))
      return O.match(/^[\d_]*(?:\.[\d_]+)?(?:[eE][+\-]?[\d_]+)?/), "number";
    if (t == "?") {
      for (; O.match(/^\\[CM]-/); )
        ;
      return O.eat("\\") ? O.eatWhile(/\w/) : O.next(), "string";
    } else {
      if (t == ":")
        return O.eat("'") ? ZO(gi("'", "atom", false), O, e) : O.eat('"') ? ZO(gi('"', "atom", true), O, e) : O.eat(/[\<\>]/) ? (O.eat(/[\<\>]/), "atom") : O.eat(/[\+\-\*\/\&\|\:\!]/) ? "atom" : O.eat(/[a-zA-Z$@_\xa1-\uffff]/) ? (O.eatWhile(/[\w$\xa1-\uffff]/), O.eat(/[\?\!\=]/), "atom") : "operator";
      if (t == "@" && O.match(/^@?[a-zA-Z_\xa1-\uffff]/))
        return O.eat("@"), O.eatWhile(/[\w\xa1-\uffff]/), "propertyName";
      if (t == "$")
        return O.eat(/[a-zA-Z_]/) ? O.eatWhile(/[\w]/) : O.eat(/\d/) ? O.eat(/\d/) : O.next(), "variableName.special";
      if (/[a-zA-Z_\xa1-\uffff]/.test(t))
        return O.eatWhile(/[\w\xa1-\uffff]/), O.eat(/[\?\!]/), O.eat(":") ? "atom" : "variable";
      if (t == "|" && (e.varList || e.lastTok == "{" || e.lastTok == "do"))
        return st = "|", null;
      if (/[\(\)\[\]{}\\;]/.test(t))
        return st = t, null;
      if (t == "-" && O.eat(">"))
        return "operator";
      if (/[=+\-\/*:\.^%<>~|]/.test(t)) {
        var o = O.eatWhile(/[=+\-\/*:\.^%<>~|]/);
        return t == "." && !o && (st = "."), "operator";
      } else
        return null;
    }
  }
}
function BZ(O) {
  for (var e = O.pos, t = 0, i, n = false, r = false; (i = O.next()) != null; )
    if (r)
      r = false;
    else {
      if ("[{(".indexOf(i) > -1)
        t++;
      else if ("]})".indexOf(i) > -1) {
        if (t--, t < 0)
          break;
      } else if (i == "/" && t == 0) {
        n = true;
        break;
      }
      r = i == "\\";
    }
  return O.backUp(O.pos - e), n;
}
function La(O) {
  return O || (O = 1), function(e, t) {
    if (e.peek() == "}") {
      if (O == 1)
        return t.tokenize.pop(), t.tokenize[t.tokenize.length - 1](e, t);
      t.tokenize[t.tokenize.length - 1] = La(O - 1);
    } else
      e.peek() == "{" && (t.tokenize[t.tokenize.length - 1] = La(O + 1));
    return ts(e, t);
  };
}
function NZ() {
  var O = false;
  return function(e, t) {
    return O ? (t.tokenize.pop(), t.tokenize[t.tokenize.length - 1](e, t)) : (O = true, ts(e, t));
  };
}
function gi(O, e, t, i) {
  return function(n, r) {
    var s = false, o;
    for (r.context.type === "read-quoted-paused" && (r.context = r.context.prev, n.eat("}")); (o = n.next()) != null; ) {
      if (o == O && (i || !s)) {
        r.tokenize.pop();
        break;
      }
      if (t && o == "#" && !s) {
        if (n.eat("{")) {
          O == "}" && (r.context = { prev: r.context, type: "read-quoted-paused" }), r.tokenize.push(La());
          break;
        } else if (/[@\$]/.test(n.peek())) {
          r.tokenize.push(NZ());
          break;
        }
      }
      s = !s && o == "\\";
    }
    return e;
  };
}
function FZ(O, e) {
  return function(t, i) {
    return e && t.eatSpace(), t.match(O) ? i.tokenize.pop() : t.skipToEnd(), "string";
  };
}
function HZ(O, e) {
  return O.sol() && O.match("=end") && O.eol() && e.tokenize.pop(), O.skipToEnd(), "comment";
}
var KZ = {
  name: "ruby",
  startState: function(O) {
    return {
      tokenize: [ts],
      indented: 0,
      context: { type: "top", indented: -O },
      continuedLine: false,
      lastTok: null,
      varList: false
    };
  },
  token: function(O, e) {
    st = null, O.sol() && (e.indented = O.indentation());
    var t = e.tokenize[e.tokenize.length - 1](O, e), i, n = st;
    if (t == "variable") {
      var r = O.current();
      t = e.lastTok == "." ? "property" : AZ.propertyIsEnumerable(O.current()) ? "keyword" : /^[A-Z]/.test(r) ? "tag" : e.lastTok == "def" || e.lastTok == "class" || e.varList ? "def" : "variable", t == "keyword" && (n = r, DZ.propertyIsEnumerable(r) ? i = "indent" : MZ.propertyIsEnumerable(r) ? i = "dedent" : ((r == "if" || r == "unless") && O.column() == O.indentation() || r == "do" && e.context.indented < e.indented) && (i = "indent"));
    }
    return (st || t && t != "comment") && (e.lastTok = n), st == "|" && (e.varList = !e.varList), i == "indent" || /[\(\[\{]/.test(st) ? e.context = { prev: e.context, type: st || t, indented: e.indented } : (i == "dedent" || /[\)\]\}]/.test(st)) && e.context.prev && (e.context = e.context.prev), O.eol() && (e.continuedLine = st == "\\" || t == "operator"), t;
  },
  indent: function(O, e, t) {
    if (O.tokenize[O.tokenize.length - 1] != ts)
      return null;
    var i = e && e.charAt(0), n = O.context, r = n.type == LZ[i] || n.type == "keyword" && /^(?:end|until|else|elsif|when|rescue)\b/.test(e);
    return n.indented + (r ? 0 : t.unit) + (O.continuedLine ? t.unit : 0);
  },
  languageData: {
    indentOnInput: /^\s*(?:end|rescue|elsif|else|\})$/,
    commentTokens: { line: "#" },
    autocomplete: Im
  }
};
function cc(O, e, t, i, n, r) {
  this.indented = O, this.column = e, this.type = t, this.info = i, this.align = n, this.prev = r;
}
function Hn(O, e, t, i) {
  var n = O.indented;
  return O.context && O.context.type == "statement" && t != "statement" && (n = O.context.indented), O.context = new cc(n, e, t, i, null, O.context);
}
function Si(O) {
  var e = O.context.type;
  return (e == ")" || e == "]" || e == "}") && (O.indented = O.context.indented), O.context = O.context.prev;
}
function Gf(O, e, t) {
  if (e.prevToken == "variable" || e.prevToken == "type" || /\S(?:[^- ]>|[*\]])\s*$|\*$/.test(O.string.slice(0, t)) || e.typeAtEndOfLine && O.column() == O.indentation())
    return true;
}
function If(O) {
  for (; ; ) {
    if (!O || O.type == "top")
      return true;
    if (O.type == "}" && O.prev.info != "namespace")
      return false;
    O = O.prev;
  }
}
function Fe(O) {
  var e = O.statementIndentUnit, t = O.dontAlignCalls, i = O.keywords || {}, n = O.types || {}, r = O.builtin || {}, s = O.blockKeywords || {}, o = O.defKeywords || {}, a = O.atoms || {}, l = O.hooks || {}, h2 = O.multiLineStrings, u = O.indentStatements !== false, f = O.indentSwitch !== false, d = O.namespaceSeparator, Q = O.isPunctuationChar || /[\[\]{}\(\),;\:\.]/, $ = O.numberStart || /[\d\.]/, p = O.number || /^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i, m = O.isOperatorChar || /[+\-*&%=<>!?|\/]/, g = O.isIdentifierChar || /[\w\$_\xa1-\uffff]/, b = O.isReservedIdentifier || false, y, w;
  function P(X, W) {
    var R = X.next();
    if (l[R]) {
      var v = l[R](X, W);
      if (v !== false)
        return v;
    }
    if (R == '"' || R == "'")
      return W.tokenize = z(R), W.tokenize(X, W);
    if ($.test(R)) {
      if (X.backUp(1), X.match(p))
        return "number";
      X.next();
    }
    if (Q.test(R))
      return y = R, null;
    if (R == "/") {
      if (X.eat("*"))
        return W.tokenize = A, A(X, W);
      if (X.eat("/"))
        return X.skipToEnd(), "comment";
    }
    if (m.test(R)) {
      for (; !X.match(/^\/[\/*]/, false) && X.eat(m); )
        ;
      return "operator";
    }
    if (X.eatWhile(g), d)
      for (; X.match(d); )
        X.eatWhile(g);
    var G = X.current();
    return vt(i, G) ? (vt(s, G) && (y = "newstatement"), vt(o, G) && (w = true), "keyword") : vt(n, G) ? "type" : vt(r, G) || b && b(G) ? (vt(s, G) && (y = "newstatement"), "builtin") : vt(a, G) ? "atom" : "variable";
  }
  function z(X) {
    return function(W, R) {
      for (var v = false, G, Oe = false; (G = W.next()) != null; ) {
        if (G == X && !v) {
          Oe = true;
          break;
        }
        v = !v && G == "\\";
      }
      return (Oe || !(v || h2)) && (R.tokenize = null), "string";
    };
  }
  function A(X, W) {
    for (var R = false, v; v = X.next(); ) {
      if (v == "/" && R) {
        W.tokenize = null;
        break;
      }
      R = v == "*";
    }
    return "comment";
  }
  function C(X, W) {
    O.typeFirstDefinitions && X.eol() && If(W.context) && (W.typeAtEndOfLine = Gf(X, W, X.pos));
  }
  return {
    name: O.name,
    startState: function(X) {
      return {
        tokenize: null,
        context: new cc(-X, 0, "top", null, false),
        indented: 0,
        startOfLine: true,
        prevToken: null
      };
    },
    token: function(X, W) {
      var R = W.context;
      if (X.sol() && (R.align == null && (R.align = false), W.indented = X.indentation(), W.startOfLine = true), X.eatSpace())
        return C(X, W), null;
      y = w = null;
      var v = (W.tokenize || P)(X, W);
      if (v == "comment" || v == "meta")
        return v;
      if (R.align == null && (R.align = true), y == ";" || y == ":" || y == "," && X.match(/^\s*(?:\/\/.*)?$/, false))
        for (; W.context.type == "statement"; )
          Si(W);
      else if (y == "{")
        Hn(W, X.column(), "}");
      else if (y == "[")
        Hn(W, X.column(), "]");
      else if (y == "(")
        Hn(W, X.column(), ")");
      else if (y == "}") {
        for (; R.type == "statement"; )
          R = Si(W);
        for (R.type == "}" && (R = Si(W)); R.type == "statement"; )
          R = Si(W);
      } else
        y == R.type ? Si(W) : u && ((R.type == "}" || R.type == "top") && y != ";" || R.type == "statement" && y == "newstatement") && Hn(W, X.column(), "statement", X.current());
      if (v == "variable" && (W.prevToken == "def" || O.typeFirstDefinitions && Gf(X, W, X.start) && If(W.context) && X.match(/^\s*\(/, false)) && (v = "def"), l.token) {
        var G = l.token(X, W, v);
        G !== void 0 && (v = G);
      }
      return v == "def" && O.styleDefs === false && (v = "variable"), W.startOfLine = false, W.prevToken = w ? "def" : v || y, C(X, W), v;
    },
    indent: function(X, W, R) {
      if (X.tokenize != P && X.tokenize != null || X.typeAtEndOfLine)
        return null;
      var v = X.context, G = W && W.charAt(0), Oe = G == v.type;
      if (v.type == "statement" && G == "}" && (v = v.prev), O.dontIndentStatements)
        for (; v.type == "statement" && O.dontIndentStatements.test(v.info); )
          v = v.prev;
      if (l.indent) {
        var oe = l.indent(X, v, W, R.unit);
        if (typeof oe == "number")
          return oe;
      }
      var ft = v.prev && v.prev.info == "switch";
      if (O.allmanIndentation && /[{(]/.test(G)) {
        for (; v.type != "top" && v.type != "}"; )
          v = v.prev;
        return v.indented;
      }
      return v.type == "statement" ? v.indented + (G == "{" ? 0 : e || R.unit) : v.align && (!t || v.type != ")") ? v.column + (Oe ? 0 : 1) : v.type == ")" && !Oe ? v.indented + (e || R.unit) : v.indented + (Oe ? 0 : R.unit) + (!Oe && ft && !/^(?:case|default)\b/.test(W) ? R.unit : 0);
    },
    languageData: {
      indentOnInput: f ? /^\s*(?:case .*?:|default:|\{\}?|\})$/ : /^\s*[{}]$/,
      commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
      autocomplete: Object.keys(i).concat(Object.keys(n)).concat(Object.keys(r)).concat(Object.keys(a)),
      ...O.languageData
    }
  };
}
function Z(O) {
  for (var e = {}, t = O.split(" "), i = 0; i < t.length; ++i)
    e[t[i]] = true;
  return e;
}
function vt(O, e) {
  return typeof O == "function" ? O(e) : O.propertyIsEnumerable(e);
}
var mn = "auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile inline restrict asm fortran";
var Em = "alignas alignof and and_eq audit axiom bitand bitor catch class compl concept constexpr const_cast decltype delete dynamic_cast explicit export final friend import module mutable namespace new noexcept not not_eq operator or or_eq override private protected public reinterpret_cast requires static_assert static_cast template this thread_local throw try typeid typename using virtual xor xor_eq";
var Am = "bycopy byref in inout oneway out self super atomic nonatomic retain copy readwrite readonly strong weak assign typeof nullable nonnull null_resettable _cmd @interface @implementation @end @protocol @encode @property @synthesize @dynamic @class @public @package @private @protected @required @optional @try @catch @finally @import @selector @encode @defs @synchronized @autoreleasepool @compatibility_alias @available";
var Dm = "FOUNDATION_EXPORT FOUNDATION_EXTERN NS_INLINE NS_FORMAT_FUNCTION  NS_RETURNS_RETAINEDNS_ERROR_ENUM NS_RETURNS_NOT_RETAINED NS_RETURNS_INNER_POINTER NS_DESIGNATED_INITIALIZER NS_ENUM NS_OPTIONS NS_REQUIRES_NIL_TERMINATION NS_ASSUME_NONNULL_BEGIN NS_ASSUME_NONNULL_END NS_SWIFT_NAME NS_REFINED_FOR_SWIFT";
var JZ = Z("int long char short double float unsigned signed void bool");
var eq = Z("SEL instancetype id Class Protocol BOOL");
function gn(O) {
  return vt(JZ, O) || /.+_t$/.test(O);
}
function Mm(O) {
  return gn(O) || vt(eq, O);
}
var Sn = "case do else for if switch while struct enum union";
var bs = "struct enum union";
function aO(O, e) {
  if (!e.startOfLine)
    return false;
  for (var t, i = null; t = O.peek(); ) {
    if (t == "\\" && O.match(/^.$/)) {
      i = aO;
      break;
    } else if (t == "/" && O.match(/^\/[\/\*]/, false))
      break;
    O.next();
  }
  return e.tokenize = i, "meta";
}
function ws(O, e) {
  return e.prevToken == "type" ? "type" : false;
}
function Ts(O) {
  return !O || O.length < 2 || O[0] != "_" ? false : O[1] == "_" || O[1] !== O[1].toLowerCase();
}
function he(O) {
  return O.eatWhile(/[\w\.']/), "number";
}
function Bt(O, e) {
  if (O.backUp(1), O.match(/^(?:R|u8R|uR|UR|LR)/)) {
    var t = O.match(/^"([^\s\\()]{0,16})\(/);
    return t ? (e.cpp11RawStringDelim = t[1], e.tokenize = Af, Af(O, e)) : false;
  }
  return O.match(/^(?:u8|u|U|L)/) ? O.match(
    /^["']/,
    /* eat */
    false
  ) ? "string" : false : (O.next(), false);
}
function Lm(O) {
  var e = /(\w+)::~?(\w+)$/.exec(O);
  return e && e[1] == e[2];
}
function Ef(O, e) {
  for (var t; (t = O.next()) != null; )
    if (t == '"' && !O.eat('"')) {
      e.tokenize = null;
      break;
    }
  return "string";
}
function Af(O, e) {
  var t = e.cpp11RawStringDelim.replace(/[^\w\s]/g, "\\$&"), i = O.match(new RegExp(".*?\\)" + t + '"'));
  return i ? e.tokenize = null : O.skipToEnd(), "string";
}
var tq = Fe({
  name: "c",
  keywords: Z(mn),
  types: gn,
  blockKeywords: Z(Sn),
  defKeywords: Z(bs),
  typeFirstDefinitions: true,
  atoms: Z("NULL true false"),
  isReservedIdentifier: Ts,
  hooks: {
    "#": aO,
    "*": ws
  }
});
Fe({
  name: "cpp",
  keywords: Z(mn + " " + Em),
  types: gn,
  blockKeywords: Z(Sn + " class try catch"),
  defKeywords: Z(bs + " class namespace"),
  typeFirstDefinitions: true,
  atoms: Z("true false NULL nullptr"),
  dontIndentStatements: /^template$/,
  isIdentifierChar: /[\w\$_~\xa1-\uffff]/,
  isReservedIdentifier: Ts,
  hooks: {
    "#": aO,
    "*": ws,
    u: Bt,
    U: Bt,
    L: Bt,
    R: Bt,
    0: he,
    1: he,
    2: he,
    3: he,
    4: he,
    5: he,
    6: he,
    7: he,
    8: he,
    9: he,
    token: function(O, e, t) {
      if (t == "variable" && O.peek() == "(" && (e.prevToken == ";" || e.prevToken == null || e.prevToken == "}") && Lm(O.current()))
        return "def";
    }
  },
  namespaceSeparator: "::"
});
Fe({
  name: "java",
  keywords: Z("abstract assert break case catch class const continue default do else enum extends final finally for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),
  types: Z("var byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),
  blockKeywords: Z("catch class do else finally for if switch try while"),
  defKeywords: Z("class interface enum @interface"),
  typeFirstDefinitions: true,
  atoms: Z("true false null"),
  number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
  hooks: {
    "@": function(O) {
      return O.match("interface", false) ? false : (O.eatWhile(/[\w\$_]/), "meta");
    },
    '"': function(O, e) {
      return O.match(/""$/) ? (e.tokenize = Bm, e.tokenize(O, e)) : false;
    }
  }
});
var Oq = Fe({
  name: "csharp",
  keywords: Z("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),
  types: Z("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),
  blockKeywords: Z("catch class do else finally for foreach if struct switch try while"),
  defKeywords: Z("class interface namespace struct var"),
  typeFirstDefinitions: true,
  atoms: Z("true false null"),
  hooks: {
    "@": function(O, e) {
      return O.eat('"') ? (e.tokenize = Ef, Ef(O, e)) : (O.eatWhile(/[\w\$_]/), "meta");
    }
  }
});
function Bm(O, e) {
  for (var t = false; !O.eol(); ) {
    if (!t && O.match('"""')) {
      e.tokenize = null;
      break;
    }
    t = O.next() == "\\" && !t;
  }
  return "string";
}
function on(O) {
  return function(e, t) {
    for (var i; i = e.next(); )
      if (i == "*" && e.eat("/"))
        if (O == 1) {
          t.tokenize = null;
          break;
        } else
          return t.tokenize = on(O - 1), t.tokenize(e, t);
      else if (i == "/" && e.eat("*"))
        return t.tokenize = on(O + 1), t.tokenize(e, t);
    return "comment";
  };
}
var iq = Fe({
  name: "scala",
  keywords: Z(
    /* scala */
    "abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"
  ),
  types: Z(
    "AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"
  ),
  multiLineStrings: true,
  blockKeywords: Z("catch class enum do else finally for forSome if match switch try while"),
  defKeywords: Z("class enum def object package trait type val var"),
  atoms: Z("true false null"),
  indentStatements: false,
  indentSwitch: false,
  isOperatorChar: /[+\-*&%=<>!?|\/#:@]/,
  hooks: {
    "@": function(O) {
      return O.eatWhile(/[\w\$_]/), "meta";
    },
    '"': function(O, e) {
      return O.match('""') ? (e.tokenize = Bm, e.tokenize(O, e)) : false;
    },
    "'": function(O) {
      return O.eatWhile(/[\w\$_\xa1-\uffff]/), "atom";
    },
    "=": function(O, e) {
      var t = e.context;
      return t.type == "}" && t.align && O.eat(">") ? (e.context = new cc(t.indented, t.column, t.type, t.info, null, t.prev), "operator") : false;
    },
    "/": function(O, e) {
      return O.eat("*") ? (e.tokenize = on(1), e.tokenize(O, e)) : false;
    }
  },
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', '"""'] }
  }
});
function nq(O) {
  return function(e, t) {
    for (var i = false, n, r = false; !e.eol(); ) {
      if (!O && !i && e.match('"')) {
        r = true;
        break;
      }
      if (O && e.match('"""')) {
        r = true;
        break;
      }
      n = e.next(), !i && n == "$" && e.match("{") && e.skipTo("}"), i = !i && n == "\\" && !O;
    }
    return (r || !O) && (t.tokenize = null), "string";
  };
}
var rq = Fe({
  name: "kotlin",
  keywords: Z(
    /*keywords*/
    "package as typealias class interface this super val operator var fun for is in This throw return annotation break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend actual expect setparam"
  ),
  types: Z(
    /* package java.lang */
    "Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void Annotation Any BooleanArray ByteArray Char CharArray DeprecationLevel DoubleArray Enum FloatArray Function Int IntArray Lazy LazyThreadSafetyMode LongArray Nothing ShortArray Unit"
  ),
  intendSwitch: false,
  indentStatements: false,
  multiLineStrings: true,
  number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+(\.\d+)?|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
  blockKeywords: Z("catch class do else finally for if where try while enum"),
  defKeywords: Z("class val var object interface fun"),
  atoms: Z("true false null this"),
  hooks: {
    "@": function(O) {
      return O.eatWhile(/[\w\$_]/), "meta";
    },
    "*": function(O, e) {
      return e.prevToken == "." ? "variable" : "operator";
    },
    '"': function(O, e) {
      return e.tokenize = nq(O.match('""')), e.tokenize(O, e);
    },
    "/": function(O, e) {
      return O.eat("*") ? (e.tokenize = on(1), e.tokenize(O, e)) : false;
    },
    indent: function(O, e, t, i) {
      var n = t && t.charAt(0);
      if ((O.prevToken == "}" || O.prevToken == ")") && t == "")
        return O.indented;
      if (O.prevToken == "operator" && t != "}" && O.context.type != "}" || O.prevToken == "variable" && n == "." || (O.prevToken == "}" || O.prevToken == ")") && n == ".")
        return i * 2 + e.indented;
      if (e.align && e.type == "}")
        return e.indented + (O.context.type == (t || "").charAt(0) ? 0 : i);
    }
  },
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', '"""'] }
  }
});
Fe({
  name: "shader",
  keywords: Z("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),
  types: Z("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),
  blockKeywords: Z("for while do if else struct"),
  builtin: Z("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),
  atoms: Z("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TextureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),
  indentSwitch: false,
  hooks: { "#": aO }
});
Fe({
  name: "nesc",
  keywords: Z(mn + " as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),
  types: gn,
  blockKeywords: Z(Sn),
  atoms: Z("null true false"),
  hooks: { "#": aO }
});
var sq = Fe({
  name: "objectivec",
  keywords: Z(mn + " " + Am),
  types: Mm,
  builtin: Z(Dm),
  blockKeywords: Z(Sn + " @synthesize @try @catch @finally @autoreleasepool @synchronized"),
  defKeywords: Z(bs + " @interface @implementation @protocol @class"),
  dontIndentStatements: /^@.*$/,
  typeFirstDefinitions: true,
  atoms: Z("YES NO NULL Nil nil true false nullptr"),
  isReservedIdentifier: Ts,
  hooks: {
    "#": aO,
    "*": ws
  }
});
Fe({
  name: "objectivecpp",
  keywords: Z(mn + " " + Am + " " + Em),
  types: Mm,
  builtin: Z(Dm),
  blockKeywords: Z(Sn + " @synthesize @try @catch @finally @autoreleasepool @synchronized class try catch"),
  defKeywords: Z(bs + " @interface @implementation @protocol @class class namespace"),
  dontIndentStatements: /^@.*$|^template$/,
  typeFirstDefinitions: true,
  atoms: Z("YES NO NULL Nil nil true false nullptr"),
  isReservedIdentifier: Ts,
  hooks: {
    "#": aO,
    "*": ws,
    u: Bt,
    U: Bt,
    L: Bt,
    R: Bt,
    0: he,
    1: he,
    2: he,
    3: he,
    4: he,
    5: he,
    6: he,
    7: he,
    8: he,
    9: he,
    token: function(O, e, t) {
      if (t == "variable" && O.peek() == "(" && (e.prevToken == ";" || e.prevToken == null || e.prevToken == "}") && Lm(O.current()))
        return "def";
    }
  },
  namespaceSeparator: "::"
});
Fe({
  name: "squirrel",
  keywords: Z("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),
  types: gn,
  blockKeywords: Z("case catch class else for foreach if switch try while"),
  defKeywords: Z("function local class"),
  typeFirstDefinitions: true,
  atoms: Z("true false null"),
  hooks: { "#": aO }
});
var Qr = null;
function Nm(O) {
  return function(e, t) {
    for (var i = false, n, r = false; !e.eol(); ) {
      if (!i && e.match('"') && (O == "single" || e.match('""'))) {
        r = true;
        break;
      }
      if (!i && e.match("``")) {
        Qr = Nm(O), r = true;
        break;
      }
      n = e.next(), i = O == "single" && !i && n == "\\";
    }
    return r && (t.tokenize = null), "string";
  };
}
Fe({
  name: "ceylon",
  keywords: Z("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),
  types: function(O) {
    var e = O.charAt(0);
    return e === e.toUpperCase() && e !== e.toLowerCase();
  },
  blockKeywords: Z("case catch class dynamic else finally for function if interface module new object switch try while"),
  defKeywords: Z("class dynamic function interface module object package value"),
  builtin: Z("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),
  isPunctuationChar: /[\[\]{}\(\),;\:\.`]/,
  isOperatorChar: /[+\-*&%=<>!?|^~:\/]/,
  numberStart: /[\d#$]/,
  number: /^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,
  multiLineStrings: true,
  typeFirstDefinitions: true,
  atoms: Z("true false null larger smaller equal empty finished"),
  indentSwitch: false,
  styleDefs: false,
  hooks: {
    "@": function(O) {
      return O.eatWhile(/[\w\$_]/), "meta";
    },
    '"': function(O, e) {
      return e.tokenize = Nm(O.match('""') ? "triple" : "single"), e.tokenize(O, e);
    },
    "`": function(O, e) {
      return !Qr || !O.match("`") ? false : (e.tokenize = Qr, Qr = null, e.tokenize(O, e));
    },
    "'": function(O) {
      return O.eatWhile(/[\w\$_\xa1-\uffff]/), "atom";
    },
    token: function(O, e, t) {
      if ((t == "variable" || t == "type") && e.prevToken == ".")
        return "variableName.special";
    }
  },
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', '"""'] }
  }
});
function oq(O) {
  (O.interpolationStack || (O.interpolationStack = [])).push(O.tokenize);
}
function Fm(O) {
  return (O.interpolationStack || (O.interpolationStack = [])).pop();
}
function aq(O) {
  return O.interpolationStack ? O.interpolationStack.length : 0;
}
function xo(O, e, t, i) {
  var n = false;
  if (e.eat(O))
    if (e.eat(O))
      n = true;
    else
      return "string";
  function r(s, o) {
    for (var a = false; !s.eol(); ) {
      if (!i && !a && s.peek() == "$")
        return oq(o), o.tokenize = lq, "string";
      var l = s.next();
      if (l == O && !a && (!n || s.match(O + O))) {
        o.tokenize = null;
        break;
      }
      a = !i && !a && l == "\\";
    }
    return "string";
  }
  return t.tokenize = r, r(e, t);
}
function lq(O, e) {
  return O.eat("$"), O.eat("{") ? e.tokenize = null : e.tokenize = cq, null;
}
function cq(O, e) {
  return O.eatWhile(/[\w_]/), e.tokenize = Fm(e), "variable";
}
var hq = Fe({
  name: "dart",
  keywords: Z("this super static final const abstract class extends external factory implements mixin get native set typedef with enum throw rethrow assert break case continue default in return new deferred async await covariant try catch finally do else for if switch while import library export part of show hide is as extension on yield late required"),
  blockKeywords: Z("try catch finally do else for if switch while"),
  builtin: Z("void bool num int double dynamic var String Null Never"),
  atoms: Z("true false null"),
  hooks: {
    "@": function(O) {
      return O.eatWhile(/[\w\$_\.]/), "meta";
    },
    // custom string handling to deal with triple-quoted strings and string interpolation
    "'": function(O, e) {
      return xo("'", O, e, false);
    },
    '"': function(O, e) {
      return xo('"', O, e, false);
    },
    r: function(O, e) {
      var t = O.peek();
      return t == "'" || t == '"' ? xo(O.next(), O, e, true) : false;
    },
    "}": function(O, e) {
      return aq(e) > 0 ? (e.tokenize = Fm(e), null) : false;
    },
    "/": function(O, e) {
      return O.eat("*") ? (e.tokenize = on(1), e.tokenize(O, e)) : false;
    },
    token: function(O, e, t) {
      if (t == "variable") {
        var i = RegExp("^[_$]*[A-Z][a-zA-Z0-9_$]*$", "g");
        if (i.test(O.current()))
          return "type";
      }
    }
  }
});
var uq = {
  break: true,
  case: true,
  chan: true,
  const: true,
  continue: true,
  default: true,
  defer: true,
  else: true,
  fallthrough: true,
  for: true,
  func: true,
  go: true,
  goto: true,
  if: true,
  import: true,
  interface: true,
  map: true,
  package: true,
  range: true,
  return: true,
  select: true,
  struct: true,
  switch: true,
  type: true,
  var: true,
  bool: true,
  byte: true,
  complex64: true,
  complex128: true,
  float32: true,
  float64: true,
  int8: true,
  int16: true,
  int32: true,
  int64: true,
  string: true,
  uint8: true,
  uint16: true,
  uint32: true,
  uint64: true,
  int: true,
  uint: true,
  uintptr: true,
  error: true,
  rune: true,
  any: true,
  comparable: true
};
var fq = {
  true: true,
  false: true,
  iota: true,
  nil: true,
  append: true,
  cap: true,
  close: true,
  complex: true,
  copy: true,
  delete: true,
  imag: true,
  len: true,
  make: true,
  new: true,
  panic: true,
  print: true,
  println: true,
  real: true,
  recover: true
};
var Df = /[+\-*&^%:=<>!|\/]/;
var kt;
function Os(O, e) {
  var t = O.next();
  if (t == '"' || t == "'" || t == "`")
    return e.tokenize = dq(t), e.tokenize(O, e);
  if (/[\d\.]/.test(t))
    return t == "." ? O.match(/^[0-9]+([eE][\-+]?[0-9]+)?/) : t == "0" ? O.match(/^[xX][0-9a-fA-F]+/) || O.match(/^0[0-7]+/) : O.match(/^[0-9]*\.?[0-9]*([eE][\-+]?[0-9]+)?/), "number";
  if (/[\[\]{}\(\),;\:\.]/.test(t))
    return kt = t, null;
  if (t == "/") {
    if (O.eat("*"))
      return e.tokenize = Mf, Mf(O, e);
    if (O.eat("/"))
      return O.skipToEnd(), "comment";
  }
  if (Df.test(t))
    return O.eatWhile(Df), "operator";
  O.eatWhile(/[\w\$_\xa1-\uffff]/);
  var i = O.current();
  return uq.propertyIsEnumerable(i) ? ((i == "case" || i == "default") && (kt = "case"), "keyword") : fq.propertyIsEnumerable(i) ? "atom" : "variable";
}
function dq(O) {
  return function(e, t) {
    for (var i = false, n, r = false; (n = e.next()) != null; ) {
      if (n == O && !i) {
        r = true;
        break;
      }
      i = !i && O != "`" && n == "\\";
    }
    return (r || !(i || O == "`")) && (t.tokenize = Os), "string";
  };
}
function Mf(O, e) {
  for (var t = false, i; i = O.next(); ) {
    if (i == "/" && t) {
      e.tokenize = Os;
      break;
    }
    t = i == "*";
  }
  return "comment";
}
function Hm(O, e, t, i, n) {
  this.indented = O, this.column = e, this.type = t, this.align = i, this.prev = n;
}
function bo(O, e, t) {
  return O.context = new Hm(O.indented, e, t, null, O.context);
}
function Lf(O) {
  if (O.context.prev) {
    var e = O.context.type;
    return (e == ")" || e == "]" || e == "}") && (O.indented = O.context.indented), O.context = O.context.prev;
  }
}
var Qq = {
  name: "go",
  startState: function(O) {
    return {
      tokenize: null,
      context: new Hm(-O, 0, "top", false),
      indented: 0,
      startOfLine: true
    };
  },
  token: function(O, e) {
    var t = e.context;
    if (O.sol() && (t.align == null && (t.align = false), e.indented = O.indentation(), e.startOfLine = true, t.type == "case" && (t.type = "}")), O.eatSpace())
      return null;
    kt = null;
    var i = (e.tokenize || Os)(O, e);
    return i == "comment" || (t.align == null && (t.align = true), kt == "{" ? bo(e, O.column(), "}") : kt == "[" ? bo(e, O.column(), "]") : kt == "(" ? bo(e, O.column(), ")") : kt == "case" ? t.type = "case" : (kt == "}" && t.type == "}" || kt == t.type) && Lf(e), e.startOfLine = false), i;
  },
  indent: function(O, e, t) {
    if (O.tokenize != Os && O.tokenize != null)
      return null;
    var i = O.context, n = e && e.charAt(0);
    if (i.type == "case" && /^(?:case|default)\b/.test(e))
      return O.context.type = "}", i.indented;
    var r = n == i.type;
    return i.align ? i.column + (r ? 0 : 1) : i.indented + (r ? 0 : t.unit);
  },
  languageData: {
    indentOnInput: /^\s([{}]|case |default\s*:)$/,
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } }
  }
};
function Ws(O) {
  for (var e = {}, t = 0; t < O.length; t++)
    e[O[t]] = true;
  return e;
}
var $q = Ws([
  "_",
  "var",
  "let",
  "actor",
  "class",
  "enum",
  "extension",
  "import",
  "protocol",
  "struct",
  "func",
  "typealias",
  "associatedtype",
  "open",
  "public",
  "internal",
  "fileprivate",
  "private",
  "deinit",
  "init",
  "new",
  "override",
  "self",
  "subscript",
  "super",
  "convenience",
  "dynamic",
  "final",
  "indirect",
  "lazy",
  "required",
  "static",
  "unowned",
  "unowned(safe)",
  "unowned(unsafe)",
  "weak",
  "as",
  "is",
  "break",
  "case",
  "continue",
  "default",
  "else",
  "fallthrough",
  "for",
  "guard",
  "if",
  "in",
  "repeat",
  "switch",
  "where",
  "while",
  "defer",
  "return",
  "inout",
  "mutating",
  "nonmutating",
  "isolated",
  "nonisolated",
  "catch",
  "do",
  "rethrows",
  "throw",
  "throws",
  "async",
  "await",
  "try",
  "didSet",
  "get",
  "set",
  "willSet",
  "assignment",
  "associativity",
  "infix",
  "left",
  "none",
  "operator",
  "postfix",
  "precedence",
  "precedencegroup",
  "prefix",
  "right",
  "Any",
  "AnyObject",
  "Type",
  "dynamicType",
  "Self",
  "Protocol",
  "__COLUMN__",
  "__FILE__",
  "__FUNCTION__",
  "__LINE__"
]);
var pq = Ws(["var", "let", "actor", "class", "enum", "extension", "import", "protocol", "struct", "func", "typealias", "associatedtype", "for"]);
var mq = Ws(["true", "false", "nil", "self", "super", "_"]);
var gq = Ws([
  "Array",
  "Bool",
  "Character",
  "Dictionary",
  "Double",
  "Float",
  "Int",
  "Int8",
  "Int16",
  "Int32",
  "Int64",
  "Never",
  "Optional",
  "Set",
  "String",
  "UInt8",
  "UInt16",
  "UInt32",
  "UInt64",
  "Void"
]);
var Sq = "+-/*%=|&<>~^?!";
var Pq = ":;,.(){}[]";
var yq = /^\-?0b[01][01_]*/;
var Xq = /^\-?0o[0-7][0-7_]*/;
var xq = /^\-?0x[\dA-Fa-f][\dA-Fa-f_]*(?:(?:\.[\dA-Fa-f][\dA-Fa-f_]*)?[Pp]\-?\d[\d_]*)?/;
var bq = /^\-?\d[\d_]*(?:\.\d[\d_]*)?(?:[Ee]\-?\d[\d_]*)?/;
var wq = /^\$\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\1/;
var Tq = /^\.(?:\$\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\1)/;
var Wq = /^\#[A-Za-z]+/;
var vq = /^@(?:\$\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\1)/;
function Km(O, e, t) {
  if (O.sol() && (e.indented = O.indentation()), O.eatSpace())
    return null;
  var i = O.peek();
  if (i == "/") {
    if (O.match("//"))
      return O.skipToEnd(), "comment";
    if (O.match("/*"))
      return e.tokenize.push(Ba), Ba(O, e);
  }
  if (O.match(Wq))
    return "builtin";
  if (O.match(vq))
    return "attribute";
  if (O.match(yq) || O.match(Xq) || O.match(xq) || O.match(bq))
    return "number";
  if (O.match(Tq))
    return "property";
  if (Sq.indexOf(i) > -1)
    return O.next(), "operator";
  if (Pq.indexOf(i) > -1)
    return O.next(), O.match(".."), "punctuation";
  var n;
  if (n = O.match(/("""|"|')/)) {
    var r = Yq.bind(null, n[0]);
    return e.tokenize.push(r), r(O, e);
  }
  if (O.match(wq)) {
    var s = O.current();
    return gq.hasOwnProperty(s) ? "type" : mq.hasOwnProperty(s) ? "atom" : $q.hasOwnProperty(s) ? (pq.hasOwnProperty(s) && (e.prev = "define"), "keyword") : t == "define" ? "def" : "variable";
  }
  return O.next(), null;
}
function kq() {
  var O = 0;
  return function(e, t, i) {
    var n = Km(e, t, i);
    if (n == "punctuation") {
      if (e.current() == "(")
        ++O;
      else if (e.current() == ")") {
        if (O == 0)
          return e.backUp(1), t.tokenize.pop(), t.tokenize[t.tokenize.length - 1](e, t);
        --O;
      }
    }
    return n;
  };
}
function Yq(O, e, t) {
  for (var i = O.length == 1, n, r = false; n = e.peek(); )
    if (r) {
      if (e.next(), n == "(")
        return t.tokenize.push(kq()), "string";
      r = false;
    } else {
      if (e.match(O))
        return t.tokenize.pop(), "string";
      e.next(), r = n == "\\";
    }
  return i && t.tokenize.pop(), "string";
}
function Ba(O, e) {
  for (var t; t = O.next(); )
    if (t === "/" && O.eat("*"))
      e.tokenize.push(Ba);
    else if (t === "*" && O.eat("/")) {
      e.tokenize.pop();
      break;
    }
  return "comment";
}
function Zq(O, e, t) {
  this.prev = O, this.align = e, this.indented = t;
}
function qq(O, e) {
  var t = e.match(/^\s*($|\/[\/\*]|[)}\]])/, false) ? null : e.column() + 1;
  O.context = new Zq(O.context, t, O.indented);
}
function zq(O) {
  O.context && (O.indented = O.context.indented, O.context = O.context.prev);
}
var Uq = {
  name: "swift",
  startState: function() {
    return {
      prev: null,
      context: null,
      indented: 0,
      tokenize: []
    };
  },
  token: function(O, e) {
    var t = e.prev;
    e.prev = null;
    var i = e.tokenize[e.tokenize.length - 1] || Km, n = i(O, e, t);
    if (!n || n == "comment" ? e.prev = t : e.prev || (e.prev = n), n == "punctuation") {
      var r = /[\(\[\{]|([\]\)\}])/.exec(O.current());
      r && (r[1] ? zq : qq)(e, O);
    }
    return n;
  },
  indent: function(O, e, t) {
    var i = O.context;
    if (!i)
      return 0;
    var n = /^[\]\}\)]/.test(e);
    return i.align != null ? i.align - (n ? 1 : 0) : i.indented + (n ? 0 : t.unit);
  },
  languageData: {
    indentOnInput: /^\s*[\)\}\]]$/,
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }
  }
};
function Pi(O, e, t) {
  return e(t), t(O, e);
}
var Vq = /[a-z]/;
var Rq = /[A-Z]/;
var Bf = /[a-zA-Z0-9_]/;
var Kn = /[0-9]/;
var _q = /[0-9A-Fa-f]/;
var Nf = /[-&*+.\\/<>=?^|:]/;
var jq = /[(),[\]{}]/;
var Cq = /[ \v\f]/;
function Vt() {
  return function(O, e) {
    if (O.eatWhile(Cq))
      return null;
    var t = O.next();
    if (jq.test(t))
      return t === "{" && O.eat("-") ? Pi(O, e, Jm(1)) : t === "[" && O.match("glsl|") ? Pi(O, e, Aq) : "builtin";
    if (t === "'")
      return Pi(O, e, Eq);
    if (t === '"')
      return O.eat('"') ? O.eat('"') ? Pi(O, e, Gq) : "string" : Pi(O, e, Iq);
    if (Rq.test(t))
      return O.eatWhile(Bf), "type";
    if (Vq.test(t)) {
      var i = O.pos === 1;
      return O.eatWhile(Bf), i ? "def" : "variable";
    }
    if (Kn.test(t)) {
      if (t === "0") {
        if (O.eat(/[xX]/))
          return O.eatWhile(_q), "number";
      } else
        O.eatWhile(Kn);
      return O.eat(".") && O.eatWhile(Kn), O.eat(/[eE]/) && (O.eat(/[-+]/), O.eatWhile(Kn)), "number";
    }
    return Nf.test(t) ? t === "-" && O.eat("-") ? (O.skipToEnd(), "comment") : (O.eatWhile(Nf), "keyword") : t === "_" ? "keyword" : "error";
  };
}
function Jm(O) {
  return O == 0 ? Vt() : function(e, t) {
    for (; !e.eol(); ) {
      var i = e.next();
      if (i == "{" && e.eat("-"))
        ++O;
      else if (i == "-" && e.eat("}") && (--O, O === 0))
        return t(Vt()), "comment";
    }
    return t(Jm(O)), "comment";
  };
}
function Gq(O, e) {
  for (; !O.eol(); ) {
    var t = O.next();
    if (t === '"' && O.eat('"') && O.eat('"'))
      return e(Vt()), "string";
  }
  return "string";
}
function Iq(O, e) {
  for (; O.skipTo('\\"'); )
    O.next(), O.next();
  return O.skipTo('"') ? (O.next(), e(Vt()), "string") : (O.skipToEnd(), e(Vt()), "error");
}
function Eq(O, e) {
  for (; O.skipTo("\\'"); )
    O.next(), O.next();
  return O.skipTo("'") ? (O.next(), e(Vt()), "string") : (O.skipToEnd(), e(Vt()), "error");
}
function Aq(O, e) {
  for (; !O.eol(); ) {
    var t = O.next();
    if (t === "|" && O.eat("]"))
      return e(Vt()), "string";
  }
  return "string";
}
var Dq = {
  case: 1,
  of: 1,
  as: 1,
  if: 1,
  then: 1,
  else: 1,
  let: 1,
  in: 1,
  type: 1,
  alias: 1,
  module: 1,
  where: 1,
  import: 1,
  exposing: 1,
  port: 1
};
var Mq = {
  name: "elm",
  startState: function() {
    return { f: Vt() };
  },
  copyState: function(O) {
    return { f: O.f };
  },
  token: function(O, e) {
    var t = e.f(O, function(n) {
      e.f = n;
    }), i = O.current();
    return Dq.hasOwnProperty(i) ? "keyword" : t;
  },
  languageData: {
    commentTokens: { line: "--" }
  }
};
function Na(O, e, t) {
  return e(t), t(O, e);
}
var Lq = /[a-z_]/;
var Bq = /[A-Z]/;
var wo = /\d/;
var Nq = /[0-9A-Fa-f]/;
var Fq = /[0-7]/;
var Ff = /[a-z_A-Z0-9'\xa1-\uffff]/;
var To = /[-!#$%&*+.\/<=>?@\\^|~:]/;
var Hq = /[(),;[\]`{}]/;
var eg = /[ \t\v\f]/;
function ti(O, e) {
  if (O.eatWhile(eg))
    return null;
  var t = O.next();
  if (Hq.test(t)) {
    if (t == "{" && O.eat("-")) {
      var i = "comment";
      return O.eat("#") && (i = "meta"), Na(O, e, tg(i, 1));
    }
    return null;
  }
  if (t == "'")
    return O.eat("\\"), O.next(), O.eat("'") ? "string" : "error";
  if (t == '"')
    return Na(O, e, Og);
  if (Bq.test(t))
    return O.eatWhile(Ff), O.eat(".") ? "qualifier" : "type";
  if (Lq.test(t))
    return O.eatWhile(Ff), "variable";
  if (wo.test(t)) {
    if (t == "0") {
      if (O.eat(/[xX]/))
        return O.eatWhile(Nq), "integer";
      if (O.eat(/[oO]/))
        return O.eatWhile(Fq), "number";
    }
    O.eatWhile(wo);
    var i = "number";
    return O.match(/^\.\d+/) && (i = "number"), O.eat(/[eE]/) && (i = "number", O.eat(/[-+]/), O.eatWhile(wo)), i;
  }
  return t == "." && O.eat(".") ? "keyword" : To.test(t) ? t == "-" && O.eat(/-/) && (O.eatWhile(/-/), !O.eat(To)) ? (O.skipToEnd(), "comment") : (O.eatWhile(To), "variable") : "error";
}
function tg(O, e) {
  return e == 0 ? ti : function(t, i) {
    for (var n = e; !t.eol(); ) {
      var r = t.next();
      if (r == "{" && t.eat("-"))
        ++n;
      else if (r == "-" && t.eat("}") && (--n, n == 0))
        return i(ti), O;
    }
    return i(tg(O, n)), O;
  };
}
function Og(O, e) {
  for (; !O.eol(); ) {
    var t = O.next();
    if (t == '"')
      return e(ti), "string";
    if (t == "\\") {
      if (O.eol() || O.eat(eg))
        return e(Kq), "string";
      O.eat("&") || O.next();
    }
  }
  return e(ti), "error";
}
function Kq(O, e) {
  return O.eat("\\") ? Na(O, e, Og) : (O.next(), e(ti), "error");
}
var Hf = function() {
  var O = {};
  function e(t) {
    return function() {
      for (var i = 0; i < arguments.length; i++)
        O[arguments[i]] = t;
    };
  }
  return e("keyword")(
    "case",
    "class",
    "data",
    "default",
    "deriving",
    "do",
    "else",
    "foreign",
    "if",
    "import",
    "in",
    "infix",
    "infixl",
    "infixr",
    "instance",
    "let",
    "module",
    "newtype",
    "of",
    "then",
    "type",
    "where",
    "_"
  ), e("keyword")(
    "..",
    ":",
    "::",
    "=",
    "\\",
    "<-",
    "->",
    "@",
    "~",
    "=>"
  ), e("builtin")(
    "!!",
    "$!",
    "$",
    "&&",
    "+",
    "++",
    "-",
    ".",
    "/",
    "/=",
    "<",
    "<*",
    "<=",
    "<$>",
    "<*>",
    "=<<",
    "==",
    ">",
    ">=",
    ">>",
    ">>=",
    "^",
    "^^",
    "||",
    "*",
    "*>",
    "**"
  ), e("builtin")(
    "Applicative",
    "Bool",
    "Bounded",
    "Char",
    "Double",
    "EQ",
    "Either",
    "Enum",
    "Eq",
    "False",
    "FilePath",
    "Float",
    "Floating",
    "Fractional",
    "Functor",
    "GT",
    "IO",
    "IOError",
    "Int",
    "Integer",
    "Integral",
    "Just",
    "LT",
    "Left",
    "Maybe",
    "Monad",
    "Nothing",
    "Num",
    "Ord",
    "Ordering",
    "Rational",
    "Read",
    "ReadS",
    "Real",
    "RealFloat",
    "RealFrac",
    "Right",
    "Show",
    "ShowS",
    "String",
    "True"
  ), e("builtin")(
    "abs",
    "acos",
    "acosh",
    "all",
    "and",
    "any",
    "appendFile",
    "asTypeOf",
    "asin",
    "asinh",
    "atan",
    "atan2",
    "atanh",
    "break",
    "catch",
    "ceiling",
    "compare",
    "concat",
    "concatMap",
    "const",
    "cos",
    "cosh",
    "curry",
    "cycle",
    "decodeFloat",
    "div",
    "divMod",
    "drop",
    "dropWhile",
    "either",
    "elem",
    "encodeFloat",
    "enumFrom",
    "enumFromThen",
    "enumFromThenTo",
    "enumFromTo",
    "error",
    "even",
    "exp",
    "exponent",
    "fail",
    "filter",
    "flip",
    "floatDigits",
    "floatRadix",
    "floatRange",
    "floor",
    "fmap",
    "foldl",
    "foldl1",
    "foldr",
    "foldr1",
    "fromEnum",
    "fromInteger",
    "fromIntegral",
    "fromRational",
    "fst",
    "gcd",
    "getChar",
    "getContents",
    "getLine",
    "head",
    "id",
    "init",
    "interact",
    "ioError",
    "isDenormalized",
    "isIEEE",
    "isInfinite",
    "isNaN",
    "isNegativeZero",
    "iterate",
    "last",
    "lcm",
    "length",
    "lex",
    "lines",
    "log",
    "logBase",
    "lookup",
    "map",
    "mapM",
    "mapM_",
    "max",
    "maxBound",
    "maximum",
    "maybe",
    "min",
    "minBound",
    "minimum",
    "mod",
    "negate",
    "not",
    "notElem",
    "null",
    "odd",
    "or",
    "otherwise",
    "pi",
    "pred",
    "print",
    "product",
    "properFraction",
    "pure",
    "putChar",
    "putStr",
    "putStrLn",
    "quot",
    "quotRem",
    "read",
    "readFile",
    "readIO",
    "readList",
    "readLn",
    "readParen",
    "reads",
    "readsPrec",
    "realToFrac",
    "recip",
    "rem",
    "repeat",
    "replicate",
    "return",
    "reverse",
    "round",
    "scaleFloat",
    "scanl",
    "scanl1",
    "scanr",
    "scanr1",
    "seq",
    "sequence",
    "sequence_",
    "show",
    "showChar",
    "showList",
    "showParen",
    "showString",
    "shows",
    "showsPrec",
    "significand",
    "signum",
    "sin",
    "sinh",
    "snd",
    "span",
    "splitAt",
    "sqrt",
    "subtract",
    "succ",
    "sum",
    "tail",
    "take",
    "takeWhile",
    "tan",
    "tanh",
    "toEnum",
    "toInteger",
    "toRational",
    "truncate",
    "uncurry",
    "undefined",
    "unlines",
    "until",
    "unwords",
    "unzip",
    "unzip3",
    "userError",
    "words",
    "writeFile",
    "zip",
    "zip3",
    "zipWith",
    "zipWith3"
  ), O;
}();
var Jq = {
  name: "haskell",
  startState: function() {
    return { f: ti };
  },
  copyState: function(O) {
    return { f: O.f };
  },
  token: function(O, e) {
    var t = e.f(O, function(n) {
      e.f = n;
    }), i = O.current();
    return Hf.hasOwnProperty(i) ? Hf[i] : t;
  },
  languageData: {
    commentTokens: { line: "--", block: { open: "{-", close: "-}" } }
  }
};
var ez = ["true", "false", "on", "off", "yes", "no"];
var tz = new RegExp("\\b((" + ez.join(")|(") + "))$", "i");
var Oz = {
  name: "yaml",
  token: function(O, e) {
    var t = O.peek(), i = e.escaped;
    if (e.escaped = false, t == "#" && (O.pos == 0 || /\s/.test(O.string.charAt(O.pos - 1))))
      return O.skipToEnd(), "comment";
    if (O.match(/^('([^']|\\.)*'?|"([^"]|\\.)*"?)/))
      return "string";
    if (e.literal && O.indentation() > e.keyCol)
      return O.skipToEnd(), "string";
    if (e.literal && (e.literal = false), O.sol()) {
      if (e.keyCol = 0, e.pair = false, e.pairStart = false, O.match("---") || O.match("..."))
        return "def";
      if (O.match(/^\s*-\s+/))
        return "meta";
    }
    if (O.match(/^(\{|\}|\[|\])/))
      return t == "{" ? e.inlinePairs++ : t == "}" ? e.inlinePairs-- : t == "[" ? e.inlineList++ : e.inlineList--, "meta";
    if (e.inlineList > 0 && !i && t == ",")
      return O.next(), "meta";
    if (e.inlinePairs > 0 && !i && t == ",")
      return e.keyCol = 0, e.pair = false, e.pairStart = false, O.next(), "meta";
    if (e.pairStart) {
      if (O.match(/^\s*(\||\>)\s*/))
        return e.literal = true, "meta";
      if (O.match(/^\s*(\&|\*)[a-z0-9\._-]+\b/i))
        return "variable";
      if (e.inlinePairs == 0 && O.match(/^\s*-?[0-9\.\,]+\s?$/) || e.inlinePairs > 0 && O.match(/^\s*-?[0-9\.\,]+\s?(?=(,|}))/))
        return "number";
      if (O.match(tz))
        return "keyword";
    }
    return !e.pair && O.match(/^\s*(?:[,\[\]{}&*!|>'"%@`][^\s'":]|[^,\[\]{}#&*!|>'"%@`])[^#]*?(?=\s*:($|\s))/) ? (e.pair = true, e.keyCol = O.indentation(), "atom") : e.pair && O.match(/^:\s*/) ? (e.pairStart = true, "meta") : (e.pairStart = false, e.escaped = t == "\\", O.next(), null);
  },
  startState: function() {
    return {
      pair: false,
      pairStart: false,
      keyCol: 0,
      inlinePairs: 0,
      inlineList: 0,
      literal: false,
      escaped: false
    };
  },
  languageData: {
    commentTokens: { line: "#" }
  }
};
var Fa = {};
function hc(O, e) {
  for (var t = 0; t < e.length; t++)
    Fa[e[t]] = O;
}
var ig = ["true", "false"];
var ng = [
  "if",
  "then",
  "do",
  "else",
  "elif",
  "while",
  "until",
  "for",
  "in",
  "esac",
  "fi",
  "fin",
  "fil",
  "done",
  "exit",
  "set",
  "unset",
  "export",
  "function"
];
var rg = [
  "ab",
  "awk",
  "bash",
  "beep",
  "cat",
  "cc",
  "cd",
  "chown",
  "chmod",
  "chroot",
  "clear",
  "cp",
  "curl",
  "cut",
  "diff",
  "echo",
  "find",
  "gawk",
  "gcc",
  "get",
  "git",
  "grep",
  "hg",
  "kill",
  "killall",
  "ln",
  "ls",
  "make",
  "mkdir",
  "openssl",
  "mv",
  "nc",
  "nl",
  "node",
  "npm",
  "ping",
  "ps",
  "restart",
  "rm",
  "rmdir",
  "sed",
  "service",
  "sh",
  "shopt",
  "shred",
  "source",
  "sort",
  "sleep",
  "ssh",
  "start",
  "stop",
  "su",
  "sudo",
  "svn",
  "tee",
  "telnet",
  "top",
  "touch",
  "vi",
  "vim",
  "wall",
  "wc",
  "wget",
  "who",
  "write",
  "yes",
  "zsh"
];
hc("atom", ig);
hc("keyword", ng);
hc("builtin", rg);
function iz(O, e) {
  if (O.eatSpace())
    return null;
  var t = O.sol(), i = O.next();
  if (i === "\\")
    return O.next(), null;
  if (i === "'" || i === '"' || i === "`")
    return e.tokens.unshift(vs(i, i === "`" ? "quote" : "string")), Oi(O, e);
  if (i === "#")
    return t && O.eat("!") ? (O.skipToEnd(), "meta") : (O.skipToEnd(), "comment");
  if (i === "$")
    return e.tokens.unshift(sg), Oi(O, e);
  if (i === "+" || i === "=")
    return "operator";
  if (i === "-")
    return O.eat("-"), O.eatWhile(/\w/), "attribute";
  if (i == "<") {
    if (O.match("<<"))
      return "operator";
    var n = O.match(/^<-?\s*['"]?([^'"]*)['"]?/);
    if (n)
      return e.tokens.unshift(rz(n[1])), "string.special";
  }
  if (/\d/.test(i) && (O.eatWhile(/\d/), O.eol() || !/\w/.test(O.peek())))
    return "number";
  O.eatWhile(/[\w-]/);
  var r = O.current();
  return O.peek() === "=" && /\w+/.test(r) ? "def" : Fa.hasOwnProperty(r) ? Fa[r] : null;
}
function vs(O, e) {
  var t = O == "(" ? ")" : O == "{" ? "}" : O;
  return function(i, n) {
    for (var r, s = false; (r = i.next()) != null; ) {
      if (r === t && !s) {
        n.tokens.shift();
        break;
      } else if (r === "$" && !s && O !== "'" && i.peek() != t) {
        s = true, i.backUp(1), n.tokens.unshift(sg);
        break;
      } else {
        if (!s && O !== t && r === O)
          return n.tokens.unshift(vs(O, e)), Oi(i, n);
        if (!s && /['"]/.test(r) && !/['"]/.test(O)) {
          n.tokens.unshift(nz(r, "string")), i.backUp(1);
          break;
        }
      }
      s = !s && r === "\\";
    }
    return e;
  };
}
function nz(O, e) {
  return function(t, i) {
    return i.tokens[0] = vs(O, e), t.next(), Oi(t, i);
  };
}
var sg = function(O, e) {
  e.tokens.length > 1 && O.eat("$");
  var t = O.next();
  return /['"({]/.test(t) ? (e.tokens[0] = vs(t, t == "(" ? "quote" : t == "{" ? "def" : "string"), Oi(O, e)) : (/\d/.test(t) || O.eatWhile(/\w/), e.tokens.shift(), "def");
};
function rz(O) {
  return function(e, t) {
    return e.sol() && e.string == O && t.tokens.shift(), e.skipToEnd(), "string.special";
  };
}
function Oi(O, e) {
  return (e.tokens[0] || iz)(O, e);
}
var sz = {
  name: "shell",
  startState: function() {
    return { tokens: [] };
  },
  token: function(O, e) {
    return Oi(O, e);
  },
  languageData: {
    autocomplete: ig.concat(ng, rg),
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "#" }
  }
};
function ks(O) {
  for (var e = {}, t = 0; t < O.length; ++t)
    e[O[t]] = true;
  return e;
}
var og = ["NULL", "NA", "Inf", "NaN", "NA_integer_", "NA_real_", "NA_complex_", "NA_character_", "TRUE", "FALSE"];
var ag = ["list", "quote", "bquote", "eval", "return", "call", "parse", "deparse"];
var lg = ["if", "else", "repeat", "while", "function", "for", "in", "next", "break"];
var oz = ["if", "else", "repeat", "while", "function", "for"];
var az = ks(og);
var lz = ks(ag);
var cz = ks(lg);
var hz = ks(oz);
var Kf = /[+\-*\/^<>=!&|~$:]/;
var ot;
function Ha(O, e) {
  ot = null;
  var t = O.next();
  if (t == "#")
    return O.skipToEnd(), "comment";
  if (t == "0" && O.eat("x"))
    return O.eatWhile(/[\da-f]/i), "number";
  if (t == "." && O.eat(/\d/))
    return O.match(/\d*(?:e[+\-]?\d+)?/), "number";
  if (/\d/.test(t))
    return O.match(/\d*(?:\.\d+)?(?:e[+\-]\d+)?L?/), "number";
  if (t == "'" || t == '"')
    return e.tokenize = uz(t), "string";
  if (t == "`")
    return O.match(/[^`]+`/), "string.special";
  if (t == "." && O.match(/.(?:[.]|\d+)/))
    return "keyword";
  if (/[a-zA-Z\.]/.test(t)) {
    O.eatWhile(/[\w\.]/);
    var i = O.current();
    return az.propertyIsEnumerable(i) ? "atom" : cz.propertyIsEnumerable(i) ? (hz.propertyIsEnumerable(i) && !O.match(/\s*if(\s+|$)/, false) && (ot = "block"), "keyword") : lz.propertyIsEnumerable(i) ? "builtin" : "variable";
  } else
    return t == "%" ? (O.skipTo("%") && O.next(), "variableName.special") : t == "<" && O.eat("-") || t == "<" && O.match("<-") || t == "-" && O.match(/>>?/) || t == "=" && e.ctx.argList ? "operator" : Kf.test(t) ? (t == "$" || O.eatWhile(Kf), "operator") : /[\(\){}\[\];]/.test(t) ? (ot = t, t == ";" ? "punctuation" : null) : null;
}
function uz(O) {
  return function(e, t) {
    if (e.eat("\\")) {
      var i = e.next();
      return i == "x" ? e.match(/^[a-f0-9]{2}/i) : (i == "u" || i == "U") && e.eat("{") && e.skipTo("}") ? e.next() : i == "u" ? e.match(/^[a-f0-9]{4}/i) : i == "U" ? e.match(/^[a-f0-9]{8}/i) : /[0-7]/.test(i) && e.match(/^[0-7]{1,2}/), "string.special";
    } else {
      for (var n; (n = e.next()) != null; ) {
        if (n == O) {
          t.tokenize = Ha;
          break;
        }
        if (n == "\\") {
          e.backUp(1);
          break;
        }
      }
      return "string";
    }
  };
}
var Jf = 1;
var Wo = 2;
var vo = 4;
function Jn(O, e, t) {
  O.ctx = {
    type: e,
    indent: O.indent,
    flags: 0,
    column: t.column(),
    prev: O.ctx
  };
}
function ed(O, e) {
  var t = O.ctx;
  O.ctx = {
    type: t.type,
    indent: t.indent,
    flags: t.flags | e,
    column: t.column,
    prev: t.prev
  };
}
function ko(O) {
  O.indent = O.ctx.indent, O.ctx = O.ctx.prev;
}
var fz = {
  name: "r",
  startState: function(O) {
    return {
      tokenize: Ha,
      ctx: {
        type: "top",
        indent: -O,
        flags: Wo
      },
      indent: 0,
      afterIdent: false
    };
  },
  token: function(O, e) {
    if (O.sol() && (e.ctx.flags & 3 || (e.ctx.flags |= Wo), e.ctx.flags & vo && ko(e), e.indent = O.indentation()), O.eatSpace())
      return null;
    var t = e.tokenize(O, e);
    return t != "comment" && !(e.ctx.flags & Wo) && ed(e, Jf), (ot == ";" || ot == "{" || ot == "}") && e.ctx.type == "block" && ko(e), ot == "{" ? Jn(e, "}", O) : ot == "(" ? (Jn(e, ")", O), e.afterIdent && (e.ctx.argList = true)) : ot == "[" ? Jn(e, "]", O) : ot == "block" ? Jn(e, "block", O) : ot == e.ctx.type ? ko(e) : e.ctx.type == "block" && t != "comment" && ed(e, vo), e.afterIdent = t == "variable" || t == "keyword", t;
  },
  indent: function(O, e, t) {
    if (O.tokenize != Ha)
      return 0;
    var i = e && e.charAt(0), n = O.ctx, r = i == n.type;
    return n.flags & vo && (n = n.prev), n.type == "block" ? n.indent + (i == "{" ? 0 : t.unit) : n.flags & Jf ? n.column + (r ? 0 : 1) : n.indent + (r ? 0 : t.unit);
  },
  languageData: {
    wordChars: ".",
    commentTokens: { line: "#" },
    autocomplete: og.concat(ag, lg)
  }
};
var dz = {
  name: "toml",
  startState: function() {
    return {
      inString: false,
      stringType: "",
      lhs: true,
      inArray: 0
    };
  },
  token: function(O, e) {
    if (!e.inString && (O.peek() == '"' || O.peek() == "'") && (e.stringType = O.peek(), O.next(), e.inString = true), O.sol() && e.inArray === 0 && (e.lhs = true), e.inString) {
      for (; e.inString && !O.eol(); )
        O.peek() === e.stringType ? (O.next(), e.inString = false) : O.peek() === "\\" ? (O.next(), O.next()) : O.match(/^.[^\\\"\']*/);
      return e.lhs ? "property" : "string";
    } else {
      if (e.inArray && O.peek() === "]")
        return O.next(), e.inArray--, "bracket";
      if (e.lhs && O.peek() === "[" && O.skipTo("]"))
        return O.next(), O.peek() === "]" && O.next(), "atom";
      if (O.peek() === "#")
        return O.skipToEnd(), "comment";
      if (O.eatSpace())
        return null;
      if (e.lhs && O.eatWhile(function(t) {
        return t != "=" && t != " ";
      }))
        return "property";
      if (e.lhs && O.peek() === "=")
        return O.next(), e.lhs = false, null;
      if (!e.lhs && O.match(/^\d\d\d\d[\d\-\:\.T]*Z/))
        return "atom";
      if (!e.lhs && (O.match("true") || O.match("false")))
        return "atom";
      if (!e.lhs && O.peek() === "[")
        return e.inArray++, O.next(), "bracket";
      if (!e.lhs && O.match(/^\-?\d+(?:\.\d+)?/))
        return "number";
      O.eatSpace() || O.next();
    }
    return null;
  },
  languageData: {
    commentTokens: { line: "#" }
  }
};
var Qz = {
  name: "properties",
  token: function(O, e) {
    var t = O.sol() || e.afterSection, i = O.eol();
    if (e.afterSection = false, t && (e.nextMultiline ? (e.inMultiline = true, e.nextMultiline = false) : e.position = "def"), i && !e.nextMultiline && (e.inMultiline = false, e.position = "def"), t)
      for (; O.eatSpace(); )
        ;
    var n = O.next();
    return t && (n === "#" || n === "!" || n === ";") ? (e.position = "comment", O.skipToEnd(), "comment") : t && n === "[" ? (e.afterSection = true, O.skipTo("]"), O.eat("]"), "header") : n === "=" || n === ":" ? (e.position = "quote", null) : (n === "\\" && e.position === "quote" && O.eol() && (e.nextMultiline = true), e.position);
  },
  startState: function() {
    return {
      position: "def",
      // Current position, "def", "quote" or "comment"
      nextMultiline: false,
      // Is the next line multiline value
      inMultiline: false,
      // Is the current line a multiline value
      afterSection: false
      // Did we just open a section
    };
  }
};
function ai(O, e) {
  return new RegExp((e ? "" : "^") + "(?:" + O.join("|") + ")" + (e ? "$" : "\\b"));
}
function Ct(O, e, t) {
  return t.tokenize.push(O), O(e, t);
}
var Ka = /^(?:[-+/%|&^]|\*\*?|[<>]{2})/;
var Ja = /^(?:[=!]~|===|<=>|[<>=!]=?|[|&]{2}|~)/;
var cg = /^(?:\[\][?=]?)/;
var $z = /^(?:\.(?:\.{2})?|->|[?:])/;
var Ri = /^[a-z_\u009F-\uFFFF][a-zA-Z0-9_\u009F-\uFFFF]*/;
var $r = /^[A-Z_\u009F-\uFFFF][a-zA-Z0-9_\u009F-\uFFFF]*/;
var pz = ai([
  "abstract",
  "alias",
  "as",
  "asm",
  "begin",
  "break",
  "case",
  "class",
  "def",
  "do",
  "else",
  "elsif",
  "end",
  "ensure",
  "enum",
  "extend",
  "for",
  "fun",
  "if",
  "include",
  "instance_sizeof",
  "lib",
  "macro",
  "module",
  "next",
  "of",
  "out",
  "pointerof",
  "private",
  "protected",
  "rescue",
  "return",
  "require",
  "select",
  "sizeof",
  "struct",
  "super",
  "then",
  "type",
  "typeof",
  "uninitialized",
  "union",
  "unless",
  "until",
  "when",
  "while",
  "with",
  "yield",
  "__DIR__",
  "__END_LINE__",
  "__FILE__",
  "__LINE__"
]);
var mz = ai(["true", "false", "nil", "self"]);
var gz = [
  "def",
  "fun",
  "macro",
  "class",
  "module",
  "struct",
  "lib",
  "enum",
  "union",
  "do",
  "for"
];
var Sz = ai(gz);
var Pz = ["if", "unless", "case", "while", "until", "begin", "then"];
var yz = ai(Pz);
var hg = ["end", "else", "elsif", "rescue", "ensure"];
var Xz = ai(hg);
var ug = ["\\)", "\\}", "\\]"];
var xz = new RegExp("^(?:" + ug.join("|") + ")$");
var td = {
  def: Od,
  fun: Od,
  macro: bz,
  class: qO,
  module: qO,
  struct: qO,
  lib: qO,
  enum: qO,
  union: qO
};
var Yo = { "[": "]", "{": "}", "(": ")", "<": ">" };
function uc(O, e) {
  if (O.eatSpace())
    return null;
  if (e.lastToken != "\\" && O.match("{%", false))
    return Ct(TO("%", "%"), O, e);
  if (e.lastToken != "\\" && O.match("{{", false))
    return Ct(TO("{", "}"), O, e);
  if (O.peek() == "#")
    return O.skipToEnd(), "comment";
  var t;
  if (O.match(Ri))
    return O.eat(/[?!]/), t = O.current(), O.eat(":") ? "atom" : e.lastToken == "." ? "property" : pz.test(t) ? (Sz.test(t) ? !(t == "fun" && e.blocks.indexOf("lib") >= 0) && !(t == "def" && e.lastToken == "abstract") && (e.blocks.push(t), e.currentIndent += 1) : (e.lastStyle == "operator" || !e.lastStyle) && yz.test(t) ? (e.blocks.push(t), e.currentIndent += 1) : t == "end" && (e.blocks.pop(), e.currentIndent -= 1), td.hasOwnProperty(t) && e.tokenize.push(td[t]), "keyword") : mz.test(t) ? "atom" : "variable";
  if (O.eat("@"))
    return O.peek() == "[" ? Ct(an("[", "]", "meta"), O, e) : (O.eat("@"), O.match(Ri) || O.match($r), "propertyName");
  if (O.match($r))
    return "tag";
  if (O.eat(":"))
    return O.eat('"') ? Ct(Zo('"', "atom", false), O, e) : O.match(Ri) || O.match($r) || O.match(Ka) || O.match(Ja) || O.match(cg) ? "atom" : (O.eat(":"), "operator");
  if (O.eat('"'))
    return Ct(Zo('"', "string", true), O, e);
  if (O.peek() == "%") {
    var i = "string", n = true, r;
    if (O.match("%r"))
      i = "string.special", r = O.next();
    else if (O.match("%w"))
      n = false, r = O.next();
    else if (O.match("%q"))
      n = false, r = O.next();
    else if (r = O.match(/^%([^\w\s=])/))
      r = r[1];
    else {
      if (O.match(/^%[a-zA-Z_\u009F-\uFFFF][\w\u009F-\uFFFF]*/))
        return "meta";
      if (O.eat("%"))
        return "operator";
    }
    return Yo.hasOwnProperty(r) && (r = Yo[r]), Ct(Zo(r, i, n), O, e);
  }
  return (t = O.match(/^<<-('?)([A-Z]\w*)\1/)) ? Ct(wz(t[2], !t[1]), O, e) : O.eat("'") ? (O.match(/^(?:[^']|\\(?:[befnrtv0'"]|[0-7]{3}|u(?:[0-9a-fA-F]{4}|\{[0-9a-fA-F]{1,6}\})))/), O.eat("'"), "atom") : O.eat("0") ? (O.eat("x") ? O.match(/^[0-9a-fA-F_]+/) : O.eat("o") ? O.match(/^[0-7_]+/) : O.eat("b") && O.match(/^[01_]+/), "number") : O.eat(/^\d/) ? (O.match(/^[\d_]*(?:\.[\d_]+)?(?:[eE][+-]?\d+)?/), "number") : O.match(Ka) ? (O.eat("="), "operator") : O.match(Ja) || O.match($z) ? "operator" : (t = O.match(/[({[]/, false)) ? (t = t[0], Ct(an(t, Yo[t], null), O, e)) : O.eat("\\") ? (O.next(), "meta") : (O.next(), null);
}
function an(O, e, t, i) {
  return function(n, r) {
    if (!i && n.match(O))
      return r.tokenize[r.tokenize.length - 1] = an(O, e, t, true), r.currentIndent += 1, t;
    var s = uc(n, r);
    return n.current() === e && (r.tokenize.pop(), r.currentIndent -= 1, s = t), s;
  };
}
function TO(O, e, t) {
  return function(i, n) {
    return !t && i.match("{" + O) ? (n.currentIndent += 1, n.tokenize[n.tokenize.length - 1] = TO(O, e, true), "meta") : i.match(e + "}") ? (n.currentIndent -= 1, n.tokenize.pop(), "meta") : uc(i, n);
  };
}
function bz(O, e) {
  if (O.eatSpace())
    return null;
  var t;
  if (t = O.match(Ri)) {
    if (t == "def")
      return "keyword";
    O.eat(/[?!]/);
  }
  return e.tokenize.pop(), "def";
}
function Od(O, e) {
  return O.eatSpace() ? null : (O.match(Ri) ? O.eat(/[!?]/) : O.match(Ka) || O.match(Ja) || O.match(cg), e.tokenize.pop(), "def");
}
function qO(O, e) {
  return O.eatSpace() ? null : (O.match($r), e.tokenize.pop(), "def");
}
function Zo(O, e, t) {
  return function(i, n) {
    for (var r = false; i.peek(); )
      if (r)
        i.next(), r = false;
      else {
        if (i.match("{%", false))
          return n.tokenize.push(TO("%", "%")), e;
        if (i.match("{{", false))
          return n.tokenize.push(TO("{", "}")), e;
        if (t && i.match("#{", false))
          return n.tokenize.push(an("#{", "}", "meta")), e;
        var s = i.next();
        if (s == O)
          return n.tokenize.pop(), e;
        r = t && s == "\\";
      }
    return e;
  };
}
function wz(O, e) {
  return function(t, i) {
    if (t.sol() && (t.eatSpace(), t.match(O)))
      return i.tokenize.pop(), "string";
    for (var n = false; t.peek(); )
      if (n)
        t.next(), n = false;
      else {
        if (t.match("{%", false))
          return i.tokenize.push(TO("%", "%")), "string";
        if (t.match("{{", false))
          return i.tokenize.push(TO("{", "}")), "string";
        if (e && t.match("#{", false))
          return i.tokenize.push(an("#{", "}", "meta")), "string";
        n = e && t.next() == "\\";
      }
    return "string";
  };
}
var Tz = {
  name: "crystal",
  startState: function() {
    return {
      tokenize: [uc],
      currentIndent: 0,
      lastToken: null,
      lastStyle: null,
      blocks: []
    };
  },
  token: function(O, e) {
    var t = e.tokenize[e.tokenize.length - 1](O, e), i = O.current();
    return t && t != "comment" && (e.lastToken = i, e.lastStyle = t), t;
  },
  indent: function(O, e, t) {
    return e = e.replace(/^\s*(?:\{%)?\s*|\s*(?:%\})?\s*$/g, ""), Xz.test(e) || xz.test(e) ? t.unit * (O.currentIndent - 1) : t.unit * O.currentIndent;
  },
  languageData: {
    indentOnInput: ai(ug.concat(hg), true),
    commentTokens: { line: "#" }
  }
};
function pe() {
  return pe = Object.assign ? Object.assign.bind() : function(O) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var i in t)
        Object.prototype.hasOwnProperty.call(t, i) && (O[i] = t[i]);
    }
    return O;
  }, pe.apply(this, arguments);
}
var Te = (O) => {
  var {
    theme: e,
    settings: t = {},
    styles: i = []
  } = O, n = {
    ".cm-gutters": {}
  }, r = {};
  t.background && (r.backgroundColor = t.background), t.foreground && (r.color = t.foreground), (t.background || t.foreground) && (n["&"] = r), t.fontFamily && (n["&.cm-editor .cm-scroller"] = {
    fontFamily: t.fontFamily
  }), t.gutterBackground && (n[".cm-gutters"].backgroundColor = t.gutterBackground), t.gutterForeground && (n[".cm-gutters"].color = t.gutterForeground), t.gutterBorder && (n[".cm-gutters"].borderRightColor = t.gutterBorder), t.caret && (n[".cm-content"] = {
    caretColor: t.caret
  }, n[".cm-cursor, .cm-dropCursor"] = {
    borderLeftColor: t.caret
  });
  var s = {};
  t.gutterActiveForeground && (s.color = t.gutterActiveForeground), t.lineHighlight && (n[".cm-activeLine"] = {
    backgroundColor: t.lineHighlight
  }, s.backgroundColor = t.lineHighlight), n[".cm-activeLineGutter"] = s, t.selection && (n["&.cm-focused .cm-selectionBackground, & .cm-selectionLayer .cm-selectionBackground, .cm-content ::selection"] = {
    backgroundColor: t.selection
  }), t.selectionMatch && (n["& .cm-selectionMatch"] = {
    backgroundColor: t.selectionMatch
  });
  var o = k.theme(n, {
    dark: e === "dark"
  }), a = ri.define(i), l = [o, vl(a)];
  return l;
};
var Wz = (O) => {
  var {
    theme: e = "dark",
    settings: t = {},
    styles: i = []
  } = O || {};
  return Te({
    theme: e,
    settings: pe({
      background: "#0f0f0f",
      foreground: "#defdef",
      caret: "#00FF00",
      selection: "#515151",
      selectionMatch: "#515151",
      gutterBackground: "#555",
      gutterForeground: "#FFFFFF",
      lineHighlight: "#314151"
    }, t),
    styles: [
      {
        tag: c.keyword,
        color: "darkgoldenrod",
        fontWeight: "bold"
      },
      {
        tag: c.atom,
        color: "#77F"
      },
      {
        tag: c.comment,
        color: "#7a7b7c",
        fontStyle: "italic"
      },
      {
        tag: c.number,
        color: "violet"
      },
      {
        tag: c.definition(c.variableName),
        color: "#fffabc"
      },
      {
        tag: c.variableName,
        color: "#abcdef"
      },
      {
        tag: c.function(c.variableName),
        color: "#fffabc"
      },
      {
        tag: c.typeName,
        color: "#FFDD44"
      },
      {
        tag: c.tagName,
        color: "#def"
      },
      {
        tag: c.string,
        color: "#2b4"
      },
      {
        tag: c.meta,
        color: "#C9F"
      },
      // { tag: t.qualifier, color: '#FFF700' },
      // { tag: t.builtin, color: '#30aabc' },
      {
        tag: c.bracket,
        color: "#8a8a8a"
      },
      {
        tag: c.attributeName,
        color: "#DDFF00"
      },
      {
        tag: c.heading,
        color: "aquamarine",
        fontWeight: "bold"
      },
      {
        tag: c.link,
        color: "blueviolet",
        fontWeight: "bold"
      },
      ...i
    ]
  });
};
var vz = Wz();
var kz = (O) => {
  var {
    theme: e = "dark",
    settings: t = {},
    styles: i = []
  } = O || {};
  return Te({
    theme: e,
    settings: pe({
      background: "#282b2e",
      foreground: "#a9b7c6",
      caret: "#00FF00",
      selection: "#343739",
      selectionMatch: "#343739",
      lineHighlight: "#343739"
    }, t),
    styles: [{
      tag: [c.keyword, c.deleted, c.className],
      color: "#cc7832"
    }, {
      tag: [c.number, c.literal, c.derefOperator],
      color: "#6897bb"
    }, {
      tag: [c.link, c.variableName],
      color: "#629755"
    }, {
      tag: [c.comment, c.quote],
      color: "grey"
    }, {
      tag: [c.meta, c.documentMeta],
      color: "#bbb529"
    }, {
      tag: [c.string, c.propertyName, c.attributeValue],
      color: "#6a8759"
    }, {
      tag: [c.heading, c.typeName],
      color: "#ffc66d"
    }, {
      tag: [c.attributeName],
      color: "#a9b7c6"
    }, {
      tag: [c.emphasis],
      fontStyle: "italic"
    }, ...i]
  });
};
var Yz = kz();
var Zz = (O) => {
  var {
    theme: e = "light",
    settings: t = {},
    styles: i = []
  } = O || {};
  return Te({
    theme: e,
    settings: pe({
      background: "#272C35",
      foreground: "#9d9b97",
      caret: "#797977",
      selection: "#ffffff30",
      selectionMatch: "#2B323D",
      gutterBackground: "#272C35",
      gutterForeground: "#465063",
      gutterBorder: "transparent",
      lineHighlight: "#2B323D"
    }, t),
    styles: [{
      tag: [c.function(c.variableName), c.function(c.propertyName), c.url, c.processingInstruction],
      color: "hsl(207, 82%, 66%)"
    }, {
      tag: [c.tagName, c.heading],
      color: "#e06c75"
    }, {
      tag: c.comment,
      color: "#54636D"
    }, {
      tag: [c.propertyName],
      color: "hsl(220, 14%, 71%)"
    }, {
      tag: [c.attributeName, c.number],
      color: "hsl( 29, 54%, 61%)"
    }, {
      tag: c.className,
      color: "hsl( 39, 67%, 69%)"
    }, {
      tag: c.keyword,
      color: "hsl(286, 60%, 67%)"
    }, {
      tag: [c.string, c.regexp, c.special(c.propertyName)],
      color: "#98c379"
    }, ...i]
  });
};
var qz = Zz();
var zz = (O) => {
  var {
    theme: e = "light",
    settings: t = {},
    styles: i = []
  } = O || {};
  return Te({
    theme: e,
    settings: pe({
      background: "#FFFFFF",
      foreground: "#000000",
      caret: "#FBAC52",
      selection: "#FFD420",
      selectionMatch: "#FFD420",
      gutterBackground: "#f5f5f5",
      gutterForeground: "#4D4D4C",
      gutterBorder: "transparent",
      lineHighlight: "#00000012"
    }, t),
    styles: [{
      tag: [c.meta, c.comment],
      color: "#804000"
    }, {
      tag: [c.keyword, c.strong],
      color: "#0000FF"
    }, {
      tag: [c.number],
      color: "#FF0080"
    }, {
      tag: [c.string],
      color: "#FF0080"
    }, {
      tag: [c.variableName],
      color: "#006600"
    }, {
      tag: [c.escape],
      color: "#33CC33"
    }, {
      tag: [c.tagName],
      color: "#1C02FF"
    }, {
      tag: [c.heading],
      color: "#0C07FF"
    }, {
      tag: [c.quote],
      color: "#000000"
    }, {
      tag: [c.list],
      color: "#B90690"
    }, {
      tag: [c.documentMeta],
      color: "#888888"
    }, {
      tag: [c.function(c.variableName)],
      color: "#0000A2"
    }, {
      tag: [c.definition(c.typeName), c.typeName],
      color: "#6D79DE"
    }, ...i]
  });
};
var Uz = zz();
var Vz = (O) => {
  var {
    theme: e = "dark",
    settings: t = {},
    styles: i = []
  } = O || {};
  return Te({
    theme: e,
    settings: pe({
      background: "#28211c",
      foreground: "#9d9b97",
      caret: "#797977",
      selection: "#36312e",
      selectionMatch: "#4f382b",
      gutterBackground: "#28211c",
      gutterForeground: "#666666",
      lineHighlight: "rgba(255, 255, 255, 0.1)"
    }, t),
    styles: [{
      tag: [c.atom, c.number, c.link, c.bool],
      color: "#9b859d"
    }, {
      tag: c.comment,
      color: "#937121"
    }, {
      tag: [c.keyword, c.tagName],
      color: "#cf6a4c"
    }, {
      tag: c.string,
      color: "#f9ee98"
    }, {
      tag: c.bracket,
      color: "#9d9b97"
    }, {
      tag: [c.variableName],
      color: "#5ea6ea"
    }, {
      tag: c.definition(c.variableName),
      color: "#cf7d34"
    }, {
      tag: [c.function(c.variableName), c.className],
      color: "#cf7d34"
    }, {
      tag: [c.propertyName, c.attributeName],
      color: "#54be0d"
    }, ...i]
  });
};
var Rz = Vz();
var _z = (O) => {
  var {
    theme: e = "light",
    settings: t = {},
    styles: i = []
  } = O || {};
  return Te({
    theme: e,
    settings: pe({
      background: "#2B2B2B",
      foreground: "#f8f8f2",
      caret: "#FFFFFF",
      selection: "rgba(255, 255, 255, 0.1)",
      selectionMatch: "rgba(255, 255, 255, 0.2)",
      gutterBackground: "rgba(255, 255, 255, 0.1)",
      gutterForeground: "#999",
      gutterBorder: "transparent",
      lineHighlight: "rgba(255, 255, 255, 0.1)"
    }, t),
    styles: [{
      tag: [c.atom, c.number],
      color: "#bd93f9"
    }, {
      tag: [c.comment],
      color: "#61A151"
    }, {
      tag: [c.string],
      color: "#6A8759"
    }, {
      tag: [c.variableName, c.operator],
      color: "#A9B7C6"
    }, {
      tag: [c.meta, c.className],
      color: "#A9B7C6"
    }, {
      tag: [c.propertyName],
      color: "#FFC66D"
    }, {
      tag: [c.keyword],
      color: "#CC7832"
    }, {
      tag: [c.tagName],
      color: "#ff79c6"
    }, {
      tag: [c.typeName],
      color: "#ffb86c"
    }, ...i]
  });
};
var jz = _z();
var Cz = (O) => {
  var {
    theme: e = "light",
    settings: t = {},
    styles: i = []
  } = O || {};
  return Te({
    theme: e,
    settings: pe({
      background: "#282a36",
      foreground: "#f8f8f2",
      caret: "#f8f8f0",
      selection: "rgba(255, 255, 255, 0.1)",
      selectionMatch: "rgba(255, 255, 255, 0.2)",
      gutterBackground: "#282a36",
      gutterForeground: "#6D8A88",
      gutterBorder: "transparent",
      lineHighlight: "rgba(255, 255, 255, 0.1)"
    }, t),
    styles: [{
      tag: c.comment,
      color: "#6272a4"
    }, {
      tag: c.string,
      color: "#f1fa8c"
    }, {
      tag: c.atom,
      color: "#bd93f9"
    }, {
      tag: c.meta,
      color: "#f8f8f2"
    }, {
      tag: [c.keyword, c.operator, c.tagName],
      color: "#ff79c6"
    }, {
      tag: [c.function(c.propertyName), c.propertyName],
      color: "#66d9ef"
    }, {
      tag: [c.definition(c.variableName), c.function(c.variableName), c.className, c.attributeName],
      color: "#50fa7b"
    }, {
      tag: c.atom,
      color: "#bd93f9"
    }, ...i]
  });
};
var Gz = Cz();
var Iz = (O) => {
  var {
    theme: e = "light",
    settings: t = {},
    styles: i = []
  } = O || {};
  return Te({
    theme: e,
    settings: pe({
      background: "#faf8f5",
      foreground: "#b29762",
      caret: "#93abdc",
      selection: "#e3dcce",
      selectionMatch: "#e3dcce",
      gutterBackground: "#faf8f5",
      gutterForeground: "#cdc4b1",
      gutterBorder: "transparent",
      lineHighlight: "#EFEFEF"
    }, t),
    styles: [{
      tag: [c.comment, c.bracket],
      color: "#b6ad9a"
    }, {
      tag: [c.atom, c.number, c.keyword, c.link, c.attributeName, c.quote],
      color: "#063289"
    }, {
      tag: [c.emphasis, c.heading, c.tagName, c.propertyName, c.variableName],
      color: "#2d2006"
    }, {
      tag: [c.typeName, c.url, c.string],
      color: "#896724"
    }, {
      tag: [c.operator, c.string],
      color: "#1659df"
    }, {
      tag: [c.propertyName],
      color: "#b29762"
    }, {
      tag: [c.unit, c.punctuation],
      color: "#063289"
    }, ...i]
  });
};
var Ez = Iz();
var Az = (O) => {
  var {
    theme: e = "light",
    settings: t = {},
    styles: i = []
  } = O || {};
  return Te({
    theme: e,
    settings: pe({
      background: "#2a2734",
      foreground: "#6c6783",
      caret: "#ffad5c",
      selection: "rgba(255, 255, 255, 0.1)",
      gutterBackground: "#2a2734",
      gutterForeground: "#545167",
      lineHighlight: "#36334280"
    }, t),
    styles: [{
      tag: [c.comment, c.bracket],
      color: "#6c6783"
    }, {
      tag: [c.atom, c.number, c.keyword, c.link, c.attributeName, c.quote],
      color: "#ffcc99"
    }, {
      tag: [c.emphasis, c.heading, c.tagName, c.propertyName, c.className, c.variableName],
      color: "#eeebff"
    }, {
      tag: [c.typeName, c.url],
      color: "#7a63ee"
    }, {
      tag: c.operator,
      color: "#ffad5c"
    }, {
      tag: c.string,
      color: "#ffb870"
    }, {
      tag: [c.propertyName],
      color: "#9a86fd"
    }, {
      tag: [c.unit, c.punctuation],
      color: "#e09142"
    }, ...i]
  });
};
var Dz = Az();
var Mz = (O) => {
  var {
    theme: e = "light",
    settings: t = {},
    styles: i = []
  } = O || {};
  return Te({
    theme: e,
    settings: pe({
      background: "#fff",
      foreground: "#000",
      caret: "#FFFFFF",
      selection: "#d7d4f0",
      selectionMatch: "#d7d4f0",
      gutterBackground: "#f7f7f7",
      gutterForeground: "#999",
      lineHighlight: "#e8f2ff",
      gutterBorder: "transparent"
    }, t),
    styles: [{
      tag: [c.comment],
      color: "#3F7F5F"
    }, {
      tag: [c.documentMeta],
      color: "#FF1717"
    }, {
      tag: c.keyword,
      color: "#7F0055",
      fontWeight: "bold"
    }, {
      tag: c.atom,
      color: "#00f"
    }, {
      tag: c.number,
      color: "#164"
    }, {
      tag: c.propertyName,
      color: "#164"
    }, {
      tag: [c.variableName, c.definition(c.variableName)],
      color: "#0000C0"
    }, {
      tag: c.function(c.variableName),
      color: "#0000C0"
    }, {
      tag: c.string,
      color: "#2A00FF"
    }, {
      tag: c.operator,
      color: "black"
    }, {
      tag: c.tagName,
      color: "#170"
    }, {
      tag: c.attributeName,
      color: "#00c"
    }, {
      tag: c.link,
      color: "#219"
    }, ...i]
  });
};
var Lz = Mz();
var Bz = (O) => {
  var {
    theme: e = "light",
    settings: t = {},
    styles: i = []
  } = O || {};
  return Te({
    theme: e,
    settings: pe({
      background: "#fff",
      foreground: "#24292e",
      selection: "#BBDFFF",
      selectionMatch: "#BBDFFF",
      gutterBackground: "#fff",
      gutterForeground: "#6e7781"
    }, t),
    styles: [{
      tag: [c.standard(c.tagName), c.tagName],
      color: "#116329"
    }, {
      tag: [c.comment, c.bracket],
      color: "#6a737d"
    }, {
      tag: [c.className, c.propertyName],
      color: "#6f42c1"
    }, {
      tag: [c.variableName, c.attributeName, c.number, c.operator],
      color: "#005cc5"
    }, {
      tag: [c.keyword, c.typeName, c.typeOperator, c.typeName],
      color: "#d73a49"
    }, {
      tag: [c.string, c.meta, c.regexp],
      color: "#032f62"
    }, {
      tag: [c.name, c.quote],
      color: "#22863a"
    }, {
      tag: [c.heading],
      color: "#24292e",
      fontWeight: "bold"
    }, {
      tag: [c.emphasis],
      color: "#24292e",
      fontStyle: "italic"
    }, {
      tag: [c.deleted],
      color: "#b31d28",
      backgroundColor: "ffeef0"
    }, {
      tag: [c.atom, c.bool, c.special(c.variableName)],
      color: "#e36209"
    }, {
      tag: [c.url, c.escape, c.regexp, c.link],
      color: "#032f62"
    }, {
      tag: c.link,
      textDecoration: "underline"
    }, {
      tag: c.strikethrough,
      textDecoration: "line-through"
    }, {
      tag: c.invalid,
      color: "#cb2431"
    }, ...i]
  });
};
var Nz = Bz();
var Fz = (O) => {
  var {
    theme: e = "dark",
    settings: t = {},
    styles: i = []
  } = O || {};
  return Te({
    theme: e,
    settings: pe({
      background: "#0d1117",
      foreground: "#c9d1d9",
      caret: "#c9d1d9",
      selection: "#003d73",
      selectionMatch: "#003d73",
      lineHighlight: "#36334280"
    }, t),
    styles: [{
      tag: [c.standard(c.tagName), c.tagName],
      color: "#7ee787"
    }, {
      tag: [c.comment, c.bracket],
      color: "#8b949e"
    }, {
      tag: [c.className, c.propertyName],
      color: "#d2a8ff"
    }, {
      tag: [c.variableName, c.attributeName, c.number, c.operator],
      color: "#79c0ff"
    }, {
      tag: [c.keyword, c.typeName, c.typeOperator, c.typeName],
      color: "#ff7b72"
    }, {
      tag: [c.string, c.meta, c.regexp],
      color: "#a5d6ff"
    }, {
      tag: [c.name, c.quote],
      color: "#7ee787"
    }, {
      tag: [c.heading],
      color: "#d2a8ff",
      fontWeight: "bold"
    }, {
      tag: [c.emphasis],
      color: "#d2a8ff",
      fontStyle: "italic"
    }, {
      tag: [c.deleted],
      color: "#ffdcd7",
      backgroundColor: "ffeef0"
    }, {
      tag: [c.atom, c.bool, c.special(c.variableName)],
      color: "#ffab70"
    }, {
      tag: c.link,
      textDecoration: "underline"
    }, {
      tag: c.strikethrough,
      textDecoration: "line-through"
    }, {
      tag: c.invalid,
      color: "#f97583"
    }, ...i]
  });
};
var Hz = Fz();
var Kz = (O) => {
  var {
    theme: e = "dark",
    settings: t = {},
    styles: i = []
  } = O || {};
  return Te({
    theme: e,
    settings: pe({
      background: "#272822",
      foreground: "#FFFFFF",
      caret: "#FFFFFF",
      selection: "#49483E",
      selectionMatch: "#49483E",
      gutterBackground: "#272822",
      gutterForeground: "#FFFFFF70",
      lineHighlight: "#00000059"
    }, t),
    styles: [
      {
        tag: [c.comment, c.documentMeta],
        color: "#8292a2"
      },
      {
        tag: [c.number, c.bool, c.null, c.atom],
        color: "#ae81ff"
      },
      {
        tag: [c.attributeValue, c.className, c.name],
        color: "#e6db74"
      },
      {
        tag: [c.propertyName, c.attributeName],
        color: "#a6e22e"
      },
      {
        tag: [c.variableName],
        color: "#9effff"
      },
      {
        tag: [c.squareBracket],
        color: "#bababa"
      },
      {
        tag: [c.string, c.special(c.brace)],
        color: "#e6db74"
      },
      {
        tag: [c.regexp, c.className, c.typeName, c.definition(c.typeName)],
        color: "#66d9ef"
      },
      {
        tag: [c.definition(c.variableName), c.definition(c.propertyName), c.function(c.variableName)],
        color: "#fd971f"
      },
      // { tag: t.keyword, color: '#f92672' },
      {
        tag: [c.keyword, c.definitionKeyword, c.modifier, c.tagName, c.angleBracket],
        color: "#f92672"
      },
      ...i
    ]
  });
};
var Jz = Kz();
var eU = "#e5c07b";
var id = "#e06c75";
var tU = "#56b6c2";
var OU = "#ffffff";
var pr = "#abb2bf";
var el = "#7d8799";
var iU = "#61afef";
var nU = "#98c379";
var nd = "#d19a66";
var rU = "#c678dd";
var sU = "#21252b";
var rd = "#2c313a";
var sd = "#282c34";
var qo = "#353a42";
var oU = "#3E4451";
var od = "#528bff";
var aU = k.theme({
  "&": {
    color: pr,
    backgroundColor: sd
  },
  ".cm-content": {
    caretColor: od
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: od },
  "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: oU },
  ".cm-panels": { backgroundColor: sU, color: pr },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847",
    outline: "1px solid #515a6b"
  },
  ".cm-gutters": {
    backgroundColor: sd,
    color: el,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: rd
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: qo
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: qo,
    borderBottomColor: qo
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: rd,
      color: pr
    }
  }
}, { dark: true });
var lU = ri.define([
  {
    tag: c.keyword,
    color: rU
  },
  {
    tag: [c.name, c.deleted, c.character, c.propertyName, c.macroName],
    color: id
  },
  {
    tag: [c.function(c.variableName), c.labelName],
    color: iU
  },
  {
    tag: [c.color, c.constant(c.name), c.standard(c.name)],
    color: nd
  },
  {
    tag: [c.definition(c.name), c.separator],
    color: pr
  },
  {
    tag: [c.typeName, c.className, c.number, c.changed, c.annotation, c.modifier, c.self, c.namespace],
    color: eU
  },
  {
    tag: [c.operator, c.operatorKeyword, c.url, c.escape, c.regexp, c.link, c.special(c.string)],
    color: tU
  },
  {
    tag: [c.meta, c.comment],
    color: el
  },
  {
    tag: c.strong,
    fontWeight: "bold"
  },
  {
    tag: c.emphasis,
    fontStyle: "italic"
  },
  {
    tag: c.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: c.link,
    color: el,
    textDecoration: "underline"
  },
  {
    tag: c.heading,
    fontWeight: "bold",
    color: id
  },
  {
    tag: [c.atom, c.bool, c.special(c.variableName)],
    color: nd
  },
  {
    tag: [c.processingInstruction, c.string, c.inserted],
    color: nU
  },
  {
    tag: c.invalid,
    color: OU
  }
]);
var cU = [aU, vl(lU)];
function hU(O) {
  var {
    theme: e = "dark",
    settings: t = {},
    styles: i = []
  } = O || {};
  return Te({
    theme: e,
    settings: pe({
      background: "#303841",
      foreground: "#FFFFFF",
      caret: "#FBAC52",
      selection: "#4C5964",
      selectionMatch: "#3A546E",
      gutterBackground: "#303841",
      gutterForeground: "#FFFFFF70",
      lineHighlight: "#00000059"
    }, t),
    styles: [
      {
        tag: [c.meta, c.comment],
        color: "#A2A9B5"
      },
      {
        tag: [c.attributeName, c.keyword],
        color: "#B78FBA"
      },
      {
        tag: c.function(c.variableName),
        color: "#5AB0B0"
      },
      {
        tag: [c.string, c.regexp, c.attributeValue],
        color: "#99C592"
      },
      {
        tag: c.operator,
        color: "#f47954"
      },
      // { tag: t.moduleKeyword, color: 'red' },
      {
        tag: [c.tagName, c.modifier],
        color: "#E35F63"
      },
      {
        tag: [c.number, c.definition(c.tagName), c.className, c.definition(c.variableName)],
        color: "#fbac52"
      },
      {
        tag: [c.atom, c.bool, c.special(c.variableName)],
        color: "#E35F63"
      },
      {
        tag: c.variableName,
        color: "#539ac4"
      },
      {
        tag: [c.propertyName, c.typeName],
        color: "#629ccd"
      },
      {
        tag: c.propertyName,
        color: "#36b7b5"
      },
      ...i
    ]
  });
}
var uU = hU();
function fU(O) {
  var {
    theme: e = "light",
    settings: t = {},
    styles: i = []
  } = O || {};
  return Te({
    theme: e,
    settings: pe({
      background: "#fff",
      foreground: "#3D3D3D",
      selection: "#BBDFFF",
      selectionMatch: "#BBDFFF",
      gutterBackground: "#fff",
      gutterForeground: "#AFAFAF",
      lineHighlight: "#EDF4FF"
    }, t),
    styles: [{
      tag: [c.comment, c.quote],
      color: "#707F8D"
    }, {
      tag: [c.typeName, c.typeOperator],
      color: "#aa0d91"
    }, {
      tag: [c.keyword],
      color: "#aa0d91",
      fontWeight: "bold"
    }, {
      tag: [c.string, c.meta],
      color: "#D23423"
    }, {
      tag: [c.name],
      color: "#032f62"
    }, {
      tag: [c.typeName],
      color: "#522BB2"
    }, {
      tag: [c.variableName],
      color: "#23575C"
    }, {
      tag: [c.definition(c.variableName)],
      color: "#327A9E"
    }, {
      tag: [c.regexp, c.link],
      color: "#0e0eff"
    }, ...i]
  });
}
var dU = fU();
var QU = (O) => {
  var {
    theme: e = "dark",
    settings: t = {},
    styles: i = []
  } = O || {};
  return Te({
    theme: e,
    settings: pe({
      background: "#292A30",
      foreground: "#CECFD0",
      caret: "#fff",
      selection: "#727377",
      selectionMatch: "#727377",
      lineHighlight: "#2F3239"
    }, t),
    styles: [{
      tag: [c.comment, c.quote],
      color: "#7F8C98"
    }, {
      tag: [c.keyword],
      color: "#FF7AB2",
      fontWeight: "bold"
    }, {
      tag: [c.string, c.meta],
      color: "#FF8170"
    }, {
      tag: [c.typeName],
      color: "#DABAFF"
    }, {
      tag: [c.definition(c.variableName)],
      color: "#6BDFFF"
    }, {
      tag: [c.name],
      color: "#6BAA9F"
    }, {
      tag: [c.variableName],
      color: "#ACF2E4"
    }, {
      tag: [c.regexp, c.link],
      color: "#FF8170"
    }, ...i]
  });
};
var $U = QU();
var pU = {
  HTML: Kl(),
  PYTHON: SW(),
  RUST: GW(),
  C: le.define(tq),
  CPP: cv(),
  CSHARP: le.define(Oq),
  CRYSTAL: le.define(Tz),
  OBJECTIVE_C: le.define(sq),
  KOTLIN: le.define(rq),
  DART: le.define(hq),
  PHP: zk(),
  PROPERTIES: le.define(Qz),
  JAVASCRIPT: Wi(),
  TYPESCRIPT: Wi({ typescript: true }),
  JSX: Wi({ jsx: true }),
  TSX: Wi({ typescript: true, jsx: true }),
  SQL: SY(),
  SHELL: le.define(sz),
  SCALA: le.define(iq),
  MARKDOWN: JY(),
  JAVA: nZ(),
  XML: TZ(),
  CSS: Ap(),
  JSON: YZ(),
  WEB_ASSEMBLY: UZ(),
  LUA: le.define(EZ),
  RUBY: le.define(KZ),
  R: le.define(fz),
  GO: le.define(Qq),
  SWIFT: le.define(Uq),
  ELM: le.define(Mq),
  HASKELL: le.define(Jq),
  YAML: le.define(Oz),
  TOML: le.define(dz)
};
var mU = {
  ANDROID_STUDIO: Yz,
  ABCDEF: vz,
  ATOMONE: qz,
  BBEDIT: Uz,
  BESPIN: Rz,
  DARCULA: jz,
  DRACULA: Gz,
  DUOTONE_LIGHT: Ez,
  DUOTONE_DARK: Dz,
  ECLIPSE: Lz,
  GITHUB_LIGHT: Nz,
  GITHUB_DARK: Hz,
  ONE_DARK: cU,
  OKAIDIA: Jz,
  SUBLIME: uU,
  X_CODE_LIGHT: dU,
  X_CODE_DARK: $U
};
var gU = {
  name: "HCodeEditor"
};
var SU = defineComponent({
  ...gU,
  props: {
    modelValue: null,
    lang: { default: "JAVASCRIPT" },
    theme: null,
    placeholder: null,
    autofocus: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false },
    copyable: { type: Boolean },
    copyBtnPosition: null,
    hiddenGutter: { type: Boolean },
    isFocus: { type: Boolean },
    errorLine: null
  },
  emits: ["update:modelValue", "update:isFocus"],
  setup(O, { emit: e }) {
    const t = O, i = k.theme({
      "& .cm-scroller": {
        fontFamily: "var(--code-font-family)",
        "& .cm-gutters": {
          display: t.hiddenGutter ? "none" : null
        }
      },
      "&.cm-editor.cm-focused": {
        outline: "none"
      }
    }), n = ref(), r = Wd();
    watch(
      [() => t.lang, () => t.theme, () => r.dark],
      ([f, d, Q]) => {
        n.value = [
          pU[f],
          mU[d ?? (Q ? "GITHUB_DARK" : "GITHUB_LIGHT")],
          i
        ];
      },
      {
        immediate: true
      }
    );
    const s = ref(), o = (f) => {
      var d;
      f === 0 ? (d = s.value.querySelector(".error-line")) == null || d.classList.remove("error-line") : s.value.querySelectorAll(".cm-line")[f - 1].classList.add("error-line");
    }, a = () => {
      t.isFocus !== void 0 && e("update:isFocus", true);
    }, l = () => {
      t.isFocus !== void 0 && e("update:isFocus", false);
    }, h2 = () => {
      t.errorLine && o(t.errorLine);
    }, u = (f) => {
      e("update:modelValue", f);
    };
    return (f, d) => (openBlock(), createElementBlock("div", {
      ref_key: "codeRef",
      ref: s,
      class: "code-editor-wrapper"
    }, [
      createVNode(unref(Aw), {
        "model-value": t.modelValue,
        placeholder: t == null ? void 0 : t.placeholder,
        "indent-with-tab": true,
        "tab-size": 2,
        extensions: n.value,
        style: {
          width: "100%",
          height: "100%"
        },
        class: "code",
        autofocus: t.autofocus,
        disabled: t.disabled,
        onChange: u,
        onFocus: a,
        onBlur: l,
        onUpdate: h2
      }, null, 8, ["model-value", "placeholder", "extensions", "autofocus", "disabled"])
    ], 512));
  }
});
var fg = ln(SU, [["__scopeId", "data-v-da9379c9"]]);
var PU = Rt(fg);
var yU = {
  name: "HCodeResult"
};
var XU = defineComponent({
  ...yU,
  props: {
    code: null,
    lang: null
  },
  setup(O) {
    const e = O;
    useCssVars((r) => ({
      "0ae24bca": unref(n)
    }));
    const t = Wd(), i = ref(e.code);
    watch(
      () => e.code,
      (r) => {
        i.value = r;
      }
    );
    const n = computed(() => t.dark ? "rgb(13, 17, 23)" : "#fff");
    return (r, s) => (openBlock(), createBlock(fg, {
      "model-value": e.code,
      lang: e.lang,
      "hidden-gutter": "",
      disabled: "",
      copyable: "",
      class: "code-result"
    }, null, 8, ["model-value", "lang"]));
  }
});
var xU = ln(XU, [["__scopeId", "data-v-6d5cd6ed"]]);
var bU = Rt(xU);
var wU = { class: "highlight-box" };
var TU = ["innerHTML"];
var WU = ["placeholder", "onKeyup"];
var vU = ["innerHTML"];
var kU = ["placeholder"];
var YU = {
  name: "HHighlightInput"
};
var ZU = defineComponent({
  ...YU,
  props: {
    highlightText: null,
    highlightTextColor: { default: "var(--default-font-color)" },
    highlightColor: { default: "var(--hight-background)" },
    modelValue: null,
    placeholder: { default: "请输入" },
    type: { default: "textarea" },
    maxHeight: { default: "220px" },
    title: { default: "Input content:" },
    regexModifier: { default: "g" }
  },
  emits: ["update:modelValue"],
  setup(O, { emit: e }) {
    const t = O;
    useCssVars((d) => ({
      "3df23931": t.maxHeight,
      "179ad549": t.highlightColor,
      "7a451dc8": t.highlightTextColor
    }));
    const i = ref(t.modelValue), n = ref(), r = ref(), s = ref();
    watch(i, () => {
      e("update:modelValue", i.value);
    }), onBeforeMount(() => {
      i.value = t.modelValue.replace(/(^\s*)|(\s*$)/g, "").replace(/<br \/>|<br\/>|<br>/g, `
`);
    }), onMounted(() => {
      h2();
    });
    function o(d) {
      if ((!d || !t.highlightText || t.highlightText.length === 0) && t.type !== "textarea")
        return d;
      let Q = a(d);
      if (t.highlightText.filter(($) => ~d.indexOf($)).length) {
        let $ = "", p = null;
        t.highlightText.forEach((m) => {
          $ = u(m), p = new RegExp($, t.regexModifier), Q = Q.replace(p, `<span>${m}</span>`);
        });
      }
      if (t.type === "textarea") {
        Q = Q.replace(/\n/g, "<br/>").replace(/\s/g, "&nbsp;");
        const $ = r.value;
        $ && $.scrollHeight > t.maxHeight && (Q = Q + "<br/>");
      }
      return Q;
    }
    const a = (d) => d ? d.replace(/[<">']/g, (Q) => ({
      "<": "&lt;",
      '"': "&quot;",
      ">": "&gt;",
      "'": "&#39;"
    })[Q]) : "";
    function l() {
      r.value.scrollHeight > t.maxHeight && s.value.scrollHeight !== r.value.scrollHeight && (s.value.style.height = `${r.value.scrollHeight}px`), r.value.scrollTop !== n.value.scrollTop && (n.value.scrollTop = r.value.scrollTop);
    }
    function h2() {
      t.type !== "input" && nextTick(() => {
        f("add");
      });
    }
    function u(d) {
      const Q = [
        "(",
        ")",
        "[",
        "]",
        "{",
        "}",
        "^",
        "$",
        "|",
        "?",
        "*",
        "+",
        "."
      ];
      let $ = d.replace(new RegExp("\\\\", "g"), "\\\\");
      return Q.forEach(function(p) {
        let m = new RegExp("\\" + p, "g");
        $ = $.replace(m, "\\" + p);
      }), $;
    }
    function f(d) {
      if (r.value) {
        let Q = /Firefox/i.test(navigator.userAgent) ? "DOMMouseScroll" : "mousewheel";
        r.value[`${d}EventListener`](Q, l), r.value[`${d}EventListener`]("scroll", l);
      }
    }
    return onBeforeUnmount(() => {
      f("remove");
    }), (d, Q) => {
      const $ = resolveComponent("HIcon");
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("p", null, toDisplayString(t.title), 1),
        createVNode($, { "data-icon": "material-symbols:360" }),
        createBaseVNode("div", wU, [
          O.type === "textarea" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            i.value ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref_key: "textareaOuter",
              ref: n,
              class: "textarea-outer",
              style: normalizeStyle({ height: O.maxHeight })
            }, [
              createBaseVNode("div", {
                ref_key: "outerInner",
                ref: s,
                class: "outer-inner",
                innerHTML: o(i.value)
              }, null, 8, TU)
            ], 4)) : createCommentVNode("", true),
            withDirectives(createBaseVNode("textarea", {
              ref_key: "textareaBox",
              ref: r,
              "onUpdate:modelValue": Q[0] || (Q[0] = (p) => i.value = p),
              style: normalizeStyle({ height: O.maxHeight }),
              placeholder: O.placeholder,
              spellcheck: false,
              onKeyup: withKeys(l, ["enter"])
            }, `\r
        `, 44, WU), [
              [vModelText, i.value]
            ])
          ], 64)) : createCommentVNode("", true),
          O.type === "input" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            i.value ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "input-outer",
              innerHTML: o(i.value)
            }, null, 8, vU)) : createCommentVNode("", true),
            withDirectives(createBaseVNode("input", {
              "onUpdate:modelValue": Q[1] || (Q[1] = (p) => i.value = p),
              type: "text",
              placeholder: O.placeholder
            }, null, 8, kU), [
              [vModelText, i.value]
            ])
          ], 64)) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});
var qU = Rt(ZU);
var ad = Object.freeze(Object.defineProperty({
  __proto__: null,
  HCodeEditor: PU,
  HCodeResult: bU,
  HHighlightInput: qU,
  HIcon: LS,
  HImagePreview: HS,
  HLayoutHorizontal: Eg,
  HLayoutSingle: Ag,
  HLayoutSplitPane: Dg,
  HLayoutVertical: Ig
}, Symbol.toStringTag, { value: "Module" }));
var zU = function(O) {
  return Object.keys(ad).forEach((e) => {
    const t = ad[e];
    t.install && O.use(t);
  }), O;
};
var EU = {
  install: zU
};
export {
  PU as HCodeEditor,
  bU as HCodeResult,
  qU as HHighlightInput,
  LS as HIcon,
  HS as HImagePreview,
  Eg as HLayoutHorizontal,
  Ag as HLayoutSingle,
  Dg as HLayoutSplitPane,
  Ig as HLayoutVertical,
  EU as default,
  zU as install
};
/*! Bundled license information:

@he3-kit/ui/dist/index.js:
  (*!
  * VueCodemirror v6.1.1
  * Copyright (c) Surmon. All rights reserved.
  * Released under the MIT License.
  * Surmon
  *)
*/
//# sourceMappingURL=@he3-kit_ui.js.map
